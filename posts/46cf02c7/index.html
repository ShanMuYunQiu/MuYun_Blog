<!DOCTYPE html><html lang="zh-CN"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="	#ff8533"><meta name="author" content="山暮云秋"><meta name="copyright" content="山暮云秋"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>Cpp基础教程 | 山暮云秋 | Blog</title><link rel="stylesheet" href="https://jsd.vxo.im/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://jsd.vxo.im/npm/prism-theme-vars/base.css"><script src="https://jsd.vxo.im/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://jsd.vxo.im/npm/katex@latest/dist/katex.min.css"><script defer src="https://jsd.vxo.im/npm/katex@latest/dist/katex.min.js"></script><link rel="stylesheet" type="text/css" href="https://jsd.vxo.im/npm/katex@latest/dist/contrib/copy-tex.min.css"><script defer src="https://jsd.vxo.im/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><script defer src="https://jsd.vxo.im/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script type="module">import { renderKatex } from '/js/utils.js'
document.addEventListener("DOMContentLoaded", () => {
  renderKatex({
    ...{},
    ...undefined?.options,
  });
});</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://jsd.vxo.im/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://jsd.vxo.im/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script src="https://jsd.vxo.im/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer type="module"></script><script src="https://jsd.vxo.im/npm/vue@2.6.14"></script><link rel="icon" type="image/png" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/info/user.jpg"><link rel="mask-icon" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/info/user.jpg" color="	#ff8533"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://jsd.vxo.im/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"blog.muyun.space","root":"/","title":"山暮云秋的空间","version":"1.10.11","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn?c=a&c=d&c=e&c=f&c=i&c=j&c=k","hitokoto":true},"local_search":{"path":"/search.xml"},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"fireworks":{"colors":["255, 117, 25","255, 163, 102","255, 209, 179"]},"waline":{"config":{"enable":true,"serverURL":"https://waline.muyun.space/","comment":true,"visitor":false,"emoji":["https://emoji.shojo.cn/bili/webp/仓鼠","https://emoji.shojo.cn/bili/webp/仓鼠松鼠","https://emoji.shojo.cn/bili/webp/东爱璃Lovely","https://emoji.shojo.cn/bili/webp/星汐seki","https://emoji.shojo.cn/bili/webp/咩栗","https://emoji.shojo.cn/bili/webp/呜米","https://emoji.shojo.cn/bili/webp/枕边童话","https://emoji.shojo.cn/bili/webp/美月もも","https://emoji.shojo.cn/bili/webp/雫るる制服ver","https://emoji.shojo.cn/bili/webp/雫るる","https://emoji.shojo.cn/bili/webp/梦音茶糯","https://unpkg.com/@waline/emojis@1.2.0/bilibili","https://unpkg.com/@waline/emojis@1.2.0/bmoji","https://unpkg.com/@waline/emojis@1.2.0/weibo","https://unpkg.com/@waline/emojis@1.2.0/qq"],"locale":{"placeholder":"填写邮箱，可以收到回复通知哦～"},"requiredMeta":["nick"],"el":"#waline","lang":"zh-CN"},"cdn":"https://jsd.vxo.im/npm/@waline/client@v2/dist/waline.js","dark":"html.dark"},"vendors":{"host":"https://jsd.vxo.im/npm/","darken":"https://jsd.vxo.im/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="stylesheet" href="https://fonts.font.im/css2?family=Noto+Serif+SC:wght@900&amp;display=swap"><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="有关于C++的基础教程，该教程建立在学习过C语言的基础上，进行对比学习，了解不同的特性和更多新内容，学习设计类和面向对象程序设计">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp基础教程">
<meta property="og:url" content="https://blog.muyun.space/posts/46cf02c7/index.html">
<meta property="og:site_name" content="山暮云秋 | Blog">
<meta property="og:description" content="有关于C++的基础教程，该教程建立在学习过C语言的基础上，进行对比学习，了解不同的特性和更多新内容，学习设计类和面向对象程序设计">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-02T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-24T16:00:00.000Z">
<meta property="article:author" content="山暮云秋">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="基础语法">
<meta name="twitter:card" content="summary"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://jsd.vxo.im/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="山暮云秋"><img width="96" loading="lazy" src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/info/user.jpg" alt="山暮云秋"><span class="site-author-status" title="精神状态美丽">😇</span></a><div class="site-author-name"><a href="/about/">山暮云秋</a></div><a class="site-name" href="/about/site.html">山暮云秋 | Blog</a><sub class="site-subtitle">千里关山边草暮，一星烽火朔云秋</sub><div class="site-description">知识分享与生活记录</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">65</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">83</span></a></div><a class="site-state-item hty-icon-button" href="/talks/" title="《道是寻常》——我的说说"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:chat-smile-3-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://muyun.space" title="个人主页" target="_blank" style="color:#ff8533"><span class="icon iconify" data-icon="ri:account-circle-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/wechat.png" title="微信" target="_blank" style="color:#1AAD19"><span class="icon iconify" data-icon="ri:wechat-2-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/QQ.png" title="QQ" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ShanMuYunQiu" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/347061710" title="Bilibili" target="_blank" style="color:#FB7299"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=509242587" title="网易云音乐" target="_blank" style="color:#E60026"><span class="icon iconify" data-icon="ri:netease-cloud-music-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://500px.com.cn/ShanMuYunQiu" title="500px" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:number-5"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://tuchong.com/28695963/" title="图虫" target="_blank" style="color:#E9357B"><span class="icon iconify" data-icon="ri:multi-image-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://waline.muyun.space/ui" title="评论管理" target="_blank" style="color:#66b3ff"><span class="icon iconify" data-icon="ri:chat-settings-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://bk.muyun.space/talks.html" title="后台管理" target="_blank" style="color:#bb99ff"><span class="icon iconify" data-icon="ri:terminal-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="《萤火虫小巷》——友情链接" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="《泡沫之夏》——喜欢的角色" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a><a class="links-item hty-icon-button" href="/donate/" title="《月亮与六便士》——打赏与鸣谢" style="color:#ff8533"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-C-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">编写一个简单的 C++程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.</span> <span class="toc-text">初识输入输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-C-%E7%89%88%E6%9C%AC%E7%9A%84-C-%E6%A0%87%E5%87%86%E5%BA%93%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">使用 C++版本的 C 标准库头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.</span> <span class="toc-text">类简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">基本内置类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">复合类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">const 限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">处理类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.</span> <span class="toc-text">自定义数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">字符串、向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84-using-%E5%A3%B0%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">命名空间的 using 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-string"><span class="toc-number">3.2.</span> <span class="toc-text">标准库类型 string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B-vector"><span class="toc-number">3.3.</span> <span class="toc-text">标准库类型 vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.</span> <span class="toc-text">迭代器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.5.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E8%A1%A5%E5%85%85"><span class="toc-number">4.1.</span> <span class="toc-text">特性补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#try-%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">try 语句块和异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">含有可变形参的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">6.2.</span> <span class="toc-text">函数的返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">6.3.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">特殊用途语言特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">定义抽象数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">7.2.</span> <span class="toc-text">访问控制与封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">7.3.</span> <span class="toc-text">类的其他特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">7.4.</span> <span class="toc-text">类的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="toc-number">7.5.</span> <span class="toc-text">构造函数再探</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">7.6.</span> <span class="toc-text">类的静态成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">IO 库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">IO 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">8.2.</span> <span class="toc-text">文件输入输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string-%E6%B5%81"><span class="toc-number">8.3.</span> <span class="toc-text">string 流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">顺序容器概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88"><span class="toc-number">9.2.</span> <span class="toc-text">容器库概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.</span> <span class="toc-text">顺序容器操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector-%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%A2%9E%E9%95%BF"><span class="toc-number">9.4.</span> <span class="toc-text">vector 对象如何增长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84-string-%E6%93%8D%E4%BD%9C"><span class="toc-number">9.5.</span> <span class="toc-text">额外的 string 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">9.6.</span> <span class="toc-text">容器适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">初识泛型算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">10.3.</span> <span class="toc-text">定制操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.4.</span> <span class="toc-text">再探迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">10.5.</span> <span class="toc-text">泛型算法结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95"><span class="toc-number">10.6.</span> <span class="toc-text">特定容器算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">使用关联容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">11.2.</span> <span class="toc-text">关联容器概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">11.3.</span> <span class="toc-text">关联容器操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">11.4.</span> <span class="toc-text">无序容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">12.</span> <span class="toc-text">动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">12.1.</span> <span class="toc-text">动态内存与智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr-%E7%B1%BB-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">12.2.</span> <span class="toc-text">shared_ptr 类(智能指针)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E6%8C%87%E9%92%88"><span class="toc-number">12.3.</span> <span class="toc-text">直接管理内存(动态内存指针)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">12.4.</span> <span class="toc-text">结合使用与异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">12.5.</span> <span class="toc-text">其他智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">12.6.</span> <span class="toc-text">动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9A%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F"><span class="toc-number">12.7.</span> <span class="toc-text">使用标准库：文本查询程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">13.</span> <span class="toc-text">拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">13.1.</span> <span class="toc-text">拷贝、赋值与销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">13.2.</span> <span class="toc-text">拷贝控制和资源管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">13.3.</span> <span class="toc-text">交换操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E7%A4%BA%E4%BE%8B"><span class="toc-number">13.4.</span> <span class="toc-text">拷贝控制示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB"><span class="toc-number">13.5.</span> <span class="toc-text">动态内存管理类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-number">13.6.</span> <span class="toc-text">对象移动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.</span> <span class="toc-text">重载运算与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.1.</span> <span class="toc-text">重载运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.2.</span> <span class="toc-text">输入输出运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.3.</span> <span class="toc-text">算术和关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.4.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.5.</span> <span class="toc-text">下标运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.6.</span> <span class="toc-text">递增递减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.7.</span> <span class="toc-text">成员访问运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.8.</span> <span class="toc-text">函数调用运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.9.</span> <span class="toc-text">重载、类型转换与运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">15.</span> <span class="toc-text">面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OOP-%E6%A6%82%E8%BF%B0"><span class="toc-number">15.1.</span> <span class="toc-text">OOP 概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BA%95%E8%AF%84%E8%AE%BA"><span class="toc-number">16.</span> <span class="toc-text">页底评论</span></a></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/01Trie/" style="font-size: 12px; color: #ffc299">01Trie</a> <a href="/tags/AVL%E6%A0%91/" style="font-size: 12px; color: #ffc299">AVL树</a> <a href="/tags/BFS/" style="font-size: 21px; color: #ffa466">BFS</a> <a href="/tags/Bellman-Ford/" style="font-size: 12px; color: #ffc299">Bellman-Ford</a> <a href="/tags/C/" style="font-size: 30px; color: #ff8533">C++</a> <a href="/tags/Cmake/" style="font-size: 16.5px; color: #ffb380">Cmake</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 25.5px; color: #ff944d">C语言</a> <a href="/tags/DFS/" style="font-size: 21px; color: #ffa466">DFS</a> <a href="/tags/DP/" style="font-size: 12px; color: #ffc299">DP</a> <a href="/tags/Dijkstra/" style="font-size: 12px; color: #ffc299">Dijkstra</a> <a href="/tags/Fleury/" style="font-size: 12px; color: #ffc299">Fleury</a> <a href="/tags/Floyd/" style="font-size: 12px; color: #ffc299">Floyd</a> <a href="/tags/Hexo/" style="font-size: 25.5px; color: #ff944d">Hexo</a> <a href="/tags/Hexo%E5%8D%9A%E5%AE%A2/" style="font-size: 12px; color: #ffc299">Hexo博客</a> <a href="/tags/Hierholzer/" style="font-size: 12px; color: #ffc299">Hierholzer</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:	#ff8533;"><link itemprop="mainEntityOfPage" href="https://blog.muyun.space/posts/46cf02c7/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="山暮云秋"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="山暮云秋 | Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Cpp基础教程<a class="post-edit-link" href="https://github.com/ShanMuYunQiu/MuYun_Blog/tree/hexo/source/_posts/编程语言/Cpp基础教程.md" target="_blank" title="编辑" rel="noopener"><span class="icon iconify" data-icon="ri:edit-line"></span></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <span class="post-meta-icon-text">发表于</span> <time title="创建时间：2022-12-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-03T00:00:00+08:00">2022-12-03</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <span class="post-meta-icon-text">更新于</span> <time title="修改时间：2023-07-25 00:00:00" itemprop="dateModified" datetime="2023-07-25T00:00:00+08:00">2023-07-25</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="本文字数">101.9k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="阅读时长">387m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><span class="icon iconify" data-icon="ri:eye-line"></span> <span id="busuanzi_value_page_pv"></span></span></span><span class="post-meta-divider">-</span><a href="#comment"><span class="post-meta-item-icon" title="评论数"><span class="icon iconify" data-icon="ri:chat-3-line"></span> <span class="waline-comment-count" id="/posts/46cf02c7/"></span></span></a><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="--text-color:#ff944d" itemprop="url" rel="index"><span itemprop="text">编程语言</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/C/" style="--text-color:#6699ff"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">C++</span></a><a class="tag-item" href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" style="--text-color:#cc33ff"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">基础语法</span></a></span></div><div class="post-author"><span class="author-name">山暮云秋</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><hr>
<p><em>注：该教程建立在学习过 C 语言的基础上，因此很多提过的细节会忽略，主要学习一些 C 语言没有或不同的特性，建议先学习 <a href="../7e973705/">C 语言基础教程</a></em></p>
<p><em>本文中没有特殊重申的，大多语句和特性都与 C 语言相同，C++ 是 C 的超集，兼容了 C 的大多数特性</em></p>
<hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a><strong>开始</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介</p>
</blockquote>
</div>

<span id="more"></span>

<h4 id="编写一个简单的-C-程序"><a href="#编写一个简单的-C-程序" class="headerlink" title="编写一个简单的 C++程序"></a><strong>编写一个简单的 C++程序</strong></h4><ul>
<li><p><strong>简单示例</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 相比C代码，可以省略main(void)的void</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a><strong>初识输入输出</strong></h4><ul>
<li><p><strong>程序示例</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter two numbers!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">int</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> v1 <span class="token operator">>></span> v2<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The sum of them is "</span> <span class="token operator">&lt;&lt;</span> v1 <span class="token operator">+</span> v2<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>C++的 IO 机制</strong></p>
<blockquote>
<p>1、<strong>C++<strong>包含了一个全面的</strong>标准库</strong>来提供<strong>IO 机制</strong>。其中有<strong>从 C 语言延续而来</strong>的<code>cstdio</code>库和<strong>新的</strong><code>iostream</code>库<br>2、<code>iostream</code>库包含<strong>两个基础类型</strong>：<code>istream</code>和<code>ostream</code>，分别表示<strong>输入流</strong>和<strong>输出流</strong><br>3、一个<strong>流</strong>(stream)就是一个<strong>字符序列</strong>，是<strong>从 IO 设备读出</strong>或<strong>写入 IO 设备</strong>的</p>
</blockquote>
</li>
<li><p><strong>标准输入输出对象</strong></p>
<blockquote>
<p>1、标准库定义了 4 个<strong>IO 对象</strong><br>2、为了<strong>处理输入</strong>，我们使用名为<code>cin</code>的<code>istream</code>类型对象，这个对象也被称为<strong>标准输入</strong><br>3、对于<strong>处理输出</strong>，我们使用名为<code>cout</code>的<code>ostream</code>类型对象，这个对象也被称为<strong>标准输出</strong><br>4、此外还有其他两个<code>ostream</code>类型对象，名为<code>cerr</code>和<code>clog</code>。其中<code>cerr</code>通常用来<strong>输出警告和错误信息</strong>，<code>clog</code>用来<strong>输出程序运行时的一般性信息</strong></p>
</blockquote>
</li>
<li><p><strong>向流写入写出</strong></p>
<blockquote>
<p>1、如果需要使用<code>iostream</code><strong>库中的对象</strong>进行<strong>输入输出</strong>，则需要用到<strong>流插入符</strong>将内容传输给<strong>流</strong><br>2、<code>&lt;&lt;</code>为<strong>输出运算符</strong>。其<strong>接受两个运算对象</strong>，<strong>左侧</strong>必须是一个<code>ostream</code><strong>对象</strong>，<strong>右侧</strong>的运算对象是<strong>要打印的值</strong>。此运算符将<strong>给定的值写入给定的</strong><code>ostream</code><strong>对象</strong>中<br>3、<code>&gt;&gt;</code>为<strong>输入运算符</strong>。其与<code>&gt;&gt;</code>类型，它<strong>左侧</strong>接受一个<code>istream</code><strong>对象</strong>，<strong>右侧</strong>接受一个<strong>运算对象</strong>。它从给定的<code>istream</code>中<strong>读入数据</strong>，并<strong>存入给定的对象</strong>中</p>
</blockquote>
</li>
<li><p><strong>endl 操纵符</strong></p>
<blockquote>
<p>1、<strong>endl</strong>是一个被称为<strong>操纵符</strong>的<strong>特殊值</strong><br>2、<strong>endl</strong>的效果是<strong>结束当前行</strong>(有换行效果)，并将与设备关联的<strong>缓冲区</strong>的内容<strong>刷到设备中</strong><br>3、<strong>缓冲刷新操作</strong>可以保证到目前为止<strong>程序所产生的所有输出</strong>都<strong>真正写入流中</strong>，而不是仅<strong>停留在内存</strong>中等待写入到流中</p>
</blockquote>
</li>
<li><p><strong>命名空间</strong></p>
<blockquote>
<p>1、示例程序中使用了<code>std::cout</code>和<code>std::endl</code>，而不是直接的<code>cout</code>和<code>endl</code>。其<strong>前缀</strong><code>std::</code>指出<strong>名字</strong><code>cout</code>和<code>endl</code>是定义在名为<code>std</code>的<strong>命名空间</strong>中的<br>2、<strong>命名空间</strong>可以帮助我们避免<strong>不经意的名字定义冲突</strong>以及<strong>使用库中相同名字导致的冲突</strong>。<strong>标准库</strong>定义的<strong>所有名字</strong>都在<strong>命名空间</strong><code>std</code>中<br>3、通过<strong>命名空间</strong>使用<strong>标准库</strong>有一个<strong>副作用</strong>：当使用<strong>标准库</strong>中的<strong>一个名字</strong>时，必须通过<strong>作用域运算符</strong><code>::</code>来<strong>显式声明</strong>我们想使用来自<code>std</code>中的名字，如示例<code>std::cout</code>那样(后续将给出一个更简单的访问标准库名字的方法)</p>
</blockquote>
</li>
</ul>
<h4 id="使用-C-版本的-C-标准库头文件"><a href="#使用-C-版本的-C-标准库头文件" class="headerlink" title="使用 C++版本的 C 标准库头文件"></a><strong>使用 C++版本的 C 标准库头文件</strong></h4><ul>
<li><p><strong>建议使用 C++版本标准库</strong></p>
<blockquote>
<p>1、C++标准库中<strong>兼容了 C 语言的标准库</strong>，其按照如下<strong>命名规则</strong>命名<br>2、C 语言的头文件形如<code>name.h</code>，C++将其命名为<code>cname</code>。即<strong>去掉</strong><code>.h</code><strong>后缀</strong>，文件名前<strong>添加字母</strong><code>c</code><br>3、因此<code>stdio.h</code>和<code>cstdio</code><strong>内容是一样的</strong>，而且<code>stdio.h</code>也能在 C++调用，但从<strong>命名规范</strong>上来讲，<code>cstdio</code>更符合 C++的要求<br>4、特别的，在名为<code>cname</code>的<strong>头文件</strong>定义的<strong>名字</strong>从属于<strong>命名空间</strong><code>std</code>，而原本<code>.h</code>的则不然<br>5、一般来说，C++程序<strong>应使用名为</strong><code>cname</code><strong>的头文件</strong>，因为这样<strong>标准库的名字</strong>总能在<code>std</code>找到。如果使用<code>.h</code>形式，那么程序员不得不时刻牢记哪些是从 C 语言继承过来的，哪些又是 C++独有的</p>
</blockquote>
</li>
</ul>
<h4 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a><strong>类简介</strong></h4><ul>
<li><p>我们将在之后详细学习<strong>类</strong>相关的知识，在此只<strong>简单介绍</strong></p>
</li>
<li><p><strong>什么是类</strong></p>
<blockquote>
<p>1、在 C++中，我们通过<strong>定义一个类</strong>来<strong>定义自己的数据结构</strong><br>2、一个<strong>类</strong>定义了<strong>一个类型</strong>，以及<strong>与之相关的一组操作</strong><br>3、<strong>类机制</strong>是 C++<strong>最重要的特性之一</strong>。实际上，C++最初的<strong>设计焦点</strong>就是能定义使用上像内置类型一样自然的<strong>类类型</strong></p>
</blockquote>
</li>
<li><p>如果要使用一个类，我们需要了解<strong>三件事情</strong>：</p>
<blockquote>
<p>1、类名是什么？<br>2、它在哪里定义的？<br>3、它支持什么操作？</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a><strong>变量和基本类型</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：基本内置类型；指定字面量类型；变量；对象；列表初始化；C++关键字；复合类型；引用；指针；void* 指针；<code>const</code>限定符；<code>const</code>的引用；<code>constexpr</code>和常量表达式；处理类型；类型别名；<code>auto</code>类型说明符；<code>decltype</code>类型指示符；自定义数据结构；定义类；使用类</p>
</blockquote>
</div>

<h4 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a><strong>基本内置类型</strong></h4><ul>
<li><p><strong>基本数据类型</strong></p>
<blockquote>
<p>1、C++定义了一套包括<strong>算术类型</strong>和<strong>空类型</strong>在内的<strong>基本数据类型</strong><br>2、其中<strong>算术类型</strong>包含了<strong>整型</strong>、<strong>浮点型</strong>、<strong>字符型</strong>、<strong>布尔型</strong><br>3、<strong>空类型 void</strong>不对应<strong>具体的值</strong>，仅用于一些<strong>特殊的场合</strong></p>
</blockquote>
</li>
<li><p>C++的<strong>基本数据类型</strong>与 C 语言<strong>规则相同</strong>，但 C++中<strong>直接支持</strong>了<strong>bool 类型</strong>，且<code>iostream</code>中<strong>直接支持</strong>了<strong>拓展类型</strong>(如<code>int32_t</code>等)</p>
</li>
<li><p><strong>指定字面量类型</strong></p>
<ul>
<li><p>通过添加<strong>前缀或后缀</strong>，可以改变不同类型<strong>字面量</strong>的<strong>默认类型</strong></p>
</li>
<li><p><strong>指定字符和字符串字面量</strong></p>
<table>
<thead>
<tr>
<th align="center">前缀</th>
<th align="center">类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">char16_t</td>
<td>Unicode 16 字符</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">char32_t</td>
<td>Unicode 32 字符</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">wchar_t</td>
<td>宽字符</td>
</tr>
<tr>
<td align="center">u8</td>
<td align="center">char</td>
<td>UTF-8(仅用于字符串字面常量)</td>
</tr>
</tbody></table>
</li>
<li><p><strong>指定整型字面量</strong></p>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u 或 U</td>
<td align="center">unsigned</td>
</tr>
<tr>
<td align="center">l 或 L</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">ll 或 LL</td>
<td align="center">long long</td>
</tr>
</tbody></table>
</li>
<li><p><strong>指定浮点型字面量</strong></p>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">f 或 F</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">l 或 L</td>
<td align="center">long double</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h4><ul>
<li><p><strong>变量</strong></p>
<blockquote>
<p>1、<strong>变量</strong>提供一个<strong>具名的</strong>、<strong>可供程序操作的存储空间</strong><br>2、C++中的每个变量都有其<strong>数据类型</strong>，<strong>数据类型</strong>决定着变量所占<strong>内存空间</strong>的<strong>大小及布局方式</strong>、该空间<strong>能存储值的范围</strong>，以及变量<strong>能参与的运算</strong><br>3、对于 C++程序员来说，<strong>变量</strong>和<strong>对象</strong>一般可以<strong>互换使用</strong></p>
</blockquote>
</li>
<li><p><strong>对象</strong></p>
<blockquote>
<p>1、C++程序员在很多场合都会使用<strong>对象</strong>这个名词。通常情况下，<strong>对象</strong>指一块<strong>能存储数据</strong>并<strong>具有某种类型</strong>的<strong>内存空间</strong><br>2、一部分人对<strong>对象</strong>的定义并不相同，比如：一些人仅在<strong>与类有关</strong>的场景才使用<strong>对象</strong>这个词；另一些人把<strong>命名了的对象</strong>叫做<strong>变量</strong>；还有一些人把<strong>对象</strong>和<strong>值</strong>区分开来，<strong>对象</strong>指<strong>能被程序修改的数据</strong>，而<strong>值</strong>指<strong>只读的数据</strong></p>
</blockquote>
</li>
<li><p><strong>列表初始化</strong></p>
<ul>
<li><p>C++定义了<strong>初始化</strong>的<strong>好几种不同形式</strong>，如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">units_sold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> units_sold <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 列表初始化</span>
<span class="token keyword">int</span> units_sold<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 列表初始化</span></code></pre>
</li>
<li><p><strong>列表初始化</strong></p>
<blockquote>
<p>1、作为<strong>C++11 新标准</strong>的一部分，用<strong>花括号</strong>来<strong>初始化变量</strong>得到了全面应用。这种初始化形式被称为<strong>列表初始化</strong><br>2、现在，无论是<strong>初始化对象</strong>还是某些时候<strong>为对象赋新值</strong>，都可以使用这样一组<strong>由花括号括起来的初始值</strong>了<br>3、当用于<strong>内置类型</strong>变量时，这种初始化形式有一个<strong>重要特点</strong>：如果我们<strong>使用列表初始化</strong>且<strong>初始值存在丢失信息的风险</strong>，<strong>编译器将报错</strong>(如下例)<br>4、这样的介绍看似无关紧要，因为我们不会故意<strong>用 long double 值初始化 int 变量</strong>，然而这种初始化<strong>可能在不经意间发生</strong>，因此这种赋值更加<strong>保守安全</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token keyword">double</span> ld <span class="token operator">=</span> <span class="token number">3.1415926536</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token punctuation">&#123;</span>ld<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token punctuation">&#123;</span>ld<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 报错：转换未执行，因为存在丢失信息的风险(丢失浮点精度)</span>
<span class="token keyword">int</span> <span class="token function">c</span><span class="token punctuation">(</span>ld<span class="token punctuation">)</span><span class="token punctuation">,</span> d <span class="token operator">=</span> ld<span class="token punctuation">;</span>      <span class="token comment">// 正确：转换执行，且确实丢失了部分值(丢失了小数点后的浮点部分)</span></code></pre></li>
</ul>
</li>
<li><p><strong>C++关键字</strong></p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">alignas</td>
<td align="center">continue</td>
<td align="center">friend</td>
<td align="center">register</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">alignof</td>
<td align="center">decltype</td>
<td align="center">goto</td>
<td align="center">reinterpret_cast</td>
<td align="center">try</td>
</tr>
<tr>
<td align="center">asm</td>
<td align="center">default</td>
<td align="center">if</td>
<td align="center">return</td>
<td align="center">typedef</td>
</tr>
<tr>
<td align="center">auto</td>
<td align="center">delete</td>
<td align="center">inline</td>
<td align="center">short</td>
<td align="center">typeid</td>
</tr>
<tr>
<td align="center">bool</td>
<td align="center">do</td>
<td align="center">int</td>
<td align="center">signed</td>
<td align="center">typename</td>
</tr>
<tr>
<td align="center">break</td>
<td align="center">double</td>
<td align="center">long</td>
<td align="center">sizeof</td>
<td align="center">union</td>
</tr>
<tr>
<td align="center">case</td>
<td align="center">dynamic_cast</td>
<td align="center">mutable</td>
<td align="center">static</td>
<td align="center">unsigned</td>
</tr>
<tr>
<td align="center">catch</td>
<td align="center">else</td>
<td align="center">namespace</td>
<td align="center">static_assert</td>
<td align="center">using</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">enum</td>
<td align="center">new</td>
<td align="center">static_cast</td>
<td align="center">virtual</td>
</tr>
<tr>
<td align="center">char16_t</td>
<td align="center">explicit</td>
<td align="center">noexcept</td>
<td align="center">struct</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">char32_t</td>
<td align="center">export</td>
<td align="center">nullptr</td>
<td align="center">switch</td>
<td align="center">volatile</td>
</tr>
<tr>
<td align="center">class</td>
<td align="center">extern</td>
<td align="center">operator</td>
<td align="center">template</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">false</td>
<td align="center">private</td>
<td align="center">this</td>
<td align="center">while</td>
</tr>
<tr>
<td align="center">constexpr</td>
<td align="center">float</td>
<td align="center">protected</td>
<td align="center">thread_local</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">const_cast</td>
<td align="center">for</td>
<td align="center">public</td>
<td align="center">throw</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a><strong>复合类型</strong></h4><ul>
<li><p><strong>复合类型</strong>是指<strong>基于其他类型</strong>定义的类型。C++有几种复合类型，在此主要了解其中两种：<strong>引用</strong>和<strong>指针</strong></p>
</li>
<li><p><strong>引用</strong></p>
<ul>
<li><p><strong>示例</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal <span class="token operator">=</span> ival<span class="token punctuation">;</span>     <span class="token comment">// 定义引用，refVal 指向 ival</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal2<span class="token punctuation">;</span>           <span class="token comment">// 报错：引用必须被初始化</span>
<span class="token comment">/*------------------------------------------------------------------*/</span>
refVal <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>             <span class="token comment">// 实际赋值给 refVal 指向的 ival</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal3 <span class="token operator">=</span> refVal<span class="token punctuation">;</span>  <span class="token comment">// refVal3 指向 refVal 指向的 ival</span>
<span class="token comment">/*------------------------------------------------------------------*/</span>
<span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal4 <span class="token operator">=</span> dval<span class="token punctuation">;</span>    <span class="token comment">// 报错：refVal4 为int类型，其指向对象必须为int类型</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal5 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment">// 报错：引用只能绑定在对象上</span></code></pre>
</li>
<li><p><strong>引用介绍</strong></p>
<blockquote>
<p>1、<strong>引用</strong>为对象<strong>起了另外一个名字</strong>，通过将声明符写成<code>&amp;变量名</code>来<strong>定义引用类型</strong><br>2、<strong>定义引用时</strong>，程序把<strong>引用</strong>和它的<strong>初始值</strong>绑定在一起。一旦初始化完成，<strong>引用</strong>将和它的<strong>初始值对象</strong>一直绑定在一起。因为<strong>无法</strong>令引用<strong>重新绑定另外一个对象</strong>，所以<strong>引用必须初始化</strong><br>3、引用<strong>并非对象</strong>，它只是为一个<strong>已经存在的对象</strong>所起的<strong>另外一个名字</strong>。定义一个引用之后，<strong>对其进行的所有操作</strong>都是在<strong>与之绑定的对象</strong>上进行的<br>4、所有<strong>引用的类型</strong>都要和<strong>与之绑定的对象</strong>严格匹配，且<strong>引用只能绑定在对象上</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>指针</strong></p>
<ul>
<li><p>C++的指针整体与 C 语言的指针相同，在此写出一些差异</p>
</li>
<li><p><strong>空指针</strong></p>
<blockquote>
<p>1、<strong>空指针</strong>不指向<strong>任何对象</strong>，下为三种<strong>生成空指针</strong>的方法<br>2、第一种方法是使用<strong>字面值</strong><code>nullptr</code>来初始化指针。<code>nullptr</code>是一种<strong>特殊类型</strong>的字面值，它可以<strong>被转换成任意其他的指针类型</strong><br>3、第二种方法是使用<strong>字面值 0</strong>来生成空指针(注意不是 int 值)<br>4、第三种方法是使用<strong>NULL 预处理器变量</strong>，这个变量在头文件<code>cstdlib</code>中定义，<strong>预处理变量</strong>不属于<strong>命名空间</strong><code>std</code>。在新标准下，现在的 C++程序<strong>最好使用</strong><code>nullptr</code>，同时<strong>尽量避免使用</strong><code>NULL</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 NULL 需要调用 cstdlib 头文件</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>void* 指针</strong></p>
<blockquote>
<p>1、void* 是一种特殊的指针类型，可用于存放<strong>任意对象的地址</strong>。不同的是，我们对该地址<strong>指向对象的类型</strong>并不了解<br>2、利用 void* 指针<strong>能做的事有限</strong>，<strong>不能直接操作</strong>其所指的对象，因为并<strong>不知道对象是什么类型</strong><br>3、概括来说，以 void* 视角来看，<strong>内存空间</strong>也就仅仅是<strong>内存空间</strong>，<strong>没办法访问</strong>内存空间中的<strong>对象</strong></p>
</blockquote>
</li>
</ul>
<h4 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a><strong>const 限定符</strong></h4><ul>
<li><p><strong>简述</strong></p>
<blockquote>
<p>1、有时我们希望定义一种<strong>值不能被改变</strong>的<strong>变量</strong>(或直接称为<strong>常量</strong>)，可以用<code>const</code>关键字加以修饰<br>2、因为<code>const</code>对象<strong>一旦创建</strong>，<strong>值就不能改变</strong>，所以<code>const</code>对象<strong>必须初始化</strong><br>3、<code>const</code>的用法整体与 C 语言中类似</p>
</blockquote>
</li>
<li><p><code>const</code><strong>的引用</strong></p>
<blockquote>
<p>1、可以把<strong>引用</strong>绑定到<code>const</code><strong>对象</strong>上，我们称之为<strong>对常量的引用</strong>(或<strong>常量引用</strong>)<br>2、<strong>常量引用</strong>仅对<strong>引用</strong>本身作出限定，对于<strong>引用的对象</strong>并未限定。如果对象本身<strong>不是常量</strong>，那么允许通过<strong>其他途径</strong>修改它的值</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> i<span class="token punctuation">;</span>      <span class="token comment">// 正确：引用及其对应对象都是常量</span>
r1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>                <span class="token comment">// 错误：r1是对常量的引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment">// 错误：r2是对非常量的引用，不能指向常量对象</span>
<span class="token comment">/*------------------------------------------------------------*/</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> n<span class="token punctuation">;</span>
r1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>                <span class="token comment">// 错误：r1是对常量的引用</span>
n <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>                 <span class="token comment">// 正确：n本身不是常量</span></code></pre>
</li>
<li><p><code>constexpr</code><strong>和常量表达式</strong></p>
<ul>
<li><p><strong>常量表达式</strong></p>
<blockquote>
<p>1、<strong>常量表达式</strong>指<strong>值不会改变</strong>且<strong>在编译过程中就能确定值</strong>的表达式<br>2、一个对象是不是常量表达式，由它的<strong>数据类型</strong>和<strong>初始值</strong>共同决定</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> max_file <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>          <span class="token comment">// 是常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> mix_file <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 是常量表达式</span>
<span class="token keyword">int</span> staff_size <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>              <span class="token comment">// 不是常量表达式：数据类型只是普通 int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 不是常量表达式：不能在编译过程中确定值</span></code></pre>
</li>
<li><p><code>constexpr</code><strong>变量</strong></p>
<blockquote>
<p>1、在一个复杂系统中，很难(甚至几乎肯定不能)<strong>分辨一个初始值</strong>是不是<strong>常量表达式</strong><br>2、<strong>C++11</strong>规定，允许将变量声明为<code>constexpr</code>类型，由<strong>编译器</strong>来验证<strong>变量的值</strong>是否为<strong>常量表达式</strong><br>3、声明为<code>constexpr</code>的变量<strong>一定是一个常量</strong>，而且<strong>必须用常量表达式初始化</strong><br>4、不能使用<strong>普通函数</strong>作为<code>constexpr</code><strong>初始值</strong>，允许定义一种特殊的<code>constexpr</code><strong>函数</strong>，后续介绍</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> mf <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>            <span class="token comment">// 编译通过</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> mf <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 编译通过</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 编译错误：除非 size() 是 constexpr 函数</span></code></pre>
</li>
<li><p><strong>字面值类型</strong></p>
<blockquote>
<p>1、<strong>常量表达式</strong>的值需要<strong>在编译时就得到计算</strong>，这些类型一般<strong>比较简单</strong>，值也显而易见，就把它们称为<strong>字面值类型</strong><br>2、目前为止，<strong>算术类型</strong>、<strong>引用</strong>、<strong>指针</strong>都<strong>是</strong>字面值类型。<strong>自定义类</strong>、<strong>IO 库</strong>、<strong>string 类型</strong>都<strong>不是</strong>字面值类型，也就不能被定义为<code>constexpr</code><br>3、尽管<strong>指针</strong>和<strong>引用</strong>都能被定义成<code>constexpr</code>，但它们的<strong>初始值受到严格限制</strong>。如<code>constexpr</code><strong>指针</strong>的初始值只能是<code>nullptr</code>或<strong>0</strong>，或存储于某个<strong>固定地址</strong>中的<strong>对象</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a><strong>处理类型</strong></h4><ul>
<li><p><strong>类型别名</strong></p>
<blockquote>
<p>1、有两种方法可用于定义<strong>类型别名</strong>，第一种是使用<code>typedef</code><strong>关键字</strong>，与 C 语言用法相同<br>2、新标准规定了一种新方法：使用<strong>别名声明</strong>。这种方法使用<code>using</code><strong>关键字</strong>作为<strong>别名声明</strong>的开始，其后紧跟别名和等号，作用是把<strong>等号左侧的名字</strong>规定成<strong>等号右侧的类型</strong>的别名</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">double</span> wages<span class="token punctuation">;</span>      <span class="token comment">// wages 是 double 的别名</span>
<span class="token keyword">typedef</span> wages base<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token comment">// base 是 wages(即double)的别名，p 是 double* 的别名</span>
<span class="token keyword">using</span> SI <span class="token operator">=</span> Sales_item<span class="token punctuation">;</span>     <span class="token comment">// SI 是 Sales_item 的别名</span></code></pre>
</li>
<li><p><code>auto</code><strong>类型说明符</strong></p>
<blockquote>
<p>1、编程时常常需要把<strong>表达式的值</strong>赋给变量，这就要求在<strong>声明变量时</strong>清楚地知道<strong>表达式的类型</strong>，然而做到这一点并不容易，甚至有时根本做不到<br>2、<strong>C++11</strong>引入了<code>auto</code><strong>类型说明符</strong>，能让<strong>编译器</strong>替我们去<strong>分析表达式的类型</strong><br>3、和原来<strong>只对应一种特定类型</strong>的说明符(如 double)不同，<code>auto</code>能让编译器<strong>通过初始值</strong>推算<strong>变量的类型</strong>。显然，<code>auto</code>定义的变量<strong>必须有初始值</strong><br>4、使用<code>auto</code>也能在<strong>一条语句</strong>声明<strong>多个变量</strong>，但由于一条声明语句<strong>只能有一个基本数据类型</strong>，所以该语句中<strong>所有变量</strong>的<strong>初始基本数据类型</strong>必须<strong>都一样</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> item <span class="token operator">=</span> val1 <span class="token operator">+</span> val2<span class="token punctuation">;</span>    <span class="token comment">// auto 自动判断表达式类型</span>
<span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>        <span class="token comment">// 正确：i 是整数，p 是整型指针</span>
<span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>     <span class="token comment">// 错误：sz 和 pi 类型不一致</span></code></pre>
</li>
<li><p><code>decltype</code><strong>类型指示符</strong></p>
<blockquote>
<p>1、有时我们希望从<strong>表达式的类型</strong>推断出要定义的<strong>变量的类型</strong>，但是不想用该表达式的值<strong>初始化变量</strong>。为此，<strong>C++11</strong>引入了<code>decltype</code><strong>说明符</strong><br>2、<code>decltype</code>可以<strong>返回操作数的数据类型</strong>，在此过程中，<strong>编译器</strong>分析表达式并<strong>得到它的类型</strong>，但并<strong>不实际计算表达式的值</strong><br>3、注意<code>decltype</code><strong>表达式的结果</strong>如果是<strong>加上括号的变量</strong>，则结果将是<strong>引用</strong>。即<code>decltype(())</code>(注意是双层括号)的<strong>结果永远是引用</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// x 的类型就是 ci 的类型，即 int，值为 0</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">def</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment">// sum的类型就是函数 def() 的返回类型，值为 x 的值</span>
<span class="token comment">/*--------------------------------------------------------------------*/</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> d<span class="token punctuation">;</span>            <span class="token comment">// 错误：d 是 int&amp; 引用类型，必须初始化</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> e<span class="token punctuation">;</span>              <span class="token comment">// 正确：e 是一个未初始化的 int 类型</span></code></pre></li>
</ul>
<h4 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a><strong>自定义数据结构</strong></h4><ul>
<li><p><strong>什么是数据结构</strong></p>
<blockquote>
<p>1、从最基本的层面理解，<strong>数据结构</strong>是把一组<strong>相关的数据元素</strong>组织起来然后使用它们的<strong>策略和方法</strong><br>2、举一个例子，我们想要创建一个<code>Sales_items</code><strong>类</strong>把书本的<strong>ISBN 编号</strong>、<strong>售出量</strong>、<strong>销售收入</strong>等数据组织在一起，并提供诸如<code>isbn()</code><strong>等函数</strong>，<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>+</code>、<code>+=</code><strong>等运算</strong>在内的<strong>一系列操作</strong>，<code>Sales_item</code><strong>类</strong>就是一个<strong>数据结构</strong><br>3、C++允许用户以<strong>类的形式</strong>自定义<strong>数据类型</strong>，而<strong>库类型</strong><code>string</code>、<code>istream</code>、<code>ostream</code>等也是<strong>以类的形式定义的</strong></p>
</blockquote>
</li>
<li><p><strong>定义类</strong></p>
<ul>
<li><p><strong>简单的不含运算功能的类</strong>的定义实际就是<strong>C 的结构体</strong>定义，使用<code>struct</code>定义</p>
</li>
<li><p>此外，C++提供<strong>另外一个关键字</strong><code>class</code>定义自己的<strong>数据结构</strong>，后续介绍</p>
</li>
</ul>
</li>
<li><p><strong>使用类</strong>：简单的<strong>类</strong>的使用与<strong>C 的结构体</strong>使用规则相似，但定义<strong>类对象</strong>(结构变量)时不需要再使用<code>struct</code>再次声明</p>
</li>
</ul>
<hr>
<h3 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a><strong>字符串、向量和数组</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：命名空间的<code>using</code>声明；标准库类型<code>string</code>；定义和初始化<code>string</code>对象；<code>string</code>对象的操作；处理<code>string</code>对象中的字符；范围 for 语句；标准库类型<code>vector</code>；模板；定义和初始化<code>vector</code>对象；向<code>vector</code>对象添加元素；其他<code>vector</code>操作；<code>vector</code>的索引；迭代器介绍；使用迭代器；泛型编程；迭代器运算；数组；<code>auto</code>与数组；指针也是迭代器；与旧代码的接口</p>
</blockquote>
</div>

<h4 id="命名空间的-using-声明"><a href="#命名空间的-using-声明" class="headerlink" title="命名空间的 using 声明"></a><strong>命名空间的 using 声明</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、目前为止，我们用到的<strong>库函数</strong>基本上都属于<strong>命名空间</strong><code>std</code>，而程序也显式地将这一点标示了出来，如<code>std::cin</code><br>2、用这种方法显得<strong>比较繁琐</strong>，然而幸运的是，通过更简单的途径也能使用到<strong>命名空间的成员</strong><br>3、本节将介绍其中一种<strong>最安全的方法</strong>，也就是<strong>使用</strong><code>using</code><strong>声明</strong>，后续会介绍另一种方法</p>
</blockquote>
</li>
<li><p><code>using</code><strong>声明</strong></p>
<blockquote>
<p>1、有了<code>using</code>声明就<strong>无须专门的前缀</strong>，也能使用所需的名字了<br>2、<code>using</code>声明具有<strong>如下形式</strong><code>using 命名空间名::名字</code>，如后示例<br>3、按照规定，每个<code>using</code>声明只能引入<strong>命名空间</strong>中的<strong>一个成员</strong>，因此每个名字都需要<strong>独立声明</strong><br>4、位于<strong>头文件</strong>的代码<strong>不应该使用</strong><code>using</code><strong>声明</strong>，因为引用该头文件的源代码也会<strong>引入这个声明</strong>，对于某些程序，可能会<strong>产生名字冲突</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    cin <span class="token operator">>></span> i<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a><strong>标准库类型 string</strong></h4><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、<strong>标准库类型</strong><code>string</code>表示<strong>可变长的字符序列</strong>(字符串)，使用<code>string</code>类型必须先包含<code>string</code><strong>头文件</strong><br>2、作为<strong>标准库的一部分</strong>，<code>string</code>定义在<strong>命名空间</strong><code>std</code>中<br>3、接下来的示例都假定已包含了下述代码</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string</code></pre>
</li>
<li><p><strong>定义和初始化 string 对象</strong></p>
<blockquote>
<p>1、如何<strong>初始化类的对象</strong>是由<strong>类本身</strong>决定的，一个类可以定义<strong>很多种</strong>初始化对象的方式，但这些方式之间<strong>必须有所区别</strong>：或者是<strong>初始值数量不同</strong>，或者是<strong>初始值类型不同</strong><br>2、下为<strong>初始化</strong><code>string</code><strong>对象</strong>的<strong>方式和示例</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string s1</td>
<td>默认初始化，s1 是一个空串</td>
</tr>
<tr>
<td>string s2(s1)</td>
<td>直接初始化，s2 是 s1 的副本</td>
</tr>
<tr>
<td>string s2 &#x3D; s1</td>
<td>拷贝初始化，s2 是 s1 的副本</td>
</tr>
<tr>
<td>string s3(“value”)</td>
<td>直接初始化，s3 是字符串字面值”value”的副本，空字符除外</td>
</tr>
<tr>
<td>string s3 &#x3D; “value”</td>
<td>拷贝初始化，s3 是字符串字面值”value”的副本，空字符除外</td>
</tr>
<tr>
<td>string s4(n, ‘c’)</td>
<td>直接初始化，把 s4 初始化为连续 n 个字符 c 组成的字符串</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string s1<span class="token punctuation">;</span>                    <span class="token comment">// 默认初始化，s1是空字符串</span>
string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>               <span class="token comment">// s2是s1的副本</span>
string <span class="token function">s3</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// s3是字面值"value"的副本</span>
string s3 <span class="token operator">=</span> <span class="token string">"value"</span><span class="token punctuation">;</span>          <span class="token comment">// s3是字面值"value"的副本</span>
string <span class="token function">s4</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 直接初始化，s4内容是 cccccccccc</span>
string s4 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 拷贝初始化，s4内容是 cccccccccc</span></code></pre>
</li>
<li><p><strong>string 对象的操作</strong></p>
<ul>
<li><p><strong>总览</strong></p>
<blockquote>
<p>1、一个<strong>类</strong>除了要规定<strong>初始化其对象的方式</strong>外，还要定义对象上<strong>能执行的操作</strong>。其中，类既能定义<strong>通过函数名调用的操作</strong>，也能定义<strong>各种运算符</strong>在<strong>该类对象</strong>上的<strong>新含义</strong><br>2、下表列举了<strong>大部分</strong><code>string</code><strong>类的操作</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>os&lt;&lt;s</td>
<td>将 s 写入到输出流 os 中，返回 os</td>
</tr>
<tr>
<td>is&gt;&gt;s</td>
<td>从 is 中读取字符串赋给 s，字符串以空格分隔，返回 is</td>
</tr>
<tr>
<td>getline(is, s)</td>
<td>从 is 中读取一行赋给 s，返回 is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s 为空返回 true，否则返回 false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回 s 中字符个数</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回 s 中第 n 个字符的引用，位置 n 从 0 计起</td>
</tr>
<tr>
<td>s1+s2</td>
<td>返回 s1 和 s2 连接后的结果</td>
</tr>
<tr>
<td>s1&#x3D;s2</td>
<td>用 s2 的副本代替 s1 中原来的字符</td>
</tr>
<tr>
<td>s1&#x3D;&#x3D;s2</td>
<td>如果 s1 和 s2 中的字符完全一样，则它们相等，对字母的判断依据是 ASCII 码</td>
</tr>
<tr>
<td>s1!&#x3D;s2</td>
<td>如果 s1 和 s2 中有一个字符不一样，则它们不相等，对字母的判断依据是 ASCII 码</td>
</tr>
<tr>
<td>&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;</td>
<td>对字符串从前向后依次比较字符的 ASCII 码，成立与否的依据是首个不相等字符的 ASCII 大小关系</td>
</tr>
</tbody></table>
</li>
<li><p><strong>读写操作</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 基本读写</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string s<span class="token punctuation">;</span>
    cin <span class="token operator">>></span> s<span class="token punctuation">;</span>   <span class="token comment">// 遇到空格停止</span>
    cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// getline整行读取</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string line<span class="token punctuation">;</span>
    <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 遇到换行符停止</span>
    cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// C语言风格EOF读写</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string word<span class="token punctuation">;</span>
    <span class="token comment">// while(getline(cin, line))</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> word<span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><code>empty</code><strong>和</strong><code>size</code><strong>操作</strong></p>
<blockquote>
<p>1、<code>empty</code><strong>函数</strong>根据<code>string</code><strong>对象是否为空</strong>返回一个<strong>布尔值</strong>，<code>size</code><strong>函数</strong>返回<code>string</code><strong>对象的长度</strong><br>2、这两个函数都是<code>string</code>的<strong>成员函数</strong>。<strong>调用该类函数</strong>的方法是，使用<strong>点操作符</strong>指明是<strong>哪个对象</strong>执行成员函数即可(<code>对象.成员函数()</code>)</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string line<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果字符串不为空 且 字符串长度大于10</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>line<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> line<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><code>string::size_type</code><strong>类型</strong></p>
<blockquote>
<p>1、实际上，<code>size</code><strong>函数的返回值</strong>是一个<code>string::size_type</code><strong>类型的值</strong><br>2、尽管我们不太清楚<code>string::size_type</code>类型的<strong>具体细节</strong>，但有一点是肯定的，它是一个<strong>无符号类型值</strong>，且<strong>足够存放任何</strong><code>string</code><strong>对象的大小</strong><br>3、所有<strong>用于存放</strong><code>string</code><strong>类</strong>的<code>size</code><strong>函数返回值</strong>的<strong>变量</strong>，都应该是<strong>该类型</strong>(<code>auto len = line.size();</code>中<code>line</code>的类型也<strong>自动设为该类型</strong>)<br>4、由于<strong>该类型</strong>是<strong>无符号整型</strong>，因此切记，如果在表达式中<strong>混用</strong>了<strong>无符号数和有符号数</strong>会产生意想不到的错误。如<strong>变量 n</strong>是一个<strong>具有负值的 int</strong>，则表达式<code>s.size() &lt; n</code>几乎肯定是<strong>true</strong>，因为<strong>负值 n</strong>会<strong>自动转换</strong>成一个<strong>较大的无符号值</strong></p>
</blockquote>
</li>
<li><p><strong>字面值和</strong><code>string</code><strong>对象相加</strong></p>
<blockquote>
<p>1、即使一种类型<strong>并非所需</strong>，我们也可以使用它，不过前提是<strong>这种类型能自动转换成所需类型</strong><br>2、因为<strong>标准库</strong>允许把<strong>字符字面值</strong>和<strong>字符串字面值</strong>转换成<code>string</code><strong>对象</strong>，所以在<strong>需要</strong><code>string</code><strong>对象的地方</strong>就可以用<strong>这两种字面值</strong>代替<br>3、注意：当把<code>string</code><strong>对象</strong>和<strong>这两种字面值</strong>混在一条语句中使用时，必须确保<strong>每个加法运算符</strong>的两侧的<strong>运算对象至少有一个</strong>是<code>string</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
string s3 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> s2 <span class="token operator">+</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token comment">/*------------------------------*/</span>
<span class="token comment">// 注意按顺序结合后结果的类型</span>
string s4 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>               <span class="token comment">// 正确</span>
string s5 <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>          <span class="token comment">// 错误</span>
string s6 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">;</span>     <span class="token comment">// 正确</span>
string s7 <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> s2<span class="token punctuation">;</span>     <span class="token comment">// 错误</span></code></pre></li>
</ul>
</li>
<li><p><strong>处理 string 对象中的字符</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、我们经常需要<strong>单独处理</strong><code>string</code><strong>对象</strong>中的<strong>字符</strong>，这类处理的关键问题是<strong>如何获取字符本身</strong>，另一个关键问题是要知道<strong>能改变某个字符的特性</strong><br>2、对于后者，我们可以使用<strong>C 语言继承而来</strong>的<code>cctype</code>(即<code>ctype.h</code>)，对于后者，我们可以通过<strong>范围 for 语句</strong>实现</p>
</blockquote>
</li>
<li><p><strong>范围 for 语句</strong></p>
<blockquote>
<p>1、如果想对<code>string</code><strong>对象</strong>中的<strong>每个字符</strong>做点什么，目前最好的操作是使用<strong>C++11 标准</strong>提供的<strong>范围 for 语句</strong>(语法形式如后附)<br>2、其中<strong>变量</strong>将被用于<strong>访问序列中的基础元素</strong>。每次<strong>迭代</strong>，<strong>变量</strong>都会被<strong>初始化</strong>为<strong>对象序列</strong>的<strong>下一个元素值</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>变量 <span class="token operator">:</span> 对象序列<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    循环体<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>示例：统计标点数并输出标点</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>getline<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> ct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    string s<span class="token punctuation">;</span>
    <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ispunct</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            ct<span class="token operator">++</span><span class="token punctuation">;</span>
            cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token string">"ct: "</span> <span class="token operator">&lt;&lt;</span> ct <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>使用范围 for 改变字符</strong></p>
<blockquote>
<p>1、如果想要<strong>改变</strong><code>string</code><strong>对象</strong>中<strong>字符的值</strong>，只需要把<strong>循环变量</strong>定义成<strong>引用</strong>类型即可<br>2、记住，所谓<strong>引用</strong>只是<strong>给定对象的一个别名</strong>，因此当<strong>引用</strong>作为<strong>循环控制变量</strong>时，这个变量实际<strong>被依次绑定到</strong>序列的<strong>每个元素</strong>上<br>3、下示例将<strong>整个字符串</strong>中的<strong>小写字母</strong>转换成<strong>大写字母</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>getline<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string s<span class="token punctuation">;</span>
    <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> s<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        c <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>只处理一部分字符</strong></p>
<blockquote>
<p>1、如果只想处理<strong>一部分</strong>字符，那么<strong>范围 for 语句</strong>则<strong>不能很好的胜任</strong>了。通常访问<code>string</code><strong>对象</strong>中的<strong>单个字符</strong>有两种方式：一种是使用<strong>下标</strong>，另一种是使用<strong>迭代器</strong>(后续介绍)<br>2、<code>string</code><strong>对象</strong>的下标使用与<strong>C 语言字符数组</strong>规则类似，使用<strong>for 循环遍历处理</strong>。对象的下标必须<strong>大于等于 0</strong>且<strong>小于</strong><code>s.size()</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="标准库类型-vector"><a href="#标准库类型-vector" class="headerlink" title="标准库类型 vector"></a><strong>标准库类型 vector</strong></h4><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、标准库类型<code>vector</code>表示<strong>对象的集合</strong>，其中<strong>所有对象的类型都相同</strong><br>2、集合中的<strong>每个对象</strong>都有一个<strong>与之对应的索引</strong>，索引用于<strong>访问对象</strong><br>3、因为<code>vector</code><strong>容纳着</strong>其他对象，所以它也常常被称作<strong>容器</strong><br>4、要想使用<code>vector</code>，必须包含<strong>适当的头文件</strong>。后续的例子中，都假设包含以下声明</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>模板</strong></p>
<ul>
<li><p><strong>模板简介</strong></p>
<blockquote>
<p>1、C++既有<strong>类模板</strong>，也有<strong>函数模板</strong>，其中<code>vector</code>是一个<strong>类模板</strong>。只要对 C++有深入了解后才能<strong>写出模板</strong>，我们将在 16 章介绍。但即使不会创建模板，我们也可以试着使用模板<br>2、<strong>模板</strong>本身不是<strong>类或函数</strong>，相反可以将<strong>模板</strong>看做<strong>编译器生成类或函数编写</strong>的一份<strong>说明</strong>。编译器<strong>根据模板创建类或函数</strong>的过程称为<strong>实例化</strong>，当使用模板时，需要指出编译器应把类或函数<strong>实例化成何种类型</strong><br>3、对于<strong>类模板</strong>来说，我们通过提供一些<strong>额外信息</strong>来指定模板应<strong>实例化成什么样的类</strong>，需要<strong>提供哪些信息</strong>由模板决定。<strong>提供信息的方式</strong>总是这样：在<strong>模板名字</strong>后面跟<strong>一对尖括号</strong>，在<strong>括号内</strong>放上信息，<code>模板名&lt;信息&gt;;</code></p>
</blockquote>
</li>
<li><p><strong>vector 模板</strong></p>
<blockquote>
<p>1、例如<code>vector</code>模板，<strong>需要提供的信息</strong>是<code>vector</code>内存放的<strong>对象类型</strong>(示例如后附代码)<br>2、<code>vector</code>是<strong>模板</strong>而非<strong>类型</strong>，由<code>vector</code><strong>生成的类型</strong>必须包含<code>vector</code>中<strong>所存放元素的类型</strong>，例如<code>vector&lt;int&gt;</code><br>3、<code>vector</code>能容纳<strong>绝大多数类型</strong>的<strong>对象</strong>作为其<strong>元素</strong>，但是由于<strong>引用不是对象</strong>，所以<strong>不存在包含引用的</strong><code>vector</code><br>4、早期版本 C++中，如果<code>vector</code><strong>的元素</strong>还是<code>vector</code>，必须在<strong>外层</strong>的<strong>右尖括号</strong>和<strong>其元素类型</strong>之间添加一个<strong>空格</strong>。比如应该写成<code>vector&lt;vector&lt;int&gt; &gt;</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ivec<span class="token punctuation">;</span>               <span class="token comment">// ivec保存int类型的对象</span>
vector<span class="token operator">&lt;</span>Sales_item<span class="token operator">></span> Sales_vec<span class="token punctuation">;</span>   <span class="token comment">// 保存Sales_item类型的对象</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> file<span class="token punctuation">;</span>    <span class="token comment">// 该向量的元素是vector对象</span></code></pre></li>
</ul>
</li>
<li><p><strong>定义和初始化 vector 对象</strong></p>
<ul>
<li><p>下表列出了<strong>初始化</strong><code>vector</code><strong>对象</strong>的<strong>方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vector&lt;T&gt; v1</td>
<td>v1 是一个空 vector，潜在元素为 T 类型，执行默认初始化</td>
</tr>
<tr>
<td>vector&lt;T&gt; v2(v1)</td>
<td>v2 中包含有 v1 所有元素的副本</td>
</tr>
<tr>
<td>vector&lt;T&gt; v2 &#x3D; v1</td>
<td>同上等价</td>
</tr>
<tr>
<td>vector&lt;T&gt; v3(n,val)</td>
<td>v3 包含 n 个重复的元素，每个元素值都是 val</td>
</tr>
<tr>
<td>vector&lt;T&gt; v4(n)</td>
<td>v4 包含 n 个重复执行了值初始化的对象</td>
</tr>
<tr>
<td>vector&lt;T&gt; v5{a,b,c,…}</td>
<td>v5 包含了初始值个数的元素，每个元素被赋予了相应的初始值</td>
</tr>
<tr>
<td>vector&lt;T&gt; v5 &#x3D; {a,b,c,…}</td>
<td>同上等价</td>
</tr>
</tbody></table>
</li>
<li><p>区分<code>()</code><strong>值初始化</strong>和<code>&#123;&#125;</code><strong>列表初始化</strong>的含义</p>
<blockquote>
<p>1、<code>vector&lt;int&gt; ivec(3,-1)</code>含义是<strong>ivec</strong>存放了<strong>3 个值为 -1 的元素</strong>；而<code>vector&lt;int&gt; ivec&#123;3,-1&#125;</code>含义是<strong>ivec</strong>存放了<strong>两个元素</strong>，<strong>值</strong>分别为<strong>3 和 -1</strong><br>2、<code>vector&lt;int&gt; ivec(10)</code>是指<strong>ivec</strong>创建了<strong>10 个执行了值初始化的元素</strong>(如 int 类型会被初始化为 0)<br>3、简单地说，想要<strong>初始化多个相同值</strong>就使用<code>()</code><strong>值初始化</strong>，想要<strong>初始化多个不同值</strong>就使用<code>&#123;&#125;</code><strong>列表初始化</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>向 vector 对象添加元素</strong></p>
<blockquote>
<p>1、经常我们会遇到，创建一个<code>vector</code>时并<strong>不清楚</strong>实际所需<strong>元素个数</strong>，元素的<strong>值</strong>也<strong>无法确定</strong>；还有些时候元素初值已知，但这些值<strong>总量较大</strong>且<strong>各不相同</strong><br>2、例如我们需要<code>vector</code><strong>对象</strong>存储 1-100 的数字，对此更好的办法是先创建一个<strong>空</strong><code>vector</code>，然后在<strong>运行时</strong>利用<code>vector</code>的<strong>成员函数</strong><code>push_back</code>来<strong>添加数据</strong><br>3、<code>push_back</code>负责把<strong>一个值</strong>当成<code>vector</code><strong>对象</strong>的<strong>尾元素</strong>，添加到<strong>对象的尾端</strong>，示例如下<br>4、注意：如果循环体内部含有<strong>向</strong><code>vector</code><strong>添加元素</strong>的语句，则不能使用<strong>范围 for 语句</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ivec<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>其他 vector 操作</strong></p>
<ul>
<li><p><code>vector</code>提供了一些<strong>其他操作</strong>，下表列出其中比较重要的一些</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>v.empty()</td>
<td>如果 v 不含有任何元素，返回 true，否则返回 false</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回 v 中元素的个数，返回值类型是 <code>vector\&lt;T&gt;::size_type</code> 类型</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td>将值为 t 的元素添加到 v 的尾端</td>
</tr>
<tr>
<td>v[n]</td>
<td>返回 v 中第 n 个位置上元素的引用</td>
</tr>
<tr>
<td>v1 &#x3D; v2</td>
<td>用 v2 中的元素拷贝替换 v1 中的元素</td>
</tr>
<tr>
<td>v1 &#x3D; {a,b,c,…}</td>
<td>用列表中的元素拷贝替换 v1 中的元素</td>
</tr>
<tr>
<td>&#x3D;&#x3D;,!&#x3D;,&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;</td>
<td>与 string 相同，比较字典序</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>vector 的索引</strong></p>
<blockquote>
<p>1、和<code>string</code>类似，如果需要<strong>逐个访问全部</strong><code>vector</code><strong>元素</strong>，也可以使用<strong>范围 for 语句</strong>+<strong>引用</strong><br>2、对于需要<strong>非顺序访问</strong>，可以使用<strong>下标</strong>访问，<strong>下标</strong>同样<strong>从 0 开始计算</strong><br>3、注意：只能对<strong>确知已存在的元素</strong>使用<strong>下标操作</strong>，因此<strong>不能使用下标添加元素</strong>，添加元素只能使用<code>push.back</code></p>
</blockquote>
</li>
</ul>
<h4 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a><strong>迭代器介绍</strong></h4><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、我们已经知道可以使用<strong>下标</strong>访问<code>string</code><strong>对象的字符</strong>和<code>vector</code><strong>对象的元素</strong>，还有另一种<strong>更通用的机制</strong>也能实现，就是<strong>迭代器</strong><br>2、除了<code>vector</code>外，<strong>标准库</strong>还定义了<strong>其他几种容器</strong>。<strong>所有标准库容器</strong>都能使用<strong>迭代器</strong>，但只有<strong>少数几种</strong>才同时支持<strong>下标操作</strong><br>3、类似于<strong>指针类型</strong>，迭代器也提供对<strong>对象</strong>的<strong>间接访问</strong>，同时迭代器也有<strong>有效</strong>和<strong>无效</strong>之分。<strong>有效</strong>的迭代器<strong>指向某个元素</strong>或指向<strong>容器尾元素的下一位置</strong>，其余都属于<strong>无效</strong>迭代器</p>
</blockquote>
</li>
<li><p><strong>使用迭代器</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>和指针不同</strong>的是，<strong>获取迭代器</strong>不是使用<strong>取地址符</strong>，<strong>有迭代器的类型</strong>同时拥有<strong>返回迭代器的成员</strong><br>2、比如<strong>这些类型</strong>都拥有名为<strong>begin</strong>和<strong>end</strong>的<strong>成员</strong>，其中<strong>begin 成员</strong>负责返回<strong>指向第一个元素的迭代器</strong>，<strong>end 成员</strong>负责返回<strong>指向容器尾元素下一位置的迭代器</strong><br>3、<strong>end 成员</strong>返回的<strong>迭代器</strong>常被称作<strong>尾后迭代器</strong>，或简称为<strong>尾迭代器</strong>。这样的迭代器没什么实际含义，只是个<strong>标记</strong>而已，表示我们已经处理完了容器中所有元素。特殊情况下，如果<strong>容器为空</strong>，则<strong>begin</strong>和<strong>end</strong>返回的是<strong>同一个迭代器</strong><br>4、一般来说，我们不清楚(也不需要在意)<strong>迭代器的准确类型</strong>是什么，通常使用<code>auto</code><strong>关键字</strong>定义变量来<strong>自动确定类型</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// b 表示 v 的第一个元素，e 表示 v 尾元素的下一位置</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>迭代器运算符</strong></p>
<blockquote>
<p>1、下表列举了部分<strong>迭代器支持的运算</strong><br>2、和指针类似，也能通过<strong>解引用迭代器</strong>来获取它<strong>所指示的元素</strong>，执行解引用的迭代器<strong>必须合法</strong>并<strong>确实指示着某个元素</strong><br>3、举个例子，使用<strong>迭代器</strong>访问<code>string</code><strong>对象</strong>，将字符串的<strong>首字母大写</strong>(如下例)</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*iter</td>
<td>返回迭代器 iter 所指元素的引用</td>
</tr>
<tr>
<td>iter-&gt;mem</td>
<td>解引用 iter 并获取该元素的名为 mem 的成员，等价于<code>(*iter).mem</code></td>
</tr>
<tr>
<td>++iter 或 iter++</td>
<td>令 iter 指示容器中的下一个元素</td>
</tr>
<tr>
<td>–iter 或 iter–</td>
<td>令 iter 指示容器中的上一个元素</td>
</tr>
<tr>
<td>iter1 &#x3D;&#x3D; iter2</td>
<td>判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等</td>
</tr>
<tr>
<td>iter1 !&#x3D; iter2</td>
<td>判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"some thing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// 确保 s 为非空字符串</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> it <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// it 表示 s 的第一个字符</span>
    <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 改为大写</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>将迭代器移动到另外一个元素</strong></p>
<blockquote>
<p>1、<strong>迭代器</strong>使用<strong>递增运算符</strong><code>++</code>来移动到<strong>下一个元素</strong>，使用<strong>递减运算符</strong><code>--</code>来移动到<strong>上一个元素</strong><br>2、因为<strong>end 返回的迭代器</strong>并不实际指示<strong>某个元素</strong>，所以<strong>不能</strong>对其进行<strong>递增</strong>或<strong>解引用</strong><br>3、下例为使用<strong>迭代器</strong>依次访问<code>string</code><strong>对象</strong>的<strong>字符</strong>，将<strong>整个字符串的字母大写</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>迭代器类型</strong></p>
<blockquote>
<p>1、就像<strong>不知道</strong><code>string</code>和<code>vector</code>的<code>size_type</code><strong>成员</strong>到底是<strong>什么类型</strong>一样，一般来说我们也<strong>不知道</strong>(也无需知道)<strong>迭代器的精确类型</strong><br>2、实际上，那些<strong>拥有迭代器</strong>的<strong>标准库类型</strong>使用<code>iterator</code>和<code>const_iterator</code>来表示<strong>迭代器的类型</strong>，其中<code>const_iterator</code>和<strong>常量指针</strong>差不多</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator it1<span class="token punctuation">;</span>          <span class="token comment">// it1 能读写 vector&lt;int> 的元素</span>
string<span class="token double-colon punctuation">::</span>iterator it2<span class="token punctuation">;</span>               <span class="token comment">// it2 能读写 string 对象中的字符</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>const_iterator it3<span class="token punctuation">;</span>    <span class="token comment">// it3 只能读元素，不能写元素</span>
string<span class="token double-colon punctuation">::</span>const_iterator it4<span class="token punctuation">;</span>         <span class="token comment">// it4 只能读字符，不能写字符</span></code></pre>
</li>
<li><p><code>cbegin</code><strong>和</strong><code>cend</code><strong>函数</strong></p>
<blockquote>
<p>1、<code>begin</code>和<code>end</code>返回的<strong>具体类型</strong>由<strong>对象是否是常量</strong>决定。如果对象<strong>是常量</strong>则返回<code>const_iterator</code>，如果<strong>不是常量</strong>在返回<code>iterator</code><br>2、有时候这种<strong>默认的行为</strong>并非我们所要，如果对象<strong>只需读无须写</strong>最好使用<strong>常量类型</strong><br>3、为了便于我们得到<code>const_iterator</code><strong>类型的返回值</strong>，C++11 引入了两个<strong>新函数</strong>：<code>cbegin</code>和<code>cend</code>，其返回值一定是<code>const_iterator</code>类型</p>
</blockquote>
</li>
<li><p><strong>组合解引用和成员访问操作</strong></p>
<blockquote>
<p>1、<strong>解引用迭代器</strong>可获得迭代器<strong>所指的对象</strong>，如果该<strong>对象的类型</strong>恰好是<strong>类</strong>，就有可能希望进一步<strong>访问它的成员</strong><br>2、例如，对于一个由字符串组成的<code>vector</code><strong>对象</strong>，要想检查其<strong>元素是否为空</strong>，令<strong>it</strong>是该<code>vector</code>的<strong>迭代器</strong>，只要检查<strong>it 所指字符串是否为空</strong>即可：<code>(*it).empty()</code>(注意前面的括号不可省略，因为关系到运算符优先级问题)<br>3、为了简化上述表达式，C++定义了<strong>箭头运算符</strong><code>-&gt;</code>。箭头运算符把<strong>解引用</strong>和<strong>成员访问</strong>两个操作<strong>结合在一起</strong>，也就是说，<code>it-&gt;mem</code>等效于<code>(*it).mem</code></p>
</blockquote>
</li>
<li><p><strong>某些对</strong><code>vector</code><strong>对象的操作会使迭代器失效</strong></p>
<blockquote>
<p>1、虽然<code>vector</code>对象可以<strong>动态地增长</strong>，但是也会有一些<strong>副作用</strong><br>2、已知的一个限制是不能在<strong>范围 for 语句</strong>内向<code>vector</code><strong>添加元素</strong>。另外一个限制是任何一种<strong>可能改变</strong><code>vector</code><strong>对象容量</strong>的操作，比如<code>push_back</code>，都会使其<strong>迭代器失效</strong>(后续解释)<br>3、谨记，但凡是使用了<strong>迭代器</strong>的<strong>循环体</strong>，<strong>都不要</strong>向迭代器所属容器<strong>添加元素</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>泛型编程</strong></p>
<blockquote>
<p>1、原来使用 C 或 Java 的程序员转而使用 C++ 后，会对<strong>for 循环</strong>中<strong>大量使用</strong><code>!=</code>而不是<code>&lt;</code>进行判断感到奇怪<br>2、C++程序员<strong>习惯性使用</strong><code>!=</code>，其原因和他们<strong>更愿意用迭代器而非下标</strong>的原因一样：这种编程风格在<strong>标准库提供的所有容器</strong>上都有效<br>3、与之类似，<strong>所有标准库容器的迭代器</strong>都定义了<code>!=</code>和<code>==</code>，但它们中的<strong>大多数没有定义</strong><code>&lt;</code><strong>运算符</strong><br>4、因此，只要我们养成使用<strong>迭代器</strong>和<code>!=</code>的习惯，就<strong>不用太在意</strong>用的到底是<strong>哪种类型</strong></p>
</blockquote>
</li>
<li><p><strong>迭代器运算</strong></p>
<blockquote>
<p>1、<code>string</code>和<code>vector</code>的<strong>迭代器</strong>提供了更多额外的<strong>运算符</strong>，一方面可使得迭代器<strong>每次移动过多个元素</strong>，另外也支持迭代器进行<strong>关系运算</strong>。<br>2、所有这些运算都被称为<strong>迭代器运算</strong>，如下表</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>iter + n</td>
<td>迭代器加上一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置</td>
</tr>
<tr>
<td>iter - n</td>
<td>迭代器减去一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置</td>
</tr>
<tr>
<td>iter +&#x3D; n</td>
<td>迭代器加法的复合赋值语句，将 iter 加 n 的结果赋给 iter</td>
</tr>
<tr>
<td>iter -&#x3D; n</td>
<td>迭代器减法的复合赋值语句，将 iter 减 n 的结果赋给 iter</td>
</tr>
<tr>
<td>iter1 - iter2</td>
<td>两个迭代器相减的结果是它们之间的距离，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置</td>
</tr>
<tr>
<td>&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;</td>
<td>迭代器关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则前者小于后者，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置，类型是<code>difference_type</code>的带符号整型</td>
</tr>
</tbody></table>
</li>
<li><p><strong>使用迭代器运算</strong></p>
<ul>
<li><p>使用迭代器运算的一个<strong>经典算法</strong>是<strong>二分搜索</strong>，其从<strong>有序序列</strong>中寻找某个<strong>给定值</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// text 必须是有序的，sought 是要搜索的给定值</span>
<span class="token keyword">auto</span> beg <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// beg 和 end 表示搜索的范围</span>
<span class="token keyword">auto</span> mid <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> bag<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 初始中间点</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>mid <span class="token operator">!=</span> end <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>mid <span class="token operator">!=</span> sought<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sought <span class="token operator">&lt;</span> <span class="token operator">*</span>mid<span class="token punctuation">)</span>                        <span class="token comment">// 如果在前半部分</span>
        end <span class="token operator">=</span> mid<span class="token punctuation">;</span>                            <span class="token comment">// 忽略后半部分</span>
    <span class="token keyword">else</span>                                      <span class="token comment">// 如果在后半部分</span>
        beg <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">// 在mid之后寻找</span>
    mid <span class="token operator">=</span> beg <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> beg<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>              <span class="token comment">// 新的中间点</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h4><ul>
<li><p><strong>数组</strong>的大部分使用规则<strong>与 C 语言相同</strong></p>
</li>
<li><p><strong>auto 与数组</strong></p>
<blockquote>
<p>1、由于<strong>数组名</strong>是数组的<strong>首元素地址</strong>，所以使用<code>auto</code><strong>关键字</strong>时，<code>auto ia2(ia)</code>等同于<code>auto ia2(&amp;ia[0])</code><br>2、但如果使用<code>decltype</code><strong>关键字</strong>，上述转换<strong>不会发生</strong>，<code>decltype(ia)</code><strong>返回类型</strong>是由<strong>10 个整数</strong>构成的<strong>数组</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// ia2是一个整型指针，指向ia的首元素</span>
<span class="token keyword">auto</span> <span class="token function">ia2</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ia3是一个含有10个整数的数组</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span> ia3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>指针也是迭代器</strong></p>
<blockquote>
<p>1、就像使用<strong>迭代器</strong>遍历<code>vector</code><strong>对象</strong>那样，使用<strong>指针</strong>也能<strong>遍历数组中的元素</strong>。不过前提是先获取到<strong>指向数组首元素的指针</strong>和<strong>指向数组尾元素下一位的指针</strong><br>2、获取<strong>首元素地址</strong>可以使用<strong>数组名</strong>，而<strong>尾后指针</strong>可以获取<strong>尾元素后</strong>那个<strong>并不存在的元素的地址</strong>。如假设定义<code>int arr[10];</code>，则可以<code>int *end = &amp;arr[10]</code><br>3、尽管<strong>通过计算</strong>可以得到<strong>尾后指针</strong>，但这种方法<strong>极易出错</strong>。为了让指针的使用更简单，C++11 新增了<strong>两个函数</strong>：<code>begin</code><strong>函数</strong>和<code>end</code><strong>函数</strong><br>4、这<strong>两个函数</strong>与<strong>容器中</strong>的<strong>两个同名成员</strong>功能类似，不过<strong>数组不是类类型</strong>，所以这两个函数<strong>不是成员函数</strong>。正确使用的方法是将<strong>数组</strong>作为它们的<strong>参数</strong>，如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>begin <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>end <span class="token operator">=</span> <span class="token function">end</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>与旧代码的接口</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、很多 C++程序在<strong>标准库出现之前</strong>就已经写成了，它们肯定没用到<code>string</code>和<code>vector</code>类型；而且有一些 C++程序实际上是<strong>与 C 语言或其他语言</strong>的<strong>接口程序</strong>，当然也无法使用<strong>C++标准库</strong><br>2、但是，现代的 C++ 程序不得不与那些<strong>充满了数组</strong>或<strong>C 风格字符串</strong>的代码衔接。为了使这一工作<strong>简单易行</strong>，C++专门提供了一组功能</p>
</blockquote>
</li>
<li><p><strong>混用</strong><code>string</code><strong>对象和 C 风格字符串</strong></p>
<blockquote>
<p>1、允许使用以<code>\0</code>结束的<strong>字符数组</strong>(即 C 风格字符串)来对<code>string</code><strong>对象</strong>进行<strong>初始化</strong>和<strong>赋值</strong><br>2、在<code>string</code><strong>对象</strong>的<strong>加法运算</strong>中允许使用<strong>C 风格字符串</strong>作为其中<strong>一个运算对象</strong>(不能两个都是)；在<code>string</code><strong>对象</strong>的<strong>复合赋值运算</strong>中允许使用<strong>C 风格字符串</strong>作为<strong>右侧运算对象</strong><br>3、上述性质<strong>反过来</strong>就<strong>不成立</strong>了：如果程序某处需要一个<strong>C 风格字符串</strong>，不能用<code>string</code><strong>对象</strong>代替它，例如不能用<code>string</code><strong>对象</strong>初始化一个<strong>指向 char 的指针</strong><br>4、为了完成该功能，<code>string</code>专门提供了一个名为<code>c_str</code>的<strong>成员函数</strong>：其返回<strong>一个指针</strong>，指向一个<strong>C 风格字符串</strong>，该<strong>字符串内容</strong>与<code>string</code><strong>对象</strong>一样；指针的类型是<code>const *char</code>，确保<strong>不会改变字符数组的内容</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> s<span class="token punctuation">;</span>                <span class="token comment">// 错误，不能用string对象初始化指向char的指针</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确</span></code></pre>
</li>
<li><p><strong>用数组初始化</strong><code>vector</code><strong>对象</strong></p>
<ul>
<li><p>允许使用<strong>数组</strong>来<strong>初始化</strong><code>vector</code><strong>对象</strong>。要实现这一目的，只需指明要<strong>拷贝区域</strong>的<strong>首元素地址</strong>和<strong>尾后地址</strong>即可(最简单的方式是用<code>begin</code>和<code>end</code>函数)</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> int_arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ivec</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>int_arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a><strong>表达式</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：特性补充；<strong>sizeof</strong>运算符；强制类型转换</p>
</blockquote>
</div>

<h4 id="特性补充"><a href="#特性补充" class="headerlink" title="特性补充"></a><strong>特性补充</strong></h4><ul>
<li><p>C++的<strong>表达式</strong>和<strong>运算符</strong>与 C 大部分相同，在此<strong>补充</strong>或<strong>强调</strong>一些特性</p>
</li>
<li><p><strong>sizeof 运算符</strong></p>
<blockquote>
<p>1、对<code>string</code>或<code>vector</code><strong>对象</strong>执行<code>sizeof</code><strong>运算符</strong>只返回<strong>该类型固定部分</strong>的<strong>大小</strong>，<strong>不会计算</strong>对象中的元素占用了多少<strong>空间</strong><br>2、因为<code>sizeof</code>的<strong>返回值</strong>是一个<strong>常量表达式</strong><code>constexpr size_t</code>，因此可以用<code>sizeof</code>的结果<strong>声明数组的大小</strong></p>
</blockquote>
</li>
<li><p><strong>强制类型转换</strong></p>
<ul>
<li><p>一个命名的<strong>强制类型转换</strong>具有<strong>如下形式</strong>：<code>转换模式&lt;转换类型&gt;(表达式)</code></p>
</li>
<li><p>其中，<strong>转换模式</strong>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code>中的一种</p>
</li>
<li><p><code>static_cast</code><strong>模式</strong></p>
<blockquote>
<p>1、任何具有<strong>明确定义</strong>的<strong>类型转换</strong>，只要不包含<strong>底层</strong><code>const</code>，都可以使用<code>static_cast</code>，例如：<code>double slope = static_cast&lt;double&gt;(i);</code><br>2、<code>static_cast</code>对于<strong>编译器无法自动执行</strong>的<strong>类型转换</strong>也非常有用，例如可以<strong>找回存在于</strong><code>void*</code><strong>的指针</strong>，转换回<strong>原始的指针类型</strong>，示例如后<br>3、但是对于<strong>存在于</strong><code>void*</code><strong>的指针</strong>，应确保<strong>指针的值保持不变</strong>，且<strong>转换后所得类型</strong>就是<strong>指针所指类型</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 任何非常量对象的地址都能存入void*</span>
<span class="token keyword">void</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
<span class="token comment">//将void*转换回原始的指针类型(指向double的指针)</span>
<span class="token keyword">double</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>const_cast</code><strong>模式</strong></p>
<blockquote>
<p>1、<code>const_cast</code><strong>只能改变</strong>运算对象的<strong>底层</strong><code>const</code>，对于将<strong>常量对象</strong>转换成<strong>非常量对象</strong>的行为，称其为<strong>去掉</strong><code>const</code><strong>性质</strong><br>2、一旦<strong>去掉了</strong>某个对象的<code>const</code><strong>性质</strong>，编译器将<strong>不再阻止</strong>我们对该对象进行<strong>写入操作</strong><br>3、如果对象<strong>本身不是一个常量</strong>，那么强制类型转换获得<strong>写权限</strong>是<strong>合法的行为</strong>；但如果对象<strong>本身是一个常量</strong>，则再使用<code>const_cast</code>执行<strong>写操作</strong>将产生<strong>未定义的后果</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 正确：但是写操作是未定义的行为</span>
<span class="token comment">/*-----------------------------*/</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 错误：static_cast不能转换掉const性质</span>
<span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 错误，const_cast只能改变常量属性</span>
<span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 正确</span></code></pre>
</li>
<li><p><code>reinterpret_cast</code><strong>模式</strong></p>
<blockquote>
<p>1、<code>reinterpret_cast</code>通常为<strong>运算对象</strong>的<strong>位模式</strong>提供<strong>较低层次</strong>上的重新解释<br>2、如下例，我们必须牢记<strong>pc</strong>所指的<strong>真实对象是 int 而非字符</strong>，如果把<strong>pc</strong>当成普通的<strong>字符指针</strong>使用就可以在运行时发生错误<br>3、使用<code>reinterpret_cast</code>是<strong>非常危险</strong>的，其中关键问题是<strong>类型改变了</strong>，但编译器<strong>没有给出任何警告或错误提示</strong>。下面<strong>使用 pc 时</strong>就会认定它的值是<strong>char*类型</strong>，<strong>编译器没法知道</strong>它实际存放的是<strong>指向 int 的指针</strong><br>4、<code>reinterpret_cast</code>本质上<strong>依赖于机器</strong>。想要安全地使用，必须对<strong>涉及的类型</strong>和<strong>编译器实现转换的过程</strong>都相当了解</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>pc <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">str</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 错误：可能导致异常的运行时行为</span></code></pre>
</li>
<li><p><code>dynamic_cast</code><strong>模式</strong>：支持<strong>运行时类型识别</strong>，后续介绍</p>
</li>
<li><p>此外，C 语言的<strong>旧式强制类型转换</strong>仍然支持，但与 C++ 的相比，表现形式上不那么清晰明了，<strong>出错追踪比较困难</strong>，建议使用 C++ 的转换方式</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a><strong>语句</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：<code>try</code>语句块和异常处理；C++的异常处理；<code>throw</code>表达式；<code>try</code>语句块；编写处理代码；标准异常</p>
</blockquote>
</div>

<h4 id="try-语句块和异常处理"><a href="#try-语句块和异常处理" class="headerlink" title="try 语句块和异常处理"></a><strong>try 语句块和异常处理</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>异常</strong>是指存在于<strong>运行时</strong>的<strong>反常行为</strong>，这些行为超出了<strong>函数正常功能</strong>的范畴，典型的异常包括<strong>失去数据库连接</strong>以及<strong>遇到意外输入</strong>等。处理反常行为可能是设计所有系统最难的一部分<br>2、当<strong>程序的某部分</strong>检测到一个让它<strong>无法处理</strong>的问题时，就需要用到<strong>异常处理</strong>。如果程序中含有<strong>可能引发异常的代码</strong>，那么通常也会有<strong>专门的代码处理问题</strong><br>3、<strong>异常处理机制</strong>为程序中<strong>异常检测</strong>和<strong>异常处理</strong>这两部分的协作提供支持。C++中，异常处理包括以下部分</p>
</blockquote>
</li>
<li><p><strong>C++的异常处理</strong></p>
<blockquote>
<p>1、<code>throw</code><strong>表达式</strong>：<strong>异常检测</strong>部分使用<code>throw</code><strong>表达式</strong>来表示它<strong>遇到了无法处理的问题</strong>，我们说<code>throw</code><strong>引发了异常</strong><br>2、<code>try</code><strong>语句块</strong>：<strong>异常处理</strong>部分使用<code>try</code><strong>语句块</strong>处理异常。<code>try</code>中包含<strong>一个或多个</strong><code>catch</code><strong>子句</strong>，抛出的<strong>异常</strong>通常会<strong>被某个</strong><code>catch</code><strong>子句处理</strong>。因为<code>catch</code><strong>子句</strong>处理异常，所以它们也被称为<strong>异常处理代码</strong><br>3、一套<strong>类异常</strong>：用于在<code>throw</code><strong>表达式</strong>和相关的<code>catch</code><strong>子句</strong>之间<strong>传递异常的具体信息</strong></p>
</blockquote>
</li>
<li><p><strong>throw 表达式</strong></p>
<blockquote>
<p>1、程序的<strong>异常检测</strong>部分使用<code>throw</code><strong>表达式</strong>引发一个<strong>异常</strong>，形式如<code>throw 表达式;</code>，其中的<strong>表达式类型</strong>就是<strong>抛出的异常类型</strong><br>2、如下示例，如果书籍的 ISBN 不一样就<strong>抛出异常</strong>，该<strong>异常类型是</strong><code>runtime_error</code><strong>对象</strong>。抛出异常将<strong>终止当前的函数</strong>，并把<strong>控制权</strong>转移给<strong>能处理该异常的代码</strong><br>3、类型<code>runtime_error</code>是<strong>标准库异常类型</strong>的一种，定义在<code>stdexcept</code><strong>头文件</strong>中，后面将介绍其他的异常类型<br>4、我们必须<strong>初始化</strong><code>runtime_error</code><strong>对象</strong>，方式是给它提供一个<code>string</code><strong>对象</strong>或一个<strong>C 风格字符串</strong>，这个字符串中有一些关于异常的<strong>辅助信息</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>item1<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> item2<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"数据必须具有相同的ISBN"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> item1 <span class="token operator">+</span> item2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>try 语句块</strong></p>
<blockquote>
<p>1、<code>try</code><strong>语句块</strong>的通用语法形式如下<br>2、跟在<code>try</code><strong>块</strong>之后的是<strong>一个或多个</strong><code>catch</code><strong>子句</strong>。<code>catch</code><strong>子句</strong>包括三部分：<strong>关键字</strong><code>catch</code>、括号内一个(可能未命名的)<strong>对象的声明</strong>(称作异常声明)、以及<strong>一个块</strong><br>3、当选中了某个<code>catch</code>子句<strong>异常处理之后</strong>，执行<strong>与之对应的块</strong>。<code>catch</code><strong>一旦执行完成</strong>，会<strong>跳转到</strong><code>try</code><strong>块</strong>中<strong>最后一个</strong><code>catch</code><strong>子句之后</strong>的语句继续执行<br>4、<code>try</code><strong>块</strong>中的<strong>程序语句</strong>组成程序的<strong>正常逻辑</strong>，像其他任何块一样，可以有包括声明在内的任意 C++ 语句</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">try</span>
<span class="token punctuation">&#123;</span>
    程序语句
<span class="token punctuation">&#125;</span>
<span class="token keyword">catch</span><span class="token punctuation">(</span>异常声明<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    处理语句
<span class="token punctuation">&#125;</span>
<span class="token keyword">catch</span><span class="token punctuation">(</span>异常声明<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    处理语句
<span class="token punctuation">&#125;</span>
<span class="token comment">// ...</span></code></pre>
</li>
<li><p><strong>编写处理代码</strong></p>
<blockquote>
<p>1、编写<strong>异常处理代码</strong>，上面的程序可以按如下示例处理<br>2、将程序<strong>本来要执行的任务</strong>放在<code>try</code><strong>语句块</strong>中，因为这段代码<strong>可能抛出异常</strong><br>3、<code>try</code>对应一个<code>catch</code><strong>子句</strong>，该子句负责<strong>处理</strong><code>runtime_error</code><strong>类型的异常</strong>。如果<code>try</code>中抛出了<strong>此类异常</strong>，则会执行该<code>catch</code>内的语句<br>4、<code>catch</code>中输出给用户的信息中，输出了<code>err.what()</code>的返回值。从<code>catch</code><strong>小括号的定义</strong>能得到<strong>err</strong>是一个<code>runtime_error</code><strong>类的对象</strong>，<code>what</code>则是该<strong>类</strong>的一个<strong>成员函数</strong><br>5、<code>what</code>成员函数<strong>没有参数</strong>，<strong>返回值</strong>是<strong>C 风格字符串</strong>(即<code>const char*</code>)。其中，<code>runtime_error</code>的<code>what</code><strong>成员</strong>返回的是<strong>初始化一个具体对象</strong>时所用的<code>string</code><strong>对象的副本</strong>(即<code>try</code>中初始化的字符串)</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> item1 <span class="token operator">>></span> item2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>item1<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> item2<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"数据必须具有相同的ISBN"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> item1 <span class="token operator">+</span> item2<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span>runtime_error err<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> err<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n 再次尝试？输入y或n"</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">char</span> c<span class="token punctuation">;</span>
        cin <span class="token operator">>></span> c<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cin <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'n'</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
              cout <span class="token operator">&lt;&lt;</span> <span class="token string">"程序退出"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token comment">// 跳出 while 循环</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>标准异常</strong></p>
<ul>
<li><p><strong>标准异常类</strong></p>
<blockquote>
<p>1、C++<strong>标准库</strong>中定义了一组<strong>类</strong>，用于报告<strong>标准库函数</strong>遇到的问题。这些<strong>异常类</strong>也可以在<strong>用户编写的程序中</strong>使用，分别定义在<strong>4 个头文件</strong><br>2、<code>exception</code>：定义了<strong>最通用的异常类</strong><code>exception</code>，它<strong>只报告异常的发生</strong>，<strong>不提供任何额外信息</strong><br>3、<code>stdexcept</code>：定义了几种<strong>常用的异常类</strong>，详细信息见下表<br>4、<code>new</code>：定义了<code>bad_alloc</code><strong>异常类型</strong>，后续介绍<br>5、<code>type_info</code>：定义了<code>bad_cast</code><strong>异常类型</strong>，后续介绍</p>
</blockquote>
<table>
<thead>
<tr>
<th>stdexcept 定义的异常类</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>exception</td>
<td>最常见的错误</td>
</tr>
<tr>
<td>runtime_error</td>
<td>只有在运行时才能检测出的任务</td>
</tr>
<tr>
<td>range_error</td>
<td>运行时错误：生成的结果超出了有意义的值域范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时错误：计算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误：计算下溢</td>
</tr>
<tr>
<td>logic_error</td>
<td>程序逻辑错误</td>
</tr>
<tr>
<td>domain_error</td>
<td>逻辑错误：参数对应的结果值不存在</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>逻辑错误：无效参数</td>
</tr>
<tr>
<td>length_error</td>
<td>逻辑错误：试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td>out_of_range</td>
<td>逻辑错误：使用一个超出有效范围的值</td>
</tr>
</tbody></table>
</li>
<li><p><strong>运算与成员</strong></p>
<blockquote>
<p>1、<strong>标准库异常类</strong>只定义了几种运算，包括<strong>创建或拷贝异常类型的对象</strong>，以及<strong>为异常类型的对象赋值</strong><br>2、我们只能以<strong>默认初始化</strong>的方式初始化<code>exception</code>、<code>bad_alloc</code>、<code>bad_cast</code>对象，<strong>不允许</strong>为这些对象<strong>提供初始值</strong><br>3、<strong>其他异常类型</strong>的行为恰好相反，应该使用<code>string</code><strong>对象</strong>或者<strong>C 风格字符串</strong>初始化这些类型的对象，<strong>不允许</strong>使用<strong>默认初始化</strong>的方式。创建此类对象时，<strong>必须提供初始值</strong>，该值含有<strong>错误相关信息</strong><br>4、<strong>异常类型</strong>中定义了一个名为<code>what</code>的<strong>成员函数</strong>，返回值是<strong>C 风格字符串</strong>，字符串的目的是<strong>提供关于异常的一些文本信息</strong>。对于其他<strong>无初始值的异常类型</strong>，<code>what</code>返回的内容由<strong>编译器决定</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：含有可变形参的函数；<code>initializer_list</code>形参；函数的返回值；不要返回局部对象的引用或指针；返回数组指针的函数；函数重载；定义重载函数；重载和<code>const</code>形参；<code>const_cast</code>和重载；特殊用途语言特性；默认实参；内联函数；<code>constexpr</code>函数</p>
</blockquote>
</div>

<h4 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a><strong>含有可变形参的函数</strong></h4><ul>
<li><p><strong>简介</strong></p>
<blockquote>
<p>1、有时我们<strong>无法提前预知</strong>应该向函数<strong>传递几个实参</strong>。为了编写<strong>能处理不同数量实参</strong>的函数，C++11 提供了以下几种方法<br>2、如果所有的<strong>实参类型相同</strong>，可以传递一个名为<code>initializer_list</code>的<strong>标准库类型</strong><br>3、如果<strong>实参类型不同</strong>，可以编写一种特殊的函数——<strong>可变参数模板</strong>，将在后续介绍<br>4、此外还有一种从<strong>C 标准库</strong><code>stdarg.h</code>继承而来的<strong>省略符形参</strong><code>...</code>，但有了一些限制</p>
</blockquote>
</li>
<li><p><strong>initializer_list 形参</strong></p>
<ul>
<li><p><strong>简介</strong></p>
<blockquote>
<p>1、<code>initializer_list</code>是一种<strong>标准库类型</strong>，用于表示<strong>某种特定类型的值的数组</strong>，其定义在<code>initializer_list</code><strong>头文件</strong>中<br>2、和<code>vector</code>一样，<strong>该类型</strong>也是一种<strong>模板类型</strong>，这意味着<strong>定义对象</strong>时，也必须说明列表中<strong>所含元素的类型</strong>：<code>initializer_list&lt;int&gt; li;</code><br>3、和<code>vector</code>不同的是，该类型对象中的<strong>元素永远是常量值</strong>，我们<strong>无法改变</strong>该类型对象中<strong>元素的值</strong></p>
</blockquote>
</li>
<li><p><strong>使用</strong></p>
<blockquote>
<p>1、我们可以使用<strong>该类型</strong>作为函数的<strong>形参</strong>，使用<strong>迭代器</strong>访问<strong>列表中的元素</strong><br>2、使用函数时，如果想向<code>initializer_list</code><strong>形参</strong>中<strong>传递一个值的序列</strong>，则必须把<strong>序列</strong>放在一对<strong>花括号</strong>内<br>3、含有<code>initializer_list</code><strong>形参</strong>的函数也<strong>可以同时拥有其他形参</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义函数</span>
<span class="token keyword">void</span> <span class="token function">error_msg</span><span class="token punctuation">(</span><span class="token keyword">int</span> error_code<span class="token punctuation">,</span> initializer_list<span class="token operator">&lt;</span>string<span class="token operator">></span> i1<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"error code:"</span> <span class="token operator">&lt;&lt;</span> error_code<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> beg <span class="token operator">=</span> i1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> beg <span class="token operator">!=</span> i1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> beg<span class="token operator">++</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>beg <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 传参使用</span>
<span class="token keyword">int</span> error_number <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"error1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">"error2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">error_msg</span><span class="token punctuation">(</span>error_number<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">"function"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>省略号形参</strong><code>...</code></p>
<blockquote>
<p>1、<strong>省略号形参</strong><code>...</code>沿用自<strong>C 语言的</strong><code>stdarg.h</code><strong>库</strong>，为了便于<strong>C++程序</strong>访问某些特殊的<strong>C 代码</strong><br>2、但省略符形参应该<strong>仅仅用于 C 和 C++ 通用的类型</strong>。特别应该注意，C++的大多数<strong>类类型的对象</strong>传递时都<strong>无法正确拷贝</strong></p>
</blockquote>
</li>
</ul>
<h4 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a><strong>函数的返回值</strong></h4><ul>
<li><p><strong>不要返回局部对象的引用或指针</strong></p>
<blockquote>
<p>1、函数完成后，所占用的<strong>内存空间</strong>也会<strong>随之释放</strong>。由此，<strong>局部变量的引用</strong>和<strong>指向局部变量的指针</strong>将指向<strong>不再有效的内存区域</strong><br>2、如下示例，对于两条<code>return</code>语句，都将返回<strong>未定义的值</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数返回值类型是const string &amp;，即一个引用</span>
<span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">manip</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string ret<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>       <span class="token comment">// 错误：返回了局部对象的引用，返回的引用将指向无效区域</span>
    <span class="token keyword">return</span> <span class="token string">"Empty"</span><span class="token punctuation">;</span>       <span class="token comment">// 错误：Empty也是一个局部临时量，返回的引用将指向无效区域</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>返回数组指针的函数</strong></p>
<ul>
<li><p><strong>直接声明</strong></p>
<blockquote>
<p>1、如果我们想定义一个<strong>返回数组指针的函数</strong>，则<strong>数组的下标数</strong>必须<strong>跟在函数名后</strong>。而函数的<strong>形参列表</strong>也跟在<strong>函数名后</strong>，且应该<strong>先于数组的下标数</strong><br>2、因此，<strong>返回数组指针的函数</strong>形式如：<code>类型 (* 函数名(形参列表))[数组下标数]</code>，具体的例子和解读如下(可以参考<a href="../6981023b/">类型声明黄金法则</a>)</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">/*---------------------*/</span>
<span class="token comment">/*
解读：
func(int i)             ：表示函数需要一个int类型形参
(*func(int i))          ：返回类型是一个指针
(*func(int i))[10]      ：指针指向一个大小是10的数组
int (*func(int i))[10]  ：指向的是一个含有10个int值的数组
*/</span></code></pre>
</li>
<li><p><strong>使用尾置返回类型</strong></p>
<blockquote>
<p>1、在 C++11 新标准中还有一种可以<strong>简化上述声明</strong>的方法，就是使用<strong>尾置返回类型</strong><br>2、<strong>任何函数的定义</strong>都能使用<strong>尾置返回</strong>，但这种形式对于<strong>返回类型比较复杂</strong>的函数最有效，比如返回类型是<strong>数组的指针</strong>或者<strong>数组的引用</strong><br>3、<strong>尾置返回类型</strong>跟在<strong>形参列表</strong>后面并以一个<code>-&gt;</code><strong>符号开头</strong>。为了表示函数<strong>真正的返回类型</strong>跟在<strong>形参列表后</strong>，原先<strong>标识返回值的地方</strong>改为<code>auto</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数返回一个指针，指向含有10个整数的数组</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>使用</strong><code>decltype</code><strong>获取类型</strong></p>
<blockquote>
<p>1、还有一种情况，<strong>如果知道</strong>函数返回的<strong>指针将指向哪个数组</strong>，可以使用<code>decltype</code>来<strong>声明返回类型</strong>，如下例<br>2、<code>decltype(odd)</code>标识了<strong>返回类型</strong>是一个<strong>含有 5 个 int 值的数组</strong>，<code>*</code>标识了<strong>返回类型</strong>是一个<strong>指针</strong><br>3、有一个地方要注意，<code>decltype</code>并<strong>不负责</strong>把数组类型<strong>转换成</strong>相应的<strong>指针</strong>，所以如果需要返回<strong>指向数组的指针</strong>的函数，需要像下例中<strong>声明时</strong>加一个<code>*</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> odd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> even<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 decltype(odd) 获取类型</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>odd<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">arrPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>odd <span class="token operator">:</span> <span class="token operator">&amp;</span>even<span class="token punctuation">;</span>  <span class="token comment">// 返回一个指向数组的指针</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h4><ul>
<li><p><strong>简介</strong></p>
<blockquote>
<p>1、如果<strong>同一作用域</strong>内的几个函数<strong>名字相同</strong>但<strong>形参列表不同</strong>，我们称之为<strong>重载函数</strong>。如下例<br>2、这些函数接受的<strong>形参类型不同</strong>，但是执行的<strong>操作非常相似</strong>，使用<strong>函数重载</strong>可以在一定程度上减轻起名记名的负担<br>3、当<strong>调用这些函数</strong>时，编译器会<strong>根据传递的实参</strong>判断具体想要执行的是<strong>哪个函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数原型</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 1</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>beg<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 2</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span>
<span class="token comment">/*--------------------------------------*/</span>
<span class="token comment">// 函数调用</span>
<span class="token keyword">int</span> j<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 调用 1</span>
<span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用 3</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 调用 2</span></code></pre>
</li>
<li><p><strong>定义重载函数</strong></p>
<blockquote>
<p>1、对于定义的<strong>重载函数</strong>来说，它们至少应该在<strong>形参数量</strong>或<strong>形参类型</strong>上<strong>有所不同</strong><br>2、假设有两个函数，他们的<strong>返回类型不同</strong>但<strong>形参列表相同</strong>，这种声明不是<strong>重载函数</strong>，是<strong>错误的</strong><br>3、有时候两个<strong>形参列表看起来不一样</strong>，但实际是<strong>相同</strong>的。比如<strong>省略了形参名</strong>，或使用<strong>类型别名</strong><br>4、<strong>不能重载</strong><code>main()</code><strong>函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 不允许两个函数除了返回类型不同其余都相同</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 错误</span>
<span class="token comment">/*--------------------------------*/</span>
<span class="token comment">// 形参列表相同</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Account <span class="token operator">&amp;</span>acct<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 相同，省略了形参名</span>
<span class="token keyword">typedef</span> Phone Telno<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Telno<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 相同，使用了类型别名</span></code></pre>
</li>
<li><p><strong>重载和 const 形参</strong></p>
<blockquote>
<p>1、<strong>顶层</strong><code>const</code>不影响传入函数的<strong>对象</strong>，一个拥有<strong>顶层</strong><code>const</code><strong>的形参</strong>无法和另一个<strong>没有顶层</strong><code>const</code><strong>的形参</strong>区分开来<br>2、如果<strong>形参</strong>是某种类型的<strong>指针或引用</strong>，则通过<strong>区分</strong>其<strong>指向</strong>的是<strong>常量对象</strong>还是<strong>非常量对象</strong>可以实现<strong>函数重载</strong>，注意此时的<code>const</code><strong>是底层的</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Phone<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 重复声明了void lookup(Phone)</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Phone<span class="token operator">*</span> <span class="token keyword">const</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 重复声明了void lookup(Phone*)，顶层const</span>
<span class="token comment">/*------------------------------------------------------*/</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 作用于Account的引用</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 新函数，作用于常量引用</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Account<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 作用于指向Account的指针</span>
<span class="token keyword">void</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">const</span> Account<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 新函数，作用于指向常量的指针，底层const</span></code></pre>
</li>
<li><p><strong>const_cast 和重载</strong></p>
<blockquote>
<p>1、<code>const_cast</code>在<strong>重载函数</strong>的情境中最有用，如下例<br>2、<strong>原函数</strong>的<strong>参数</strong>和<strong>返回类型</strong>都是<code>const string</code><strong>的引用</strong>。虽然我们可以对两个<strong>非常量的</strong><code>string</code>调用这个函数，但<strong>返回结果</strong>仍是<code>const string</code>，我们并<strong>不希望返回的是常量</strong><br>3、此时我们需要一种<strong>新的函数</strong>，当它的<strong>实参不是常量</strong>时，得到的结果是一个<strong>非常量引用</strong>，使用<code>const_cast</code>可以很方便做到这一点<br>4、<strong>新函数</strong>内通过<code>const_cast</code>把参数先转为<strong>常量</strong>，调用<strong>原函数</strong>，再将<strong>原函数结果</strong>转为<strong>非常量</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 原函数，返回 const string 的引用</span>
<span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 重载函数，返回非 const 的引用</span>
string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a><strong>特殊用途语言特性</strong></h4><ul>
<li><p><strong>默认实参</strong></p>
<blockquote>
<p>1、可以将<strong>函数</strong>的<strong>形参列表</strong>中的值赋予初始值，这便是<strong>默认实参</strong>。当<strong>函数调用</strong>时，如果<strong>没有给定这个值的实参</strong>，便会使用<strong>默认实参</strong><br>2、我们可以为<strong>一个或多个形参</strong>赋予默认值。但要注意，一旦某个形参被赋予了默认值，它<strong>后面的所有形参</strong>都<strong>必须有默认值</strong><br>3、<strong>函数调用</strong>时，实参按照<strong>位置顺序</strong>解析，<strong>默认实参</strong>负责填补函数调用<strong>缺少的尾部实参</strong>(即靠右侧位置的形参)。即<strong>不能省略前面的参数值</strong>，<strong>只能省略尾部的参数值</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 默认实参函数定义</span>
<span class="token keyword">typedef</span> string<span class="token double-colon punctuation">::</span>size_type sz<span class="token punctuation">;</span>
string <span class="token function">screen</span><span class="token punctuation">(</span>sz ht <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">,</span> sz wid <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token keyword">char</span> background <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 函数调用</span>
string window<span class="token punctuation">;</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// screen(24, 80, ' ')</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// screen(66, 80, ' ')</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token char">'#'</span><span class="token punctuation">)</span>   <span class="token comment">// screen(66, 256, '#')</span>
<span class="token comment">// 错误调用</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 错误</span>
window <span class="token operator">=</span> <span class="token function">screen</span><span class="token punctuation">(</span><span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 错误，screen('?', 80, ' ')</span></code></pre>
</li>
<li><p><strong>内联函数</strong></p>
<blockquote>
<p>1、使用<code>inline</code>将函数指定为<strong>内联函数</strong>，通常就是将它在<strong>每个调用点</strong>上<strong>内联地展开</strong>，可以<strong>避免函数调用的开销</strong>。说明如下示例<br>2、<strong>内联</strong>只是向<strong>编译器</strong>发出的<strong>一个请求</strong>，<strong>编译器</strong>可以选择<strong>忽略这个请求</strong><br>3、一般来说，<strong>内联机制</strong>用于<strong>优化规模较小</strong>、<strong>流程直接</strong>、<strong>调用频繁</strong>的函数。很多编译器不支持<strong>内联递归函数</strong>，而且一个<strong>大于 75 行</strong>的函数也不大可能在<strong>调用点内联展开</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 原函数即程序调用</span>
<span class="token keyword">inline</span> string <span class="token function">shorterString</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
string s1 <span class="token operator">=</span> <span class="token string">"abcde"</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">"abcdef"</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">shorterString</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在编译过程中，函数调用将直接展开成下面形式，从而不经过shorterString，减少了函数调用的开销</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>constexpr 函数</strong></p>
<blockquote>
<p>1、<code>constexpr</code><strong>函数</strong>是指能用于<strong>常量表达式</strong>的函数。定义的方法与其他函数类似，但<strong>有如下规定</strong>：函数的<strong>返回类型</strong>及<strong>所有形参</strong>都必须是<strong>字面值类型</strong>，而且函数体中必须<strong>有且仅有一条</strong><code>return</code><strong>语句</strong><br>2、执行<strong>初始化任务</strong>时，<strong>编译器</strong>把<strong>对</strong><code>constexpr</code><strong>函数的调用</strong>都替换成其<strong>结果值</strong>。为了能在编译过程中<strong>随时展开</strong>，<code>constexpr</code><strong>函数</strong>被<strong>隐式指定为内联函数</strong><br>3、<code>constexpr</code><strong>函数</strong>不一定返回常量表达式</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> size_t <span class="token function">scale</span><span class="token punctuation">(</span>size_t ct<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">3</span> <span class="token operator">*</span> ct<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 正确，编译时 scale(2) 将被内联展开为 6</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 错误，i不是常量表达式</span></code></pre></li>
</ul>
<hr>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：定义抽象数据类型；设计<code>Sales_data</code>类；定义<code>Sales_data</code>类；分析与设计；<code>this</code>参数；<code>const</code>成员函数；返回<code>this</code>对象的函数；该类相关的非成员函数；构造函数；合成的默认构造函数；合成的默认构造函数的局限性；定义构造函数；<code>= default</code>的含义；构造函数初始值列表；类外定义构造函数；拷贝、赋值和析构；访问控制与封装；<code>public</code>和<code>private</code>；<code>class</code>和<code>struct</code>；友元；类的其他特性；类成员再探；<code>mutable</code>可变数据成员；返回<code>*this</code>的成员函数；从<code>const</code>成员函数返回<code>*this</code>；基于<code>const</code>的重载；友元再探；类之间的友元关系；令函数成员作为友元；友元函数重载和作用域；类的作用域；名字查找与类作用域；构造函数再探；委托构造函数；隐式类类型转换；<code>explicit</code>抑制构造函数隐式转换；聚合类；字面值常量类；<code>constexpr</code>构造函数；类的静态成员；声明、使用、定义静态成员；静态成员的类内初始化；静态成员与普通成员的区别</p>
</blockquote>
</div>

<h4 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a><strong>定义抽象数据类型</strong></h4><ul>
<li><p><strong>抽象数据类型</strong></p>
<blockquote>
<p>1、如果一个类，我们可以通过它的<strong>接口</strong>(例如描述的操作)来<strong>使用该类的对象</strong>，但<strong>不能访问该类的数据成员</strong>(甚至不知道该类有哪些数据成员)，我们称<strong>这样的类</strong>为<strong>抽象数据类型</strong><br>2、反之，如果一个类<strong>允许用户</strong>直接<strong>访问它的数据成员</strong>，并要求<strong>用户</strong>来<strong>编写操作</strong>，<strong>这样的类</strong>不是一个抽象数据类型<br>3、对于一个<strong>普通的数据类型</strong>(非抽象数据类型)，如果想把它变成<strong>抽象数据类型</strong>，我们需要<strong>定义一些操作</strong>供类的用户使用。一旦<strong>定义了自己的操作</strong>，我们就可以<strong>封装它的数据成员</strong>了</p>
</blockquote>
</li>
<li><p><strong>设计 Sales_data 类</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、为了方便图书管理，我们需要<strong>设计一个类</strong>便于<strong>信息存储</strong>与<strong>操作</strong>，需要先<strong>分析满足下列操作</strong>：<br>2、类中需要有<strong>能读写的数据对象</strong>，需要对这些对象<strong>支持一些操作</strong><br>3、<strong>操作包括</strong>一个名为<code>isbn</code>的<strong>成员函数</strong>，并且支持<code>+</code>、<code>=</code>、<code>+=</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code><strong>运算符</strong><br>4、我们将在后续学习<strong>重载运算符</strong>，现在对于<strong>运算符运算</strong>，我们先定义为<strong>普通函数</strong>的形式<br>5、由于特殊的原因(后续重载运算符介绍)，执行<strong>加法</strong>和<strong>IO 的函数</strong>不作为<strong>类的成员</strong>，我们将其定义成<strong>普通函数</strong></p>
</blockquote>
</li>
<li><p><strong>该类应包含的操作</strong></p>
<blockquote>
<p>1、一个<code>isbn</code><strong>成员函数</strong>，返回<strong>对象的 ISBN 编号</strong><br>2、一个<code>combine</code><strong>成员函数</strong>，用于将一个<code>Sales_data</code><strong>对象加到另一个对象上</strong><br>3、一个<code>add</code><strong>函数</strong>，执行两个<code>Sales_data</code>对象的<strong>加法</strong><br>4、一个<code>read</code><strong>函数</strong>，将数据从<code>istream</code><strong>读入到</strong><code>Sales_data</code><strong>对象中</strong><br>5、一个<code>print</code><strong>函数</strong>，将<code>Sales_data</code><strong>对象的值输出到</strong><code>ostream</code>中</p>
</blockquote>
</li>
<li><p><strong>使用类的接口</strong>(先不考虑如何实现该类，首先看看应该如何使用这些接口函数)</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Sales_data total<span class="token punctuation">;</span>             <span class="token comment">// 保存当前求和结果的变量</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment">// 读入第一笔交易</span>
<span class="token punctuation">&#123;</span>
    Sales_data trans<span class="token punctuation">;</span>         <span class="token comment">// 保存下一条交易数据的变量</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> trans<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// 读入剩余的交易</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>total<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> trans<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 检查 isbn</span>
          total<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>trans<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 更新变量 total 当前的值</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">print</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> total<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token comment">// 输出结果</span>
            total <span class="token operator">=</span> trans<span class="token punctuation">;</span>                  <span class="token comment">// 处理下一本书</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> total<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出最后一条交易</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">else</span>                            <span class="token comment">// 如果没有输入</span>
<span class="token punctuation">&#123;</span>
    cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"No data?"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 通知用户</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>定义 Sales_data 类</strong></p>
<ul>
<li><p><strong>分析与设计</strong></p>
<blockquote>
<p>1、该类的<strong>数据成员</strong>有：<code>string</code>类型的<strong>bookNo</strong>，表示 ISBN 编号；<code>unsigned</code>类型的<strong>units_sold</strong>，表示某书的销量；<code>double</code>类型的<strong>revenue</strong>，表示这本书的总销售收入<br>2、类中将包含<code>combine</code>和<code>isbn</code>两个<strong>成员函数</strong>，此外，我们还需要另一个<strong>成员函数</strong><code>avg_price</code>返回售出书籍的平均价格。由于<code>avg_price</code>的<strong>目的并非通用</strong>，所以它应该属于<strong>类的实现的一部分</strong>，而不是<strong>接口的一部分</strong><br>3、<strong>定义</strong>和<strong>声明</strong>一个<strong>成员函数</strong>的方法与普通函数差不多。<strong>成员函数的声明</strong>必须在<strong>类的内部</strong>，而它的<strong>定义可以在外部</strong>。作为<strong>接口组成部分</strong>的<strong>非成员函数</strong><code>add</code>、<code>read</code>、<code>print</code>等，它们的<strong>定义和声明</strong>都在<strong>类的外部</strong><br>4、定义在<strong>类内部的函数</strong>是<strong>隐式的内联函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 数据成员</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token comment">// 成员函数</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> bookNo<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    Sales_data <span class="token operator">&amp;</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将在类外定义</span>
    <span class="token keyword">double</span> <span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>                   <span class="token comment">// 将在类外定义</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 非成员接口函数</span>
Sales_data <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token punctuation">,</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>this</code><strong>参数</strong></p>
<blockquote>
<p>1、<code>isbn</code><strong>成员函数</strong>是如何获得<strong>bookNo 成员</strong>所依赖的<strong>对象</strong>的呢？<br>2、观察对<code>isbn</code>的<strong>调用</strong>：<code>total.isbn()</code>。我们使用了<strong>点运算符</strong>来访问<strong>total 对象</strong>中的<code>isbn</code><strong>成员函数</strong>并调用它<br>3、还有一种<strong>例外的形式</strong>，当我们<strong>调用成员函数</strong>时，实际上是在<strong>替某个对象调用它</strong>。如果<code>isbn</code>指向<code>Sales_data</code>的<strong>成员</strong>(如 bookNo)，则它<strong>隐式地</strong>指向<strong>调用该函数的对象的成员</strong>。在上例中，当<code>isbn</code>返回<strong>bookNo</strong>时，实际上它<strong>隐式地</strong>返回<strong>total.bookNo</strong><br>4、<strong>成员函数</strong>通过名为<code>this</code>的<strong>额外的隐式参数</strong>来访问和调用它的那个对象，当我们<strong>调用成员函数</strong>时，会用<strong>请求该函数的对象地址</strong>初始化<code>this</code>。例如调用<code>total.isbn()</code>时，<strong>编译器</strong>负责把<strong>total 的地址</strong>传递给<code>isbn</code>的<strong>隐式形参</strong><code>this</code><br>5、在<strong>成员函数体</strong>内部，也可以直接使用<strong>调用该函数的对象的成员</strong>，而无须通过<strong>成员访问运算符</strong>，因为<code>this</code>所指的<strong>正是这个对象</strong>。任何对<strong>类成员</strong>的<strong>直接访问</strong>都被看作<code>this</code>的<strong>隐式引用</strong><br>6、对于我们来说，<code>this</code><strong>形参</strong>是<strong>隐式定义</strong>的，我们可以在<strong>成员函数体</strong>内部使用<code>this</code>。尽管没有必要，但我们还是可以把<code>isbn</code>的<strong>函数体写为</strong><code>return this-&gt;bookNo;</code><br>7、因为<code>this</code><strong>总是指向这个对象</strong>，所以<code>this</code>是一个<strong>常量指针</strong>，<strong>不允许修改</strong><code>this</code>中保存的地址</p>
</blockquote>
</li>
<li><p><code>const</code><strong>成员函数</strong></p>
<blockquote>
<p>1、<code>isbn</code>函数的另一个<strong>关键之处</strong>是<strong>参数列表后的</strong><code>const</code>，这里，<code>const</code>的作用是<strong>修改隐式</strong><code>this</code><strong>指针的类型</strong><br>2、默认情况下，<code>this</code>的类型是<strong>指向类类型</strong>的<strong>非常量版本</strong>的<strong>常量指针</strong>，例如<code>Sales_data</code><strong>成员函数</strong>中，<code>this</code>的类型是<code>Sales_data *const</code>。这意味着，我们不能把<code>this</code>绑定到一个<strong>常量对象</strong>上，这使得不能在一个<strong>常量对象</strong>上调用<strong>普通的成员函数</strong><br>3、如果<code>isbn</code>是一个<strong>普通函数</strong>且<code>this</code>是一个<strong>普通指针形参</strong>，则我们<strong>应该把</strong><code>this</code><strong>声明成</strong><code>const Sales_data *const</code><strong>类型</strong>，毕竟<code>isbn</code>函数体内<strong>不会改变</strong><code>this</code><strong>所指的对象</strong><br>4、然而，<code>this</code><strong>是隐式的</strong>而且不会出现在<strong>形参列表</strong>中，在哪将<code>this</code>声明成<strong>指向常量的指针</strong>？C++的做法是把<code>const</code>放在成员函数的<strong>参数列表后</strong><br>5、紧跟在<strong>参数列表后</strong>的<code>const</code>表示<code>this</code>是一个<strong>指向常量的指针</strong>，而像这样使用<code>const</code>的<strong>成员函数</strong>称作<strong>常量成员函数</strong></p>
</blockquote>
</li>
<li><p><strong>在类的外部定义成员函数</strong></p>
<blockquote>
<p>1、前面提过<strong>成员函数的定义可以在类外</strong>，我们的<code>avg_price</code>和<code>combine</code><strong>成员函数</strong>就打算通过这种方式定义<br>2、要注意，<strong>类外部定义的成员的名字</strong>必须包含<strong>所属的类名</strong>，通过<strong>作用域运算符</strong>来告知<strong>编译器</strong>定义的这个函数是<strong>类内的成员函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>units_sold<span class="token punctuation">)</span>
        <span class="token keyword">return</span> revenue <span class="token operator">/</span> units_sold<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>返回</strong><code>this</code><strong>对象的函数</strong></p>
<blockquote>
<p>1、函数<code>combine</code>的设计初衷类似于<strong>复合赋值运算符</strong><code>+=</code>，其定义如下<br>2、当程序调用<code>total.combine(trans);</code>时，<code>this</code>指针绑定了<strong>total 的地址</strong>，<strong>rhs 引用</strong>绑定了<strong>实参 trans</strong><br>3、该函数值得关注的是它的<strong>返回类型</strong>和<strong>返回语句</strong>。模仿标准的<strong>赋值运算符</strong>把它的<strong>左侧运算对象</strong>当做<strong>左值</strong>返回，因此<code>combine</code><strong>必须返回引用</strong>，而<strong>左侧运算对象</strong>又是<code>Sales_data</code><strong>对象</strong>，因此返回类型是<code>Sales_data&amp;</code><br>4、如前所述，我们需要<strong>把该对象当做左值返回</strong>。我们无须使用隐式的<code>this</code>指针访问<strong>函数调用者</strong>的<strong>某个具体成员</strong>，而是要把<strong>调用函数的对象</strong>当做一个整体来访问，即<code>return *this;</code>，该调用<strong>返回 total 的引用</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Sales_data <span class="token operator">&amp;</span><span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 把 rhs 的成员加到 this 的成员上</span>
    units_sold <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
    revenue <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
    <span class="token comment">// 返回调用该函数的对象</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>该类相关的非成员函数</strong></p>
<ul>
<li><p><code>read</code>和<code>print</code>函数</p>
<blockquote>
<p>1、<code>read</code>和<code>print</code>函数分别接受一个<strong>各自 IO 类型的引用</strong>作为其参数，是因为<strong>IO 类</strong>属于<strong>不能被拷贝的类型</strong>，因此只能<strong>通过引用传递</strong>。而且，读取和写入的操作<strong>会改变流的内容</strong>，所以使用<strong>普通引用</strong>而不是<code>const</code><strong>引用</strong><br>2、<code>print</code><strong>函数不负责换行</strong>。一般来说，<strong>执行输出任务的函数</strong>应该尽量<strong>减少对格式的控制</strong>，这样可以确保<strong>由用户代码决定</strong>是否换行</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输入的交易信息包括 ISBN、售出总数、售出单价</span>
std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> Sales_data <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    is <span class="token operator">>></span> item<span class="token punctuation">.</span>bookNo <span class="token operator">>></span> item<span class="token punctuation">.</span>units_sold <span class="token operator">>></span> price<span class="token punctuation">;</span>
    item<span class="token punctuation">.</span>revenue <span class="token operator">=</span> price <span class="token operator">*</span> item<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
    <span class="token keyword">return</span> is<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    os <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>revenue <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> os<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><code>add</code>函数</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Sales_data <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rsh<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Sales_data sum <span class="token operator">=</span> lhs<span class="token punctuation">;</span> <span class="token comment">// 把 lhs 的数据成员拷贝给 sum</span>
    sum<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>rsh<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 把 rsh 的数据成员添加到 sum</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>           <span class="token comment">// 返回新的 Sales_data 对象</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构造函数</strong></p>
<ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、每个<strong>类</strong>都分别定义了它的<strong>对象被初始化的方式</strong>，<strong>类</strong>通过一个或几个<strong>特殊的成员函数</strong>控制其对象的初始化过程，<strong>这些函数</strong>被称为<strong>构造函数</strong><br>2、<strong>构造函数</strong>的任务是<strong>初始化类对象</strong>的<strong>数据成员</strong>，无论何时只要<strong>有类的对象被创建</strong>，<strong>就会执行构造函数</strong><br>3、构造函数的<strong>名字和类名相同</strong>。和其他函数不同的是，构造函数<strong>没有返回类型</strong>，且不能被声明成<code>const</code>。类可以包含<strong>多个构造函数</strong>，和其他<strong>重载函数</strong>类似<br>4、当我们创建类的一个<code>const</code><strong>对象</strong>时，直到<strong>构造函数完成初始化</strong>过程，对象才真正取得了<strong>常量属性</strong>。因此<strong>构造函数</strong>在<code>const</code><strong>对象</strong>的构造过程中<strong>可以向其写值</strong></p>
</blockquote>
</li>
<li><p><strong>合成的默认构造函数</strong></p>
<blockquote>
<p>1、我们的<code>Sales_data</code>类并没有定义任何<strong>构造函数</strong>，可是之前<strong>使用了</strong><code>Sales_data</code><strong>对象</strong>的程序却没有异常，它们是如何初始化的？<br>2、我们没有为这些对象<strong>提供初始值</strong>，它们执行了<strong>默认初始化</strong>。<strong>类</strong>通过一个<strong>特殊的构造函数</strong>来控制<strong>默认初始化过程</strong>，这个函数叫做<strong>默认构造函数</strong>，其<strong>无须任何实参</strong><br>3、如我们所见，<strong>默认构造函数</strong>在很多方面都有其<strong>特殊性</strong>。其中之一是，如果我们的类<strong>没有显式定义构造函数</strong>，编译器会为我们<strong>隐式定义一个默认构造函数</strong>，这样的函数有称为<strong>合成的默认构造函数</strong><br>4、对于大多数类来说，这个<strong>合成的默认构造函数</strong>将按照<strong>如下规则</strong>初始化数据：使用<strong>类内的初始值</strong>(如果有的话)<strong>初始化</strong>成员，否则<strong>默认初始化该成员</strong></p>
</blockquote>
</li>
<li><p><strong>合成的默认构造函数的局限性</strong></p>
<blockquote>
<p>1、<strong>合成的默认构造函数</strong>只适合<strong>非常简单</strong>的类，对于一个<strong>普通的类</strong>来说，<strong>必须</strong>定义它自己的<strong>默认构造函数</strong>，原因有三：<br>2、首先，编译器只有在发现<strong>类不包含任何构造函数时</strong>才会替我们生成默认构造函数，一旦我们<strong>定义了一些其他构造函数</strong>，除非我们<strong>再定义</strong>一个<strong>默认生成函数</strong>，否则类将<strong>没有默认构造函数</strong>。如果一个类需要<strong>在某种情况下控制初始化</strong>，那么该类很可能<strong>在所有情况下都需要控制</strong><br>3、其次，对于某些类来说，<strong>合成的默认构造函数</strong>可能执行<strong>错误的操作</strong>。如果定义在<strong>块中的内置类型</strong>或数组指针这类的<strong>复合类型的对象</strong>被<strong>默认初始化</strong>，它们的值是<strong>未定义</strong>的。因此这样的类应该在<strong>类内初始化</strong>这些成员，或定义一个自己的<strong>默认构造函数</strong><br>4、最后，有时候<strong>编译器</strong>不能为<strong>某些类</strong>合成默认构造函数。对这样的类来说，<strong>必须</strong>自定义<strong>默认构造函数</strong>，否则该类将没有可用的<strong>默认构造函数</strong></p>
</blockquote>
</li>
<li><p><strong>定义构造函数</strong></p>
<ul>
<li><p><strong>示例</strong></p>
<blockquote>
<p>1、对于我们的<code>Sales_data</code>类，我们将使用<strong>下面的参数</strong>定义 4 个不同的<strong>构造函数</strong><br>2、一个<code>istream&amp;</code>，从中读取一条交易信息<br>3、一个<code>const string&amp;</code>，表示 ISBN 编号；一个<code>unsigned</code>，表示图书数量；一个<code>double</code>，表示售出单价<br>4、一个<code>const string&amp;</code>，表示 ISBN 编号，编译器将赋予其他成员默认值<br>5、一个<strong>空参数列表</strong>(即默认构造函数)，如刚刚介绍，既然<strong>已定义其他构造函数</strong>，那么也<strong>必须</strong>定义一个<strong>默认构造函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 新增的构造函数</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>p <span class="token operator">*</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 将在类外定义</span>

    <span class="token comment">// 数据成员</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token comment">// 成员函数</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> bookNo<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    Sales_data <span class="token operator">&amp;</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> <span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>= default</code>的含义</p>
<blockquote>
<p>1、我们首先解释<strong>默认构造函数</strong>：<code>Sales_data() = default;</code><br>2、首先请明确：因为该构造函数<strong>不接受任何实参</strong>，所以它是<strong>默认构造函数</strong>。我们定义它只是因为我们既需要<strong>其他形式的构造函数</strong>，又需要<strong>默认的构造函数</strong>，我们希望它的作用完全等同于<strong>合成的默认构造函数</strong><br>3、在 C++11 中，如果我们需要<strong>默认的行为</strong>，可以通过在<strong>参数列表后</strong>写上<code>= default</code>来<strong>要求编译器生成构造函数</strong>。其中<code>= default</code>既可以和声明一起<strong>出现在类内</strong>，也可以作为定义<strong>出现在类外</strong><br>4、和其他函数一样，如果<code>= default</code>在<strong>类内</strong>，则默认构造函数<strong>是内联的</strong>；反之则<strong>不是内联的</strong></p>
</blockquote>
</li>
<li><p><strong>构造函数初始值列表</strong></p>
<blockquote>
<p>1、之后的两个构造函数中，出现了<strong>新的部分</strong>，即<strong>冒号</strong>及<strong>冒号和花括号之间</strong>的代码。其中<strong>花括号</strong>定义了<strong>空的函数体</strong>，我们把<strong>新出现的部分</strong>称为<strong>构造函数初始值列表</strong><br>2、这部分负责为<strong>新创建的对象</strong>的一个或几个<strong>数据成员</strong>赋初值。<strong>构造函数初始值</strong>是<strong>成员名字</strong>的一个列表，每个名字后紧跟<strong>括号括起来的</strong>或者<strong>在花括号内的</strong>成员初始值。不同成员初始化通过<strong>逗号分隔</strong><br>3、例如，上例含有三个参数的<strong>构造函数</strong>分别用<strong>前两个参数</strong>初始化了成员<strong>bookNo</strong>和<strong>units_sold</strong>，而<strong>revenue</strong>的初始值则通过<code>revenue(p * n)</code>使用计算后的值作为初始值<br>4、需要注意，这两个<strong>构造函数</strong>的<strong>函数体是空的</strong>是因为这些构造函数的<strong>唯一目的</strong>就是<strong>为成员赋值</strong>，没有其他任务需要执行</p>
</blockquote>
</li>
<li><p><strong>类外定义构造函数</strong></p>
<blockquote>
<p>1、我们将在<strong>类外定义</strong>以<code>istream</code>为参数的构造函数。该函数需要<strong>执行一些实际操作</strong>，所以在函数体内，调用了之前定义的<code>read</code><strong>函数</strong>给<strong>数据成员赋值</strong><br>2、<code>Sales_data::Sales_data</code>的含义是，我们定义的是<code>Sales_data</code><strong>类的成员</strong>，其<strong>成员名</strong>是<code>Sales_data</code><br>3、这个<strong>构造函数</strong>的<strong>初始值列表为空</strong>，但是由于执行了<strong>构造函数体</strong>，所以<strong>对象的成员</strong>依然能被初始化</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">read</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>拷贝、赋值和析构</strong></p>
<blockquote>
<p>1、除了定义类的对象<strong>如何初始化</strong>外，类还需要控制<strong>拷贝</strong>、<strong>赋值</strong>和<strong>销毁对象时发生的行为</strong><br>2、如果我们不<strong>主动定义</strong>这些操作，编译器将替我们<strong>合成它们</strong>。一般来说，编译器生成的版本将对对象的<strong>每个成员</strong>执行<strong>拷贝</strong>、<strong>赋值</strong>和<strong>销毁操作</strong><br>3、我们将在 13 章介绍如何<strong>自定义上述操作</strong></p>
</blockquote>
</li>
<li><p><strong>完整的类与使用</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>

<span class="token keyword">struct</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 新增的构造函数</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>p <span class="token operator">*</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 数据成员</span>
    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token comment">// 成员函数</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> bookNo<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    Sales_data <span class="token operator">&amp;</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> <span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>


<span class="token comment">// 非成员接口函数</span>
Sales_data <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token punctuation">,</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>units_sold<span class="token punctuation">)</span>
        <span class="token keyword">return</span> revenue <span class="token operator">/</span> units_sold<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

Sales_data <span class="token operator">&amp;</span><span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 把 rhs 的成员加到 this 的成员上</span>
    units_sold <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
    revenue <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
    <span class="token comment">// 返回调用该函数的对象</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 输入的交易信息包括 ISBN、售出总数、售出单价</span>
std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> Sales_data <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    is <span class="token operator">>></span> item<span class="token punctuation">.</span>bookNo <span class="token operator">>></span> item<span class="token punctuation">.</span>units_sold <span class="token operator">>></span> price<span class="token punctuation">;</span>
    item<span class="token punctuation">.</span>revenue <span class="token operator">=</span> price <span class="token operator">*</span> item<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
    <span class="token keyword">return</span> is<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    os <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>revenue <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> os<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

Sales_data <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rsh<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Sales_data sum <span class="token operator">=</span> lhs<span class="token punctuation">;</span> <span class="token comment">// 把 lhs 的数据成员拷贝给 sum</span>
    sum<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>rsh<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 把 rsh 的数据成员添加到 sum</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>           <span class="token comment">// 返回新的 Sales_data 对象</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 构造函数</span>
<span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">read</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Sales_data total<span class="token punctuation">;</span>          <span class="token comment">// 保存当前求和结果的变量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 读入第一笔交易</span>
    <span class="token punctuation">&#123;</span>
        Sales_data trans<span class="token punctuation">;</span>             <span class="token comment">// 保存下一条交易数据的变量</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">,</span> trans<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 读入剩余的交易</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>total<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> trans<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 检查 isbn</span>
                total<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>trans<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 更新变量 total 当前的值</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">&#123;</span>
                <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">,</span> total<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出结果</span>
                total <span class="token operator">=</span> trans<span class="token punctuation">;</span>                        <span class="token comment">// 处理下一本书</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">,</span> total<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出最后一条交易</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token comment">// 如果没有输入</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"No data?"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 通知用户</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a><strong>访问控制与封装</strong></h4><ul>
<li><p><strong>public 和 private</strong></p>
<blockquote>
<p>1、对目前为止，我们已经为类<strong>定义了接口</strong>，但没有任何机制<strong>强制用户使用这些接口</strong>。我们的类<strong>还没有封装</strong>，也就是说，用户可以<strong>直达</strong><code>Sales_data</code><strong>对象内部</strong>并<strong>控制它的具体细节</strong><br>2、C++中，我们使用<strong>访问说明符</strong>来加强类的<strong>封装性</strong>，如下说明。我们可以使用这些说明符再次定义<code>Sales_data</code>类，如后示例程序<br>3、<code>public</code><strong>说明符</strong>：定义在<code>publib</code>后的成员<strong>可以在整个程序内被访问</strong>，<code>public</code>成员<strong>定义类的接口</strong><br>4、<code>private</code><strong>说明符</strong>：定义在<code>private</code>后的成员<strong>只可以被类的成员函数访问</strong>，不能被使用该类的代码访问，<code>private</code>部分封装了<strong>类的实现细节</strong><br>5、通常<strong>构造函数</strong>和<strong>部分成员函数</strong>跟在<code>public</code>后，而<strong>数据成员</strong>和<strong>作为实现部分的函数</strong>跟在<code>private</code>后<br>6、一个类可以包含<strong>任意数量</strong>的<strong>访问说明符</strong>，每个<strong>访问说明符</strong>指定了接下来的<strong>成员访问级别</strong>，其<strong>有效范围</strong>直到出现<strong>下一个访问说明符</strong>或<strong>类的结尾</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
        <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>p <span class="token operator">*</span> n<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        std<span class="token double-colon punctuation">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> bookNo<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        Sales_data <span class="token operator">&amp;</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">double</span> <span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> units_sold <span class="token operator">?</span> revenue <span class="token operator">/</span> units_sold <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
        <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>class 和 struct</strong></p>
<blockquote>
<p>1、上例我们使用了<code>class</code>而非<code>struct</code><strong>定义类</strong>，这种变化只是<strong>形式上有所不同</strong>，可以<strong>任意选择</strong>。<strong>唯一区别</strong>是它们的<strong>默认访问权限不一样</strong><br>2、类可以在它<strong>第一个访问说明符前</strong>定义成员，这种成员的<strong>访问权限</strong>依赖于<strong>类定义的方式</strong><br>3、使用<code>struct</code>则这种成员<strong>默认是</strong><code>public</code>的，而<code>class</code>这种成员<strong>默认是</strong><code>private</code>的</p>
</blockquote>
</li>
<li><p><strong>友元</strong></p>
<blockquote>
<p>1、既然<code>Sales_data</code>的<strong>数据成员</strong>是<code>private</code>的，那么我们的<code>add</code>、<code>print</code>、<code>add</code>函数就<strong>无法正常编译</strong>了。这是因为这几个函数虽然<strong>是类接口的一部分</strong>，但<strong>不是类的成员</strong><br>2、类可以允许<strong>其他类或函数</strong>访问它的<strong>非公有成员</strong>，方法是令它们成为该类的<strong>友元</strong>。对于函数，只需要增加一条<code>friend</code><strong>关键字</strong>开头的<strong>函数声明</strong>即可<br>3、<strong>友元声明</strong>只能出现在<strong>类定义内部</strong>，但友元<strong>不是类的成员</strong>也<strong>不受访问控制的约束</strong><br>4、<strong>友元声明</strong>仅仅指定了<strong>访问权限</strong>，而非一个通常意义上的<strong>函数声明</strong>。如果我们希望<strong>类的用户</strong>能够调用某个<strong>友元函数</strong>，就必须在<strong>友元声明外</strong>再次专门进行一次<strong>函数声明</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">friend</span> Sales_data <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">friend</span> std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token function">read</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span><span class="token punctuation">,</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">friend</span> std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
<h4 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a><strong>类的其他特性</strong></h4><ul>
<li><p><strong>类成员再探</strong></p>
<ul>
<li><p>为了展示这些新特性，我们需要定义<strong>一对相互关联的类</strong>：<code>Screen</code>和<code>Window_mgr</code></p>
</li>
<li><p><strong>定义类型成员</strong></p>
<blockquote>
<p>1、假设<code>Screen</code>表示显示器中的<strong>一个窗口</strong>，该类中包含一个用于<strong>保存内容</strong>的<code>string</code>成员和分别用于表示<strong>光标位置</strong>、<strong>屏幕的高和宽</strong>的<code>string::size_type</code>成员<br>2、除了定义<strong>数据和函数成员</strong>外，类还可以<strong>自定义某种类型</strong>在类中的<strong>别名</strong>。这种<strong>类型别名</strong>与其他成员一样存在<strong>访问限制</strong>，可以是<code>public</code>或<code>private</code>的一种<br>3、如下我们在<code>public</code>部分定义了<code>pos</code><strong>别名</strong>，这样用户就可以使用这个名字。<code>Screen</code>的用户不应该知道该类使用<code>string</code><strong>对象</strong>来<strong>存放数据</strong>，因此通过把<code>pos</code>定义成<code>public</code>可以<strong>隐藏</strong><code>Screen</code>的<strong>实现细节</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size_type pos<span class="token punctuation">;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        pos cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        pos height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> width <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>string contents<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>Screen</code><strong>类的成员函数</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size_type pos<span class="token punctuation">;</span>
        <span class="token function">Screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 默认构造函数</span>
        <span class="token function">Screen</span><span class="token punctuation">(</span>pos ht<span class="token punctuation">,</span> pos wd<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token function">height</span><span class="token punctuation">(</span>ht<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">width</span><span class="token punctuation">(</span>wd<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">contents</span><span class="token punctuation">(</span>ht <span class="token operator">*</span> wd<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token comment">// 构造函数，cursor 会被类内初始值初始化为 0</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">char</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment">// 读取光标处的字符</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> contents<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 隐式内联</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 重载成员函数 get</span>
        <span class="token keyword">inline</span> <span class="token keyword">char</span> <span class="token function">get</span><span class="token punctuation">(</span>pos ht<span class="token punctuation">,</span> pos wd<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// 显式内联</span>
        Screen <span class="token operator">&amp;</span><span class="token function">move</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 能在之后被设置为内联</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        pos cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        pos height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> width <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>string contents<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 在类内声明为 inline</span>
<span class="token keyword">char</span> <span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos c<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    pos row <span class="token operator">=</span> r <span class="token operator">*</span> width<span class="token punctuation">;</span>      <span class="token comment">// 计算行的位置</span>
    <span class="token keyword">return</span> contents<span class="token punctuation">[</span>row <span class="token operator">+</span> c<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 返回给定列的字符</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 在定义处指定 inline</span>
<span class="token keyword">inline</span> Screen <span class="token operator">&amp;</span><span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos c<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    pos row <span class="token operator">=</span> r <span class="token operator">*</span> width<span class="token punctuation">;</span> <span class="token comment">// 计算行的位置</span>
    cursor <span class="token operator">=</span> row <span class="token operator">+</span> c<span class="token punctuation">;</span>    <span class="token comment">// 在行内将光标移动到指定列</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment">// 以左值形式返回对象</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><code>mutable</code><strong>可变数据成员</strong></p>
<blockquote>
<p>1、有时我们希望能<strong>修改类的某个数据成员</strong>，即使是在一个<code>const</code><strong>成员函数</strong>里，对此可以通过在<strong>变量的声明</strong>中加入<code>mutable</code><strong>关键字</strong>声明一个<strong>可变数据成员</strong><br>2、一个<strong>可变数据成员</strong>永远不会是<code>const</code>，即使它是<code>const</code><strong>对象的成员</strong>。因此，一个<code>const</code><strong>成员函数</strong>可以改变一个可变成员的值<br>3、例如，我们将给<code>Screen</code>添加一个<strong>access_ctr 可变成员</strong>，以跟纵成员函数被调用了多少次，如下例。尽管<code>some_member</code>是一个<code>const</code><strong>成员函数</strong>，但依然可以改变<strong>access_ctr</strong>的值</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">some_member</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">&#123;</span>
        <span class="token operator">++</span>access_ctr<span class="token punctuation">;</span> <span class="token comment">// 保存一个计数值，用于记录成员函数被调用的次数</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">mutable</span> size_t access_ctr<span class="token punctuation">;</span> <span class="token comment">// 即使在一个 const 对象内也能被修改</span></code></pre>
</li>
<li><p><strong>类数据成员的初始值</strong></p>
<blockquote>
<p>1、定义好<code>Screen</code>后，我们将继续定义一个<strong>窗口管理类</strong>并用它来表示显示器上的<strong>一组</strong><code>Screen</code>。这个类将包含一个<code>Screen</code><strong>类型的</strong><code>vector</code>，<strong>每个元素</strong>表示一个特定的<code>Screen</code><br>2、默认情况下，我们希望<code>Window_mgr</code>类开始时总是<strong>拥有一个默认初始化的</strong><code>Screen</code>。C++11 中，最好的办法是把这个<strong>默认值</strong>声明成一个<strong>类内初始值</strong>，由<code>Screen</code>的<strong>构造函数初始化</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Window_mgr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token comment">// 默认情况下，一个 Window_mgr 包含一个标准尺寸的空白 Screen，通过类内初始值和 Screen 的构造函数实现</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Screen<span class="token operator">></span> screens<span class="token punctuation">&#123;</span><span class="token function">Screen</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>返回 *this 的成员函数</strong></p>
<ul>
<li><p><strong>继续改进</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 添加两个新的成员函数</span>
        Screen <span class="token operator">&amp;</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Screen <span class="token operator">&amp;</span><span class="token function">set</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">inline</span> Screen <span class="token operator">&amp;</span><span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    contents<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 设置当前光标所在位置的新值</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>         <span class="token comment">// 将 this 作为左值返回</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">inline</span> Screen <span class="token operator">&amp;</span><span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">set</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos col<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    contents<span class="token punctuation">[</span>r <span class="token operator">*</span> width <span class="token operator">+</span> col<span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span> <span class="token comment">// 设置给定位置的新值</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                   <span class="token comment">// 将 this 作为左值返回</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>返回</strong><code>*this</code><strong>的意义</strong></p>
<blockquote>
<p>1、和<code>move</code>操作一样，<code>set</code>的<strong>返回值</strong>也是<strong>调用</strong><code>set</code><strong>对象的引用</strong>，意味着这些函数<strong>返回的是对象本身</strong>而不是<strong>对象的副本</strong><br>2、如果我们把<strong>一系列操作</strong>连在<strong>一条表达式</strong>：<code>myScreen.move(4,0).set(&#39;#&#39;);</code>，这些操作将会<strong>在同一个对象上执行</strong><br>3、更直观的，我们将这条<strong>语句的含义拆解</strong>，如下：</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 如果返回 Screen &amp;，其等价于：</span>
myScreen<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myScreen<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果返回 Screen，其等价于：</span>
Screen temp <span class="token operator">=</span> myScreen<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 对返回值进行拷贝</span>
temp<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 不会改变 myScreen 的 contents</span></code></pre>
</li>
<li><p><strong>从</strong><code>const</code><strong>成员函数返回</strong><code>*this</code></p>
<blockquote>
<p>1、下面我们要添加一个<code>display</code><strong>操作</strong>，负责<strong>打印</strong><code>Screen</code><strong>的内容</strong>。我们希望这个函数能和<code>move</code>、<code>set</code><strong>出现在同一序列</strong>，因此该函数也应该<strong>返回它的对象的引用</strong><br>2、从逻辑上说，<strong>显示</strong>并不需要<strong>改变对象内容</strong>，因此我们令<code>display</code>是一个<code>const</code>成员。此时<code>this</code>将是一个<strong>指向</strong><code>const</code><strong>的指针</strong>，而<code>*this</code>就是<code>const</code><strong>对象</strong><br>3、由此推断，<code>display</code>的<strong>返回类型</strong>是<code>const Screen&amp;</code>。然而，如果真的<strong>返回一个</strong><code>const</code><strong>的引用</strong>，那我们就<strong>不能</strong>将其<strong>嵌入到一组动作的序列</strong>里(如后示例)<br>4、即使<strong>myScreen</strong>是个<strong>非常量对象</strong>，对<code>set</code>的调用也<strong>不能通过编译</strong>。问题在于<code>display</code>的<code>const</code>版本返回了<strong>常量引用</strong>，我们无权<code>set</code>一个<strong>常量对象</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Screen myScreen<span class="token punctuation">;</span>
<span class="token comment">// 如果 display 返回常量引用，set 将无权更改常量对象的数据，因而报错</span>
myScreen<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span>cout<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>基于</strong><code>const</code><strong>的重载</strong></p>
<blockquote>
<p>1、通过区分<strong>成员函数</strong>是否是<code>const</code>的，我们可以对其<strong>进行重载</strong>，其原因主要如下<br>2、首先，<strong>非常量版本</strong>的函数对于<strong>常量对象</strong>是不可用的，所以我们只能在<strong>常量对象</strong>上调用<code>const</code><strong>成员函数</strong>。其次，虽然可以在<strong>非常量对象</strong>上使用<strong>常量版本</strong>的函数，但显然此时<strong>非常量版本</strong>是一个<strong>更好的匹配</strong><br>3、如下例，我们将声明一个<code>do_display</code><strong>私有成员</strong>，用于负责打印。<strong>所有的</strong><code>display</code><strong>操作</strong>都将<strong>调用这个函数</strong>，然后<strong>返回自己的类型的对象</strong><br>4、当<code>do_display</code>执行完成后，这<strong>非常量版本</strong>的<code>display</code>函数<strong>返回普通引用</strong>，而<strong>常量版本</strong>的<code>display</code>函数<strong>返回常量引用</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 普通版本 display</span>
        Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">do_display</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// const 版本 display</span>
        <span class="token keyword">const</span> Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">do_display</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">void</span> <span class="token function">do_display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            os <span class="token operator">&lt;&lt;</span> contents<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>完整的 Screen 类</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size_type pos<span class="token punctuation">;</span>

        <span class="token function">Screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 默认构造函数</span>
        <span class="token function">Screen</span><span class="token punctuation">(</span>pos ht<span class="token punctuation">,</span> pos wd<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token function">height</span><span class="token punctuation">(</span>ht<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">width</span><span class="token punctuation">(</span>wd<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">contents</span><span class="token punctuation">(</span>ht <span class="token operator">*</span> wd<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token comment">// 构造函数，cursor 会被类内初始值初始化为 0</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">char</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment">// 读取光标处的字符</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> contents<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 隐式内联</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">inline</span> <span class="token keyword">char</span> <span class="token function">get</span><span class="token punctuation">(</span>pos ht<span class="token punctuation">,</span> pos wd<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// 显式内联</span>
        Screen <span class="token operator">&amp;</span><span class="token function">move</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 能在之后被设置为内联</span>

        <span class="token keyword">void</span> <span class="token function">some_member</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token operator">++</span>access_ctr<span class="token punctuation">;</span> <span class="token comment">// 保存一个计数值，用于记录成员函数被调用的次数</span>
        <span class="token punctuation">&#125;</span>

        Screen <span class="token operator">&amp;</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Screen <span class="token operator">&amp;</span><span class="token function">set</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 普通版本 display</span>
        Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">do_display</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// const 版本 display</span>
        <span class="token keyword">const</span> Screen <span class="token operator">&amp;</span><span class="token function">display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">do_display</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">mutable</span> size_t access_ctr<span class="token punctuation">;</span> <span class="token comment">// 即使在一个 const 对象内也能被修改</span>
        pos cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        pos height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> width <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>string contents<span class="token punctuation">;</span>

        <span class="token keyword">void</span> <span class="token function">do_display</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            os <span class="token operator">&lt;&lt;</span> contents<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 在类内声明为 inline</span>
<span class="token keyword">char</span> <span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos c<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    pos row <span class="token operator">=</span> r <span class="token operator">*</span> width<span class="token punctuation">;</span>      <span class="token comment">// 计算行的位置</span>
    <span class="token keyword">return</span> contents<span class="token punctuation">[</span>row <span class="token operator">+</span> c<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 返回给定列的字符</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 在定义处指定 inline</span>
<span class="token keyword">inline</span> Screen <span class="token operator">&amp;</span><span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos c<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    pos row <span class="token operator">=</span> r <span class="token operator">*</span> width<span class="token punctuation">;</span> <span class="token comment">// 计算行的位置</span>
    cursor <span class="token operator">=</span> row <span class="token operator">+</span> c<span class="token punctuation">;</span>    <span class="token comment">// 在行内将光标移动到指定列</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment">// 以左值形式返回对象</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> Screen <span class="token operator">&amp;</span><span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    contents<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 设置当前光标所在位置的新值</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>         <span class="token comment">// 将 this 作为左值返回</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">inline</span> Screen <span class="token operator">&amp;</span><span class="token class-name">Screen</span><span class="token double-colon punctuation">::</span><span class="token function">set</span><span class="token punctuation">(</span>pos r<span class="token punctuation">,</span> pos col<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    contents<span class="token punctuation">[</span>r <span class="token operator">*</span> width <span class="token operator">+</span> col<span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span> <span class="token comment">// 设置给定位置的新值</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                   <span class="token comment">// 将 this 作为左值返回</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>友元再探</strong></p>
<ul>
<li><p>先前我们的<code>Sales_data</code>类把三个普通的<strong>非成员函数</strong>定义成了<strong>友元</strong>，类还可以把<strong>其他的类</strong>定义成<strong>友元</strong>，还可以把<strong>其他类的成员函数</strong>定义成<strong>友元</strong></p>
</li>
<li><p><strong>类之间的友元关系</strong></p>
<blockquote>
<p>1、假设我们的<code>Window_mgr</code>类的<strong>某些成员</strong>可能需要访问它管理的<code>Screen</code>类的<strong>内部数据</strong>。例如我们需要为<code>Window_mgr</code>添加一个<strong>clear 成员</strong>，用于把指定的<code>Screen</code><strong>内容设为空白</strong><br>2、此时<strong>clear</strong>需要访问<code>Screen</code>的<strong>私有成员</strong>，而要使这种<strong>访问合法</strong>，<code>Screen</code>需要把<code>Window_mgr</code>指定成它的<strong>友元</strong><br>3、如果一个类指定了<strong>友元类</strong>，则<strong>友元类</strong>的<strong>成员函数</strong>可以访问此类包括<strong>私有成员在内</strong>的<strong>所有成员</strong><br>4、需要注意的是，<strong>友元关系不存在传递性</strong>。即如果<code>Window_mgr</code>有它自己的友元，这些友元<strong>不能理所当然地访问</strong><code>Screen</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Window_mgr</span><span class="token punctuation">;</span>
    <span class="token comment">// 此处省略先前的类对象</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Window_mgr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 窗口中每个屏幕的编号</span>
        <span class="token keyword">using</span> ScreenIndex <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Screen<span class="token operator">></span><span class="token double-colon punctuation">::</span>size_type<span class="token punctuation">;</span>
        <span class="token comment">// 按照编号将指定的 Screen 重置为空白</span>
        <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span>ScreenIndex i<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">// s 是一个 Screen 的引用，指向我们想清空的屏幕</span>
            Screen <span class="token operator">&amp;</span>s <span class="token operator">=</span> screens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            s<span class="token punctuation">.</span>contents <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Screen<span class="token operator">></span> screens<span class="token punctuation">&#123;</span><span class="token function">Screen</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>令函数成员作为友元</strong></p>
<blockquote>
<p>1、除了令<strong>整个类</strong>作为<strong>友元</strong>外，还可以<strong>只为 clear 提供访问权限</strong>。当把一个成员<strong>函数声明</strong>称友元时，必须<strong>明确指出</strong>成员函数<strong>属于哪个类</strong><br>2、但要想令某个<strong>成员函数</strong>作为<strong>友元</strong>，必须要按照如下方式设计程序：<br>3、首先定义<code>Window_mgr</code>类，其中声明<strong>clear</strong>函数，但<strong>不能定义</strong>它。在<strong>clear</strong>使用<code>Screen</code>成员之前必须<strong>先声明</strong><code>Screen</code>；接下来定义<code>Screen</code>，包含对于<strong>clear</strong>的友元声明；最后定义<strong>clear</strong>，此时它才可以使用<code>Screen</code>成员</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token class-name">Window_mgr</span><span class="token double-colon punctuation">::</span><span class="token function">clear</span><span class="token punctuation">(</span>ScreenIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>友元函数重载和作用域</strong></p>
<blockquote>
<p>1、尽管<strong>重载函数</strong>的名字相同，但它们仍是<strong>不同的函数</strong>。因此如果一个类想把<strong>一组重载函数声明</strong>成<strong>友元</strong>，则需要对每一个函数<strong>分别声明</strong><br>2、<strong>类</strong>和<strong>非成员函数</strong>的<strong>声明</strong>不是必须在它们的<strong>友元声明之前</strong>，当一个名字<strong>第一个出现</strong>在一个<strong>友元声明</strong>中，我们<strong>隐式假定该名字在当前作用域中可见</strong>，然而友元本身不一定真的声明在当前作用域。甚至就算在<strong>类内定义该函数</strong>，我们也必须在<strong>类外提供相应的声明</strong>，从而使得<strong>函数可见</strong><br>3、重点在于理解<strong>友元声明本身的作用</strong>是<strong>影响访问权限</strong>，而不是<strong>普通意义上的声明</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 友元函数可以定义在类内，但不是真正的定义</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
      <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 调用 f() 函数，错误：f 还没有被声明</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 f() 函数，错误：f 还没有被声明</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 声明定义在 X 中的函数 f，从此时 f 才被真正声明可用</span>
<span class="token keyword">void</span> <span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确：现在 f 的声明在作用域中了</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a><strong>类的作用域</strong></h4><ul>
<li><p><strong>类的作用域</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、每个类都会定义<strong>它自己的作用域</strong>。在<strong>类的作用域外</strong>，<strong>普通数据</strong>和<strong>函数成员</strong>只能由对象、引用、指针使用<strong>成员访问运算符</strong>来访问；对于<strong>类类型成员</strong>则使用<strong>作用域运算符</strong>来访问<br>2、不论哪种情况，跟在<strong>运算符后的名字</strong>都必须是<strong>对应类的成员</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Screen<span class="token double-colon punctuation">::</span>pos ht <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">,</span> wd <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>   <span class="token comment">// 使用 Screen 定义的 pos 类型</span>
Screen <span class="token function">scr</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span> wd<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Screen <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>scr<span class="token punctuation">;</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> scr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 访问 scr 对象的 get 成员</span>
c <span class="token operator">=</span> p <span class="token operator">-></span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 访问 p 所指向的 scr 的 get 成员</span></code></pre>
</li>
<li><p><strong>作用域和定义在类外的成员</strong></p>
<blockquote>
<p>1、一个<strong>类</strong>就是一个<strong>作用域</strong>很好的说明了为什么我们在<strong>类外定义成员函数</strong>时需要提供<code>类名::函数名</code>。在类外，<strong>成员的名字被隐藏了</strong><br>2、一旦遇到了<strong>类名</strong>，定义的<strong>剩余部分</strong>就在<strong>类的作用域内</strong>了，这里的剩余部分包括<strong>参数列表</strong>和<strong>函数体</strong>，因而我们可以<strong>直接使用类的其他成员</strong>而无须再次授权<br>3、<code>Window_mgr</code>类的<strong>clear 成员</strong>用到了<strong>该类中定义的</strong><code>ScreenIndex</code><strong>类型</strong>：<code>void Window_mgr::clear(ScreenIndex i);</code>。这里使用<code>ScreenIndex</code>时已经在<strong>该类的作用域下</strong>(因为在<code>Window_mgr::</code>后)，所以<strong>不需要额外说明</strong><br>4、有时由于<strong>返回类型</strong>出现在<strong>类名前</strong>，此时想要使用<code>ScreenIndex</code>作为<strong>返回类型</strong>，必须明确<strong>指定哪个类定义了它</strong>，如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 作用域::返回类型 类名::函数名(形参列表)</span>
window_mgr<span class="token double-colon punctuation">::</span>ScreenIndex <span class="token class-name">Window_mgr</span><span class="token double-colon punctuation">::</span><span class="token function">addScreen</span><span class="token punctuation">(</span><span class="token keyword">const</span> Screen <span class="token operator">&amp;</span>s<span class="token punctuation">)</span></code></pre></li>
</ul>
</li>
<li><p><strong>名字查找与类作用域</strong></p>
<ul>
<li><p><strong>用于类成员声明的名字查找</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">double</span> Money<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string bal<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        Money <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> bal<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        Money bal<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、<strong>编译器</strong>看到<code>balance</code>函数的声明语句时，将先在<code>Account</code><strong>类内查找 Money 的声明</strong>，没找到就到<strong>类外的作用域</strong>去查找，找到<strong>Money</strong>的<code>typedef</code>语句<br>2、<code>balance</code>函数体由于在<strong>整个类可见后</strong>才被处理，因此其<code>return</code>语句返回<strong>名为 bal 的成员</strong>而不是外层的<code>string</code>对象</p>
</blockquote>
</li>
<li><p><strong>类型名要特殊处理</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">double</span> Money<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        Money <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> bal<span class="token punctuation">;</span>             <span class="token comment">// 已经使用了外层作用域的 Money</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">typedef</span> <span class="token keyword">double</span> Money<span class="token punctuation">;</span>       <span class="token comment">// 错误：不能重新定义 Money</span>
        Money bal<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、一般来说，<strong>内层作用域</strong>可以重新定义<strong>外层作用域</strong>的名字，即使该名字已经在<strong>内层作用域</strong>中使用过<br>2、然而<strong>在类中</strong>，如果<strong>成员使用了外层作用域中的名字</strong>，而该名字<strong>代表一种类型</strong>，则类<strong>不能在之后重新定义</strong>该名字<br>3、尽管<strong>重新定义类型名字</strong>是一种错误的行为，但是<strong>编译器并不为此负责</strong>，一些编译器将顺利通过这样的代码</p>
</blockquote>
</li>
<li><p><strong>成员定义中的普通块作用域的名字查找</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> height<span class="token punctuation">;</span> <span class="token comment">// 定义了一个名字，稍后将在 Screen 中使用</span>

<span class="token keyword">class</span> <span class="token class-name">Screen</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>size_type pos<span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token function">dummy_fcn</span><span class="token punctuation">(</span>pos height<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cursor <span class="token operator">=</span> width <span class="token operator">*</span> height<span class="token punctuation">;</span> <span class="token comment">// 使用的是函数的形参 height</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        pos cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        pos height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> width <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、该例中，<strong>编译器</strong>处理函数中的<strong>乘法表达式</strong>时，它首先在<strong>函数作用域</strong>内查找名字，即先查找<strong>形参列表</strong>的<strong>同名形参</strong>。因此该例使用的是<strong>形参 height</strong>而非<strong>成员 height</strong>或<strong>全局 height</strong><br>2、如果要在这种情况下单独使用<strong>其他作用域的名字</strong>，可以使用<code>::height</code>调用<strong>全局 height</strong>，使用<code>this -&gt; height</code>或<code>Screen::height</code>调用<strong>成员 height</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a><strong>构造函数再探</strong></h4><ul>
<li><p><strong>委托构造函数</strong></p>
<blockquote>
<p>1、C++11 新标准拓展了<strong>构造函数初始值</strong>的功能，使得我们可以定义所谓的<strong>委托构造函数</strong>。一个<strong>委托构造函数</strong>，使用它<strong>所属类的其他构造函数</strong>执行它自己的初始化过程<br>2、和其他构造函数一样，一个<strong>委托构造函数</strong>也有一个<strong>成员初始值列表</strong>和一个<strong>函数体</strong>。与其他成员初始值一样，<strong>类名后面</strong>紧跟圆括号括起来的<strong>参数列表</strong>，<strong>列表必须与类中另一个构造函数匹配</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 非委托构造函数使用对应的实参初始化成员</span>
        <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> ct<span class="token punctuation">,</span> <span class="token keyword">double</span> price<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span>ct<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>ct <span class="token operator">*</span> price<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 其余构造函数全部委托给另一个构造函数</span>
        <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Sales_data</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">read</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 之前上文类中定义过的函数</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>隐式类类型转换</strong></p>
<ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、在类中，如果<strong>构造函数</strong>只接受<strong>一个实参</strong>，则它实际上定义了<strong>转换为此类类型</strong>的<strong>隐式转换机制</strong>，有时我们把这种构造函数称为<strong>转换构造函数</strong><br>2、在先前的<code>Sales_data</code>类中，接受<code>string</code>的和接受<code>istream</code>的<strong>构造函数</strong>分别定义了<strong>这两种类型向</strong><code>Sales_data</code><strong>隐式转换</strong>的规则。也就是说，在需要使用<code>Sales_data</code>的地方，可以使用<code>string</code>或<code>istream</code><strong>代替</strong><br>3、如下例，我们用一个<code>string</code><strong>实参</strong>调用了<code>combine</code><strong>成员函数</strong>。该调用合法，<strong>编译器</strong>用给定的<code>string</code>自动创建了一个<strong>临时</strong><code>Sales_data</code><strong>对象</strong>，这个新生成的<strong>临时对象</strong>被传递给了<code>combine</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string null_book <span class="token operator">=</span> <span class="token string">"9-999-99999-9"</span><span class="token punctuation">;</span>
<span class="token comment">// 构造一个临时的 Sales_data 对象，该对象的 units_sold 和 revenue 都为 0，bookNo 等于 null_book</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>null_book<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>只允许一步类类型转换</strong></p>
<blockquote>
<p>1、<strong>编译器</strong>只会自动地<strong>执行一步类型转换</strong>，因此下面代码隐式使用了<strong>两种转换规则</strong>是错误的<br>2、如果我们想完成上述调用，可以主动进行一步<strong>显式转换</strong>，如后例</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 错误：需要用户定义的两种转换，但编译器只转换一次</span>
<span class="token comment">// 1 把 字符串字面量 转换成 string</span>
<span class="token comment">// 2 把 string 转换成 Sales_data</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token string">"9-999-99999-9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 正确：显式转换成 string，隐式转换成 Sales_data</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"9-999-99999-9"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 正确：隐式转换成 string，显式转换成 Sales_data</span>
item<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token string">"9-999-99999-9"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>explicit</code><strong>抑制构造函数隐式转换</strong></p>
<blockquote>
<p>1、我们可以通过将只有一个实参的<strong>构造函数</strong>声明为<code>explicit</code>来<strong>阻止隐式转换</strong>(多个实参的构造函数不能用于执行隐式转换，所以无须指定)，此时将<strong>不能通过</strong>指定了<code>explicit</code>的<strong>构造函数</strong>来<strong>隐式创建类对象</strong><br>2、<strong>只能在类内声明构造函数时</strong>使用<code>explicit</code>，在类外定义时不应重复<br>3、<code>explicit</code><strong>构造函数</strong>只能用于<strong>直接初始化</strong>，当我们执行<strong>拷贝初始化</strong>(<code>=</code>)不能使用<code>explicit</code>构造函数</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">explicit</span> <span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 错误：类外定义时不要重复使用 explicit</span>
<span class="token keyword">explicit</span> <span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">Sales_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">read</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 错误：不能使用拷贝初始化</span>
Sales_data item <span class="token operator">=</span> null_book<span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>聚合类</strong></p>
<blockquote>
<p>1、<strong>聚合类</strong>使得用户可以<strong>直接访问其成员</strong>，当一个类满足<strong>如下条件</strong>时，我们说它是<strong>聚合</strong>的：<br>2、<strong>所有成员</strong>都是<code>public</code>的；没有定义任何<strong>构造函数</strong>；没有<strong>类内初始值</strong>；没有<strong>基类</strong>，也没有<code>virtual</code><strong>函数</strong>(这部分后续介绍)<br>3、我们可以提供一个<strong>花括号括起来</strong>的<strong>成员初始值列表</strong>来初始化聚合类的<strong>数据成员</strong>，顺序必须与声明的顺序一致</p>
</blockquote>
</li>
<li><p><strong>字面值常量类</strong></p>
<ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、之前我们提到过<code>constexpr</code><strong>函数</strong>的<strong>参数</strong>和<strong>返回值</strong>都必须是<strong>字面值类型</strong>。除了算术类型、引用、指针外，<strong>某些类也是字面值类型</strong><br>2、和其他类不同，这样的类可能含有<code>constexpr</code><strong>构造函数</strong>，这样的成员必须<strong>符合</strong><code>constexpr</code><strong>函数的所有要求</strong>，它们是<strong>隐式</strong><code>const</code>的<br>3、<strong>数据成员都是字面值类型</strong>的<strong>聚合类</strong>都是<strong>字面值常量类</strong>，此外，如果一个类满足<strong>以下要求</strong>，也是一个<strong>字面值常量类</strong>：<br>4、<strong>数据成员</strong>都必须是<strong>字面值类型</strong>；类必须包含<strong>至少一个</strong><code>constexpr</code><strong>函数</strong>；数据成员的<strong>类内初始值</strong>必须是<strong>常量表达式</strong>，如果成员属于某种类类型，<strong>初始值</strong>必须使用成员自己的<code>constexpr</code><strong>构造函数</strong>；类必须使用<strong>析构函数</strong>的<strong>默认定义</strong>，该成员负责销毁类的对象</p>
</blockquote>
</li>
<li><p><code>constexpr</code><strong>构造函数</strong></p>
<blockquote>
<p>1、<code>constexpr</code><strong>构造函数</strong>可以声明成<code>=default</code>。否则，该函数就必须既满足<strong>构造函数的要求</strong>(不包含返回语句)，又满足<code>constexpr</code><strong>函数的要求</strong>(唯一可执行的语句就是返回语句)<br>2、综合这两点，<code>constexpr</code><strong>构造函数体</strong>一般来说是<strong>空的</strong><br>3、<code>constexpr</code><strong>构造函数</strong>必须<strong>初始化所有数据成员</strong>，<strong>初始值</strong>要么使用<code>constexpr</code><strong>构造函数</strong>，要么是<strong>一条常量表达式</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Debug</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">constexpr</span> <span class="token function">Debug</span><span class="token punctuation">(</span><span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">hw</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">io</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">other</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">constexpr</span> <span class="token function">Debug</span><span class="token punctuation">(</span><span class="token keyword">bool</span> h<span class="token punctuation">,</span> <span class="token keyword">bool</span> i<span class="token punctuation">,</span> <span class="token keyword">bool</span> o<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">hw</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">io</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">other</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> <span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> hw <span class="token operator">||</span> io <span class="token operator">||</span> other<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">bool</span> hw<span class="token punctuation">;</span>
        <span class="token keyword">bool</span> io<span class="token punctuation">;</span>
        <span class="token keyword">bool</span> other<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a><strong>类的静态成员</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、有的时候类需要它的<strong>一些成员</strong>与<strong>类本身</strong>直接相关，而不是与类的<strong>各个对象</strong>保持关联<br>2、例如，一个<strong>银行账户类</strong>可能需要一个<strong>数据成员</strong>来表示当前的<strong>基准利率</strong>，我们希望<strong>利率与类关联</strong>，没必要<strong>每个对象</strong>都<strong>存储利率信息</strong><br>3、一旦利率浮动，我们希望<strong>所有的对象</strong>都能<strong>使用新值</strong></p>
</blockquote>
</li>
<li><p><strong>声明静态成员</strong></p>
<blockquote>
<p>1、我们通过在<strong>成员的声明前</strong>加上关键字<code>static</code>使其<strong>与类关联在一起</strong>。下例为我们模拟实现的银行账户类<br>2、<strong>静态成员</strong>存在于任何对象之外，对象中<strong>不包含</strong>任何<strong>与数据成员有关</strong>的数据<br>3、<strong>静态成员函数</strong>也<strong>不与任何对象绑定</strong>在一起，它们<strong>不包含</strong><code>this</code><strong>指针</strong>，且静态成员函数<strong>不能声明成</strong><code>const</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            amount <span class="token operator">+=</span> amount <span class="token operator">*</span> interesRate<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> interesRate<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>string owner<span class="token punctuation">;</span>
        <span class="token keyword">double</span> amount<span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">double</span> interesRate<span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">initRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>使用静态成员</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用作用域运算符直接访问静态成员</span>
<span class="token keyword">double</span> r<span class="token punctuation">;</span>
r <span class="token operator">=</span> <span class="token class-name">Account</span><span class="token double-colon punctuation">::</span><span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用类的对象、引用或指针来访问静态成员</span>
Account ac1<span class="token punctuation">;</span>
Account <span class="token operator">*</span>ac2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ac1<span class="token punctuation">;</span>
r <span class="token operator">=</span> ac1<span class="token punctuation">.</span><span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r <span class="token operator">=</span> ac2 <span class="token operator">-></span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 成员函数不通过作用域运算符就能直接使用静态成员</span>
<span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            ammout <span class="token operator">+=</span> amount <span class="token operator">*</span> interestRate<span class="token punctuation">;</span>    <span class="token comment">// 直接使用</span>
        <span class="token punctuation">&#125;</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">static</span> <span class="token keyword">double</span> interestRate<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>定义静态成员</strong></p>
<blockquote>
<p>1、和其他<strong>成员函数</strong>一样，我们在<strong>类内和类外</strong>都可以定义<strong>静态成员函数</strong>。当在<strong>类外定义时</strong>，不要重复<code>static</code>关键字<br>2、因为<strong>静态数据成员</strong>不属于类的任何一个对象，所以它们并不是在<strong>创建类的时候</strong>被定义的，这意味着它们<strong>不是由构造函数初始化的</strong><br>3、我们<strong>不能在类内初始化静态成员</strong>，相反，我们必须<strong>在类外定义和初始化</strong>每个静态成员</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 类外定义静态成员函数</span>
<span class="token keyword">void</span> <span class="token class-name">Account</span><span class="token double-colon punctuation">::</span><span class="token function">rate</span><span class="token punctuation">(</span><span class="token keyword">double</span> newRate<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    interestRate <span class="token operator">=</span> newRate<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 定义并初始化一个静态成员</span>
<span class="token keyword">double</span> Account<span class="token double-colon punctuation">::</span>interestRate <span class="token operator">=</span> <span class="token function">initRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>静态成员的类内初始化</strong></p>
<blockquote>
<p>1、通常情况下，类的<strong>静态成员</strong>不应该在类内初始化<br>2、然而，我们可以为<strong>静态成员</strong>提供<code>const</code><strong>整型</strong>的<strong>类内初始值</strong>，不过要求<strong>静态成员</strong>必须是<strong>字面值常量类型</strong>的<code>constexpr</code><br>3、如果在<strong>类内提供了一个初始值</strong>，则静态成员的定义<strong>不能再指定一个初始值</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Account</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> interestRate<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rate</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> period <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">// period 是常量表达式</span>
        <span class="token keyword">double</span> daily_tbl<span class="token punctuation">[</span>period<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>静态成员与普通成员的区别</strong></p>
<blockquote>
<p>1、<strong>静态成员</strong>能用于<strong>某些场景</strong>，而<strong>普通成员不能</strong>。静态成员<strong>独立于任何对象</strong>，因此，在某些<strong>普通成员可能非法</strong>的场合，<strong>静态成员</strong>可以<strong>正常使用</strong>。比如<strong>静态数据成员</strong>可以是<strong>不完全类型</strong>(后续介绍)<br>2、特别的，<strong>静态数据成员的类型</strong>可以是它<strong>所属的类类型</strong>，而<strong>普通成员</strong>只能声明成它<strong>所属类的指针或引用</strong><br>3、此外，我们可以使用<strong>静态成员</strong>作为<strong>默认实参</strong>，而<strong>普通成员不能</strong>，这是因为<strong>普通成员的值</strong>本身<strong>属于对象的一部分</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="IO-库"><a href="#IO-库" class="headerlink" title="IO 库"></a><strong>IO 库</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：<code>IO</code>类；<code>IO</code>库类型；<code>IO</code>类型间的关系；<code>IO</code>对象；无拷贝或赋值；条件状态；查询流的状态；管理条件状态；管理输出缓冲；缓冲刷新的原因；刷新输出缓冲区；<code>unitbuf</code>操作符；<code>tie</code>关联输入和输出流；文件输入输出；<code>fstream</code>操作；<code>fstream</code>对象；<code>open</code>和<code>close</code>；文件模式；指定文件模式的限制；阻止丢弃已有数据；<code>string</code>流；<code>stringstream</code>操作；使用<code>istringstream</code>；使用<code>ostringstream</code></p>
</blockquote>
</div>

<h4 id="IO-类"><a href="#IO-类" class="headerlink" title="IO 类"></a><strong>IO 类</strong></h4><ul>
<li><p><strong>IO 库类型</strong></p>
<blockquote>
<p>1、目前为止，我们已使用过的<code>IO</code><strong>类型和对象</strong>都是操纵<strong>char</strong>数据的。但现实场景下，我们不能限制<strong>实际应用程序</strong>仅从<strong>控制台窗口</strong>进行<strong>IO 操作</strong><br>2、<strong>应用程序</strong>常常需要<strong>读写命名文件</strong>，而且使用<code>IO</code><strong>操作</strong>处理<code>string</code>中的字符很方便。此外，还可能读写<strong>需要宽字符支持的语言</strong><br>3、为了支持这些不同种类的<strong>IO 操作</strong>，在<code>istream</code>和<code>ostream</code>之外，<strong>标准库</strong>还定义了其他一些<code>IO</code><strong>库类型</strong>，下表列出其中部分<br>4、<code>iostream</code>定义了用于<strong>读写流的基本类型</strong>；<code>fstream</code>定义了<strong>读写命名文件的类型</strong>；<code>sstream</code>定义了<strong>读写内存</strong><code>string</code><strong>对象的类型</strong><br>5、为了支持<strong>使用宽字符的语言</strong>，标准库定义了一组类型和对象来<strong>操纵</strong><code>wchat_t</code><strong>类型数据</strong>。宽字符版本的<strong>类型和函数名</strong>以<code>w</code>开头，如<code>wcin</code>、<code>wcout</code>、<code>wcerr</code>等</p>
</blockquote>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>iostream</td>
<td>istream，wistream</td>
<td>从流中读取数据</td>
</tr>
<tr>
<td>iostream</td>
<td>ostream，wostream</td>
<td>向流中写入数据</td>
</tr>
<tr>
<td>iostream</td>
<td>iostream，wiostream</td>
<td>读写流</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream，wifstream</td>
<td>从文件读取数据</td>
</tr>
<tr>
<td>fstream</td>
<td>ofstream，wofstream</td>
<td>向文件写入数据</td>
</tr>
<tr>
<td>fstream</td>
<td>fstream，wfstream</td>
<td>读写文件</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream，wistringstream</td>
<td>从<code>string</code>读取数据</td>
</tr>
<tr>
<td>sstream</td>
<td>ostringstream，wostringstream</td>
<td>向<code>string</code>写入数据</td>
</tr>
<tr>
<td>sstream</td>
<td>stringstream，wstringstream</td>
<td>读写<code>string</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>IO 类型间的关系</strong></p>
<blockquote>
<p>1、概念上，<strong>设备类型</strong>和<strong>字符大小</strong>都不会影响我们要执行的<strong>IO 操作</strong>。比如我们可以使用<code>&gt;&gt;</code><strong>读取数据</strong>，却<strong>不必管</strong>是从控制台，磁盘文件，或是<code>string</code>中读取；也<strong>不必管</strong>读取的字符能存入一个<strong>char 对象</strong>内，还是需要一个<code>wchar_t</code><strong>对象</strong><br>2、<strong>标准库</strong>使我们能<strong>忽略</strong>这些<strong>不同类型流之间的差异</strong>，是通过<strong>继承机制</strong>实现的。我们可以使用<strong>具有继承关系的类</strong>，而不必了解<strong>继承机制如何工作</strong>的细节<br>3、简单地说，<strong>继承机制</strong>使我们可以声明一个<strong>特定的类</strong>继承自<strong>另一个类</strong>。我们通常可以将一个<strong>派生类对象</strong>(继承类对象)当做其<strong>基类对象</strong>(被继承的类对象)来使用<br>4、比如，<code>ifstream</code>和<code>istringstream</code>都<strong>继承自</strong><code>istream</code>。因此，我们可以像<strong>使用</strong><code>istream</code><strong>对象</strong>那样，<strong>使用</strong><code>ifstream</code>和<code>istringstream</code><strong>对象</strong>。这意味着，我们如何使用<code>cin</code>的，就可以<strong>同样使用这些类型的对象</strong></p>
</blockquote>
</li>
<li><p><strong>IO 对象</strong></p>
<ul>
<li><p><strong>无拷贝或赋值</strong></p>
<blockquote>
<p>1、我们<strong>不能拷贝</strong>或<strong>对</strong><code>IO</code><strong>对象赋值</strong><br>2、由于<strong>不能拷贝</strong>，因此我们不能将<strong>形参</strong>或<strong>返回类型</strong>设置为<strong>流类型</strong>。进行<strong>IO 操作</strong>的<strong>函数</strong>通常<strong>以引用的方式传递和返回流</strong><br>3、由于<strong>读写一个 IO 对象</strong>会<strong>改变其状态</strong>，所以<strong>传递和返回的引用</strong>也不能是<code>const</code>的</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span>

std<span class="token double-colon punctuation">::</span>ofstream out1<span class="token punctuation">,</span> out2<span class="token punctuation">;</span>
out1 <span class="token operator">=</span> out2<span class="token punctuation">;</span>                          <span class="token comment">// 错误：不能对流对象赋值</span>
std<span class="token double-colon punctuation">::</span>ofstream <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ofstream<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 错误：不能初始化 ofstream 参数</span>
out2 <span class="token operator">=</span> <span class="token function">print</span><span class="token punctuation">(</span>out2<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 错误：不能拷贝流对象</span></code></pre>
</li>
<li><p><strong>条件状态</strong></p>
<blockquote>
<p>1、<strong>IO 操作</strong>一个与生俱来的问题是<strong>可能发生错误</strong>。一些错误是<strong>可恢复的</strong>，而其他错误<strong>可能发生在系统深处</strong>，已经超出了应用程序<strong>可修正的范围</strong><br>2、下表列出了<code>IO</code><strong>类</strong>所定义的一些<strong>函数和标志</strong>，可以帮助我们<strong>访问和操纵</strong>流的<strong>条件状态</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>函数和标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>strm::iostate</td>
<td>是一种机器相关的类型，提供了表达条件状态的完整功能</td>
</tr>
<tr>
<td>strm::badbit</td>
<td>用来指出流已崩溃</td>
</tr>
<tr>
<td>strm::failbit</td>
<td>用来指出一个 IO 操作失败了</td>
</tr>
<tr>
<td>strm::eofbit</td>
<td>用来指出流到达了文件结束</td>
</tr>
<tr>
<td>strm::goodbit</td>
<td>用来指出流未处于错误状态，此值保证为 0</td>
</tr>
<tr>
<td>s.eof()</td>
<td>若流 s 的 eofbit 置位，则返回 true</td>
</tr>
<tr>
<td>s.fail()</td>
<td>若流 s 的 failbit 或 badbit 置位，则返回 true</td>
</tr>
<tr>
<td>s.bad()</td>
<td>如流 s 的 badbit 置位，则返回 true</td>
</tr>
<tr>
<td>s.good()</td>
<td>若流 s 处于有效状态，则返回 true</td>
</tr>
<tr>
<td>s.clear()</td>
<td>将流 s 中所有条件状态位复位，将流的状态设置为有效，返回 void</td>
</tr>
<tr>
<td>s.clear(flag)</td>
<td>根据给定的 flag 标志位，将流 s 中对应条件状态位复位，其中 flag 的类型为<code>strm::iostate</code>，返回 void</td>
</tr>
<tr>
<td>s.setstate(flag)</td>
<td>根据给定的 flag 标志位，将流 s 中对应条件状态位置位，其中 flag 的类型为<code>strm::iostate</code>，返回 void</td>
</tr>
<tr>
<td>s.rdstate()</td>
<td>返回流 s 的当前条件状态，返回值类型为<code>strm::iostate</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>查询流的状态</strong></p>
<blockquote>
<p>1、<code>IO</code><strong>库</strong>定义了<strong>与机器无关的</strong><code>iostate</code><strong>类型</strong>，它提供了<strong>表达流状态的完整功能</strong>，该类型应作为一个<strong>位集合</strong>来使用<br>2、该类型包含如上表中的<strong>四个</strong><code>constexpr</code><strong>值</strong>，这些值用来表示<strong>特定类型的 IO 条件</strong>，可以与<strong>位运算符</strong>一起使用来<strong>一次性检测或设置多个标志位</strong><br>3、<code>badbit</code>表示<strong>系统级错误</strong>，如不可恢复的读写操作，通常如果<code>badbit</code><strong>被置位</strong>，流就<strong>无法再使用</strong>了；<code>failbit</code>在发生<strong>可恢复错误</strong>后<strong>被置位</strong>，如读取类型不对应等错误，通常这种问题是可修正的，流<strong>还可以继续使用</strong>；如果到达<strong>文件结束位置</strong>，<code>eofbit</code>和<code>failbit</code><strong>都会被置位</strong>；<code>goodbit</code><strong>值为 0</strong>表示<strong>流未发生错误</strong><br>4、同样，如上表所列，<strong>标准库</strong>还定义了一组函数来<strong>查询标志位的状态</strong></p>
</blockquote>
</li>
<li><p><strong>管理条件状态</strong></p>
<blockquote>
<p>1、如上表，<strong>标准库</strong>中还有一些用来<strong>管理条件状态</strong>的函数<br>2、<strong>流对象的成员</strong><code>rdstate</code>返回一个<code>iostate</code><strong>值</strong>，对应<strong>当前流的状态</strong>；<code>setstate</code>操作将给定的<strong>条件位置位</strong>，表示发生了对应错误；<code>clear</code>是一个<strong>重载成员函数</strong>，它分别有一个<strong>不接受参数</strong>的版本和<strong>接受一个</strong><code>iostate</code><strong>参数</strong>的版本，用于将<strong>条件位复位</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> old_state <span class="token operator">=</span> cin<span class="token punctuation">.</span><span class="token function">rdstate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记住 cin 的当前状态</span>
cin<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 复位，使 cin 有效</span>
<span class="token function">process_input</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 使用 cin</span>
cin<span class="token punctuation">.</span><span class="token function">setstate</span><span class="token punctuation">(</span>old_state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将 cin 置为原有状态</span></code></pre></li>
</ul>
</li>
<li><p><strong>管理输出缓冲</strong></p>
<ul>
<li><p>每个<strong>输出流</strong>都管理一个<strong>缓冲区</strong>，用来保存<strong>程序读写的数据</strong>。如果需要<strong>打印一串文本</strong>，<strong>文本串</strong>可能会<strong>立即打印</strong>出来，也可能被操作系统<strong>保存在缓冲区中</strong>，之后<strong>再打印</strong></p>
</li>
<li><p><strong>缓冲刷新的原因</strong></p>
<blockquote>
<p>1、程序<strong>正常结束</strong>，作为<code>main</code>函数的<code>return</code><strong>操作的一部分</strong>，<strong>缓冲刷新</strong>被执行<br>2、<strong>缓冲区满时</strong>，需要<strong>刷新缓冲</strong>，而后新的数据才能继续写入缓冲区<br>3、我们可以使用<strong>操纵符</strong>(如<code>endl</code>)来<strong>显式刷新缓冲区</strong><br>4、在每个<strong>输出操作之后</strong>，我们可以用<strong>操纵符</strong><code>unitbuf</code><strong>设置流的内部状态</strong>，来<strong>清空缓冲区</strong>。默认情况下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此<strong>写到</strong><code>cerr</code><strong>的内容</strong>都是<strong>立即刷新</strong>的<br>5、一个<strong>输出流</strong>可能<strong>被关联到另一个流</strong>，这种情况下，当读写<strong>被关联的流</strong>时，<strong>关联到的流</strong>的<strong>缓冲区会被刷新</strong>。例如默认情况下，<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>，因此，读<code>cin</code>或写<code>cerr</code>都会导致<code>cout</code><strong>的缓冲区被刷新</strong></p>
</blockquote>
</li>
<li><p><strong>刷新输出缓冲区</strong></p>
<blockquote>
<p>1、我们已经使用过<strong>操纵符</strong><code>endl</code>，它完成<strong>换行并刷新缓冲区</strong>的工作<br>2、<code>IO</code><strong>库</strong>中还有两个<strong>类似的操纵符</strong>：<code>flush</code>和<code>ends</code>。其中<code>flush</code><strong>只刷新缓冲区</strong>，不输出任何额外字符；<code>ends</code>向缓冲区<strong>插入一个空字符</strong>，然后<strong>刷新缓冲区</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> flush<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> ends<span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>unitbuf</code><strong>操作符</strong></p>
<blockquote>
<p>1、如果想在接下来<strong>每次输出操作后</strong>都<strong>刷新缓冲区</strong>，我们可以使用<code>unitbuf</code><strong>操纵符</strong><br>2、它告诉<strong>流</strong>在接下来的<strong>每次写操作之后</strong>都<strong>执行一次</strong><code>flush</code><strong>操作</strong><br>3、而使用<code>nounitbuf</code>可以<strong>重置流</strong>，使其恢复使用正常的<strong>系统管理</strong>的<strong>缓冲区刷新机制</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> unitbuf<span class="token punctuation">;</span>        <span class="token comment">// 此后所有输出操作后都会立即刷新缓冲区</span>
cout <span class="token operator">&lt;&lt;</span> nounitbuf<span class="token punctuation">;</span>      <span class="token comment">// 此后回到正常的缓冲机制</span></code></pre>
</li>
<li><p><code>tie</code><strong>关联输入和输出流</strong></p>
<blockquote>
<p>1、当一个<strong>输入流</strong>被<strong>关联到</strong>一个<strong>输出流</strong>时，任何试图<strong>从输入流读取数据</strong>的操作将会导致<strong>关联的输出流被刷新</strong><br>2、<code>tie</code>有<strong>两个重载的版本</strong>。<strong>不带参数</strong>的<code>tie</code>返回<strong>指向输出流的指针</strong>。如果本对象当前关联到一个<strong>输出流</strong>，则返回的就是<strong>这个流的指针</strong>；如果对象<strong>未关联</strong>到其他流，则返回<strong>空指针</strong><br>3、接受一个<strong>指向</strong><code>ostream</code><strong>的指针</strong>作为<strong>参数</strong>的<code>tie</code>，<strong>将自己关联到此</strong><code>ostream</code>。即<code>x.tie(&amp;o)</code>返回<strong>指向原输出流的指针</strong>，并将<strong>流</strong><code>x</code>关联到<strong>新输出流</strong><code>o</code><br>4、我们既可以将<code>istream</code><strong>关联到</strong><code>ostream</code>，也可以将<code>ostream</code><strong>关联到</strong><code>ostream</code>。<strong>每个流</strong>同时最多<strong>关联到一个流</strong>，但<strong>多个流</strong>可以同时关联到<strong>同一个</strong><code>ostream</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 将 cin 和 cout 关联在一起</span>
<span class="token comment">// old_tie 指向当前关联到 cin 的流(如果有的话)</span>
ostream <span class="token operator">*</span>old_tie <span class="token operator">=</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cin 不再与其他流关联</span>
<span class="token comment">// 将 cin 和 cerr 关联，这不是一个好主意，因为 cin 应该关联到 cout</span>
cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cerr<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 读取 cin 会刷新 cerr 而不是 cout</span>
cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span>old_tie<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 重建 cin 和 cout 间的正常关联</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a><strong>文件输入输出</strong></h4><ul>
<li><p><code>fstream</code><strong>操作</strong></p>
<blockquote>
<p>1、<strong>头文件</strong><code>fstream</code>定义了<strong>三个类型</strong>来支持<strong>文件 IO</strong>：<code>ifstream</code>、<code>ofstream</code>、<code>fstream</code>，这些类型<strong>提供的操作</strong>与我们之前是用过的对象<code>cin</code>和<code>cout</code><strong>操作一样</strong><br>2、特别是，我们可以用<code>IO</code><strong>运算符</strong>(流插入符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>)来<strong>读写文件</strong>，可以用<code>getline</code>从一个<code>ifstream</code><strong>读取数据</strong><br>3、除了<strong>继承自</strong><code>iostream</code><strong>类型</strong>的行为外，<code>fstream</code>还增加了一些新成员来<strong>管理与流关联的文件</strong>，如下表</p>
</blockquote>
<table>
<thead>
<tr>
<th>fstream 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fstream fstrm</td>
<td>创建一个未绑定的文件流，此处的 fstream 是头文件 fstream 中定义的一个类型</td>
</tr>
<tr>
<td>fstream fstrm(s)</td>
<td>创建一个 fstream，并打开名为 s 的文件。s 可以是 string 类型或指向字符数组形式字符串的指针。这些构造函数都是 explicit 的，默认文件模式 mode 依赖于 fstream 的类型</td>
</tr>
<tr>
<td>fstream fstrm(s, mode)</td>
<td>与前一个构造函数类似，但按照指定模式 mode 打开文件</td>
</tr>
<tr>
<td>fstrm.open(s)</td>
<td>打开名为 s 的文件，并将文件与 fstrm 绑定，返回 void。默认文件模式 mode 依赖于 fstream 的类型</td>
</tr>
<tr>
<td>fstrm.close()</td>
<td>关闭与 fstrm 绑定的文件，返回 void</td>
</tr>
<tr>
<td>fstrm.is_open()</td>
<td>返回一个 bool 值，指出与 fstrm 关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody></table>
</li>
<li><p><code>fstream</code><strong>对象</strong></p>
<ul>
<li><p><strong>创建对象</strong></p>
<blockquote>
<p>1、当我们想要<strong>读写一个文件</strong>时，可以定义一个<strong>文件流对象</strong>，并<strong>将对象与文件关联起来</strong><br>2、每个文件流都定义了一个名为<code>open</code>的<strong>成员函数</strong>，它完成一些系统相关的操作，来<strong>定位给定的文件</strong>，并视情况打开为<strong>读或写模式</strong><br>3、创建<strong>文件流对象</strong>时，可以<strong>直接提供文件名</strong>(可选)，如果直接提供了文件名，则<code>open</code><strong>会被自动调用</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">ifstream <span class="token function">in</span><span class="token punctuation">(</span>ifile<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 构造一个 ifstream 并打开 ifile 文件</span>
ofstream out<span class="token punctuation">;</span>               <span class="token comment">// 输出文件流未关联到任何文件</span></code></pre>
</li>
<li><p><strong>可以用</strong><code>fstream</code><strong>替代</strong><code>iostream&amp;</code></p>
<blockquote>
<p>1、之前提到过，在要求使用<strong>基类类型对象</strong>的地方，我们可以使用<strong>继承类型对象</strong>来<strong>替代</strong><br>2、这意味着，接受一个<code>iostream</code><strong>类型引用或指针</strong>的参数的函数，也可以用一个对应的<code>fstream</code>或<code>sstream</code><strong>类型</strong>来<strong>调用</strong></p>
</blockquote>
</li>
<li><p><code>open</code><strong>和</strong><code>close</code></p>
<blockquote>
<p>1、如果我们定义了一个<strong>空文件流对象</strong>，可以随后<strong>调用</strong><code>open</code>来<strong>将它与文件关联</strong>起来，如下示例<br>2、如果<strong>调用</strong><code>open</code><strong>失败</strong>，<code>failbit</code>将被置位。由于<strong>调用可能失败</strong>，所以使用类似<code>if(out)</code>的方式<strong>进行检测</strong>是好习惯<br>3、一旦一个<strong>文件流已经打开</strong>，它就会一直<strong>保持关联</strong>。如果对一个<strong>已打开的文件流</strong>调用<code>open</code><strong>会失败</strong>，并会导致<code>failbit</code>被置位，随后试图<strong>使用该文件流</strong>的操作<strong>都会失败</strong><br>4、为了<strong>将文件流关联到另一个文件</strong>，必须先<code>close</code><strong>关闭已关联的文件</strong>，成功关闭后才可以<strong>打开新的文件</strong>。如果<code>open</code>成功，则<code>open</code>会<strong>设置流的状态</strong>，使得<code>good()</code>为<strong>true</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">ifstream <span class="token function">in</span><span class="token punctuation">(</span>ifile<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 构造一个 ifstream 并打开 ifile 文件</span>
ofstream out<span class="token punctuation">;</span>               <span class="token comment">// 输出文件流未关联到任何文件</span>
out<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>ifile <span class="token operator">+</span> <span class="token string">".copy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打开指定文件</span>

in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 关闭文件</span>
in<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>ifile <span class="token operator">+</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 打开另一个文件</span></code></pre></li>
</ul>
</li>
<li><p><strong>文件模式</strong></p>
<ul>
<li><p><strong>文件模式</strong></p>
<blockquote>
<p>1、每个流都有一个<strong>关联的文件模式</strong>，用来指出<strong>如何使用文件</strong>，如下表<br>2、无论用哪种方法打开文件(调用<code>open</code>或文件名初始化流等)，都可以<strong>指定文件模式</strong><br>3、默认情况下，<code>ifstream</code>以<code>in</code>打开，<code>ofstream</code>以<code>out</code>打开，<code>fstream</code>以<code>in</code>和<code>out</code>打开</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">文件模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">in</td>
<td>只读(输入)模式</td>
</tr>
<tr>
<td align="center">out</td>
<td>只写(输出)模式</td>
</tr>
<tr>
<td align="center">app</td>
<td>只写，每次写操作前均定位到文件末尾</td>
</tr>
<tr>
<td align="center">ate</td>
<td>打开文件后立刻定位到文件末尾</td>
</tr>
<tr>
<td align="center">trunc</td>
<td>阶段文件</td>
</tr>
<tr>
<td align="center">binary</td>
<td>二进制模式</td>
</tr>
</tbody></table>
</li>
<li><p><strong>指定文件模式的限制</strong></p>
<blockquote>
<p>1、只可以对<code>ofstream</code>或<code>fstream</code>设定<code>out</code>模式<br>2、只可以对<code>ifstream</code>或<code>fstream</code>设定<code>in</code>模式<br>3、只有当<code>out</code><strong>被设定时</strong>才能设定<code>trunc</code>模式<br>4、只要<code>trunc</code><strong>没被设定</strong>，就可以设定<code>app</code>模式<br>5、默认情况下，即使我们<strong>没有设定</strong><code>trunc</code>，以<code>out</code>打开的文件<strong>也会被阶段</strong>。为了<strong>保留以</strong><code>out</code><strong>打开的文件的内容</strong>，我们必须<strong>同时指定</strong><code>app</code>模式，这样只会将数据<strong>追加到文件末尾</strong>；或者<strong>同时指定</strong><code>in</code>模式，即<strong>打开文件同时进行读写操作</strong><br>6、<code>ate</code>和<code>binary</code>可用于<strong>任何类型</strong>的文件流对象，且可以与其他任何类型模式<strong>组合使用</strong></p>
</blockquote>
</li>
<li><p><strong>阻止丢弃已有数据</strong></p>
<blockquote>
<p>1、默认情况下，当我们<strong>打开一个</strong><code>ofstream</code>时，<strong>文件的内容会被丢弃</strong><br>2、<strong>阻止清空</strong><code>ostream</code><strong>给定文件</strong>的方式是<strong>同时指定</strong><code>app</code><strong>模式</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 下列语句中，file 都会被截断</span>
ofstream <span class="token function">out1</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ofstream <span class="token function">out2</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> ofstream<span class="token double-colon punctuation">::</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
ofstream <span class="token function">out3</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> ofstream<span class="token double-colon punctuation">::</span>out <span class="token operator">|</span> ofstream<span class="token double-colon punctuation">::</span>trunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 下列语句，通过 app 保留了文件内容</span>
ofstream <span class="token function">app1</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> ofstream<span class="token double-colon punctuation">::</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>
ofstream <span class="token function">app2</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">,</span> ofstream<span class="token double-colon punctuation">::</span>out <span class="token operator">|</span> ofstream<span class="token double-colon punctuation">::</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="string-流"><a href="#string-流" class="headerlink" title="string 流"></a><strong>string 流</strong></h4><ul>
<li><p><code>stringstream</code><strong>操作</strong></p>
<blockquote>
<p>1、<strong>头文件</strong><code>sstream</code>定义了<strong>三个类型</strong>来支持<strong>内存 IO</strong>：<code>istringstream</code>、<code>ostringstream</code>、<code>stringstream</code><br>2、与<code>fstream</code>类似，<code>sstream</code><strong>定义的类型</strong>也都<strong>继承自</strong><code>iostream</code><br>3、除了<strong>继承</strong>得来的操作，<code>sstream</code>还定义了一些成员来<strong>管理与流相关联的</strong><code>string</code>，如下表</p>
</blockquote>
<table>
<thead>
<tr>
<th>stringstream 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sstream strm</td>
<td>创建一个未绑定的 stringstream 对象，此处的 sstream 是头文件 sstream 中的一个类型</td>
</tr>
<tr>
<td>sstream strm(s)</td>
<td>创建一个 sstream，保存字符串 s 的一个拷贝。此构造函数是 explicit 的</td>
</tr>
<tr>
<td>strm.str()</td>
<td>返回 strm 保存的 string 的拷贝</td>
</tr>
<tr>
<td>strm.str(s)</td>
<td>将字符串 s 拷贝到 strm 中，返回 void</td>
</tr>
</tbody></table>
</li>
<li><p><strong>使用</strong><code>istringstream</code></p>
<ul>
<li><p>当我们的某些工作是<strong>对整行文本进行处理</strong>，而其他一些工作是<strong>处理行内的单个单词</strong>，通常可以使用<code>istringstream</code>(在理解上，可以认为该类型对象类似于一个单独的<code>string</code>输入缓冲区)</p>
</li>
<li><p><strong>示例</strong></p>
<blockquote>
<p>1、假定有一个文件，列出了一些人和他们的电话号码，某些人只有<strong>一个号码</strong>，另一些人有<strong>多个号码</strong>，文件中每条记录都<strong>以人名开始</strong>，后面跟随<strong>一个或多个电话号码</strong>，不同记录之间换行。通过程序实现这些内容的存储<br>2、我们在程序中使用一个<code>istringstream</code><strong>与读入的文本行绑定</strong>，这样就可以在<strong>该类型对象</strong>上使用<strong>输入运算符</strong><code>&gt;&gt;</code>来<strong>读取每个元素</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">struct</span> <span class="token class-name">PersonInfo</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> phones<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">,</span> word<span class="token punctuation">;</span>         <span class="token comment">// 分别保存来自输入的一行和单词</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>PersonInfo<span class="token operator">></span> people<span class="token punctuation">;</span> <span class="token comment">// 保存来自输入的所有记录</span>
    <span class="token comment">// 逐行从输入读取数据</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        PersonInfo info<span class="token punctuation">;</span>                 <span class="token comment">// 创建一个保存此记录数据的对象</span>
        std<span class="token double-colon punctuation">::</span>istringstream <span class="token function">record</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将记录绑定到刚读入的行</span>
        record <span class="token operator">>></span> info<span class="token punctuation">.</span>name<span class="token punctuation">;</span>             <span class="token comment">// 读取名字(到空格停止)</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>record <span class="token operator">>></span> word<span class="token punctuation">)</span>           <span class="token comment">// 读取电话号码(到空格停止并再次循环)</span>
            info<span class="token punctuation">.</span>phones<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保持它们</span>
        people<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 将此记录追加到 people 末尾</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>使用</strong><code>ostringstream</code></p>
<ul>
<li><p>当我们<strong>逐步构造输出</strong>，希望<strong>最后一起打印</strong>时，<code>ostringstream</code>是很有用的(在理解上，可以认为该类型对象类似于一个单独的<code>string</code>输出缓冲区)</p>
</li>
<li><p><strong>示例</strong></p>
<blockquote>
<p>1、假定对于<code>istringstream</code>的上例，我们想<strong>逐个验证电话</strong>再<strong>改变其格式</strong>输出，对于有无效号码的人，我们不会将其输出，而是打印一条包含<strong>人名和无效号码</strong>的<strong>错误信息</strong>。通过程序实现这些内容的格式化与转存<br>2、由于我们<strong>不希望输出有无效号码的人</strong>，因此对每个人，直到<strong>验证完所有号码</strong>才能进行输出。这种情况下，我们可以将输出内容先写入到一个<code>ostringstream</code>中更加方便</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">struct</span> <span class="token class-name">PersonInfo</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> phones<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">,</span> word<span class="token punctuation">;</span>         <span class="token comment">// 分别保存来自输入的一行和单词</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>PersonInfo<span class="token operator">></span> people<span class="token punctuation">;</span> <span class="token comment">// 保存来自输入的所有记录</span>
    <span class="token comment">// 逐行从输入读取数据</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        PersonInfo info<span class="token punctuation">;</span>                 <span class="token comment">// 创建一个保存此记录数据的对象</span>
        std<span class="token double-colon punctuation">::</span>istringstream <span class="token function">record</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将记录绑定到刚读入的行</span>
        record <span class="token operator">>></span> info<span class="token punctuation">.</span>name<span class="token punctuation">;</span>             <span class="token comment">// 读取名字</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>record <span class="token operator">>></span> word<span class="token punctuation">)</span>           <span class="token comment">// 读取电话号码</span>
            info<span class="token punctuation">.</span>phones<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保持它们</span>
        people<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 将此记录追加到 people 末尾</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 假定已有两个函数：</span>
    <span class="token comment">// valid() 完成电话号码验证；format() 完成格式化</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>entry <span class="token operator">:</span> people<span class="token punctuation">)</span> <span class="token comment">// 对于 people 的每一项</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>ostringstream formatted<span class="token punctuation">,</span> badNums<span class="token punctuation">;</span> <span class="token comment">// 每个循环创建的对象</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>nums <span class="token operator">:</span> entry<span class="token punctuation">.</span>phones<span class="token punctuation">)</span>  <span class="token comment">// 对每个数</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">valid</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment">// 如果无效</span>
                badNums <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> nums<span class="token punctuation">;</span>           <span class="token comment">// 将数的字符存入 badNums</span>
            <span class="token keyword">else</span>                                  <span class="token comment">// 如果有效</span>
                formatted <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">format</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进行格式化</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>badNums<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如果没有错误的数，打印名字和格式化的数</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> entry<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> formatted<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token comment">// 如果有错误，打印错误信息</span>
            std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"input error: "</span> <span class="token operator">&lt;&lt;</span> entry<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">" invalid number(s): "</span> <span class="token operator">&lt;&lt;</span> badNums<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<hr>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a><strong>顺序容器</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：顺序容器概述；顺序容器类型；选择容器；容器库概览；容器操作；迭代器范围；容器类型成员；<code>begin</code>和<code>end</code>成员；容器定义与初始化；<code>assign</code>和<code>swap</code>；顺序容器操作；添加元素；添加元素的操作；使用<code>insert</code>添加元素；使用<code>insert</code>的返回值；使用<code>emplace</code>；访问元素；删除元素；特殊的<code>forward_list</code>操作；改变容器大小；有关迭代器失效；<code>vector</code>对象如何增长；操作原理描述；管理容量的成员函数；额外的<code>string</code>操作；构造<code>string</code>的其他方法；其他构造函数；<code>substr</code>操作；改变<code>string</code>的其他方法；特殊版本函数；<code>append</code>和<code>replace</code>函数；<code>string</code>搜索操作；<code>compare</code>函数；数值转换；容器适配器；适配器类型；定义适配器；栈适配器；队列适配器</p>
</blockquote>
</div>

<h4 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a><strong>顺序容器概述</strong></h4><ul>
<li><p><strong>顺序容器类型</strong></p>
<blockquote>
<p>1、下表中列出了<strong>标准库</strong>中的<strong>顺序容器</strong>，其中大部分类型都提供<strong>高效灵活的内存管理</strong>，我们可以<strong>添加删除元素</strong>、<strong>扩张收缩容器大小</strong><br>2、容器<strong>保存元素的策略</strong>对<strong>容器操作</strong>有着<strong>固有且重大的影响</strong>。某些情况下，<strong>存储策略</strong>还会影响特定容器<strong>是否支持特定操作</strong><br>3、<code>forward_list</code>和<code>array</code>是<strong>C++新标准</strong>增加的类型。与<strong>内置数组</strong>相比，<code>array</code>是一种<strong>更安全易用</strong>的数组类型<br>4、<strong>新标准库的容器</strong>比旧版本<strong>快得多</strong>，其性能几乎与<strong>最精心优化过</strong>的<strong>同类数据结构</strong>一样好，甚至过之<br>5、现代<strong>C++程序</strong>应该尽可能多使用<strong>标准库容器</strong>，而不是像<strong>内置数组</strong>这样的<strong>原始数据结构</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>顺序容器类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列，支持快速随机访问，在头尾插入删除速度很快</td>
</tr>
<tr>
<td>list</td>
<td>双向链表，只支持双向顺序访问，在任何位置插入删除速度都很快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表，只支持单向顺序访问，在任何位置插入删除速度都很快</td>
</tr>
<tr>
<td>array</td>
<td>固定大小数组，支持快速随机访问，不能添加删除元素</td>
</tr>
<tr>
<td>string</td>
<td>与 vector 类似，专门用来保存字符，随机访问快，尾部插入删除速度快</td>
</tr>
</tbody></table>
</li>
<li><p><strong>选择容器</strong></p>
<blockquote>
<p>1、通常，使用<code>vector</code>是<strong>最好的选择</strong>，除非你有<strong>很好的理由</strong>选择其他容器<br>2、如果你的程序有<strong>很多小的元素</strong>，且<strong>空间的额外开销</strong>很重要，则不要使用<code>list</code>或<code>forward_list</code><br>3、如果程序要求<strong>随机访问元素</strong>，应使用<code>vector</code>或<code>deque</code><br>4、如果程序要求<strong>在容器的中间插入或删除</strong>元素，应使用<code>list</code>或<code>forward_list</code><br>5、如果程序需要<strong>在头尾插入或删除</strong>元素，但不会在中间插入或删除，则使用<code>deque</code><br>6、如果程序只在<strong>输入时</strong>才<strong>在容器中间位置插入</strong>元素，随后需要<strong>随机访问元素</strong>，则最好在<strong>输入阶段</strong>使用<code>list</code>，完成后<strong>拷贝到</strong><code>vector</code>(但最好确定是否真的一定要在中间位置插入元素，大多情况可以输入到<code>vector</code>再通过<code>sort</code>函数排序)</p>
</blockquote>
</li>
</ul>
<h4 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a><strong>容器库概览</strong></h4><ul>
<li><p>一般来说，每个<strong>容器</strong>都定义在一个<strong>头文件</strong>中，<strong>头文件名与类型名相同</strong></p>
</li>
<li><p><strong>容器操作</strong></p>
<ul>
<li><p><strong>类型别名</strong></p>
<table>
<thead>
<tr>
<th>类型别名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>iterator</td>
<td>此容器类型的迭代器类型</td>
</tr>
<tr>
<td>const_iterator</td>
<td>可以读取元素但不能修改元素的迭代器类型</td>
</tr>
<tr>
<td>size_type</td>
<td>无符号整数类型，足够保存此种容器类型最大可能容器的大小</td>
</tr>
<tr>
<td>difference_type</td>
<td>带符号整数类型，足够保存两个迭代器之间的距离</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>reference</td>
<td>元素的左值类型，与 value_type&amp;含义相同</td>
</tr>
<tr>
<td>const_reference</td>
<td>元素的 const 左值类型，即 cosnt value_type&amp;</td>
</tr>
</tbody></table>
</li>
<li><p><strong>构造函数</strong></p>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>C c</td>
<td>默认构造函数，构造空容器</td>
</tr>
<tr>
<td>C c1(c2)</td>
<td>构造 c2 的拷贝 c1</td>
</tr>
<tr>
<td>C c(b,e)</td>
<td>构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c，但不适用于 array</td>
</tr>
<tr>
<td>C c{a,b,c,…}</td>
<td>列表初始化 c</td>
</tr>
</tbody></table>
</li>
<li><p><strong>赋值和 swap</strong>(assign 不适用于关联容器和 array)</p>
<table>
<thead>
<tr>
<th>赋值和 swap</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c1 &#x3D; c2</td>
<td>将 c1 的元素替换为 c2 的元素</td>
</tr>
<tr>
<td>c1 &#x3D; {a,b,c,…}</td>
<td>将 c1 的元素替换为列表中的元素，但不适用于 array</td>
</tr>
<tr>
<td>a.swap(b)</td>
<td>交换 a 和 b 的元素</td>
</tr>
<tr>
<td>swap(a,b)</td>
<td>交换 a 和 b 的元素</td>
</tr>
<tr>
<td>seq.assign(b,e)</td>
<td>将 seq 中的元素替换为迭代器 b 和 e 所表示范围中的元素，b 和 e 不能指向 seq 中的元素</td>
</tr>
<tr>
<td>seq.assign(il)</td>
<td>将 seq 中的元素替换为初始化列表 il 中的元素</td>
</tr>
<tr>
<td>seq.assign(n,t)</td>
<td>将 seq 中的元素替换为 n 个值为 t 的元素</td>
</tr>
</tbody></table>
</li>
<li><p><strong>大小</strong></p>
<table>
<thead>
<tr>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.size()</td>
<td>c 中元素的数目，但不支持 forward_list</td>
</tr>
<tr>
<td>c.max_size()</td>
<td>c 可保存的最大元素数目</td>
</tr>
<tr>
<td>c.empty()</td>
<td>若 c 为空，返回 true，否则返回 false</td>
</tr>
</tbody></table>
</li>
<li><p><strong>增删元素</strong>(不适用于 array，且在不同容器中这些操作的接口都不同)</p>
<table>
<thead>
<tr>
<th>增删元素</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.insert(args)</td>
<td>将 args 中的元素拷贝进 c</td>
</tr>
<tr>
<td>c.emplace(inits)</td>
<td>使用 inits 构造 c 中的一个元素</td>
</tr>
<tr>
<td>c.erase(args)</td>
<td>删除 args 指定的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除 c 中所有元素，返回 void</td>
</tr>
</tbody></table>
</li>
<li><p><strong>关系运算符</strong></p>
<table>
<thead>
<tr>
<th>关系运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;，!&#x3D;</td>
<td>所有容器都支持相等和不等运算符</td>
</tr>
<tr>
<td>&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D;</td>
<td>关系运算符，无序关联容器不支持</td>
</tr>
</tbody></table>
</li>
<li><p><strong>获取迭代器</strong></p>
<table>
<thead>
<tr>
<th>获取迭代器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.begin()，c.end()</td>
<td>返回指向 c 的首元素与尾元素之后位置的迭代器</td>
</tr>
<tr>
<td>c.cbegin()，c.cend()</td>
<td>返回 const_interator</td>
</tr>
</tbody></table>
</li>
<li><p><strong>反向容器的额外成员</strong>(不支持 forward_list)</p>
<table>
<thead>
<tr>
<th>反向容器的额外成员</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reverse_iterator</td>
<td>按逆序寻址元素的迭代器</td>
</tr>
<tr>
<td>const_reverse_interator</td>
<td>不能修改元素的逆序迭代器</td>
</tr>
<tr>
<td>c.rbegin()，c.rend()</td>
<td>返回指向 c 的尾元素与首元素之前位置的迭代器</td>
</tr>
<tr>
<td>c.crbegin()，c.crend()</td>
<td>返回 const_reverse_interator</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>迭代器范围</strong></p>
<blockquote>
<p>1、一个<strong>迭代器范围</strong>由一对迭代器表示，<strong>两个迭代器</strong>分别指向<strong>同一个容器</strong>中的<strong>元素位置</strong>或<strong>尾元素之后位置</strong>，这<strong>两个迭代器</strong>通常被称为<strong>begin</strong>和<strong>end</strong><br>2、这种元素范围被称为<strong>左闭合区间</strong>，数学描述为<code>[begin, end)</code>，表示<strong>自 begin 开始</strong>，<strong>于 end 前结束</strong><br>3、标准库使用<strong>左闭合范围</strong>是因为这种范围有<strong>三种方便的特性</strong>，假定<strong>begin</strong>和<strong>end</strong>构成合法的迭代器范围，则有：<br>4、如果<strong>begin</strong>和<strong>end</strong>相等，则范围为空；如果<strong>begin</strong>和<strong>end</strong>不等，则范围至少包含一个元素，且<strong>begin</strong>指向首元素；我们可以对<strong>begin</strong>递增若干次，使<code>begin==end</code>，过程中进行迭代</p>
</blockquote>
</li>
<li><p><strong>容器类型成员</strong></p>
<blockquote>
<p>1、每个容器都定义了<strong>多个类型</strong>，我们已经使用过<strong>其中三种</strong>：<code>size_type</code>、<code>iterator</code>、<code>const_iterator</code><br>2、除了已经使用过的<strong>迭代器类型</strong>，大多容器还提供<strong>反向迭代器</strong>，简单说，<strong>反向迭代器</strong>就是一种<strong>反向遍历容器</strong>的迭代器<br>3、剩下还有一些<strong>类型别名</strong>，通过别名我们可以在<strong>不了解容器中元素类型</strong>的情况下<strong>使用它</strong>。比如<strong>元素类型</strong><code>value_type</code>；<strong>元素类型引用</strong><code>reference</code>或<code>const_reference</code></p>
</blockquote>
</li>
<li><p><strong>begin 和 end 成员</strong></p>
<blockquote>
<p>1、<code>begin</code>和<code>end</code><strong>操作</strong>生成指向容器<strong>首元素位置</strong>和<strong>尾后位置</strong>的迭代器，这两个迭代器<strong>最常见的用途</strong>是形成一个<strong>包含容器所有元素</strong>的<strong>迭代器范围</strong><br>2、<code>begin</code>和<code>end</code>有<strong>多个版本</strong>，带<code>r</code>的版本(<code>rbegin</code>)返回<strong>反向迭代器</strong>，带<code>c</code>的版本(<code>cbegin</code>)返回<code>const</code><strong>迭代器</strong>，二者可叠加(<code>crbegin</code>)</p>
</blockquote>
</li>
<li><p><strong>容器定义与初始化</strong></p>
<ul>
<li><p><strong>将一个容器初始化为另一个容器的拷贝</strong></p>
<blockquote>
<p>1、将一个<strong>新容器</strong>创建为<strong>另一个容器的拷贝</strong>有两种方法：可以<strong>直接拷贝整个容器</strong>，或者可以拷贝由一个<strong>迭代器对指定的元素范围</strong><br>2、为了创建一个<strong>容器</strong>为<strong>另一个容器的拷贝</strong>(即第一种方法)，两个<strong>容器的类型</strong>及其<strong>元素的类型</strong>必须匹配<br>3、而使用<strong>迭代器对</strong>(即第二种方法)本质上是<strong>拷贝迭代器指向的数据</strong>，就不要求<strong>容器类型相同</strong>了，但<strong>元素类型</strong>需要<strong>能转换成相应的类型</strong></p>
</blockquote>
</li>
<li><p><code>array</code><strong>具有固定大小</strong></p>
<blockquote>
<p>1、与<strong>内置数组</strong>一样，<code>array</code><strong>的大小</strong>也是<strong>类型的一部分</strong>，即定义一个<code>array</code>时，除了指定<strong>元素类型</strong>，还要指定<strong>容器大小</strong>：<code>array&lt;int, 42&gt;</code>、<code>array&lt;int, 42&gt;::size_type</code><br>2、由于<strong>大小</strong>是<code>array</code><strong>类型的一部分</strong>，所以<code>array</code>不支持<strong>普通的容器构造函数</strong>，<code>array</code><strong>大小固定</strong>的特性也影响了它所定义的<strong>构造函数的行为</strong><br>3、一个<strong>默认构造</strong>的<code>array</code>是<strong>非空</strong>的，它包含<strong>与其大小一样多的元素</strong>，这些<strong>元素</strong>都被<strong>默认初始化</strong><br>4、虽然我们不能对<strong>内置数组</strong>进行<strong>拷贝</strong>或<strong>对象赋值操作</strong>，但对于<code>array</code>来说<strong>并无此限制</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>assign 和 swap</strong></p>
<ul>
<li><p><strong>使用</strong><code>assgin</code>(仅顺序容器)</p>
<blockquote>
<p>1、使用<strong>赋值运算符</strong>赋值要求左边和右边的<strong>运算对象类型相同</strong>，而<strong>除</strong><code>array</code><strong>外的顺序容器</strong>还定义了一个<code>assign</code><strong>成员函数</strong>，允许我们从<strong>不同但相容的类型</strong>赋值，或从<strong>容器的一个子序列</strong>赋值<br>2、<code>assign</code>操作用<strong>迭代器参数</strong>所<strong>指定的元素</strong>替换<strong>左边容器的所有元素</strong>，比如我们可以用<code>assign</code>实现将<code>vector</code><strong>中的一段</strong><code>char*</code>赋值给一个<code>list</code><strong>中的</strong><code>string</code>，如下例</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">list<span class="token operator">&lt;</span>string<span class="token operator">></span> names<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span> oldstyle<span class="token punctuation">;</span>
names <span class="token operator">=</span> oldstyle<span class="token punctuation">;</span>                                   <span class="token comment">// 错误：容器类型不匹配</span>
names<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>oldstyle<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> oldstyle<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确：可以将 const char* 转换成 string</span></code></pre>
</li>
<li><p><strong>使用</strong><code>swap</code></p>
<blockquote>
<p>1、<code>swap</code>操作<strong>交换两个相同类型容器</strong>的<strong>内存</strong>，调用<code>swap</code>后，两个容器中的<strong>元素将会交换</strong><br>2、除<code>array</code>外，<code>swap</code><strong>不对任何元素</strong>进行<strong>拷贝</strong>、<strong>删除</strong>、<strong>插入</strong>操作，<strong>不会真正移动元素</strong>，因此可以保证在<code>O(1)</code><strong>常数时间</strong>内完成；而<code>array</code>会<strong>真正交换它们的元素</strong>，因此所需时间是<code>O(n)</code><strong>级别</strong>的<br>3、<strong>元素不会被移动</strong>意味着除<code>string</code>外，指向容器的<strong>迭代器</strong>、<strong>引用</strong>、<strong>指针</strong>在<code>swap</code><strong>之后不会失效</strong>，它们仍<strong>指向</strong><code>swap</code><strong>之前所指向的那些元素</strong>，只是<code>swap</code>之后这些元素已经<strong>属于不同的容器</strong>了(即<code>swap</code>前指向<code>vec1[3]</code>，<code>swap</code>后指向<code>vec2[3]</code>，而<code>vec2</code>实际就是交换前的<code>vec1</code>)。不同的是，对一个<code>string</code>调用<code>swap</code>会导致<strong>迭代器</strong>、<strong>引用</strong>、<strong>指针失效</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a><strong>顺序容器操作</strong></h4><ul>
<li><p><strong>添加元素</strong></p>
<ul>
<li><p><strong>添加元素的操作</strong></p>
<blockquote>
<p>1、除<code>array</code>外，所有<strong>标准库容器</strong>都提供<strong>灵活的内存管理</strong>，在运行时可以<strong>动态添加或删除元素</strong>来<strong>改变容器大小</strong>，如下表<br>2、这些操作<strong>会改变容器大小</strong>，因此<code>array</code><strong>不支持这些操作</strong><br>3、<code>forward_list</code>有自己<strong>专有版本的</strong><code>insert</code>和<code>emplace</code>，且<strong>不支持</strong><code>push_back</code>和<code>emplace_back</code><br>4、<code>vector</code>和<code>string</code><strong>不支持</strong><code>push_front</code>和<code>emplace_front</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>添加元素的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.push_back(t)，c.emplace_back(args)</td>
<td>在 c 的尾部创建一个值为 t 或由 args 创建的元素，返回 void</td>
</tr>
<tr>
<td>c.push_front(t)，c.emplace_front(args)</td>
<td>在 c 的头部创建一个值为 t 或由 args 创建的元素，返回 void</td>
</tr>
<tr>
<td>c.insert(p,t)，c.emplace(p,args)</td>
<td>在迭代器 p 指向的元素之前创建一个值为 t 或由 args 创建的元素，返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p,n,t)</td>
<td>在迭代器 p 指向的元素之前插入 n 个值为 t 的元素，返回指向新添加的第一个元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p,b,e)</td>
<td>将迭代器 b 和 e 指定的范围内的元素插入到迭代器 p 指向的元素之前，b 和 e 不能指向 c 中的元素，返回指向新添加的第一个元素的迭代器，若范围为空，则返回 p</td>
</tr>
<tr>
<td>c.insert(p,il)</td>
<td>il 是一个花括号包裹的元素值列表列表，将这些给定值插入到迭代器 p 指向的元素之前，返回指向新添加的第一个元素的迭代器，若列表为空，则返回 p</td>
</tr>
</tbody></table>
</li>
<li><p><strong>使用</strong><code>insert</code><strong>添加元素</strong></p>
<blockquote>
<p>1、<code>push_back</code>和<code>push_front</code>操作能够快捷<strong>添加元素</strong>到<strong>容器头尾</strong>，而<code>insert</code>允许我们在容器<strong>任意位置插入元素</strong><br>2、每个<code>insert</code><strong>函数</strong>都接受一个<strong>迭代器</strong>作为<strong>第一个参数</strong>，指出在容器<strong>什么位置放置新元素</strong>，它可以指向容器<strong>任何位置</strong>，包括<strong>尾后位置</strong>，<code>insert</code>会将元素<strong>插入到这个位置之前</strong><br>3、虽然某些容器<strong>不支持</strong><code>push_front</code>，但对<code>insert</code>操作<strong>插入开始位置并无限制</strong>，因此我们可以将元素<strong>插入到容器开始位置</strong>，而不必关心容器是否支持<code>push_front</code>，但这样操作需要<strong>注意运行效率</strong><br>4、此外<code>insert</code>还可以<strong>接受更多参数</strong>来<strong>添加多个相同值</strong>或<strong>添加一个迭代器范围内的值</strong>，使用方法见上表格</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>string<span class="token operator">></span> svec<span class="token punctuation">;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">></span> slist<span class="token punctuation">;</span>

<span class="token comment">// 等价于调用 slist.push_front("Hello!");</span>
slist<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>slist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// vector 不支持 push_front，但可以 insert 到 begin() 之前</span>
<span class="token comment">// 警告：插入到 vector 末尾之外的任何位置都可能很慢</span>
svec<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>使用</strong><code>insert</code><strong>的返回值</strong></p>
<blockquote>
<p>1、<code>insert</code>返回<strong>指向新添加的第一个元素</strong>的<strong>迭代器</strong><br>2、通过使用<code>insert</code>的返回值，可以在容器中一个<strong>特定位置反复插入元素</strong>，如下例</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string word<span class="token punctuation">;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">></span> lst<span class="token punctuation">;</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> word<span class="token punctuation">)</span>
    iter <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 每次执行后 iter 都赋值为返回值，即每次 iter 都指向开头位置</span></code></pre>
</li>
<li><p><strong>使用</strong><code>emplace</code></p>
<blockquote>
<p>1、<strong>新标准</strong>引入了<strong>三个新成员</strong>：<code>emplace_front</code>、<code>emplace</code>、<code>emplace_back</code>，这些操作将会<strong>构造元素</strong>(而不是拷贝元素)，分别对应<code>push_front</code>、<code>insert</code>、<code>push_back</code><br>2、当调用<code>push</code>或<code>insert</code><strong>成员函数</strong>时，我们将<strong>元素类型的对象</strong>传递给它们，这些<strong>对象</strong>被<strong>拷贝到容器中</strong>。而当我们调用<code>emplace</code>时，则是将<strong>参数</strong>传递给<strong>元素类型的构造函数</strong>，<code>emplace</code>使用这些参数在<strong>容器管理的内存空间中</strong>直接<strong>构造元素</strong><br>3、<code>emplace</code>函数在容器中<strong>直接构造元素</strong>，所以传递给<code>emplace</code>函数的<strong>参数</strong>必须与<strong>元素类型的构造函数</strong>相匹配</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>访问元素</strong></p>
<blockquote>
<p>1、下表列出了<strong>顺序容器</strong>中<strong>访问元素</strong>的<strong>操作</strong>，如果容器<strong>没有元素</strong>，则访问操作是<strong>未定义的</strong><br>2、<code>at</code>和<strong>下标操作</strong>只适用于<code>string</code>、<code>vector</code>、<code>deque</code>、<code>array</code>，此外<code>back</code>不适用于<code>forward_list</code><br>3、此外，使用时有一些注意事项，如下示例</p>
</blockquote>
<table>
<thead>
<tr>
<th>访问元素的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.back()</td>
<td>返回 c 中尾元素的引用</td>
</tr>
<tr>
<td>c.front()</td>
<td>返回 c 中首元素的引用</td>
</tr>
<tr>
<td>c[n]</td>
<td>返回 c 中下标为 n 的元素的引用，n 是一个无符号整数。如 n&gt;&#x3D;c.size()，则函数行为未定义</td>
</tr>
<tr>
<td>c.at(n)</td>
<td>返回 c 中下标为 n 的元素的引用。如果下标越界，则抛出一个<code>out_of_range</code>异常</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在解引用一个迭代器或调用 front 或 back 之前检查是否有元素</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// val1 和 val2 是 c 中第一个元素值的拷贝</span>
    <span class="token keyword">auto</span> val1 <span class="token operator">=</span> <span class="token operator">*</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 解引用迭代器</span>
    <span class="token keyword">auto</span> val2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// front 获取首元素的引用</span>
    <span class="token comment">// val3 和 val4 是 c 中最后一个元素值的拷贝(但此处操作对 forward_list 不适用)</span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 注意迭代器指向尾后位置</span>
    <span class="token keyword">auto</span> val3 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 注意不能递减 forward_list</span>
    <span class="token keyword">auto</span> val4 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// forward_list 不支持</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>删除元素</strong></p>
<blockquote>
<p>1、与<strong>添加元素</strong>的操作类似，非<code>array</code>的容器也有多种<strong>删除元素</strong>的方式，如下表。需要注意，删除元素的函数<strong>不检查其参数</strong>，程序员必须<strong>确保待删除的元素存在</strong><br>2、这些操作<strong>会改变容器大小</strong>，所以<strong>不适用于</strong><code>array</code><br>3、<code>forward_list</code>有<strong>特殊版本的</strong><code>erase</code>，且<strong>不支持</strong><code>pop_back</code><br>4、<code>vector</code>和<code>string</code><strong>不支持</strong><code>pop_front</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>删除元素的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.pop_back()</td>
<td>删除 c 中尾元素，函数返回 void</td>
</tr>
<tr>
<td>c.pop_front()</td>
<td>删除 c 中首元素，函数返回 void</td>
</tr>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器 p 所指定的元素，返回一个指向被删除元素之后元素的迭代器。若 p 是尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td>c.erase(b,e)</td>
<td>删除迭代器 b 和 e 所指范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器。若 e 本身是尾后迭代器，返回尾后迭代器</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除 c 中所有元素，返回 void</td>
</tr>
</tbody></table>
</li>
<li><p><strong>特殊的 forward_list 操作</strong></p>
<ul>
<li><p><strong>单向链表的操作</strong></p>
<blockquote>
<p>1、为了理解<code>forward_list</code>为什么有<strong>特殊版本</strong>的<strong>添加和删除操作</strong>，考虑当我们从一个<strong>单向链表</strong>删除一个元素会发生什么。当<strong>删除一个元素</strong>时，会<strong>改变序列中的链接</strong>，如<strong>删除</strong><code>elem3</code>会<strong>改变</strong><code>elem2</code><strong>指向</strong><code>elem4</code><br>2、当<strong>添加或删除一个元素</strong>时，<strong>该元素之前的元素</strong>的<strong>后继</strong>会<strong>发生改变</strong>。为了执行这一操作，我们需要<strong>访问其前驱</strong>，以<strong>改变前驱的链接</strong>。但是<code>forward_list</code>是<strong>单向链表</strong>，没有简单的办法<strong>获取一个元素的前驱</strong><br>3、由于这个原因，在一个<code>forward_list</code>中的<strong>增删操作</strong>是通过<strong>改变给定元素后的元素</strong>来完成的，这样，我们总是可以访问到<strong>被增删操作所影响的元素</strong></p>
</blockquote>
</li>
<li><p><code>forward_list</code><strong>增删操作</strong></p>
<blockquote>
<p>1、由于<code>forward_list</code><strong>操作</strong>与<strong>其他容器上的操作</strong>的<strong>实现方式不同</strong>，所以定义了<strong>一套特殊的函数</strong>，如下表<br>2、为了<strong>支持这些操作</strong>，<code>forward_list</code>也定义了<code>before_begin</code>，它是一个<strong>首前迭代器</strong>，它将允许我们在<strong>链表首元素之前</strong>的不存在的元素<strong>之后</strong>执行<strong>增删操作</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>forward_list 增删操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lst.before_begin()，lst.cbefore_begin()</td>
<td>返回指向链表首前元素的迭代器，此迭代器不能解引用。cbefore_begin 返回一个 const_iterator</td>
</tr>
<tr>
<td>lst.insert_after(p,t)，lst.insert_after(p,n,t)，lst.insert_after(p,b,e)，lst.insert_after(p,il)</td>
<td>在迭代器 p 之后的位置插入元素。t 是一个对象，n 是数量，b 和 e 是表示范围的一对迭代器(但不能指向 lst 内)，il 是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果 b 和 e 的范围为空，则返回 p。若 p 为尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td>emplace_after(p,args)</td>
<td>使用 args 在 p 指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td>lst.erase_after(p)，lst.erase_after(b,e)</td>
<td>删除 p 指向的位置之后的元素，或删除[b,e)之间的元素。返回一个指向被删元素之后元素的迭代器或尾后迭代器。如果 p 指向 lst 的尾元素或是一个尾后迭代器，则函数行为未定义</td>
</tr>
</tbody></table>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> flst <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> prev <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">before_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 表示 flst 的首前元素</span>
<span class="token keyword">auto</span> curr <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 表示 flst 的第一个元素</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> flst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token comment">// 表示仍有元素要处理</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>curr <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>                       <span class="token comment">// 若元素为奇数</span>
        curr <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">erase_after</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除它并移动 curr</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>                    <span class="token comment">// prev 指向 curr，即移动 prev 指向了下一个元素</span>
        <span class="token operator">++</span>curr<span class="token punctuation">;</span>                         <span class="token comment">// 移动迭代器 curr，指向 curr 下一个元素</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>改变容器大小</strong></p>
<blockquote>
<p>1、下标列出了<strong>改变容器大小的操作</strong>，但<strong>不适用于</strong><code>array</code><br>2、注意：如果<code>resize</code><strong>缩小容器</strong>，则<strong>指向被删除元素</strong>的<strong>迭代器</strong>、<strong>引用</strong>、<strong>指针</strong>都会<strong>失效</strong>；对<code>vector</code>、<code>string</code>、<code>deque</code>进行<code>resize</code>可能导致<strong>迭代器</strong>、<strong>指针</strong>、<strong>引用失效</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>改变容器大小的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.resize(n)</td>
<td>调整 c 的大小为 n 个元素，如 n &lt; c.size()，则多出的元素被丢弃；若必须添加新元素，则对新元素进行值初始化</td>
</tr>
<tr>
<td>c.resize(n,t)</td>
<td>调整 c 的大小为 n 个元素，任何新添加的元素都初始化值为 t</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ilist</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 10 个 int，每个的值都是 42</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 再将 5 个值为 0 的元素添加到 ilist 的末尾</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 再将 10 个值为 -1 的元素添加到 ilist 的末尾</span>
ilist<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 再从 ilist 末尾删除 20 个元素</span></code></pre>
</li>
<li><p><strong>有关迭代器失效</strong></p>
<ul>
<li><p><strong>迭代器失效</strong></p>
<blockquote>
<p>1、向<strong>容器</strong>中<strong>添加元素</strong>和<strong>删除元素</strong>的操作可能使<strong>指向容器元素</strong>的<strong>指针</strong>、<strong>引用</strong>、<strong>迭代器失效</strong><br>2、一个<strong>失效的指针</strong>、<strong>引用</strong>、<strong>迭代器</strong>将<strong>不再表示任何元素</strong>，使用它们是一种<strong>严重的程序设计错误</strong>，可能引起与<strong>使用未初始化指针一样的问题</strong><br>3、有关<strong>迭代器失效</strong>的具体说明如下</p>
</blockquote>
</li>
<li><p><strong>向容器添加元素时</strong></p>
<blockquote>
<p>1、如果<strong>容器</strong>是<code>vector</code>或<code>string</code>，且<strong>存储空间被重新分配</strong>，则<strong>上述三者都会失效</strong>；如果<strong>存储空间未重新分配</strong>，则<strong>指向插入位置之前</strong>的<strong>三者仍然有效</strong>，但<strong>指向插入位置之后</strong>的<strong>三者将失效</strong><br>2、对于<code>deque</code>，插入到<strong>除首尾位置之外</strong>的任何位置都会<strong>导致三者失效</strong>；如果<strong>在首尾插入元素</strong>，<strong>迭代器会失效</strong>，但<strong>指针引用不会失效</strong><br>3、对于<code>list</code>和<code>forward_list</code>，指向容器的<strong>三者仍然有效</strong></p>
</blockquote>
</li>
<li><p><strong>从容器删除元素时</strong></p>
<blockquote>
<p>1、对于<code>vector</code>和<code>string</code>，指向<strong>被删元素之前</strong>元素的<strong>三者仍然有效</strong>，<strong>之后部分</strong>的<strong>三者将失效</strong><br>2、对于<code>deque</code>，如果在<strong>首尾之外</strong>的任何位置<strong>删除元素</strong>，那么<strong>指向被删除元素外</strong>的其他元素的<strong>三者也会失效</strong>；如果<strong>删除尾元素</strong>，则<strong>尾后迭代器也会失效</strong>，<strong>其他位置三者不受影响</strong>；如果<strong>删除首元素</strong>，<strong>三者也不会受影响</strong><br>3、对于<code>list</code>和<code>forward_list</code>，<strong>指向容器其他位置</strong>的<strong>三者仍然有效</strong><br>4、注意，当我们<strong>删除元素时</strong>，<strong>被删除元素</strong>的<strong>三者一定失效</strong>，<strong>尾后迭代器</strong>也<strong>一定失效</strong></p>
</blockquote>
</li>
<li><p><strong>编写改变容器的循环程序</strong></p>
<blockquote>
<p>1、<strong>添加删除</strong><code>vector</code>、<code>string</code>、<code>deque</code>元素的<strong>循环程序</strong>必须考虑<strong>上述三者可能失效</strong>的问题。程序必须保证<strong>每个循环步中</strong>都<strong>更新三者</strong><br>2、如果循环中<strong>调用的是</strong><code>insert</code>或<code>erase</code>，那么<strong>更新迭代器很容易</strong>，我们可以利用<strong>这些操作</strong>的<strong>返回值</strong>来更新，如下示例</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vi <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>iter <span class="token operator">!=</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>iter <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 复制当前元素</span>
        iter <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>                        <span class="token comment">// 向前移动迭代器，跳过当前元素以及插入到它之前的元素</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        iter <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 删除偶数元素</span>
        <span class="token comment">// 不应向前移动迭代器，iter 指向我们删除的元素之后的元素</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>不要保存</strong><code>end</code><strong>返回的迭代器</strong></p>
<blockquote>
<p>1、当我们在<code>vector</code>、<code>string</code>或在<code>deque</code><strong>首元素之外</strong>的任何位置<strong>增删元素</strong>时，原来<code>end</code>返回的<strong>迭代器总是会失效的</strong><br>2、因此，<strong>增删元素</strong>的循环程序必须<strong>反复调用</strong><code>end</code>，而<strong>不能在循环之前保存</strong><code>end</code><strong>返回的迭代器</strong>来<strong>一直当做容器末尾使用</strong><br>3、通常<strong>C++标准库</strong>的实现中<code>end()</code><strong>都很快</strong>，部分原因就是因为<strong>需要经常反复调用</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="vector-对象如何增长"><a href="#vector-对象如何增长" class="headerlink" title="vector 对象如何增长"></a><strong>vector 对象如何增长</strong></h4><ul>
<li><p><strong>操作原理描述</strong></p>
<blockquote>
<p>1、为了支持<strong>快速随机访问</strong>，<code>vector</code>将元素<strong>连续存储</strong>(每个元素紧挨着前一个元素存储)。通常情况下，我们<strong>不关心</strong>一个<strong>标准库类型如何实现</strong>，<strong>只需要关心</strong>它<strong>如何使用</strong>。然而对于<code>vector</code>和<code>string</code>，其<strong>部分实现渗透到了接口上</strong><br>2、假定容器中<strong>元素是连续存储的</strong>，且<strong>容器大小可变</strong>，考虑向<code>vector</code>或<code>string</code><strong>添加元素</strong>会发生什么：如果<strong>没有空间容纳新元素</strong>，容器<strong>不可能</strong>简单将它<strong>添加到内存中其他位置</strong>，因为<strong>元素必须连续存储</strong><br>3、假如如此，容器必须<strong>分配新的内存空间</strong>来<strong>保存已有元素和新元素</strong>，将<strong>已有元素移动到新空间</strong>，然后<strong>添加新元素</strong>，再<strong>释放旧空间</strong>。如果我们<strong>每添加一个新元素</strong>就执行一次这样的操作，性能会<strong>慢到不可接受</strong><br>4、为了<strong>避免这种代价</strong>，<strong>标准库实现者</strong>采用了可以<strong>减少容器空间重新分配次数</strong>的策略。当不得不重新<strong>获取新的空间</strong>时，<code>vector</code>和<code>string</code>通常会分配<strong>比新的空间需求更大的空间</strong>。容器预留这些空间<strong>作为备用</strong>，可用来<strong>保存更多新元素</strong>，并<strong>减少重新分配次数</strong></p>
</blockquote>
</li>
<li><p><strong>管理容量的成员函数</strong></p>
<blockquote>
<p>1、<code>vector</code>和<code>string</code>类型提供了一些<strong>成员函数</strong>，它们允许我们<strong>与实现中内存分配的部分互动</strong>，如下表<br>2、<code>shrink_to_fit</code>只适用于<code>vector</code>、<code>string</code>、<code>deque</code>。新标准中可以使用<code>shrink_to_fit</code>要求容器<strong>退回不需要的内存空间</strong>，但具体的实现<strong>可以选择忽略此请求</strong><br>3、<code>capacity</code>和<code>reserve</code>只适用于<code>vector</code>和<code>string</code>。注意<code>reserve</code>并<strong>不改变元素的数量</strong>，它<strong>仅影响预先分配多大的内存</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>容器大小管理操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.shrink_to_fit()</td>
<td>将 capacity() 减少为与 size() 相同大小</td>
</tr>
<tr>
<td>c.capacity()</td>
<td>返回不重新分配内存空间的情况下，c 还能保存多少元素</td>
</tr>
<tr>
<td>c.reserve(n)</td>
<td>分配至少能容纳 n 个元素的内存空间</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="额外的-string-操作"><a href="#额外的-string-操作" class="headerlink" title="额外的 string 操作"></a><strong>额外的 string 操作</strong></h4><ul>
<li><p><strong>构造 string 的其他方法</strong></p>
<ul>
<li><p><strong>其他构造函数</strong></p>
<blockquote>
<p>1、除了之前介绍过的<strong>构造函数</strong>，以及<strong>与其他顺序容器相同</strong>的<strong>构造函数</strong>，<code>string</code>还支持<strong>另外三个构造函数</strong>，如下表<br>2、<strong>n</strong>、<strong>len2</strong>、<strong>pos2</strong>都是<strong>无符号值</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>string 构造函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>string s(cp,n)</td>
<td>s 是 cp 指向数组中前 n 个字符的拷贝。此数组应至少包含 n 个字符</td>
</tr>
<tr>
<td>string s(s2,pos2)</td>
<td>s 是 string s2 从下标 pos2 开始的字符的拷贝。若 pos2&gt;s2.size()，则行为未定义</td>
</tr>
<tr>
<td>string s(s2,pos2,len2)</td>
<td>s 是 string s2 从下标 pos2 开始 len2 个字符的拷贝。若 pos2&gt;s2.size()，则行为未定义。不管 len2 值是多少，函数至多拷贝 s2.size() - pos2 个字符</td>
</tr>
</tbody></table>
</li>
<li><p><code>substr</code><strong>操作</strong></p>
<blockquote>
<p>1、<code>s.substr(pos,n)</code>：返回一个<code>string</code>，包含<strong>s</strong>中从<strong>pos</strong>开始的<strong>n</strong>个字符的拷贝。<strong>pos</strong>默认为<strong>0</strong>，<strong>n</strong>默认为<code>s.size() - pos</code>，即所有字符<br>2、<code>substr</code><strong>返回一个</strong><code>string</code>，它是原始<code>string</code>的<strong>一部分或全部</strong>的<strong>拷贝</strong>，可以传递给<code>substr</code>一个<strong>可选的开始位置</strong>、<strong>计数值</strong>作为参数<br>3、如果<strong>开始位置</strong>超过了<code>string</code><strong>大小</strong>，则会抛出一个<code>out_of_range</code><strong>异常</strong>；如果<strong>开始位置+计数值</strong>大于<code>string</code><strong>大小</strong>，则函数会<strong>自动调整计数值</strong>，只拷贝到<code>string</code><strong>末尾</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
string s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// hello</span>
string s3 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// world</span>
string s4 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 自动调整 11，拷贝到末尾，world</span>
string s5 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 抛出 out_of_range 异常</span></code></pre></li>
</ul>
</li>
<li><p><strong>改变 string 的其他方法</strong></p>
<ul>
<li><p><strong>特殊版本函数</strong></p>
<blockquote>
<p>1、<code>string</code><strong>类型支持</strong>顺序容器的<strong>赋值运算符</strong>、<code>assign</code>、<code>insert</code>、<code>erase</code>操作。此外它还定义了<strong>这些函数</strong>的一些<strong>特殊版本</strong><br>2、除了<strong>接受迭代器</strong>的<code>insert</code>和<code>erase</code>外，<code>string</code>还提供了<strong>接受下标的版本</strong>，如后例<br>3、<strong>标准库</strong><code>string</code>还提供了<strong>接受 C 风格字符数组</strong>的<code>insert</code>和<code>assign</code>，如后例</p>
</blockquote>
<table>
<thead>
<tr>
<th>修改 string 的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s.insert(pos,args)</td>
<td>在 pos 之前插入 args 指定的字符。pos 可以是一个下标或迭代器。接受下标的版本返回指向 s 的引用；接受迭代器的版本返回指向第一个插入字符的迭代器</td>
</tr>
<tr>
<td>s.erase(pos,len)</td>
<td>删除从 pos 开始的 len 个字符。如果 len 被省略，则删除 pos 开始直至末尾的所有字符。返回指向 s 的引用</td>
</tr>
<tr>
<td>s.assign(args)</td>
<td>将 s 中的字符替换为 args 指定的字符。返回指向 s 的引用</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 在 s 末尾插入 5 个 !</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 从 s 删除最后的 5 个字符</span>

<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token string">"Stately, plump Buck"</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>cp<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 调用 assign 替换 s 的内容为 "Stately"</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cp <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// s = "Stately, plump duck";</span></code></pre>
</li>
<li><p><code>append</code><strong>和</strong><code>replace</code><strong>函数</strong></p>
<blockquote>
<p>1、<code>string</code><strong>类</strong>定义了两个额外的<strong>成员函数</strong>：<code>append</code>和<code>replace</code>，这两个函数可以<strong>改变</strong><code>string</code><strong>内容</strong>，如下表<br>2、<code>append</code>是在<code>string</code><strong>末尾</strong>进行<strong>插入操作</strong>的一种简写；<code>replace</code>是<strong>调用</strong><code>erase</code><strong>和</strong><code>insert</code>的一种简写</p>
</blockquote>
<table>
<thead>
<tr>
<th>修改 string 的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s.append(args)</td>
<td>将 args 追加到 s。返回指向 s 的引用</td>
</tr>
<tr>
<td>s.replace(range,args)</td>
<td>删除 s 中范围 range 内的字符，替换为 args 指定的字符。range 或者是一个下标和一个长度，或者是一对指向 s 的迭代器。返回指向 s 的引用</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>string 搜索操作</strong></p>
<blockquote>
<p>1、<code>string</code><strong>类</strong>提供了一些<strong>6 种搜索函数</strong>，每种都有<strong>4 种重载函数</strong>，下表中描述了这些成员函数及其参数<br>2、每个<strong>搜索操作</strong>都返回一个<code>string::size_type</code><strong>值</strong>，表示<strong>匹配发生位置的下标</strong>。如果<strong>搜索失败</strong>，则返回一个名为<code>string::npos</code>的<code>static</code><strong>成员</strong><br>3、<strong>标准库</strong>将<code>string::npos</code><strong>定义为</strong><code>const string::size_type</code><strong>类型</strong>，并<strong>初始化为-1</strong>。由于<strong>npos</strong>是<code>unsigned</code><strong>类型</strong>，<strong>初始值-1</strong>意味着<strong>npos</strong>等于<strong>任何</strong><code>string</code><strong>最大的可能大小</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>string 搜索操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s.find(args)</td>
<td>查找 s 中 args 第一次出现的位置</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>查找 s 中 args 最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>在 s 中查找 args 中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>在 s 中查找 args 中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>在 s 中查找第一个不在 args 中的字符</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>在 s 中查找最后一个不在 args 中的字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>args 的重载形式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c,pos</td>
<td>从 s 中位置 pos 开始查找字符 c 。pos 默认为 0</td>
</tr>
<tr>
<td>s2,pos</td>
<td>从 s 中位置 pos 开始查找字符串 s2 。pos 默认为 0</td>
</tr>
<tr>
<td>cp,pos</td>
<td>从 s 中位置 pos 开始查找指针 cp 指向的 C 风格字符串。pos 默认为 0</td>
</tr>
<tr>
<td>cp,pos,n</td>
<td>从 s 中位置 pos 开始查找指针 cp 指向的数组的前 n 个字符。pos 和 n 无默认值</td>
</tr>
</tbody></table>
</li>
<li><p><code>compare</code><strong>函数</strong></p>
<blockquote>
<p>1、除了<strong>关系运算符</strong>外，<strong>标准库</strong><code>string</code>还提供了一组<code>compare</code><strong>函数</strong>，其与<strong>C 标准库</strong>的<code>strcmp</code><strong>很相似</strong>，如下表<br>2、类似<code>strcmp</code>，根据<strong>s</strong>是<strong>等于</strong>、<strong>大于</strong>、<strong>小于</strong>参数指定的字符串，<code>s.compare</code><strong>分别返回 0</strong>、<strong>正数</strong>、<strong>负数</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>compare 函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s.compare(s2)</td>
<td>比较 s 和 s2</td>
</tr>
<tr>
<td>s.compare(pos1,n1,s2)</td>
<td>将 s 中从 pos1 开始的 n1 个字符与 s2 进行比较</td>
</tr>
<tr>
<td>s.compare(pos1,n1,s2,pos2,n2)</td>
<td>将 s 中从 pos1 开始的 n1 个字符与 s2 中从 pos2 开始的 n2 个字符进行比较</td>
</tr>
<tr>
<td>s.compare(cp)</td>
<td>比较 s 与 cp 指向的 C 风格字符串</td>
</tr>
<tr>
<td>s.compare(pos1,n1,cp)</td>
<td>将 s 中从 pos1 开始的 n1 个字符与 cp 指向的 C 风格字符串进行比较</td>
</tr>
<tr>
<td>s.compare(pos1,n1,cp,pos2)</td>
<td>将 s 中从 pos1 开始的 n1 个字符与 cp 指向的地址开始的 n2 个字符进行比较</td>
</tr>
</tbody></table>
</li>
<li><p><strong>数值转换</strong></p>
<blockquote>
<p>1、<strong>字符串</strong>中常常包含<strong>表示数值的字符</strong>，有时我们需要将其<strong>转换为数值</strong>。<strong>新标准</strong>引入了<strong>多个函数</strong>，可以实现<strong>数值数据与</strong><code>string</code><strong>之间的转换</strong>，如下表<br>2、<code>string</code><strong>参数中第一个非空白符</strong>必须是<strong>正负符号或数字</strong>，它可以<strong>以 0x 或 0X 开头</strong>表示<strong>十六进制数</strong>；对那些将<strong>字符串</strong>转换成<strong>浮点值</strong>的函数，参数还可以<strong>以小数点开头</strong>，并可以<strong>包含 e 或 E</strong>表示<strong>指数部分</strong>；对那些将<strong>字符串</strong>转换为<strong>整型值</strong>的函数，根据<strong>基数不同</strong>，<code>string</code>参数还可以包含<strong>字母字符</strong>对于<strong>大于数字 9 的数</strong><br>3、如果<code>string</code><strong>不能转换</strong>为<strong>一个数值</strong>，函数会抛出<code>invalid_argument</code><strong>异常</strong>；如果<strong>转换得到的数值</strong>不能用<strong>任何类型表示</strong>，函数会抛出<code>out_of_range</code><strong>异常</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>数值转换函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>to_string(val)</td>
<td>一组重载函数，返回数值 val 的 string 表示</td>
</tr>
<tr>
<td>stoi(s,p,b)，stol(s,p,b)，stoul(s,p,b)，stoll(s,p,b)，stoull(s,p,b)</td>
<td>返回 s 的起始子串(表示整数内容)的数值，返回值类型对应函数名 sto 后的类型名缩写，如 i 为 int，ul 为 unsigned long。b 表示转换所用的基数(进制)，默认为 10。p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标，默认为 0，即不保存下标</td>
</tr>
<tr>
<td>stof(s,p)，stod(s,p)，stold(s,p)</td>
<td>返回 s 的起始子串(表示浮点数内容)的数值，返回值类型对应函数名 sto 后的类型名缩写。p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标，默认为 0，即不保存下标</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string s2 <span class="token operator">=</span> <span class="token string">"pi = 3.14"</span><span class="token punctuation">;</span>
<span class="token comment">// 转换 s 中以数字开始的第一个子串，结果 d = 3.14</span>
<span class="token comment">// 先使用 find_first_of 找到数值部分，再用 substr 截取子串，再用 stod 转换</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">"+-.0123456789"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a><strong>容器适配器</strong></h4><ul>
<li><p><strong>适配器类型</strong></p>
<blockquote>
<p>1、除了<strong>顺序容器</strong>外，<strong>标准库</strong>还定义了三个<strong>顺序容器适配器</strong>：<code>stack</code>、<code>queue</code>、<code>priority_queue</code>，此外下表列出了它们支持的操作<br>2、<strong>适配器</strong>是<strong>标准库</strong>中的一个<strong>通用概念</strong>，<strong>容器</strong>、<strong>迭代器</strong>、<strong>函数</strong>都有<strong>适配器</strong>。本质上，一个<strong>适配器</strong>是一种<strong>机制</strong>，能使<strong>某种事物的行为</strong>看起来像<strong>另外一种事物</strong>一样<br>3、一个<strong>容器适配器</strong>接受一种<strong>已有的容器类型</strong>，使其<strong>行为看起来像</strong>一种<strong>不同的类型</strong>。例如<code>stack</code>接受一个<strong>顺序容器</strong>，使其操作看起来像一个<code>stack</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>适配器操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>size_type</td>
<td>一种类型，足以保存当前类型的最大对象的大小</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>container_type</td>
<td>实现适配器的底层容器类型</td>
</tr>
<tr>
<td>A a;</td>
<td>创建一个名为 a 的空适配器</td>
</tr>
<tr>
<td>A a(c)</td>
<td>创建一个名为 a 的适配器，带有容器 c 的一个拷贝</td>
</tr>
<tr>
<td>关系运算符</td>
<td>每个适配器都支持所有关系运算符</td>
</tr>
<tr>
<td>a.empty()</td>
<td>若 a 为空，则返回 true，否则返回 false</td>
</tr>
<tr>
<td>a.size()</td>
<td>返回 a 中的元素数目</td>
</tr>
<tr>
<td>a.swap(b)，swap(a,b)</td>
<td>交换 a 和 b 的内容，a 和 b</td>
</tr>
</tbody></table>
</li>
<li><p><strong>定义适配器</strong></p>
<blockquote>
<p>1、每个<strong>适配器</strong>都定义了<strong>两个构造函数</strong>：<strong>默认构造函数</strong>创建一个<strong>空对象</strong>，<strong>接受一个容器</strong>的构造函数<strong>拷贝该容器</strong>来<strong>初始化适配器</strong><br>2、默认情况下，<code>stack</code>和<code>queue</code>是<strong>基于</strong><code>deque</code><strong>实现的</strong>，<code>priority_queue</code>是<strong>基于</strong><code>vector</code><strong>实现的</strong>。我们可以在<strong>创建适配器时</strong>将一个<strong>命名的顺序容器</strong>作为<strong>第二个类型参数</strong>，来<strong>重载默认容器类型</strong><br>3、对于一个<strong>给定的适配器</strong>，可以使用<strong>哪些容器</strong>是有限制的。<strong>所有适配器</strong>都要求容器具有<strong>增删元素</strong>和<strong>访问尾元素</strong>的能力，因此<strong>不能构造在</strong><code>array</code>和<code>forward_list</code>上；此外<code>queue</code><strong>不能构造在</strong><code>vector</code>上，<code>priority_queue</code><strong>不能构造在</strong><code>list</code>上</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">stk</span><span class="token punctuation">(</span>deq<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 从 deq 拷贝元素到 stk</span>

stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> str_stk<span class="token punctuation">;</span>          <span class="token comment">// 在 vector 上实现的空栈</span>
stack<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">str_stk2</span><span class="token punctuation">(</span>svec<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 在 vector 上实现，初始化时保存 svec 的拷贝</span></code></pre>
</li>
<li><p><strong>栈适配器</strong></p>
<blockquote>
<p>1、<code>stack</code><strong>类型</strong>定义在<code>stack</code><strong>头文件</strong>中，下表列出了<strong>栈特有的操作</strong>，并举出了一个示例<br>2、<strong>栈</strong>默认基于<code>deque</code>实现，也可以在<code>list</code>或<code>vector</code>上实现<br>3、每个<strong>容器适配器</strong>都基于<strong>底层容器类型</strong>的操作定义了自己的<strong>特殊操作</strong>，但我们<strong>只能使用适配器操作</strong>，而<strong>不能使用底层容器类型的操作</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>栈特有的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s.pop()</td>
<td>删除栈顶元素，但不返回元素值</td>
</tr>
<tr>
<td>s.push(item)，s.emplace(args)</td>
<td>创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来，或者由 args 构造</td>
</tr>
<tr>
<td>s.top()</td>
<td>返回栈顶元素，但不将元素弹出栈</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> intStack<span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>size_t ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> ix<span class="token operator">++</span><span class="token punctuation">)</span>
  intStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ix<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>intStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> intStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    intStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>队列适配器</strong></p>
<blockquote>
<p>1、<code>queue</code>和<code>priority_queue</code><strong>类型</strong>定义在<code>queue</code><strong>头文件</strong>中，下标列出了<strong>队列特有的操作</strong><br>2、<code>queue</code>默认基于<code>deque</code>实现，<code>priority_queue</code>默认基于<code>vector</code>实现。<code>queue</code>也可以用<code>list</code>或<code>vector</code>实现，<code>priority_queue</code>也可以用<code>deque</code>实现<br>3、<code>priority_queue</code>允许我们<strong>为队列中的元素建立优先级</strong>，<strong>新加入的元素</strong>会排在<strong>所有优先级比他低的已有元素</strong>之前。饭店按照客人预定时间而不是到店时间来安排座位就是一个例子</p>
</blockquote>
<table>
<thead>
<tr>
<th>队列特有的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>q.pop()</td>
<td>返回 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回元素值</td>
</tr>
<tr>
<td>q.front()，q.back()</td>
<td>返回首元素或尾元素，但不删除此元素，只适用于 queue</td>
</tr>
<tr>
<td>q.top()</td>
<td>返回最高优先级的元素，但不删除此元素，只适用于 priority_queue</td>
</tr>
<tr>
<td>q.push(item)，q.emplace(args)</td>
<td>在 queue 末尾或 priority_queue 中恰当位置创建一个元素，其值为 item，或由 args 构造</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a><strong>泛型算法</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：概述；算法如何工作；算法不执行容器操作；初识泛型算法；只读算法；<code>accumulate</code>；算法和元素类型；操作两个序列的<code>equal</code>；写容器元素的算法；<code>fill</code>；算法不检查写操作；介绍<code>back_inserter</code>；<code>copy</code>；<code>replace</code>；重排容器元素的算法；<code>sort</code>和<code>unique</code>；定制操作；谓词与向算法传参；<code>lambda</code>表达式；向<code>lambda</code>传参；使用捕获列表；<code>lambda</code>捕获和返回；<code>lambda</code>捕获列表；可变<code>lambda</code>；指定<code>lambda</code>返回类型；参数绑定；<code>bind</code>；使用<code>placeholders</code>名字；<code>bind</code>重排参数顺序；绑定引用参数；再探迭代器；标准库迭代器；插入迭代器；<code>iostream</code>迭代器；<code>istream_iterator</code>操作；使用算法操作流迭代器；<code>ostream_iterator</code>操作；反向迭代器；泛型算法结构；五类迭代器；算法参数规范；算法命名规范；特定容器算法；链表类型的成员算法；<code>splice</code>成员</p>
</blockquote>
</div>

<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>大多数算法</strong>都定义在<strong>头文件</strong><code>algorithm</code>中。<strong>标准库</strong>还在<strong>头文件</strong><code>numeric</code>中定义了一组<strong>数值泛型算法</strong><br>2、一般情况下，这些算法并<strong>不直接操作容器</strong>，而是遍历由<strong>两个迭代器</strong>指定的<strong>一个元素范围</strong>来进行操作。通常情况下，算法<strong>遍历范围</strong>，对其中<strong>每个元素</strong>进行<strong>操作</strong><br>3、例如，假设我们有一个<strong>int</strong>的<code>vector</code>，希望知道其中<strong>是否包含某个特定值</strong>，可以使用<code>find</code>算法，如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>     <span class="token comment">// 要查找的值</span>
<span class="token comment">// 如果在 vec 中找到想要的元素，则返回结果指向它，否则返回结果为 vec.cend()</span>
<span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 报告结果</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The value"</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"is not present"</span> <span class="token operator">:</span> <span class="token string">"is present"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>算法如何工作</strong></p>
<blockquote>
<p>1、为了弄清这些<strong>算法</strong>如何用于<strong>不同类型的容器</strong>，让我们更近距离观察一下<code>find</code><strong>如何工作</strong>。概念上，<code>find</code>应执行<strong>如下步骤</strong><br>2、访问序列中的<strong>首元素</strong>；比较此元素与我们<strong>要查找的值</strong>匹配；如果此元素与我们<strong>要查找的值</strong>匹配，就<strong>返回标识此元素的值</strong>；否则<code>find</code>前进到<strong>下一元素</strong>，<strong>重复步骤 2 和 3</strong>；如果<strong>到达序列尾</strong>，<code>find</code><strong>应停止</strong>；如果<strong>到达序列末尾</strong>，返回一个指出<strong>元素未找到</strong>的值<br>3、<strong>迭代器</strong>令<strong>算法</strong>不依赖于<strong>容器</strong>，但<strong>算法</strong>依赖于<strong>元素类型的操作</strong></p>
</blockquote>
</li>
<li><p><strong>算法不执行容器操作</strong></p>
<blockquote>
<p>1、<strong>泛型算法</strong>本身<strong>不会执行容器操作</strong>，它们只会运行于<strong>迭代器</strong>之上，<strong>执行迭代器的操作</strong>，该特性说明<strong>算法永远不会改变底层容器的大小</strong><br>2、算法<strong>可能改变</strong>容器中<strong>保存的元素的值</strong>，也可能在容器内<strong>移动元素</strong>，但<strong>永远不会</strong>直接<strong>增删元素</strong><br>3、<strong>标准库</strong>定义了一类<strong>特殊的迭代器</strong>，称为<strong>插入器</strong>。与<strong>普通迭代器只能遍历</strong>所绑定的容器相比，<strong>插入器</strong>能做更多的事情，后续介绍</p>
</blockquote>
</li>
</ul>
<h4 id="初识泛型算法"><a href="#初识泛型算法" class="headerlink" title="初识泛型算法"></a><strong>初识泛型算法</strong></h4><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、<strong>标准库</strong>提供了<strong>超过 100 个算法</strong>，幸运的是，与容器类似，这些<strong>算法有一致的结构</strong>，<strong>附录</strong>中<strong>按操作方式</strong>列出了<strong>所有算法</strong><br>2、除了<strong>少数例外</strong>，<strong>标准库算法</strong>都对一个<strong>范围内的元素</strong>进行操作。我们将此<strong>元素范围</strong>称为<strong>输入范围</strong>，接受<strong>输入范围</strong>的算法总是使用<strong>前两个参数</strong>来表示此范围(范围<code>[a, b)</code>)<br>3、虽然大多算法<strong>遍历输入范围的方式相似</strong>，但它们<strong>使用范围内的元素的方式不同</strong>。<strong>理解算法</strong>最基本的方法就是了解它们<strong>是否读取元素</strong>、<strong>改变元素</strong>或<strong>重排元素顺序</strong></p>
</blockquote>
</li>
<li><p><strong>只读算法</strong></p>
<ul>
<li><p><code>accumulate</code></p>
<blockquote>
<p>1、一些<strong>算法</strong>只会<strong>读取输入范围内的元素</strong>，而<strong>不改变元素</strong>，称为<strong>只读算法</strong>，<code>find</code>就是这样一种<strong>算法</strong><br>2、另一个<strong>只读算法</strong>是<code>accumulate</code>，它定义在<strong>头文件</strong><code>numeric</code>中。该<strong>函数接受三个参数</strong>，前两个<strong>表示范围</strong>，第三个参数是<strong>和的初值</strong><br>3、假定<strong>vec</strong>是一个<strong>整数序列</strong>，则有下例<strong>对 vec 中元素求和</strong><br>4、<code>accumulate</code>的<strong>第三个参数的类型</strong>决定了函数中<strong>使用哪个加法运算符</strong>以及<strong>返回值的类型</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 对 vec 中元素求和，和初始值为 0</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>算法和元素类型</strong></p>
<blockquote>
<p>1、<code>accumulate</code>将<strong>第三个参数</strong>作为<strong>求和起点</strong>，这蕴含着一个<strong>编程假定</strong>：将<strong>元素类型</strong>加到<strong>和的类型</strong>上的<strong>操作</strong>必须是可行的<br>2、即，序列中<strong>元素的类型</strong>必须与<strong>第三个参数匹配</strong>，或者<strong>能转换为第三个参数的类型</strong><br>3、下例中，由于<code>string</code>定义了<code>+</code><strong>运算符</strong>，所以我们可以<strong>通过调用</strong><code>accumulate</code>将<code>vector</code>中所有<code>string</code>元素<strong>连接起来</strong>。但注意，必须<strong>显式创建一个</strong><code>string</code>，<strong>不可以</strong>将<strong>空串</strong>当成<strong>第三个参数</strong>传给函数，原因在于空串表示<strong>保存和的类型</strong>将是<code>const char*</code>，而此类型<strong>没有定义</strong><code>+</code><strong>运算符</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 错误：const char* 没有定义 + 运算符</span>
string sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>操作两个序列的</strong><code>equal</code></p>
<blockquote>
<p>1、另一个<strong>只读算法</strong>是<code>equal</code>，用于确定<strong>两个序列</strong>是否保存<strong>相同的值</strong>。它将<strong>第一个序列</strong>中的<strong>每个元素</strong>与<strong>第二个序列</strong>中的<strong>对应元素</strong>进行比较，如果<strong>对应元素都相等</strong>，则返回<strong>true</strong>，否则返回<strong>false</strong><br>2、此算法<strong>接受三个迭代器</strong>，前两个表示<strong>第一个序列中的元素范围</strong>，第三个表示<strong>第二个序列的首元素</strong>。但要注意，<code>equal</code>假定<strong>第二个序列</strong>至少<strong>与第一个序列一样长</strong>，且默认<strong>只接受一个单一迭代器</strong>来表示<strong>第二个序列</strong>的<strong>其他算法</strong>，也<strong>都有此假定</strong><br>3、由于<code>equal</code><strong>利用迭代器完成操作</strong>，因此可以调用<code>equal</code>比较两个<strong>不同类型容器中的元素</strong>，而且<strong>元素类型也不必一样</strong>，只要能用<code>==</code>来<strong>比较两个元素类型</strong>即可<br>4、如下例，<code>roster1</code>可以是<code>vector&lt;string&gt;</code>，而<code>roster2</code>可以是<code>list&lt;const char*&gt;</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// roster2 中元素数目应至少与 roster1 中一样多</span>
<span class="token function">equal</span><span class="token punctuation">(</span>roster1<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> roster1<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> roster2<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>写容器元素的算法</strong></p>
<ul>
<li><p><code>fill</code></p>
<blockquote>
<p>1、一些<strong>算法</strong>将<strong>新值</strong>赋予<strong>序列中的元素</strong>。当我们<strong>使用这类算法时</strong>，必须注意<strong>确保序列原大小</strong>大于等于我们要<strong>写入的元素数目</strong>，这是因为<strong>算法不会执行容器操作</strong>，因此它们自己<strong>不能改变容器大小</strong><br>2、一些算法会<strong>自己向输入范围写入元素</strong>，这些算法本质上<strong>并不危险</strong>，它们<strong>最多写入与给定序列一样多的元素</strong><br>3、例如<strong>算法</strong><code>fill</code>接受<strong>一对迭代器</strong>表示<strong>一个范围</strong>，还接受<strong>一个值</strong>作为<strong>第三个参数</strong>，<code>fill</code>将给定的<strong>这个值</strong>赋予序列中的<strong>每个元素</strong>。由于<code>fill</code>向给定<strong>输入序列</strong>中<strong>写入数据</strong>，所以只要传递一个<strong>有效的输入序列</strong>，<strong>写入操作</strong>就是<strong>安全</strong>的</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">fill</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 将每个元素重置为 0</span>
<span class="token function">fill</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将容器的一个子序列设置为 10</span></code></pre>
</li>
<li><p><strong>算法不检查写操作</strong></p>
<blockquote>
<p>1、一些<strong>算法</strong>接受一个<strong>迭代器</strong>来指出一个<strong>单独的目的位置</strong>，这些算法将<strong>新值</strong>赋予一个<strong>序列中的元素</strong>，该<strong>序列</strong>从<strong>目的位置迭代器指向的元素</strong>开始<br>2、例如，函数<code>fill_n</code>接受一个<strong>单迭代器</strong>、一个<strong>计数值</strong>、一个<strong>值</strong>。它将<strong>给定值</strong>赋予迭代器<strong>指向元素开始</strong>的<strong>指定个元素</strong>。我们可以用<code>fill_n</code>将一个新值赋予<code>vector</code>中的元素，如下例<br>3、<strong>函数</strong><code>fill_n</code>会<strong>假定写入指定个元素是安全的</strong>，即<strong>假定从指定元素起有指定个元素</strong>，如果<strong>越界</strong>，会出现严重错误，<strong>行为未定义</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>                      <span class="token comment">// 空 vector</span>
<span class="token function">fill_n</span><span class="token punctuation">(</span>dest<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将所有元素重置为 0</span>
<span class="token function">fill_n</span><span class="token punctuation">(</span>dest<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 错误：vec 为空，没有 10 个元素，行为未定义</span></code></pre>
</li>
<li><p><strong>介绍</strong><code>back_inserter</code></p>
<blockquote>
<p>1、一种<strong>保证算法</strong>有<strong>足够元素空间</strong>来容纳<strong>输出数据</strong>的方法是使用<strong>插入迭代器</strong>，这是一种<strong>向容器中添加元素</strong>的<strong>迭代器</strong><br>2、通常情况，我们通过一个<strong>普通迭代器向容器元素赋值时</strong>，<strong>值</strong>被赋予<strong>迭代器指向的元素</strong>；而通过<strong>插入迭代器赋值时</strong>，一个与<code>=</code><strong>右侧值</strong>相等的<strong>元素</strong>被<strong>添加到容器</strong>中<br>3、后续还会再详细介绍<strong>插入迭代器</strong>，现在我们简要介绍<strong>插入迭代器</strong>中的<code>back_inserter</code>，它定义在<code>iterator</code><strong>头文件</strong>中<br>4、<code>back_inserter</code>接受一个<strong>指向容器的引用</strong>，返回一个<strong>与该容器绑定</strong>的<strong>插入迭代器</strong>。我们常常使用<code>back_inserter</code><strong>创建迭代器</strong>作为算法的<strong>目的位置</strong>来使用，如下例</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>                    <span class="token comment">// 空 vector</span>
<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 创建插入迭代器，通过 it 赋值会将元素添加到 vec 中</span>
<span class="token operator">*</span>it <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>                           <span class="token comment">// vec 中现在有一个元素，值为 42</span>
<span class="token function">fill_n</span><span class="token punctuation">(</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 添加 10 个 0 到 vec 中</span></code></pre>
</li>
<li><p><code>copy</code></p>
<blockquote>
<p>1、<code>copy</code><strong>算法</strong>是另一个向<strong>目的位置迭代器</strong>指定的<strong>输出序列中的元素</strong>写入数据的算法。它接受<strong>三个迭代器</strong>，<strong>前两个</strong>表示一个<strong>输入范围</strong>，<strong>第三个</strong>表示<strong>目的序列的起始位置</strong><br>2、此算法将<strong>输入范围</strong>中的<strong>元素</strong>拷贝到<strong>目的序列</strong>中，注意传递的<strong>目的序列</strong>至少要包含<strong>与输入序列一样多的元素</strong>。我们可以用<code>copy</code>实现<strong>内置数组的拷贝</strong>，如下例<br>3、<code>copy</code>返回的是其<strong>目的位置迭代器</strong>(递增后)的<strong>值</strong>，即<strong>ret</strong>指向拷贝到<strong>a2</strong>的<strong>尾后位置</strong><br>4、<strong>多个算法</strong>都提供所谓的<strong>拷贝版本</strong>，这些算法<strong>计算新元素的值</strong>，但不会将它们放在<strong>输入序列的末尾</strong>，而是<strong>创建一个新序列保存这些结果</strong><br>5、例如<code>replace</code><strong>读取一个序列</strong>(前两个参数迭代器表示)，将其中<strong>等于给定值</strong>(第三个参数)的值<strong>更改为另一个值</strong>(第四个参数)。如果我们希望<strong>保留原序列不变</strong>，可以使用<code>replace_copy</code>，它<strong>接受额外的第三个参数</strong>表示调整后<strong>序列的保存位置</strong>，如下例</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>a1<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// a2 与 a1 大小一样</span>
<span class="token comment">// ret 指向拷贝到 a2 的尾元素之后的位置</span>
<span class="token keyword">auto</span> ret <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">,</span> a2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 把 a1 的内容拷贝给 a2</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 将所有值为 0 的元素改为 42</span>
<span class="token function">replace</span><span class="token punctuation">(</span>ilst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ilst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 back_inserter 按需要增长目标序列，序列保存至 back_inserter(ivec)</span>
<span class="token function">replace_copy</span><span class="token punctuation">(</span>ilst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ilst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>ivec<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span></code></pre></li>
</ul>
</li>
<li><p><strong>重排容器元素的算法</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、某些算法会<strong>重排容器</strong>中<strong>元素的顺序</strong>，比如<code>sort</code>。调用<code>sort</code>会<strong>重排输入序列中的元素</strong>，<strong>使之有序</strong>，它是利用<strong>元素类型</strong>的<code>&lt;</code><strong>运算符</strong>来实现排序的<br>2、现在假定我们要分析一段文章所用的词汇。假定已有一个<code>vector</code><strong>保存了文本</strong>，我们希望<strong>简化</strong><code>vector</code>使<strong>每个单词只出现一次</strong></p>
</blockquote>
</li>
<li><p><code>sort</code><strong>和</strong><code>unique</code></p>
<blockquote>
<p>1、为了<strong>消除重复单词</strong>，首先使用<code>sort</code>将<code>vector</code><strong>排序</strong>，使<strong>重复单词相邻出现</strong><br>2、排序完成后，可以使用<strong>标准库算法</strong><code>unique</code>来<strong>重排</strong><code>vector</code>，使<strong>不重复的元素</strong>出现在<code>vector</code><strong>的开始部分</strong><br>3、由于算法<strong>不能执行容器的操作</strong>，我们将使用<code>vector</code>的<code>erase</code>来真正完成<strong>删除操作</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">elimDups</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;</span>words<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 按字典序排序 words，以便查找重复单词</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// unique 重排输入范围，使每个单词只出现一次，重复的单词置后</span>
    <span class="token comment">// 返回指向不重复区域之后一个位置的迭代器</span>
    <span class="token keyword">auto</span> end_unique <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用向量操作 erase 删除重复单词</span>
    words<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>end_unique<span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a><strong>定制操作</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、很多<strong>算法</strong>都会比较<strong>输入序列</strong>中的<strong>元素</strong>，默认情况下，这类算法使用<strong>元素类型</strong>的<code>&lt;</code>或<code>==</code><strong>运算符</strong>来完成比较<br>2、<strong>标准库</strong>还为这些算法定义了<strong>额外的版本</strong>，允许我们提供<strong>自定义的操作</strong>来代替<strong>默认运算符</strong><br>3、例如<code>sort</code>默认使用<strong>元素类型</strong>的<code>&lt;</code>来比较，但可能我们<strong>希望的顺序</strong>与<code>&lt;</code><strong>定义的顺序</strong>不同，或者序列保存的是<strong>未定义</strong><code>&lt;</code><strong>运算符</strong>的<strong>元素类型</strong>，这些情况都需要<strong>重载</strong><code>sort</code>的<strong>默认行为</strong></p>
</blockquote>
</li>
<li><p><strong>谓词与向算法传参</strong></p>
<blockquote>
<p>1、<strong>谓词</strong>是一个<strong>可调用的表达式</strong>，其返回结果是一个<strong>能用作条件的值</strong>，<strong>标准库</strong>所使用的<strong>谓词</strong>分两类：<strong>一元谓词</strong>和<strong>二元谓词</strong><br>2、<strong>接受谓词参数</strong>的算法对<strong>输入序列中的元素</strong>调用<strong>谓词</strong>，因此，<strong>元素类型</strong>必须能转换为<strong>谓词的参数类型</strong><br>3、例如，接受一个<strong>二元谓词参数</strong>的<code>sort</code><strong>版本</strong>，用这个<strong>谓词</strong>来<strong>代替</strong><code>&lt;</code><strong>比较元素</strong>。我们可以按长度排序单词，如下例<br>4、在我们将<strong>words</strong>按长短排序后，还希望<strong>相同长度的元素</strong>按<strong>字典序排序</strong>，可以使用<code>stable_sort</code>，如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>string<span class="token operator">></span> words<span class="token punctuation">&#123;</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"yy"</span><span class="token punctuation">,</span> <span class="token string">"bbbb"</span><span class="token punctuation">,</span> <span class="token string">"zzz"</span><span class="token punctuation">,</span> <span class="token string">"aaaaa"</span><span class="token punctuation">,</span> <span class="token string">"za"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 比较函数</span>
<span class="token keyword">bool</span> <span class="token function">isShorter</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 按长度由短至长排序</span>
<span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> words<span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>

<span class="token comment">// 按长度排序，且相同长度按字典序排序</span>
<span class="token function">stable_sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> words<span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>lambda 表达式</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、根据<strong>算法</strong>接受<strong>一元谓词</strong>还是<strong>二元谓词</strong>，我们<strong>传递给算法的谓词</strong>也必须严格<strong>接受一个或两个参数</strong>，但有时我们希望进行的<strong>操作需要更多参数</strong>，会<strong>超出算法对谓词的限制</strong><br>2、例如我们要计算<strong>大于等于一个给定长度的单词有多少</strong>，且<strong>只打印这些单词</strong>，我们能设计出一个<strong>大体框架</strong>，如下<br>3、我们可以使用<strong>标准库算法</strong><code>find_if</code>来查找。其接受<strong>一对迭代器</strong>，表示<strong>范围</strong>，<strong>第三个参数</strong>接受一个<strong>一元谓词</strong>。返回<strong>第一个使谓词返回非 0 值</strong>的<strong>元素</strong>，如果不存在则返回<strong>尾后迭代器</strong><br>4、但是，<code>find_if</code>只接受<strong>一元谓词</strong>，我们会使用<strong>一个参数表示当前元素</strong>，<strong>没有任何办法</strong>能传递<strong>第二个参数表示长度</strong>。为此，需要使用另外一些<strong>语言特性</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">biggie</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;</span>words<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token double-colon punctuation">::</span>size_type sz<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 之前自定义的函数，将 words 按字典序排序，删除重复单词</span>
    <span class="token function">elimDups</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 先前定义的 isShorter</span>
    <span class="token function">stable_sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> isShorter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取一个迭代器，指向第一个满足 size() >= sz 的元素，即此后的都符合条件</span>
    <span class="token comment">// 计算数目</span>
    <span class="token comment">// 输出</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><code>lambda</code><strong>介绍</strong></p>
<blockquote>
<p>1、我们可以<strong>向一个算法</strong>传递<strong>任何类别</strong>的<strong>可调用对象</strong>。对于一个<strong>对象</strong>或<strong>表达式</strong>，如果可以对其使用<strong>调用运算法</strong><code>()</code>，则称它为<strong>可调用的</strong><br>2、到目前为止，我们使用过的<strong>两种可调用对象</strong>：<strong>函数</strong>和<strong>函数指针</strong>，此外还有两种<strong>可调用对象</strong>：<strong>重载了函数调用运算符的类</strong>(后续介绍)和<code>lambda</code><strong>表达式</strong><br>3、一个<code>lambda</code><strong>表达式</strong>表示一个<strong>可调用的代码单元</strong>，我们可以将其理解为一个<strong>未命名的内联函数</strong>。<strong>与任何函数类似</strong>，一个<code>lambda</code>具有一个<strong>返回类型</strong>、<strong>形参列表</strong>和<strong>函数体</strong>；但<strong>与函数不同</strong>的是，<code>lambda</code><strong>可能定义在函数内部</strong><br>4、一个<code>lambda</code>形式如：<code>[捕获列表](参数列表) -&gt; 返回类型&#123;函数体&#125;</code>。其中，<strong>捕获列表</strong>是一个<code>lambda</code><strong>所在函数中定义的局部变量</strong>的列表(通常为空)，<strong>其余三者与函数一样</strong>，但是<code>lambda</code>必须使用<strong>尾置返回</strong>来<strong>指定返回类型</strong><br>5、我们可以<strong>忽略参数列表</strong>和<strong>返回类型</strong>，但必须永远包含<strong>捕获列表</strong>和<strong>函数体</strong>，如<code>auto f = []&#123; return 42; &#125;;</code>。当<strong>忽略返回类型</strong>时，如果<strong>函数体</strong>只有<code>return</code>语句，则<strong>自动推断返回类型</strong>，否则返回<code>void</code></p>
</blockquote>
</li>
<li><p><strong>向</strong><code>lambda</code><strong>传参</strong></p>
<blockquote>
<p>1、可以像<strong>给普通函数传参</strong>那样<strong>给</strong><code>lambda</code><strong>传参</strong>，但注意<strong>不同的是</strong>，<code>lambda</code>不能有<strong>默认形参</strong><br>2、如下例，我们可以编写一个<strong>与</strong><code>isShorter()</code><strong>函数功能相同的</strong><code>lambda</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>string<span class="token operator">></span> words<span class="token punctuation">&#123;</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"yy"</span><span class="token punctuation">,</span> <span class="token string">"bbbb"</span><span class="token punctuation">,</span> <span class="token string">"zzz"</span><span class="token punctuation">,</span> <span class="token string">"aaaaa"</span><span class="token punctuation">,</span> <span class="token string">"za"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> lam <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 此处 lam 也可以直接写上述 lambda 表达式</span>
<span class="token function">stable_sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lam<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> words<span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>使用捕获列表</strong></p>
<blockquote>
<p>1、虽然一个<code>lambda</code>可以<strong>出现在一个函数中</strong>，<strong>使用其局部变量</strong>，但<strong>只能使用</strong>那些<strong>明确指明的变量</strong><br>2、一个<code>lambda</code>通过将<strong>局部变量</strong>包含在其<strong>捕获列表</strong>中来<strong>指出将使用这些变量</strong>，<strong>捕获列表</strong>指引<code>lambda</code>在其内部<strong>访问局部变量</strong>所需的信息<br>3、如下例，该<code>lambda</code>会<strong>捕获 sz</strong>，并只有单一的<code>string</code><strong>参数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> sz<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>完整的</strong><code>biggies()</code></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">biggies</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;</span>words<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token double-colon punctuation">::</span>size_type sz<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 自定义的 elimDups，按字典序排序并删除重复单词</span>
    <span class="token function">elimDups</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 按长度排序</span>
    <span class="token keyword">auto</span> sort_length <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">stable_sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sort_length<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取一个迭代器，指向第一个满足 size() >= sz 的元素</span>
    <span class="token keyword">auto</span> find_first <span class="token operator">=</span> <span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> sz<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> wc <span class="token operator">=</span> <span class="token function">find_if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> find_first<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 计算数目</span>
    <span class="token keyword">auto</span> count <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> wc<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 打印单词</span>
    <span class="token keyword">auto</span> print <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">for_each</span><span class="token punctuation">(</span>wc<span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> print<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 标准库算法，接受一个可调用对象，并对输入序列中每个元素调用此对象</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>lambda 捕获和返回</strong></p>
<ul>
<li><p><code>lambda</code><strong>对象</strong></p>
<blockquote>
<p>1、当<strong>定义一个</strong><code>lambda</code>时，<strong>编译器</strong>生成一个<strong>与</strong><code>lambda</code><strong>对应的</strong>新的<strong>类类型</strong>，后续会介绍这种类如何生成<br>2、目前，可以认为当<strong>向一个函数传递</strong><code>lambda</code>时，同时定义了一个<strong>新类型</strong>和<strong>该类型的一个对象</strong>，<strong>传递的参数</strong>就是编译器生成的<strong>类类型的未命名对象</strong><br>3、类似的，当使用<code>auto</code>定义一个<strong>用</strong><code>lambda</code><strong>初始化的变量</strong>时，定义了一个<strong>从</strong><code>lambda</code><strong>生成的类型的对象</strong></p>
</blockquote>
</li>
<li><p><code>lambda</code><strong>捕获列表</strong></p>
<table>
<thead>
<tr>
<th>捕获列表</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[ ]</td>
<td>空捕获列表，lambda 不能使用所在函数中的变量</td>
</tr>
<tr>
<td>[names]</td>
<td>names 是一个逗号分隔的名字列表，这些名字都是 lambda 所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝，名字前如果使用了&amp;，则采用引用捕获方式</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>隐式捕获列表，采用引用捕获方式。lambda 中所使用的来自所在函数的实体都采用引用方式使用</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>隐式捕获列表，采用值捕获方式。lambda 将拷贝所使用的来自所在函数的实体的值</td>
</tr>
<tr>
<td>[&amp;, identifier_list]</td>
<td>identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list 名字前不能使用&amp;</td>
</tr>
<tr>
<td>[&#x3D;, identifier_list]</td>
<td>identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。这些变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。identifier_list 名字不能包括 this，而名字前必须使用&amp;</td>
</tr>
</tbody></table>
</li>
<li><p><strong>可变</strong><code>lambda</code></p>
<blockquote>
<p>1、默认情况下，对于一个<strong>值被拷贝的变量</strong>，<code>lambda</code><strong>不会改变其值</strong><br>2、如果我们希望能<strong>改变一个被捕获的变量的值</strong>，就必须在<strong>参数列表首</strong>加上<strong>关键字</strong><code>mutable</code>。因此，<strong>可变</strong><code>lambda</code>可以<strong>省略参数列表</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    size_t v1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token comment">// f 可以改变它所捕获的变量的值</span>
    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>v1<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">++</span>v1<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    v1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> j <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// j 为 43</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>指定</strong><code>lambda</code><strong>返回类型</strong></p>
<blockquote>
<p>1、默认情况下，如果一个<code>lambda</code>包含<code>return</code><strong>之外的任何语句</strong>，则<strong>编译器</strong>将假定其<strong>返回</strong><code>void</code><br>2、如下例，我们可以用<strong>标准库算法</strong><code>transform</code>和一个<code>lambda</code><strong>表达式</strong>来实现<strong>转换数字为其绝对值</strong>，<code>transform</code><strong>第三个参数</strong>表示<strong>目的位置</strong><br>3、使用<strong>三目运算符</strong>的版本由于是<strong>只有一条</strong><code>return</code>，被解析为<strong>返回</strong><code>int</code>；而使用<code>if</code>的版本则被解析为<code>void</code>因此<strong>编译错误</strong>，必须<strong>显式指定返回类型</strong><br>4、当我们需要为一个<code>lambda</code><strong>定义返回类型</strong>时，必须使用<strong>尾置返回类型</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 三目运算符版本，正确</span>
<span class="token function">transform</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span>i <span class="token operator">:</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// if 版本，错误</span>
<span class="token function">transform</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span>i<span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// if 版本，正确</span>
<span class="token function">transform</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span>i<span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>参数绑定</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、对于那种只在<strong>一两个地方</strong>使用的<strong>简单操作</strong>，<code>lambda</code><strong>表达式</strong>是最有用的。如果我们需要在很多地方使用<strong>相同的操作</strong>，通常应该<strong>定义一个函数</strong>，而不是<strong>多次编写相同的</strong><code>lambda</code>。类似的，如果一个操作需要<strong>很多语句才能完成</strong>，通常使用<strong>函数</strong>更好<br>2、如果<code>lambda</code><strong>捕获列表为空</strong>，通常可以<strong>用函数来代替</strong>，既可以用<code>lambda</code>也可以用<strong>函数</strong>来实现<br>3、但是对于<strong>捕获局部变量</strong>的<code>lambda</code>，<strong>用函数代替</strong>就<strong>没那么容易</strong>了。例如如果<strong>调用的一个函数</strong>接受一个<strong>一元谓词</strong>，<code>lambda</code>可以<strong>通过捕获列表从形参获取额外信息</strong>，而<strong>函数</strong>必须解决如何作为<strong>一元谓词</strong>的问题</p>
</blockquote>
</li>
<li><p><code>bind</code></p>
<blockquote>
<p>1、为了解决<strong>向作为一元谓词的函数传递多个参数</strong>的问题，方法是使用一个名为<code>bind</code>的<strong>标准库函数</strong>，它定义在<strong>头文件</strong><code>functional</code>中<br>2、可以将<code>bind</code>看作一个<strong>通用的函数适配器</strong>，它接受一个<strong>可调用对象</strong>，生成一个<strong>新的可调用对象</strong>来<strong>适应原对象的形参列表</strong><br>3、调用<code>bind</code>的一般形式如：<code>auto newCallable = bind(callable, arg_list)</code>。其中，<code>newCallable</code>本身是一个<strong>可调用对象</strong>，<code>arg_list</code>是<strong>形参列表</strong>。当<strong>调用</strong><code>newCallable</code>时，会<strong>调用</strong><code>callable</code>，并<strong>使用</strong><code>arg_list</code><strong>作为</strong><code>callable</code><strong>的形参</strong><br>4、<code>arg_list</code>中可能出现<strong>形如</strong><code>_n</code><strong>的名字</strong>，其中<strong>n</strong>是一个<strong>整数</strong>，这些参数是<strong>占位符</strong>，它们占据了<strong>传递给</strong><code>newCallable</code><strong>的参数的位置</strong>：<code>_1</code>为<code>newCallable</code><strong>第一个参数</strong>，<code>_2</code>为<strong>第二个参数</strong>，以此类推</p>
</blockquote>
</li>
<li><p><strong>使用</strong><code>bind</code><strong>绑定参数</strong></p>
<blockquote>
<p>1、一个简单的例子，我们将<strong>使用</strong><code>bind</code>生成一个<strong>调用</strong><code>check_size</code><strong>的对象</strong>，如下<br>2、此<code>bind</code>调用<strong>只有一个占位符</strong>，表示<code>check6</code><strong>接受一个参数</strong>；<strong>占位符</strong>出现在<code>arg_list</code><strong>第一个位置</strong>上，表示<code>check6</code><strong>的此参数</strong>对应<code>check_size</code><strong>的第一个参数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 原函数</span>
<span class="token keyword">bool</span> <span class="token function">check_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> string<span class="token double-colon punctuation">::</span>size_type sz<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> sz<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 绑定参数</span>
<span class="token keyword">auto</span> check6 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>check_size<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 调用</span>
string s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> b1 <span class="token operator">=</span> <span class="token function">check6</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 即调用 check_size(s, 6)</span>

<span class="token comment">// 作为一元谓词</span>
<span class="token keyword">auto</span> wc <span class="token operator">=</span> <span class="token function">find_if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> check6<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> wc <span class="token operator">=</span> <span class="token function">find_if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bind</span><span class="token punctuation">(</span>check_size<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>使用</strong><code>placeholders</code><strong>名字</strong></p>
<blockquote>
<p>1、<strong>名字</strong><code>_n</code>都定义在<strong>命名空间</strong><code>placeholders</code>中(定义在头文件<code>functional</code>中)，而这个<strong>命名空间</strong>定义在<code>std</code><strong>命名空间</strong>中，因此为了<strong>使用这些名字</strong>，两个命名空间都要写上(如<code>std::placeholders::_1</code>)<br>2、为了<strong>更方便的使用</strong>，我们通常使用<code>using</code>声明：<code>using std::placeholders::_1</code>。但这样对于<strong>每个占位符名字</strong>都要<strong>单独声明</strong>，不仅繁琐还易出错<br>3、我们可以使用<strong>另一种</strong><code>using</code><strong>声明形式</strong>：<code>using namespace namespace_name</code>，表示希望<strong>所有来自</strong><code>namespace_name</code><strong>的名字</strong>都可以在我们的程序中<strong>直接使用</strong>，如此处可写作<code>using namespace std::placeholders</code></p>
</blockquote>
</li>
<li><p><code>bind</code><strong>重排参数顺序</strong></p>
<blockquote>
<p>1、如前文所述，我们可以用<code>bind</code><strong>修正参数的值</strong>，更一般的，可以用<code>bind</code><strong>绑定</strong>给定可调用对象中的<strong>参数</strong>或是<strong>重新安排其顺序</strong><br>2、例如，<code>func</code>是一个<strong>可调用对象</strong>，它有<strong>5 个参数</strong>，则允许下面的调用</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> g <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> _2<span class="token punctuation">,</span> c<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">g</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等同于 func(a, b, e, c, d)</span></code></pre>
</li>
<li><p><strong>绑定引用参数</strong></p>
<blockquote>
<p>1、默认情况下，<code>bind</code>的那些<strong>不是占位符的参数</strong>被<strong>拷贝</strong>到<strong>返回的可调用对象</strong>中。但与<code>lambda</code>类似，有时对于有些<strong>绑定的参数</strong>我们希望<strong>以引用方式传递</strong>，或是希望<strong>绑定参数的类型无法拷贝</strong><br>2、如下例，为了替换一个<strong>引用方式捕获</strong><code>ostream</code>的<code>lambda</code>，可以很容易编写一个函数<strong>完成相同工作</strong>，但不能直接用<code>bind</code>来<strong>代替对</strong><code>os</code><strong>的捕获</strong>。原因在于<code>bind</code><strong>拷贝其参数</strong>，而我们<strong>不能拷贝一个</strong><code>ostream</code><br>3、如果我们希望<strong>传给</strong><code>bind</code><strong>一个对象</strong>而<strong>不拷贝它</strong>，必须使用<strong>标准库函数</strong><code>ref</code>，它定义在<strong>头文件</strong><code>functional</code>中。<code>ref</code><strong>返回一个对象</strong>，包含<strong>给定的引用</strong>，此对象是<strong>可以拷贝的</strong>；<strong>标准库</strong>还有一个<code>cref</code>，生成一个<strong>保存</strong><code>const</code><strong>引用的类</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// os 是一个局部变量，引用一个输出流</span>
<span class="token comment">// c 是一个局部变量，类型为 char</span>
<span class="token function">for_each</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>os<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> os <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 同功能函数</span>
ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> os <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 错误：不能拷贝 os</span>
<span class="token function">for_each</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bind</span><span class="token punctuation">(</span>print<span class="token punctuation">,</span> os<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 ref</span>
<span class="token function">for_each</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bind</span><span class="token punctuation">(</span>print<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a><strong>再探迭代器</strong></h4><ul>
<li><p><strong>标准库迭代器</strong>(头文件<code>iterator</code>)</p>
<table>
<thead>
<tr>
<th>迭代器类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>插入迭代器</td>
<td>这些迭代器被绑定到一个容器上，可用来向容器插入元素</td>
</tr>
<tr>
<td>流迭代器</td>
<td>这些迭代器被绑定到输入或输出流上，可用来遍历所有关联的 IO 流</td>
</tr>
<tr>
<td>反向迭代器</td>
<td>这些迭代器向后而不是向前移动。除了 forward_list 外标准库容器都有反向迭代器</td>
</tr>
<tr>
<td>移动迭代器</td>
<td>这些专用的迭代器不是拷贝其中的元素，而是移动它们(将在后续介绍)</td>
</tr>
</tbody></table>
</li>
<li><p><strong>插入迭代器</strong></p>
<ul>
<li><p><strong>插入迭代器操作</strong></p>
<blockquote>
<p>1、<strong>插入器</strong>是一种<strong>迭代器适配器</strong>，它<strong>接受一个容器</strong>，<strong>生成一个迭代器</strong><br>2、当我们通过一个<strong>插入迭代器进行赋值</strong>时，该迭代器<strong>调用容器操作</strong>来向给定容器的指定位置<strong>插入一个元素</strong>，下表列出了<strong>插入迭代器</strong>支持的操作</p>
</blockquote>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>it &#x3D; t</td>
<td>在 it 指定的当前位置插入值 t。假定 c 是 it 绑定的容器，依赖于插入迭代器不同种类，赋值分别调用 c.push_back(t)、c.push_front(t)、c.insert(t,p)</td>
</tr>
<tr>
<td>*it，++it，it++</td>
<td>虽然这些操作存在，但不会对 it 做任何事情，每个操作都返回 it</td>
</tr>
</tbody></table>
</li>
<li><p><strong>插入迭代器类型</strong></p>
<blockquote>
<p>1、<strong>插入迭代器</strong>有<strong>三种类型</strong>，差异在于<strong>元素插入的位置</strong><br>2、只有在<strong>容器支持</strong><code>push_front</code>操作时<strong>才能使用</strong><code>front_inserter</code>；只有在<strong>容器支持</strong><code>push_back</code>操作时才能使用<code>back_inserter</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>back_inserter</td>
<td>创建一个使用 push_back 的迭代器，元素插入到容器末尾</td>
</tr>
<tr>
<td>front_inserter</td>
<td>创建一个使用 push_front 的迭代器，元素插入到容器首端</td>
</tr>
<tr>
<td>inserter</td>
<td>创建一个使用 insert 的迭代器，此函数接受第二个参数，其必须是指向给定容器的一个迭代器，表示插入位置，元素将插入到给定迭代器表示的元素之前</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>iostream 迭代器</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、虽然<code>iostream</code>类型<strong>不是容器</strong>，但<strong>标准库</strong>定义了可以用于这些<strong>IO 类型对象</strong>的<strong>迭代器</strong><br>2、<code>istream_iterator</code><strong>读取输入流</strong>，<code>ostream_iterator</code><strong>向一个输出流写数据</strong><br>3、这些<strong>迭代器</strong>将它们<strong>对应的流</strong>当做一个<strong>特定类型的元素序列</strong>来处理，通过使用<strong>流迭代器</strong>，我们可以用<strong>泛型算法</strong>从<strong>流对象</strong>中<strong>读写数据</strong></p>
</blockquote>
</li>
<li><p><code>istream_iterator</code><strong>操作</strong></p>
<blockquote>
<p>1、当创建一个<strong>流迭代器</strong>时，必须<strong>指定迭代器</strong>将要读写的<strong>对象类型</strong>。一个<code>istream_iterator</code>使用<code>&gt;&gt;</code>来<strong>读取流</strong>，所以<strong>要读取的类型</strong>必须定义了<code>&gt;&gt;</code><strong>运算符</strong>。下表列出了<code>istream_iterator</code>的操作<br>2、当创建一个<code>istream_iterator</code>时，我们可以<strong>将它绑定到一个流</strong>。此外还可以<strong>默认初始化迭代器</strong>，这样就创建了一个<strong>可以当做尾后值使用的迭代器</strong>，如下<br>3、如下例，使用<code>istream_iterator</code><strong>从标准输入读取数据</strong>，<strong>存入一个</strong><code>vector</code>。此外我们还可以重写这部分代码，以体现<strong>流迭代器</strong>更有用的地方，即<strong>构造容器</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>istream_iterator 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>istream_iterator&lt;T&gt; in(is)</td>
<td>in 从输入流 is 读取类型为 T 的值</td>
</tr>
<tr>
<td>istream_iterator&lt;T&gt; end</td>
<td>读取类型为 T 的值的 istream_iterator 迭代器，表示尾后位置</td>
</tr>
<tr>
<td>in1 &#x3D;&#x3D; in2，in1 !&#x3D; in2</td>
<td>in1 和 in2 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同输入，则两者相等</td>
</tr>
<tr>
<td>*in</td>
<td>返回从流中读取的值</td>
</tr>
<tr>
<td>in-&gt;mem</td>
<td>与(*in).mem 含义相同</td>
</tr>
<tr>
<td>++in，in++</td>
<td>使用元素类型所定义的&gt;&gt;运算符从输入流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用示例</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">int_it</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 从 cin 读取 int</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> int_eof<span class="token punctuation">;</span>            <span class="token comment">// 尾后迭代器</span>
ifstream <span class="token function">in</span><span class="token punctuation">(</span><span class="token string">"afile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 创建一个文件输入流与 afile 绑定</span>
istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">str_it</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 从 afile 读取字符串</span>

<span class="token comment">// 从 istream_iterator 读入数据存入 vector</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in_iter<span class="token operator">&lt;</span>cin<span class="token operator">></span><span class="token punctuation">;</span>       <span class="token comment">// 从 cin 读取 int</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> eof<span class="token punctuation">;</span>                <span class="token comment">// istream 尾后迭代器</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>in_iter <span class="token operator">!=</span> eof<span class="token punctuation">)</span>                     <span class="token comment">// 当有数据可供读取时</span>
    <span class="token comment">// 后值递增运算读取流，返回迭代器的旧值</span>
    <span class="token comment">// 解引用迭代器，获得从流读取的前一个值</span>
    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>in_iter<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 重写优化</span>
istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">in_iter</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> eof<span class="token punctuation">;</span>  <span class="token comment">// 从 cin 读取 int</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vec</span><span class="token punctuation">(</span>in_iter<span class="token punctuation">,</span> eof<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 从迭代器范围构造 vec</span></code></pre>
</li>
<li><p><strong>使用算法操作流迭代器</strong></p>
<blockquote>
<p>1、由于<strong>算法</strong>使用<strong>迭代器</strong>来<strong>处理数据</strong>，而<strong>流迭代器</strong>又至少<strong>支持某些迭代器操作</strong>，因此我们可以<strong>用某些算法</strong>来<strong>操作流迭代器</strong><br>2、如下例，我们可以<strong>用一对</strong><code>istream_iterator</code><strong>来调用</strong><code>accumulate</code>，该调用会<strong>计算从标准输入读取的值的和</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">in</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> eof<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> eof<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>ostream_iterator</code><strong>操作</strong></p>
<blockquote>
<p>1、我们可以对任何<strong>具有</strong><code>&lt;&lt;</code><strong>运算符</strong>的<strong>类型</strong>定义<code>ostream_iterator</code>，下表列出了<code>ostream_iterator</code>的操作<br>2、当创建一个<code>ostream_iterator</code>时，可以提供<strong>可选的第二参数</strong>，它是一个<strong>C 风格字符串</strong>，在<strong>输出每个元素后</strong>都会<strong>打印此字符串</strong><br>3、<strong>必须将</strong><code>ostream_iterator</code><strong>绑定到一个指定流</strong>，不允许<strong>空的</strong>或<strong>表示尾后位置的</strong><code>ostream_iterator</code><br>4、如下例，我们可以用<code>ostream_iterator</code>来<strong>输出值的序列</strong>。由于<strong>解引用</strong>和<strong>递增运算</strong>没有实意，<strong>可以省略</strong>。我们还可以<strong>调用</strong><code>copy</code><strong>算法</strong>更方便地打印元素</p>
</blockquote>
<table>
<thead>
<tr>
<th>ostream_iterator 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ostream_iterator&lt;T&gt; out(os)</td>
<td>out 将 类型为 T 的值写到输出流 os 中</td>
</tr>
<tr>
<td>ostream_iterator&lt;T&gt; out(os, d)</td>
<td>out 将 类型为 T 的值写到输出流 os 中，每个值后都输出一个 d，d 必须是 C 风格字符串</td>
</tr>
<tr>
<td>out &#x3D; val</td>
<td>用 &lt;&lt; 运算符将 val 写入到 out 所绑定的 ostream 中，val 的类型必须与 out 可写的类型兼容</td>
</tr>
<tr>
<td>*out，++out，out++</td>
<td>虽然存在这些运算符，但不对 out 做任何事情，每个运算符都返回 out</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">out_iter</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> vec<span class="token punctuation">)</span>
    <span class="token comment">// 也可以直接写为：</span>
    <span class="token comment">// out_iter = e;</span>
    <span class="token operator">*</span>out_iter<span class="token operator">++</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>

<span class="token comment">// 使用算法操作</span>
<span class="token function">copy</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> out_iter<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>反向迭代器</strong></p>
<blockquote>
<p>1、<strong>反向迭代器</strong>就是在<strong>容器</strong>中从<strong>尾元素向首元素</strong>反向移动的<strong>迭代器</strong>。对于<strong>反向迭代器</strong>，<strong>递增</strong>(或递减)操作的含义<strong>会颠倒过来</strong>(即<code>++</code>移动到前一个元素)<br>2、除了<code>forward_list</code>外，<strong>其他容器</strong>都支持<strong>反向迭代器</strong>，我们可以通过<strong>调用</strong><code>rbegin</code>、<code>rend</code>、<code>crbegin</code>、<code>crend</code><strong>成员函数</strong>来获得<strong>反向迭代器</strong>，它们返回指向<strong>容器尾元素</strong>和<strong>首前元素</strong>位置的<strong>迭代器</strong></p>
</blockquote>
</li>
</ul>
<h4 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a><strong>泛型算法结构</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、任何算法<strong>最基本的特性</strong>是它要求其<strong>迭代器</strong>提供<strong>哪些操作</strong>。<strong>算法要求</strong>的<strong>迭代器操作</strong>可以分为<strong>五个迭代器类型</strong>，<strong>每个算法</strong>都会对它的<strong>每个迭代器参数</strong>指明须提供<strong>哪类迭代器</strong><br>2、第二种算法分类的方式是<strong>按照是否读写</strong>或<strong>重排序列元素</strong><br>3、<strong>算法</strong>还共享一组<strong>参数传递规范</strong>和一组<strong>命名规范</strong>，我们将在后续介绍</p>
</blockquote>
</li>
<li><p><strong>五类迭代器</strong></p>
<ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、类似<strong>容器</strong>，<strong>迭代器</strong>也定义了一组<strong>公共操作</strong>。一些操作<strong>所有迭代器都支持</strong>，另外一些<strong>只有特定迭代器才支持</strong><br>2、<strong>迭代器</strong>是按照它们<strong>所提供的操作</strong>来<strong>分类</strong>的，分为<strong>五类迭代器</strong>，如下表。这种分类<strong>形成了一种层次</strong>，除了<strong>输出迭代器</strong>外，一个<strong>高层类型的迭代器</strong>能完全支持<strong>低层类别的迭代器</strong>的所有操作<br>3、<strong>C++标准</strong>指明了<strong>泛型和数值算法</strong>的每个<strong>迭代器参数</strong>的<strong>最小类别</strong>，即对每个<strong>迭代器参数</strong>来说，其<strong>能力</strong>必须与<strong>规定的最小类别</strong>至少相当。向算法传递一个<strong>能力更差的迭代器</strong>会<strong>产生错误</strong>，对于这类错误，很多<strong>编译器不会给出任何警告</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>迭代器类别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>只读不写，单遍扫描，只能递增</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写不读，单遍扫描，只能递增</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>可读写，多遍扫描，只能递增</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>可读写，多遍扫描，可递增递减</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>可读写，多遍扫描，支持全部迭代器运算</td>
</tr>
</tbody></table>
</li>
<li><p><strong>输入迭代器</strong></p>
<ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、<strong>输入迭代器</strong>可以<strong>读取序列的元素</strong>，且<strong>输入迭代器</strong>只用于<strong>顺序访问</strong><br>2、对于一个<strong>输入迭代器</strong>，<code>*it++</code><strong>保证是有效的</strong>，但<strong>递增它</strong>可能导致所有<strong>其他指向流的迭代器失效</strong>，其结果就是<strong>不能保证输入迭代器的状态可以保存</strong>并<strong>用来访问元素</strong>。因此，<strong>输入迭代器</strong>只能用于<strong>单遍扫描算法</strong><br>3、<code>istream_iterator</code>是一种<strong>输入迭代器</strong></p>
</blockquote>
</li>
<li><p><strong>输入迭代器必须支持的操作</strong></p>
<blockquote>
<p>1、用于<strong>比较两个迭代器</strong>的<code>==</code>和<code>!=</code><strong>运算符</strong><br>2、用于<strong>推进迭代器</strong>的前置和后置<strong>递增运算符</strong><code>++</code><br>3、用于<strong>读取元素</strong>的<strong>解引用运算符</strong><code>*</code>，<strong>解引用</strong>只会出现在<strong>赋值运算符右侧</strong><br>4、<strong>箭头运算符</strong><code>-&gt;</code>，等价于<code>(*it).mem</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>输出迭代器</strong></p>
<ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、<strong>输出迭代器</strong>的特点是<strong>只写不读元素</strong>，且我们<strong>只能向输出迭代器赋值一次</strong><br>2、类似<strong>输入迭代器</strong>，<strong>输出迭代器</strong>也只能用于<strong>单遍扫描算法</strong>。<strong>用作目的位置</strong>的<strong>迭代器</strong>通常都是<strong>输出迭代器</strong>，如<code>copy</code>第三个<strong>表示目的位置的迭代器参数</strong>就是<strong>输出迭代器</strong><br>3、<code>ostream_iterator</code>是一种<strong>输出迭代器</strong></p>
</blockquote>
</li>
<li><p><strong>输出迭代器必须支持的操作</strong></p>
<blockquote>
<p>1、用于<strong>推进迭代器</strong>的前置和后置<strong>递增运算符</strong><code>++</code><br>2、<strong>解引用运算符</strong><code>*</code>，<strong>解引用</strong>只会出现在<strong>赋值运算符左侧</strong>(向一个已经解引用的输出迭代器赋值，就是将值写入它所指的元素)</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>前向迭代器</strong></p>
<blockquote>
<p>1、<strong>前向迭代器</strong>可以<strong>读写元素</strong>，这类<strong>迭代器</strong>只能在序列中<strong>沿一个方向移动</strong><br>2、<strong>前向迭代器</strong>支持所有<strong>输入输出迭代器的操作</strong>，而且可以<strong>多次读写同一个元素</strong>，因此我们<strong>可以保存前向迭代器的状态</strong>，<strong>算法</strong>可以<strong>对序列多次扫描</strong><br>3、<strong>算法</strong><code>replace</code>要求<strong>前向迭代器</strong>，<code>forward_list</code><strong>上的迭代器</strong>是<strong>前向迭代器</strong></p>
</blockquote>
</li>
<li><p><strong>双向迭代器</strong></p>
<blockquote>
<p>1、<strong>双向迭代器</strong>可以<strong>正向反向读写元素</strong><br>2、除了支持所有<strong>前向迭代器的操作</strong>外，还支持前置和后置<strong>递减运算符</strong><code>--</code><br>3、<strong>算法</strong><code>reverse</code>要求<strong>双向迭代器</strong>，除了<code>forward_list</code>外，<strong>其他标准库</strong>都提供<strong>符合双向迭代器要求</strong>的<strong>迭代器</strong></p>
</blockquote>
</li>
<li><p><strong>随机访问迭代器</strong></p>
<ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、<strong>随机访问迭代器</strong>提供在<strong>常量时间</strong><code>O(1)</code>内<strong>访问任意元素</strong>的能力<br>2、此类<strong>迭代器</strong>除了支持<strong>双向迭代器的操作</strong>，还支持一些其他操作<br>3、<strong>算法</strong><code>sort</code>要求<strong>随机访问迭代器</strong>，<code>array</code>、<code>deque</code>、<code>string</code>、<code>vector</code>的<strong>迭代器</strong>都是<strong>随机访问迭代器</strong>，用于<strong>访问内置数组元素</strong>的<strong>指针</strong>也是</p>
</blockquote>
</li>
<li><p><strong>随机访问迭代器额外支持的操作</strong></p>
<blockquote>
<p>1、用于<strong>比较两个迭代器相对位置</strong>的<strong>关系运算符</strong><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code><br>2、<strong>迭代器</strong>和一个<strong>整数值</strong>的<strong>加减运算</strong>，计算结果是在序列中<strong>前进</strong>(或后退)<strong>给定整数个元素</strong>的位置<br>3、用于<strong>两个迭代器</strong>上的<strong>减法运算</strong>，得到<strong>两个迭代器的距离</strong><br>4、<strong>下标运算符</strong><code>iter[n]</code>，与<code>*(iter[n])</code>等价</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>算法参数规范</strong></p>
<blockquote>
<p>1、在<strong>任何其他算法分类之上</strong>，还有一组<strong>参数规范</strong>。理解<strong>参数规范</strong>可以更方便得知<strong>算法需要的参数及操作</strong>，<strong>大多算法</strong>都具有<strong>如下四种形式之一</strong><br>2、<code>alg</code>是<strong>算法的名字</strong>，<code>beg</code>和<code>end</code>表示算法<strong>所操作的输入范围</strong>。<strong>几乎所有算法</strong>都接受一个<strong>输入范围</strong>，<strong>是否有其他参数</strong>依赖于<strong>要执行的操作</strong>，<code>dest</code>、<code>beg2</code>、<code>end2</code>都是可以顾名思义的<strong>迭代器参数</strong><br>3、除了这些<strong>迭代器参数</strong>，一些算法还接受<strong>额外的</strong>、<strong>非迭代器</strong>的<strong>特定参数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">alg</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> other_args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alg</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> other_args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alg</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> other_args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alg</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> beg2<span class="token punctuation">,</span> end2<span class="token punctuation">,</span> other_args<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>算法命名规范</strong></p>
<blockquote>
<p>1、除了<strong>参数规范</strong>，算法还遵循一套<strong>命名和重载规范</strong><br>2、一些算法使用<strong>重载形式</strong>传递一个<strong>谓词</strong>。接受<strong>谓词参数</strong>来代替<code>&lt;</code>或<code>==</code><strong>运算符</strong>的算法，以及<strong>不接受额外参数</strong>的算法，通常都是<strong>重载的函数</strong>，如<code>unique</code><br>3、一些算法有<code>_if</code><strong>版本</strong>。<strong>接受一个元素值</strong>的算法通常有另一个<strong>不同名的版本</strong>(非重载版本)，其接受一个<strong>谓词</strong>代替<strong>元素值</strong>，这些算法都有<code>_if</code><strong>后缀</strong>，如<code>find</code><br>4、一些算法有<strong>区分拷贝和不拷贝的版本</strong>。默认情况下，<strong>重排元素</strong>的算法将重排后的元素<strong>写回给定输入序列中</strong>，这些算法还提供另一个版本<strong>将元素写到指定输出目的位置</strong>，其名字后附加<code>_copy</code><strong>后缀</strong>，如<code>reverse</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">unique</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 使用 == 运算符比较元素</span>
<span class="token function">unique</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 使用 comp 比较元素</span>

<span class="token function">find</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 查找输入范围中 val 第一次出现的位置</span>
<span class="token function">find_if</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 查找第一个令 pred 为真的元素</span>

<span class="token function">reverse</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 反转输入范围中元素的顺序</span>
<span class="token function">reverse_copy</span><span class="token punctuation">(</span>beg<span class="token punctuation">,</span> end<span class="token punctuation">,</span> dest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将元素按逆序拷贝到 dest</span></code></pre></li>
</ul>
<h4 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a><strong>特定容器算法</strong></h4><ul>
<li><p><strong>链表类型的成员算法</strong></p>
<blockquote>
<p>1、与<strong>其他容器</strong>不同，<strong>链表类型</strong><code>list</code>和<code>forward_list</code>定义了几个<strong>成员函数</strong>形式的<strong>算法</strong>，这些算法都<strong>返回</strong><code>void</code>，如下表<br>2、<strong>链表类型</strong>定义的<strong>其他算法的通用版本</strong>也可以<strong>用于链表</strong>，但<strong>代价太高</strong>。这些<strong>通用版本算法</strong>需要<strong>交换元素</strong>，而链表可以通过<strong>改变元素间的链接</strong>来<strong>快速交换元素</strong>。因此，<strong>链表版本</strong>的算法比<strong>通用版本</strong>的算法<strong>性能好得多</strong>，应当优先使用<strong>成员函数版本</strong>的算法</p>
</blockquote>
<table>
<thead>
<tr>
<th>list 和 forward_list 的成员算法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lst.merge(lst2)，lst.merge(lst2, comp)</td>
<td>将来自 lst2 的元素合并入 lst。lst 和 lst2 都必须是有序的，元素将从 lst2 中删除，合并后 lst2 变为空。第一个版本使用<code>&lt;</code>运算符，第二个版本使用 comp 给定的比较操作</td>
</tr>
<tr>
<td>lst.remove(val)，lst.remove_if(pred)</td>
<td>调用 erase 删除与给定值相等或令一元谓词 pred 为真的每个元素</td>
</tr>
<tr>
<td>lst.reverse()</td>
<td>反转 lst 中元素的顺序</td>
</tr>
<tr>
<td>lst.sort()，lst.sort(comp)</td>
<td>使用<code>&lt;</code>或 comp 给定的比较操作排序元素</td>
</tr>
<tr>
<td>lst.unique()，lst.unique(pred)</td>
<td>调用 erase 删除同一个值的连续拷贝。第一个版本使用<code>==</code>，第二个版本使用 pred 给定的二元谓词</td>
</tr>
</tbody></table>
</li>
<li><p><strong>splice 成员</strong></p>
<blockquote>
<p>1、<strong>链表类型</strong>还定义了<code>splice</code><strong>算法</strong>，其形式如<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code>，参数描述如下表<br>2、此算法是<strong>链表数据结构特有的</strong>，因此<strong>不需要通用版本</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>splice 的 args 参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(p, lst2)</td>
<td>p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。函数将 lst2 的所有元素移动到 lst 中 p 之前的位置或是 flst 中 p 之后的位置，将元素从 lst2 中删除。lst2 不能是与 lst 或 flst 相同的链表</td>
</tr>
<tr>
<td>(p, lst2, p2)</td>
<td>p2 是一个指向 lst2 中位置的有效迭代器。函数将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中。lst2 可以是与 lst 或 flst 相同的链表</td>
</tr>
<tr>
<td>(p, lst2, b, e)</td>
<td>b 和 e 表示 lst2 中的合法范围。函数将给定范围中的元素从 lst2 移动到 lst 或 flst。lst2 可以是与 lst 或 flst 相同的链表，但 p 不能指向给定范围中的元素</td>
</tr>
</tbody></table>
</li>
<li><p><strong>链表特有的操作会改变容器</strong></p>
<blockquote>
<p>1、<strong>多数链表特有的算法</strong>与其<strong>通用版本</strong>很相似，但不完全相同，二者至关重要的<strong>区别是链表版本会改变底层的容器</strong><br>2、例如，<strong>通用版本</strong>的<code>merge</code>将<strong>合并的序列</strong>写入到一个<strong>给定的目的迭代器</strong>，<strong>两个输入序列不变</strong>；而<strong>链表版本</strong>的<code>merge</code>会<strong>销毁给定的链表</strong>，<strong>元素</strong>将<strong>从指定链表中删除</strong>，被<strong>合并到调用</strong><code>merge</code><strong>的链表中</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a><strong>关联容器</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：使用关联容器;<code>map</code>；<code>set</code>；关联容器概述；通用操作；重复关联容器；关键字类型要求；关键字类型的比较函数；<code>pair</code>类型；创建<code>pair</code>的函数；关联容器操作；关联容器迭代器；迭代器解引用；关联容器和算法；添加元素；<code>insert</code>操作；<code>insert</code>返回值；删除元素；<code>erase</code>操作；<code>map</code>下标操作；下标操作的返回值；访问元素；在<code>multimap</code>或<code>multiset</code>中查找元素；示例：单词转换程序；无序容器；使用无序容器；管理桶；关键字类型要求</p>
</blockquote>
</div>

<h4 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a><strong>使用关联容器</strong></h4><ul>
<li><p><strong>关联容器类型</strong></p>
<blockquote>
<p>1、<strong>关联容器</strong>支持高效的<strong>关键字查找和访问</strong>。两个主要的<strong>关联容器</strong>是<strong>map</strong>和<strong>set</strong><br>2、<strong>map</strong>中的元素是一些<strong>键值对</strong>，其中<strong>关键字</strong>起到<strong>索引作用</strong>，<strong>值</strong>则表示与索引<strong>相关联的数据</strong>。<strong>set</strong>每个元素<strong>只包含一个关键字</strong>，可以<strong>快速检查</strong>一个给定<strong>关键字是否在 set 中</strong><br>3、<strong>类型</strong><code>map</code>和<code>multimap</code>定义在<strong>头文件</strong><code>map</code>中，类型<code>set</code>和<code>multiset</code>定义在<strong>头文件</strong><code>set</code>中，相对应的<strong>无序容器</strong>定义在<strong>头文件</strong><code>unordered_map</code>和<code>unordered_set</code>中</p>
</blockquote>
<table>
<thead>
<tr>
<th>关联容器类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map</td>
<td>关联数组，保存键值对</td>
</tr>
<tr>
<td>set</td>
<td>只保存关键字的容器</td>
</tr>
<tr>
<td>multimap</td>
<td>关键字可重复出现的 map</td>
</tr>
<tr>
<td>multiset</td>
<td>关键字可重复出现的 set</td>
</tr>
<tr>
<td>unordered_map</td>
<td>用哈希函数组织的无序 map</td>
</tr>
<tr>
<td>unordered_set</td>
<td>用哈希函数组织的无序 set</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>用哈希函数组织的无序 map，关键字可重复出现</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>用哈希函数组织的无序 set，关键字可重复出现</td>
</tr>
</tbody></table>
</li>
<li><p><strong>使用 map</strong></p>
<blockquote>
<p>1、<code>map</code>是<strong>键值对</strong>的集合。例如，可以将<strong>人名</strong>作为<strong>关键字</strong>，将<strong>电话号码</strong>作为<strong>值</strong>，我们称这样的数据结构为<strong>将名字映射到电话号码</strong><br>2、<code>map</code>常被称为<strong>关联数组</strong>，<strong>关联数组</strong>与<strong>普通数组</strong>类似，不同之处在于<strong>其下标不必是整数</strong>，我们<strong>通过关键字</strong>而不是位置来<strong>查找值</strong><br>3、类似<strong>顺序容器</strong>，<strong>关联容器</strong>也是<strong>模板</strong>。因此<strong>定义一个</strong><code>map</code>，必须<strong>指定关键字和值的类型</strong><br>4、从<code>map</code><strong>提取元素</strong>时，会得到一个<code>pair</code><strong>类型对象</strong>(一个模板类型，保存名为 first 和 second 的公有数据成员)，<code>map</code>所使用的<code>pair</code>用<code>first</code>保存<strong>关键字</strong>，<code>second</code>保存<strong>值</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 统计每个单词出现的次数</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> word_count<span class="token punctuation">;</span>   <span class="token comment">// 创建 string 到 int 的空 map</span>
string word<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> word<span class="token punctuation">)</span>
    word_count<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token comment">// 提取关键字 word 的计数器并累加</span>
<span class="token comment">// 打印结果</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>w <span class="token operator">:</span> word_count<span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">":  "</span> <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>使用 set</strong></p>
<blockquote>
<p>1、<code>set</code>是<strong>关键字</strong>的集合。当只是想知道<strong>一个值是否存在</strong>时，<code>set</code>是最有用的<br>2、<code>set</code>也是一个<strong>模板</strong>，<strong>定义一个</strong><code>set</code>必须指定其<strong>元素类型</strong><br>3、<code>find</code><strong>成员</strong>返回一个<strong>迭代器</strong>，如果<strong>给定关键字在</strong><code>set</code><strong>中</strong>，则迭代器<strong>指向该关键字</strong>，否则指向<strong>尾后迭代器</strong><br>4、对于上面使用<code>map</code>的例子，我们可以<strong>额外使用</strong><code>set</code>实现<strong>忽略统计某些单词</strong>，如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 统计每个单词出现的次数</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> word_count<span class="token punctuation">;</span>  <span class="token comment">// 创建 string 到 int 的空 map</span>
set<span class="token operator">&lt;</span>string<span class="token operator">></span> exclude <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"the"</span><span class="token punctuation">,</span> <span class="token string">"but"</span><span class="token punctuation">,</span> <span class="token string">"and"</span><span class="token punctuation">,</span> <span class="token string">"or"</span><span class="token punctuation">,</span> <span class="token string">"an"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
string word<span class="token punctuation">;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> word<span class="token punctuation">)</span>
    <span class="token comment">// 只统计不在 exclude 中的单词</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>exclude<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> exclude<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        word_count<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">// 提取关键字 word 的计数器并累加</span></code></pre></li>
</ul>
<h4 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a><strong>关联容器概述</strong></h4><ul>
<li><p><strong>通用操作</strong></p>
<blockquote>
<p>1、<strong>关联容器</strong>支持所有的<strong>普通容器操作</strong>(见 9.2 节)<br>2、但<strong>不支持顺序容器的位置相关的操作</strong>，例如<code>push_front</code>或<code>push_back</code>，原因是<strong>关联容器中的元素</strong>是<strong>根据关键字存储</strong>的，<strong>这些操作</strong>对关联容器<strong>没有意义</strong><br>3、此外，<strong>关联容器</strong>也<strong>不支持构造函数或插入操作</strong>这些接受一个<strong>元素值</strong>和一个<strong>数量值</strong>的操作</p>
</blockquote>
</li>
<li><p><strong>重复关联容器</strong></p>
<blockquote>
<p>1、一个<code>map</code>或<code>set</code>的<strong>关键字必须唯一</strong>，即对于一个给定<strong>关键字</strong>，<strong>只能有一个元素与之对应</strong>。而<code>multimap</code>和<code>multiset</code><strong>没有此限制</strong>，即<strong>多个元素</strong>都可以具有<strong>相同的关键字</strong><br>2、下例展示了<strong>具有唯一关键字的容器</strong>与<strong>允许重复关键字的容器</strong>的区别</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义有 20 个元素的 vector，保存 0-9 每个整数的两个拷贝</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ivec<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>size_type i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ivec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 重复保存一次</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// iset 包含来自 ivec 的不重复的元素，miset 包含所有 20 个元素</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">iset</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ivec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
multiset<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">miset</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ivec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> ivec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token comment">// 打印出 20</span>
cout <span class="token operator">&lt;&lt;</span> iset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token comment">// 打印出 10</span>
cout <span class="token operator">&lt;&lt;</span> miset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token comment">// 打印出 20</span></code></pre>
</li>
<li><p><strong>关键字类型要求</strong></p>
<ul>
<li><p><strong>有序容器的关键字类型</strong></p>
<blockquote>
<p>1、对于<strong>有序容器</strong>，<strong>关键字类型</strong>必须定义<strong>元素比较的方法</strong>。默认情况下，<strong>标准库</strong>使用<strong>关键字类型</strong>的<code>&lt;</code><strong>运算符</strong>来比较两个关键字<br>2、在<strong>集合类型</strong>(<code>set</code>)中，<strong>元素类型</strong>就是<strong>关键字类型</strong>；在<strong>映射类型</strong>(<code>map</code>)中，<strong>元素的第一部分的类型</strong>就是<strong>关键字类型</strong><br>3、先前可以向一个<strong>算法</strong>提供我们<strong>自定义的比较操作</strong>，与之类似，也可以提供<strong>自定义的操作</strong>来代替<strong>关键字</strong>上的<code>&lt;</code><strong>运算符</strong><br>4、但<strong>所定义的操作</strong>必须在<strong>关键字类型</strong>上定义一个<strong>严格弱序</strong>(可以看做<code>&lt;=</code>)，无论我们怎样定义<strong>比较函数</strong>，它必须具备<strong>下列性质</strong><br>5、实际编程中，如果<strong>一个类型</strong>定义了<strong>行为正常的</strong><code>&lt;</code><strong>运算符</strong>，则它<strong>可以用作关键字类型</strong></p>
</blockquote>
</li>
<li><p><strong>比较函数所需的性质</strong></p>
<blockquote>
<p>1、两个关键字<strong>不能同时</strong><code>&lt;=</code><strong>对方</strong><br>2、如果<strong>k1</strong><code>&lt;=</code><strong>k2</strong>，且<strong>k2</strong><code>&lt;=</code><strong>k3</strong>，那么必须也有<strong>k1</strong><code>&lt;=</code><strong>k3</strong><br>3、如果存在两个关键字，<strong>任何一个都不</strong><code>&lt;=</code><strong>对方</strong>，那么称这两个关键字<strong>等价</strong>(容器将它们视作相等)。如果<strong>k1 等价于 k2</strong>，且<strong>k2 等价于 k3</strong>，那么必须也有<strong>k1 等价于 k3</strong></p>
</blockquote>
</li>
<li><p><strong>关键字类型的比较函数</strong></p>
<blockquote>
<p>1、用来<strong>组织一个容器中元素操作的类型</strong>也是<strong>容器类型</strong>的一部分。为了<strong>指定使用自定义的操作</strong>，必须在<strong>定义关联容器类型</strong>时提供<strong>操作的类型</strong>，在<strong>尖括号</strong>中紧跟<strong>元素类型</strong>给出<br>2、如下例，我们定义了一个<strong>比较函数</strong>，我们希望<strong>创建一个</strong><code>multiset</code><strong>使用该函数为元素排序</strong>。定义<code>multiset</code>时必须<strong>提供两种类型</strong>：一个<strong>关键字类型</strong>和一个<strong>函数指针类型</strong><br>3、<code>bookstore(compareIsbn)</code>使用<strong>传入函数地址初始化对象</strong>，表示当我们<strong>向</strong><code>bookstore</code><strong>添加元素</strong>时，通过<strong>调用</strong><code>compareIsbn</code><strong>为这些元素排序</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 比较函数</span>
<span class="token keyword">bool</span> <span class="token function">compareIsbn</span><span class="token punctuation">(</span>Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> lhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// bookstore 中的多条记录可以有相同的 ISBN</span>
<span class="token comment">// bookstore 中的元素以 ISBN 的顺序进行排列</span>
<span class="token comment">// 尖括号中 Sales_data 为关键字类型，decltype(compareIsbn)* 为指向 compareIsbn() 的函数指针</span>
multiset<span class="token operator">&lt;</span>Sales_data<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>compareIsbn<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">bookstore</span><span class="token punctuation">(</span>compareIsbn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>pair 类型</strong></p>
<ul>
<li><p><code>pair</code><strong>类型与操作</strong></p>
<blockquote>
<p>1、在介绍<strong>关联容器操作</strong>之前，我们需要了解名为<code>pair</code>的<strong>标准库类型</strong>，它定义在<strong>头文件</strong><code>utility</code>中<br>2、一个<code>pair</code><strong>保存两个数据成员</strong>。类似<strong>容器</strong>，<code>pair</code>是一个用来<strong>生成特定类型</strong>的<strong>模板</strong>。因此当<strong>创建一个</strong><code>pair</code>时，必须<strong>提供两个类型名</strong>，其<strong>两个数据成员</strong>将分别具有<strong>对应的类型</strong>，两个类型<strong>不要求一致</strong>：<code>pair&lt;string, vector&lt;int&gt;&gt; line</code><br>3、<code>pair</code>的<strong>默认构造函数</strong>对<strong>数据成员</strong>进行<strong>值初始化</strong>，我们也可以为每个成员提供<strong>初始化器</strong>：<code>pair&lt;string, string&gt; author&#123;&quot;James&quot;, &quot;Joyce&quot;&#125;</code><br>4、与其他<strong>标准库类型</strong>不同，<code>pair</code>的<strong>数据成员</strong>是<code>public</code>的，我们可以<strong>通过成员访问符直接访问</strong><br>5、<strong>标准库</strong>定义了如下几个<code>pair</code><strong>操作</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>pair 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pair&lt;T1,T2&gt; p;</td>
<td>p 是一个 pair，两个类型分别为 T1 和 T2 的成员都进行了值初始化</td>
</tr>
<tr>
<td>pair&lt;T1,T2&gt; p(v1,v2);</td>
<td>p 是一个成员类型为 T1 和 T2 的 pair，first 和 second 成员分别用 v1 和 v2 进行初始化</td>
</tr>
<tr>
<td>pair&lt;T1,T2&gt; p &#x3D; {v1,v2};</td>
<td>等价于 p(v1,v2)</td>
</tr>
<tr>
<td>make_pair(v1,v2)</td>
<td>返回一个用 v1 和 v2 初始化的 pair，pair 类型由 v1 和 v2 的类型推断</td>
</tr>
<tr>
<td>p.first</td>
<td>返回 p 的名为 first 的公有数据成员</td>
</tr>
<tr>
<td>p.second</td>
<td>返回 p 的名为 second 的公有数据成员</td>
</tr>
<tr>
<td>p1 &lt; p2</td>
<td>关系运算符按字典序定义，利用元素的 &lt; 运算符来实现</td>
</tr>
<tr>
<td>p1 &#x3D;&#x3D; p2，p1 !&#x3D; p2</td>
<td>当 first 和 second 分别相等时，则 pair 相等</td>
</tr>
</tbody></table>
</li>
<li><p><strong>创建 pair 的函数</strong></p>
<blockquote>
<p>1、如果一个<strong>函数</strong>需要<strong>返回一个</strong><code>pair</code>。在<strong>新标准</strong>下，我们可以对<strong>返回值</strong>进行<strong>列表初始化</strong><br>2、在早期版本中，<strong>不允许</strong>使用花括号包裹的<strong>初始化器</strong>来<strong>返回</strong><code>pair</code><strong>类型对象</strong>，必须<strong>显式构造返回值</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 返回 pair 的函数</span>
pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">process</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 处理 v</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                   <span class="token comment">// 列表初始化</span>
        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 使用 make_pair</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 早期版本</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">// 隐式构造返回值</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a><strong>关联容器操作</strong></h4><ul>
<li><p><strong>关联容器迭代器</strong></p>
<ul>
<li><p><strong>额外的类型别名</strong></p>
<table>
<thead>
<tr>
<th>类型别名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>key_type</td>
<td>此容器类型的关键字类型</td>
</tr>
<tr>
<td>mapped_type</td>
<td>每个关键字关联的类型，只适用于 map</td>
</tr>
<tr>
<td>value_type</td>
<td>对于 map，为 pair&lt;const key_type, mapped_type&gt;，对于 set，与 key_type 相同</td>
</tr>
</tbody></table>
</li>
<li><p><strong>迭代器解引用</strong></p>
<blockquote>
<p>1、当<strong>解引用</strong>一个<strong>关联容器迭代器</strong>时，会得到一个类型为<strong>容器</strong><code>value_type</code>的<strong>值的引用</strong><br>2、如下例，对<code>map</code>而言，<code>value_type</code>是一个<code>pair</code>类型，但要注意<code>map</code>的<code>value_type</code>中的<code>key_type</code>是<code>const</code>的(即表示索引名的<code>first</code>不可改变)<br>3、<code>set</code>的<strong>迭代器</strong>类型同时定义了<code>iterator</code>和<code>const_interator</code>，但<strong>两种类型都只允许只读访问</strong>(即索引名不可改变)<br>4、<strong>遍历关联容器</strong>的方法与先前<strong>遍历顺序容器</strong>的方法类似，使用<code>begin</code>和<code>end</code>成员完成</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 获得指向 word_count 中一个元素的迭代器</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> word_count<span class="token punctuation">;</span>
<span class="token keyword">auto</span> map_it <span class="token operator">=</span> word_count<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// *map_it 是一个指向 pair&lt;const string, int> 对象的引用</span>
cout <span class="token operator">&lt;&lt;</span> map_it<span class="token operator">-></span>first <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> map_it<span class="token operator">-></span>second<span class="token punctuation">;</span>
map_it<span class="token operator">-></span>first <span class="token operator">=</span> <span class="token string">"new key"</span><span class="token punctuation">;</span>        <span class="token comment">// 错误：关键字是 const 的，不能改变索引名</span>
map_it<span class="token operator">-></span>second<span class="token operator">++</span><span class="token punctuation">;</span>                 <span class="token comment">// 正确：可以通过迭代器改变元素的值</span></code></pre>
</li>
<li><p><strong>关联容器和算法</strong></p>
<blockquote>
<p>1、我们通常不对<strong>关联容器</strong>使用<strong>泛型算法</strong>，因为<strong>关键字</strong>是<code>const</code>意味着不能将<strong>关联容器</strong>传递给<strong>修改或重排容器元素的算法</strong><br>2、虽然<strong>关联容器</strong>可用于<strong>只读元素的算法</strong>，但是很多这类算法都要<strong>搜索序列</strong>。由于关联容器的元素<strong>不能通过它们的关键字快速查找</strong>，因此使用<strong>搜索算法</strong>几乎总是个坏主意<br>3、<strong>关联容器</strong>定义了一个名为<code>find</code>的<strong>成员函数</strong>，通过一个<strong>给定的关键字</strong>直接获取元素。<strong>泛型算法库</strong>中也有一个<code>find</code><strong>算法</strong>，但此算法会进行<strong>顺序搜索</strong>，因此使用<strong>关联容器定义的</strong><code>find</code><strong>成员函数</strong>比<strong>调用泛型</strong><code>find</code>好得多<br>4、实际编程中，如果我们真要<strong>对一个关联容器使用算法</strong>，要么是将它<strong>当做一个源序列</strong>，要么是<strong>当做一个目的位置</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>添加元素</strong></p>
<ul>
<li><p><code>insert</code><strong>操作</strong></p>
<blockquote>
<p>1、<strong>关联容器</strong>的<code>insert</code><strong>成员</strong>向容器中<strong>添加一个元素</strong>或<strong>一个元素范围</strong><br>2、由于<code>map</code>和<code>set</code>包含<strong>不重复的关键字</strong>，因此<strong>插入已存在的元素</strong>对容器<strong>没有任何影响</strong><br>3、对一个<code>map</code>进行<code>insert</code>操作时，必须记住<strong>元素类型</strong>是<code>pair</code>，我们可以在<code>insert</code><strong>参数列表</strong>中创建一个<code>pair</code>，此外还另有如下三种方法</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 重复元素对容器没有影响</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ivec <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// ivec 有 8 个元素</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> set2<span class="token punctuation">;</span>                            <span class="token comment">// 空集合</span>
set2<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>ivec<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ivec<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// set2 有 4 个元素</span>
set2<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// set2 现在有 8 个元素</span>

<span class="token comment">// 向 map 添加元素的 4 种方法</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span> word_count<span class="token punctuation">;</span>
word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span></span></span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">value_type</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<table>
<thead>
<tr>
<th>insert 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.insert(v)，c.emplace(args)</td>
<td>v 是 value_type 类型的对象，args 用来构造一个元素。对于 map 和 set，只有当元素的关键字不在 c 中时才插入(或构造)元素，函数返回一个 pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的 bool 值。对于 multimap 和 multiset，总会插入(或构造)给定元素，并返回一个指向新元素的迭代器</td>
</tr>
<tr>
<td>c.insert(b,e)，c.insert(il)</td>
<td>b 和 e 是迭代器，表示一个 c::value_type 类型值的范围，il 是这种值的花括号列表。函数返回 void</td>
</tr>
<tr>
<td>c.insert(p,v)，c.insert(p,args)</td>
<td>类似 insert(v) 或 emplace(v)，但将迭代器 p 作为一个指示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素</td>
</tr>
</tbody></table>
</li>
<li><p><code>insert</code><strong>返回值</strong></p>
<blockquote>
<p>1、<code>insert</code>和<code>emplace</code>的<strong>返回值</strong>依赖于<strong>容器类型和参数</strong>。对于<strong>不包含重复关键字</strong>的容器，它们返回一个<code>pair</code>，其<code>first</code>指向<strong>具有给定关键字的元素</strong>，<code>second</code>为一个<code>bool</code>值，如果<strong>关键字已在容器中</strong>则为<strong>false</strong><br>2、作为一个例子，我们用<code>insert</code>重写<strong>单词计数程序</strong>，如下例</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">></span> word_count<span class="token punctuation">;</span>
string word<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> word<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 插入一个元素，关键字等于 word，值为 1</span>
    <span class="token comment">// ret 记录返回值</span>
    <span class="token keyword">auto</span> ret <span class="token operator">=</span> word_count<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>word<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果已经存在，则 insert 什么也没做，手动 +1</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">.</span>second<span class="token punctuation">)</span>
        ret<span class="token punctuation">.</span>first<span class="token operator">-></span>second<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 递增计数器，等价于 word_count[word]++</span>
        <span class="token comment">// ret.first 是指向具有该关键字的元素的迭代器</span>
        <span class="token comment">// ret.first->second 该元素的计数器部分(second)</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>删除元素</strong></p>
<ul>
<li><p><code>erase</code><strong>操作</strong></p>
<table>
<thead>
<tr>
<th>erase 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.erase(k)</td>
<td>从 c 中删除每个关键字为 k 的元素。返回一个 size_type 值，指出删除的元素的数量</td>
</tr>
<tr>
<td>c.erase(p)</td>
<td>从 c 中删除迭代器 p 指定的元素。p 必须指向 c 中一个真实元素，不能等于 c.end()。返回指向 p 之后元素的迭代器，若 p 指向 c 中的尾元素，则返回 c.end()</td>
</tr>
<tr>
<td>c.erase(b,e)</td>
<td>删除迭代器对 b 和 e 所表示的范围中的元素。返回 e</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>map 下标操作</strong></p>
<ul>
<li><p><strong>下标操作</strong></p>
<blockquote>
<p>1、<code>map</code>和<code>unordered_map</code>提供了<strong>下标运算符</strong>和一个对应的<code>at</code><strong>函数</strong><br>2、<code>set</code>类型<strong>不支持下标</strong>，因为<code>set</code>中没有<strong>与关键字相关联</strong>的<strong>值</strong><br>3、我们不能对一个<code>multimap</code>或一个<code>unordered_multimap</code>进行<strong>下标操作</strong>，因为这些容器中可能有<strong>多个值与一个关键字相关联</strong><br>4、下标和<code>at</code>操作只适用于非<code>const</code>的<code>map</code>和<code>unordered_map</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>下标操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c[k]</td>
<td>返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化</td>
</tr>
<tr>
<td>c.at(k)</td>
<td>访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出一个 out_of_range 异常</td>
</tr>
</tbody></table>
</li>
<li><p><strong>下标操作的返回值</strong></p>
<blockquote>
<p>1、<code>map</code>的<strong>下标运算符</strong>与我们用过的<strong>其他下标运算符</strong>的一个<strong>不同之处</strong>是<strong>返回类型</strong>。通常，<strong>解引用一个迭代器</strong>返回的类型和<strong>下标运算符</strong>返回的类型是<strong>一样</strong>的，但对<code>map</code>则不然<br>2、当对一个<code>map</code><strong>进行下标操作</strong>时，会获得一个<code>mapped_type</code><strong>对象</strong>；当<strong>解引用一个</strong><code>map</code>时，会得到一个<code>value_type</code>对象<br>3、相同的是，<code>map</code>的<strong>下标运算符</strong>返回一个<strong>左值</strong>，这意味着我们<strong>既可以读也可以写</strong>元素<br>4、如果<strong>关键字还未在</strong><code>map</code><strong>中</strong>，<strong>下标运算符</strong>会<strong>添加一个新元素</strong>，这一特性允许我们编写出十分简洁的程序</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> word_count<span class="token punctuation">[</span><span class="token string">"Anna"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token operator">++</span>word_count<span class="token punctuation">[</span><span class="token string">"Anna"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> word_count<span class="token punctuation">[</span><span class="token string">"Anna"</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>访问元素</strong></p>
<ul>
<li><p><strong>访问操作</strong></p>
<blockquote>
<p>1、<strong>关联容器</strong>提供多种<strong>查找一个指定元素</strong>的方法，如下表。具体应该使用哪个操作依赖于我们要解决什么问题<br>2、对于<strong>不允许重复关键字</strong>的容器，使用<code>find</code>和<code>count</code><strong>没什么区别</strong>；对于<strong>允许重复关键字</strong>的容器，<code>count</code>额外还会统计<strong>有多少个元素有相同的关键字</strong><br>3、<code>lower_bound</code>和<code>upper_bound</code>不适用于<strong>无序容器</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> iset <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
iset<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回一个迭代器，指向 key == 1 的元素</span>
iset<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 返回一个迭代器，其值等于 iset.end()</span>
iset<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 返回 1</span>
iset<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 返回 0</span>

<span class="token comment">// 使用 find 检查一个元素是否存在</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>word_count<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"foobar"</span><span class="token punctuation">)</span> <span class="token operator">==</span> word_count<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<table>
<thead>
<tr>
<th>访问操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.find(k)</td>
<td>返回一个迭代器，指向第一个关键字为 k 的元素，若 k 不在容器中，则返回尾后迭代器</td>
</tr>
<tr>
<td>c.count(k)</td>
<td>返回关键字等于 k 的元素的数量</td>
</tr>
<tr>
<td>c.lower_bound(k)</td>
<td>返回一个迭代器，指向第一个关键字不小于 k 的元素(首个具有给定关键字的元素的位置)</td>
</tr>
<tr>
<td>c.upper_bound(k)</td>
<td>返回一个迭代器，指向第一个关键字大于 k 的元素(最后一个匹配给定关键字的元素之后的位置)</td>
</tr>
<tr>
<td>c.equal_range(k)</td>
<td>返回一个迭代器 pair，表示关键字等于 k 的元素的范围。若 k 不存在，pair 的两个成员均等于 c.end()</td>
</tr>
</tbody></table>
</li>
<li><p><strong>在</strong><code>multimap</code><strong>或</strong><code>multiset</code><strong>中查找元素</strong></p>
<blockquote>
<p>1、在一个<strong>不允许重复关键字</strong>的关联容器中<strong>查找一个元素</strong>是一件<strong>很简单</strong>的事情——<strong>元素要么在</strong>容器中，<strong>要么不在</strong>；但对于<strong>允许重复关键字</strong>的容器过程<strong>更为复杂</strong>：在容器中可能有<strong>很多元素</strong>具有<strong>给定的关键字</strong><br>2、如果一个<code>multimap</code>或<code>multiset</code>中有<strong>多个元素</strong>具有<strong>给定关键字</strong>，则<strong>这些元素</strong>在容器中会<strong>相邻储存</strong><br>3、例如，给定一个<strong>从作者到书籍</strong>的映射，我们可能想<strong>打印一个特定作者的所有著作</strong>，共有<strong>三种方法</strong>解决这个问题</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 最直观的方法：使用 find 和 count</span>

string <span class="token function">search_item</span><span class="token punctuation">(</span><span class="token string">"Alain de Botton"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 要查找的作者</span>
<span class="token keyword">auto</span> entries <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 元素的数量</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 作者的第一本书</span>
<span class="token comment">// 用一个循环来查找此作者的所有著作</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>entries<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>             <span class="token comment">// 打印书籍名</span>
    <span class="token operator">++</span>iter<span class="token punctuation">;</span>                                   <span class="token comment">// 前进到下一本书</span>
    <span class="token operator">--</span>entries<span class="token punctuation">;</span>                                <span class="token comment">// 记录已经打印了多少本书</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 面向迭代器的解决方法：使用 lower_bound 和 upper_bound</span>

string <span class="token function">search_item</span><span class="token punctuation">(</span><span class="token string">"Alain de Botton"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 要查找的作者</span>
<span class="token comment">// beg 和 end 表示对应此作者的元素的范围</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> beg <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span> beg <span class="token operator">!=</span> end<span class="token punctuation">;</span> beg<span class="token operator">++</span><span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> beg<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>              <span class="token comment">// 打印书籍名</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 最直接的方法：使用 euqal_range</span>

string <span class="token function">search_item</span><span class="token punctuation">(</span><span class="token string">"Alain de Botton"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 要查找的作者</span>
<span class="token comment">// pos 保存迭代器时，表示与关键字匹配的元素范围，是一个 pair</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> pos <span class="token operator">=</span> authors<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span>search_item<span class="token punctuation">)</span><span class="token punctuation">;</span> pos<span class="token punctuation">.</span>first <span class="token operator">!=</span> pos<span class="token punctuation">.</span>second<span class="token punctuation">;</span> pos<span class="token punctuation">.</span>first<span class="token operator">++</span><span class="token punctuation">)</span>
    cout <span class="token operator">&lt;&lt;</span> pos<span class="token punctuation">.</span>first<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token comment">// 打印书籍名</span></code></pre></li>
</ul>
</li>
<li><p><strong>示例：单词转换程序</strong></p>
<ul>
<li><p><strong>需求描述</strong>：向程序输入一段文字，将如下单词转换成对应单词</p>
<pre class="language-none"><code class="language-none">where r u
y dont u send me a pic
k thk 18r</code></pre>

<pre class="language-none"><code class="language-none">where are you
why dont you send me a picture
okay? thanks! later</code></pre>
</li>
<li><p><strong>单词转换程序</strong></p>
<blockquote>
<p>1、我们的程序将使用<strong>三个函数</strong>来实现这些功能<br>2、函数<code>word_transform</code><strong>管理整个过程</strong>，它接受<strong>两个</strong><code>ifstream</code><strong>参数</strong>：第一个参数绑定到<strong>单词转换规则文件</strong>，第二个参数绑定到<strong>要转换的文本文件</strong><br>3、函数<code>buildMap</code>会<strong>读取转换规则文件</strong>，并<strong>创建一个</strong><code>map</code>，用于保存每个<strong>单词到其转换内容</strong>的<strong>映射</strong><br>4、函数<code>transform</code>接受一个<code>string</code>，如果存在转换规则，<strong>返回转换后的内容</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">word_transform</span><span class="token punctuation">(</span>ifstream <span class="token operator">&amp;</span>map_file<span class="token punctuation">,</span> ifstream <span class="token operator">&amp;</span>input<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> trans_map <span class="token operator">=</span> <span class="token function">buildMap</span><span class="token punctuation">(</span>map_file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 buildMap，保存转换规则</span>
    string text<span class="token punctuation">;</span>                                <span class="token comment">// 保存输入中的每一行</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment">// 读取一行输入</span>
    <span class="token punctuation">&#123;</span>
        istringstream <span class="token function">stream</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 字符输入流，用于读取每个单词</span>
        string word<span class="token punctuation">;</span>
        <span class="token keyword">bool</span> firstword <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                  <span class="token comment">// 控制是否打印空格</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>stream <span class="token operator">>></span> word<span class="token punctuation">)</span>                   <span class="token comment">// 读取一个单词</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>firstword<span class="token punctuation">)</span>
                firstword <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                cout <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>                    <span class="token comment">// 单词之间打印一个空格</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token function">transform</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> trans_map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 transform，翻译并输出</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                           <span class="token comment">// 完成一行的转换，打印换行</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> <span class="token function">buildMap</span><span class="token punctuation">(</span>ifstream <span class="token operator">&amp;</span>map_file<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> trans_map<span class="token punctuation">;</span>              <span class="token comment">// 保存转换规则</span>
    string key<span class="token punctuation">;</span>                                 <span class="token comment">// 要转换的单词</span>
    string value<span class="token punctuation">;</span>                               <span class="token comment">// 替换后的内容</span>
    <span class="token comment">// 读取第一个单词存入 key 中，行中剩余内容存入 value</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>map_file <span class="token operator">>></span> key <span class="token operator">&amp;&amp;</span> <span class="token function">getline</span><span class="token punctuation">(</span>map_file<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token comment">// 检查是否有转换规则</span>
            trans_map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 跳过前导空格</span>
        <span class="token keyword">else</span>
            <span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"no rule for"</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> trans_map<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 实际的转换工作；此部分是程序的核心</span>
    <span class="token keyword">auto</span> map_it <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果单词在转换规则 map 中</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>map_it <span class="token operator">!=</span> m<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> map_it<span class="token operator">-></span>second<span class="token punctuation">;</span>                  <span class="token comment">// 使用替换短语</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> s<span class="token punctuation">;</span>                               <span class="token comment">// 否则返回原 string</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a><strong>无序容器</strong></h4><ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、新标准定义了<strong>4 个无序关联容器</strong>，这些容器<strong>不使用比较运算符</strong>来<strong>组织元素</strong>，而是使用一个<strong>哈希函数</strong>和<strong>关键字类型的</strong><code>==</code><strong>运算符</strong><br>2、在关键字类型的元素<strong>没有明显的序关系</strong>的情况下，<strong>无序容器</strong>是非常有用的。在某些应用中，<strong>维护元素的序代价非常高</strong>时，<strong>无序容器</strong>也很有用<br>3、理论上<strong>哈希技术</strong>能获得<strong>更好的平均性能</strong>，但实际中还需要进行<strong>性能测试和调优</strong>。不过因此，使用<strong>无序容器通常更为简单</strong>，也有<strong>更好的性能</strong></p>
</blockquote>
</li>
<li><p><strong>使用无序容器</strong></p>
<blockquote>
<p>1、除了<strong>哈希管理</strong>操作之外，<strong>无序容器</strong>还提供了<strong>与有序容器相同的操作</strong>(如<code>find</code>、<code>insert</code>等)<br>2、这意味着我们曾<strong>用于</strong><code>map</code><strong>和</strong><code>set</code><strong>的操作也能用于</strong><code>unordered_map</code><strong>和</strong><code>unordered_set</code>。类似的，<strong>无序容器</strong>也有<strong>允许重复关键字的版本</strong><br>3、因此，通常可以用一个<strong>无序容器</strong>替换对应的<strong>有序容器</strong>，反之亦然。但是由于元素<strong>未按顺序存储</strong>，其<strong>输出</strong>会<strong>与有序容器的版本不同</strong></p>
</blockquote>
</li>
<li><p><strong>管理桶</strong></p>
<blockquote>
<p>1、<strong>无序容器</strong>在存储上组织为<strong>一组桶</strong>，<strong>每个桶</strong>保存<strong>零个或多个元素</strong>。<strong>无序容器</strong>使用一个<strong>哈希函数</strong>将<strong>元素</strong>映射到<strong>桶</strong>，为了<strong>访问一个元素</strong>，容器首先计算元素的<strong>哈希值</strong>，它指出<strong>应该搜索哪个桶</strong><br>2、容器将具有<strong>特定哈希值</strong>的<strong>所有元素</strong>保存在<strong>相同桶中</strong>。如果容器<strong>允许重复关键字</strong>，所有<strong>具有相同关键字的元素</strong>也都会保存在<strong>相同桶中</strong>。因此，<strong>无序容器的性能</strong>依赖于<strong>哈希函数的质量</strong>和<strong>桶的数量与大小</strong><br>3、对于<strong>相同的参数</strong>，<strong>哈希函数</strong>必须<strong>总是产生相同结果</strong>。理想情况下，<strong>哈希函数</strong>还能将每个<strong>特定的值</strong>映射到<strong>唯一的桶</strong>，但将<strong>不同关键字的元素</strong>映射到<strong>相同的桶</strong>也是<strong>允许的</strong>。当<strong>一个桶保存多个元素时</strong>，需要<strong>顺序搜索</strong>这些元素来<strong>查找目标元素</strong><br>4、<strong>无序容器</strong>提供了一组<strong>管理桶的函数</strong>，如下表。它们将允许我们<strong>查询容器状态</strong>及必要时<strong>强制容器进行重组</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>无序容器管理操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>c.bucket_count()</td>
<td>正在使用的桶的数量</td>
</tr>
<tr>
<td>c.max_bucket_count()</td>
<td>容器能容纳的最多的桶的数量</td>
</tr>
<tr>
<td>c.bucket_size(n)</td>
<td>第 n 个桶有多少个元素</td>
</tr>
<tr>
<td>c.bucket(k)</td>
<td>关键字为 k 的元素在哪个桶里</td>
</tr>
<tr>
<td>local_iterator</td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td>const_local_iterator</td>
<td>桶迭代器的 const 版本</td>
</tr>
<tr>
<td>c.begin(n)，c.end(n)</td>
<td>桶 n 的首元素迭代器和尾后迭代器</td>
</tr>
<tr>
<td>c.cbegin(n)，c.cend(n)</td>
<td>与前两个函数类型，返回 const_local_iterator</td>
</tr>
<tr>
<td>c.load_factor()</td>
<td>每个桶的平均元素数量，返回 float 值</td>
</tr>
<tr>
<td>c.max_load_factor()</td>
<td>c 试图维护的平均桶大小，返回 float 值。c 会在需要时添加新的桶，以使得 load_factor &lt;&#x3D; max_load_factor</td>
</tr>
<tr>
<td>c.rehash(n)</td>
<td>重组存储，使得 bucket_count &gt;&#x3D; n 且 bucket_count &gt; size&#x2F;max_load_factor</td>
</tr>
<tr>
<td>c.reserve(n)</td>
<td>重组存储，使得 c 可以保存 n 个元素且不必 rehash</td>
</tr>
</tbody></table>
</li>
<li><p><strong>关键字类型要求</strong></p>
<ul>
<li><p><strong>描述</strong></p>
<blockquote>
<p>1、默认情况下，<strong>无序容器</strong>使用<strong>关键字类型的</strong><code>==</code><strong>运算符</strong>来<strong>比较元素</strong>，他们还使用一个<code>hash&lt;key_type&gt;</code><strong>类型对象</strong>来生成每个元素的<strong>哈希值</strong><br>2、<strong>标准库</strong>为<strong>内置类型</strong>(包括指针)提供了<code>hash</code><strong>模板</strong>，还为一些<strong>标准库类型</strong>(如<code>string</code>、智能指针等)定义了<code>hash</code>。因此，我们可以直接定义<strong>关键字类型</strong>是<strong>内置类型</strong>和<strong>标准库类型</strong>的<strong>无序容器</strong><br>3、但是，我们<strong>不能</strong>直接定义<strong>关键字类型</strong>为<strong>自定义类类型</strong>的<strong>无序容器</strong>。与<strong>容器</strong>不同，不能直接使用<strong>哈希模板</strong>，而是<strong>必须提供</strong>我们<strong>自己的</strong><code>hash</code><strong>模板版本</strong>，我们将在后续介绍如何做到这点</p>
</blockquote>
</li>
<li><p><strong>定义重载函数</strong></p>
<blockquote>
<p>1、我们<strong>不使用默认的</strong><code>hash</code>，而是用另一种办法，类似于为<strong>有序容器</strong>重载<strong>关键字类型的默认比较操作</strong><br>2、为了能将<code>Sales_data</code><strong>用作关键字</strong>，我们需要<strong>提供函数</strong>来代替<code>==</code><strong>运算符</strong>和<strong>哈希值计算函数</strong>。我们从定义这些<strong>重载函数</strong>开始，如下例<br>3、我们的<code>hasher</code>使用一个<strong>标准库</strong><code>hash</code><strong>类型对象</strong>来计算<code>ISBN</code><strong>成员</strong>的<strong>哈希值</strong>，该<code>hash</code><strong>类型</strong>建立在<code>string</code><strong>类型</strong>之上。类似的，<code>eq0p</code>通过<strong>比较</strong><code>ISBN</code>号来<strong>比较两个</strong><code>Sales_data</code><br>4、接着如下，我们使用<strong>这些函数</strong>来<strong>定义一个</strong><code>unordered_multiset</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token function">hasher</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>sd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">hash</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sd<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">bool</span> <span class="token function">eq0p</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> lhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> rhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">using</span> SD_multiset <span class="token operator">=</span> unordered_multiset<span class="token operator">&lt;</span>Sales_data<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>hasher<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>eq0p<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token comment">// 参数是桶大小、哈希函数指针 和 相等性判断运算符指针</span>
SD_multiset <span class="token function">bookstore</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> hasher<span class="token punctuation">,</span> eq0p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<hr>
<h3 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a><strong>动态内存</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：动态内存与智能指针；<code>shared_ptr</code>类(智能指针)；定义与使用智能指针；智能指针操作；<code>make_shared</code>函数；<code>shared_ptr</code>的拷贝与赋值；<code>shared_ptr</code>的销毁与释放；设计使用动态生存期资源的类；直接管理内存(动态内存指针)；<code>new</code>动态分配和初始化对象；<code>delete</code>释放内存；结合使用与异常；<code>shared_ptr</code>和<code>new</code>结合使用；智能指针和异常；自定义的释放；其他智能指针；<code>unique_ptr</code>类；<code>weak_ptr</code>类；设计核查指针类；动态数组；<code>new</code>和动态数组；智能指针管理动态数组；<code>allocator</code>类；使用标准库：文本查询程序</p>
</blockquote>
</div>

<h4 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a><strong>动态内存与智能指针</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、我们的程序到目前为止只使用过<strong>静态内存</strong>或<strong>栈内存</strong>。<strong>静态内存</strong>用来保存<strong>局部</strong><code>static</code><strong>对象</strong>、<strong>类</strong><code>static</code><strong>数据成员</strong>以及<strong>定义在任何函数外的变量</strong>；<strong>栈内存</strong>用来保存<strong>定义在函数内</strong>的<strong>非</strong><code>static</code><strong>对象</strong><br>2、分配在<strong>静态内存</strong>或<strong>栈内存</strong>中的对象<strong>由编译器自动创建和销毁</strong>。对于<strong>栈对象</strong>，仅在其<strong>定义的程序块运行时</strong>才存在；而<code>static</code><strong>对象</strong>在<strong>使用之前分配</strong>，<strong>程序结束时销毁</strong><br>3、除了<strong>静态内存</strong>和<strong>栈内存</strong>，每个程序还拥有一个<strong>内存池</strong>，这部分内存被称作<strong>自由空间</strong>或<strong>堆</strong>。程序用<strong>堆</strong>来存储<strong>动态分配的对象</strong>(即程序运行时分配的对象)<br>4、<strong>动态对象</strong>的<strong>生存期由程序控制</strong>，也就是说，当<strong>动态对象不使用时</strong>，代码必须<strong>显式地销毁它们</strong>。虽然使用<strong>动态内存</strong>有时是必要的，但正确地<strong>管理动态内存</strong>是非常棘手的</p>
</blockquote>
</li>
<li><p><strong>动态内存</strong></p>
<blockquote>
<p>1、<strong>动态内存的管理</strong>是通过<strong>一对运算符</strong>来完成的：<code>new</code>在<strong>动态内存</strong>中为对象<strong>分配空间</strong>并<strong>返回指向该对象的指针</strong>，我们可以选择对对象进行<strong>初始化</strong>；<code>delete</code>接受一个<strong>动态对象指针</strong>，<strong>销毁该对象</strong>并<strong>释放关联的内存</strong><br>2、<strong>动态内存的使用</strong>很容易出问题，因为确保<strong>在正确的时机释放内存</strong>是十分困难的。有时我们会<strong>忘记释放内存</strong>，就会产生<strong>内存泄漏</strong>；有时在<strong>尚有指针引用内存时释放</strong>，就会产生<strong>引用非法内存的指针</strong></p>
</blockquote>
</li>
<li><p><strong>智能指针</strong></p>
<blockquote>
<p>1、为了<strong>更安全便捷</strong>地使用<strong>动态内存</strong>，新的标准库提供了两种<strong>智能指针类型</strong>来<strong>管理动态对象</strong>，它们都定义在<code>memory</code><strong>头文件</strong>中<br>2、<strong>智能指针</strong>的行为<strong>类似常规指针</strong>，重要的区别是它负责<strong>自动释放所指向的对象</strong><br>3、新标准库提供的<strong>两种智能指针</strong>区别在于<strong>管理底层指针的方式</strong>：<code>shared_ptr</code>允许<strong>多个指针指向同个对象</strong>，<code>unique_ptr</code>则<strong>独占所指向的对象</strong><br>4、标准库还定义了一个<strong>名为</strong><code>weak_ptr</code><strong>的伴随类</strong>，它是一种<strong>弱引用</strong>，<strong>指向</strong><code>shared_ptr</code><strong>所管理的对象</strong></p>
</blockquote>
</li>
</ul>
<h4 id="shared-ptr-类-智能指针"><a href="#shared-ptr-类-智能指针" class="headerlink" title="shared_ptr 类(智能指针)"></a><strong>shared_ptr 类(智能指针)</strong></h4><ul>
<li><p><strong>定义与使用智能指针</strong></p>
<blockquote>
<p>1、类似于<code>vector</code>，<strong>智能指针</strong>也是<strong>模板</strong>。因此，当我们<strong>创建智能指针</strong>时，必须<strong>在尖括号内</strong>提供<strong>额外的信息</strong>，即提供<strong>指针指向的类型</strong><br>2、<strong>默认初始化</strong>的<strong>智能指针</strong>中保存着一个<strong>空指针</strong>，我们将在后续介绍<strong>初始化智能指针</strong>的其他方法<br>3、智能指针<strong>使用方式与普通指针类似</strong>，<strong>解引用</strong>一个智能指针<strong>返回它指向的对象</strong>。如果在一个<strong>条件判断中使用智能指针</strong>，效果为<strong>检测它是否为空</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>        <span class="token comment">// shared_ptr，可以指向 string</span>
shared_ptr<span class="token operator">&lt;</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> p2<span class="token punctuation">;</span>     <span class="token comment">// shared_ptr，可以指向 int 的 list</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">&amp;&amp;</span> p1 <span class="token operator">-></span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment">// 如果智能指针 p1 不为空，其指向的 string 对象也不为空</span>
  <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token string">"hi"</span><span class="token punctuation">;</span>                 <span class="token comment">// 解引用 p1，将一个新值赋予 string 对象</span></code></pre>
</li>
<li><p><strong>智能指针操作</strong></p>
<table>
<thead>
<tr>
<th>智能指针通用的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>shared_ptr&lt;T&gt; sp，unique_ptr&lt;T&gt; up</td>
<td>空智能指针，可以指向类型为 T 的对象</td>
</tr>
<tr>
<td>p</td>
<td>将 p 用作一个条件判断，若 p 指向一个对象(即 p 不为空)，则为 true</td>
</tr>
<tr>
<td>*p</td>
<td>解引用 p，得到它指向的对象</td>
</tr>
<tr>
<td>p-&gt;mem</td>
<td>等价于(*p).mem</td>
</tr>
<tr>
<td>p.get()</td>
<td>返回 p 中保存的指针(内置指针类型)。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</td>
</tr>
<tr>
<td>swap(p, q)，p.swap(q)</td>
<td>交换 p 和 q 中的指针</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>shared_ptr 独有的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>make_shared&lt;T&gt;(args)</td>
<td>返回一个 shared_ptr，指向一个动态分配的类型为 T 的对象。使用 args 初始化此对象</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(q)</td>
<td>p 是 shared_ptr q 的拷贝；此操作会递增 q 中的引用计数器。q 中的指针必须能转换为 T*</td>
</tr>
<tr>
<td>p &#x3D; q</td>
<td>p 和 q 都是 shared_ptr，所保存的指针必须能相互转换。此操作会递减 p 的引用计数，递增 q 的引用计数；若 p 的引用计数变为 0，则将其管理的原内存释放</td>
</tr>
<tr>
<td>p.use_count()</td>
<td>返回与 p 共享对象的智能指针的数量；可能很慢，主要用于调试</td>
</tr>
<tr>
<td>p.unique()</td>
<td>若 p.use_count() 为 1，返回 true，否则返回 false</td>
</tr>
</tbody></table>
</li>
<li><p><strong>make_shared 函数</strong></p>
<blockquote>
<p>1、<strong>最安全</strong>的<strong>分配和使用动态内存</strong>的方法是调用<code>memory</code><strong>头文件</strong>中定义的<code>make_shared</code>函数：<code>make_shared&lt;T&gt;(args)</code><br>2、该函数在<strong>动态内存</strong>中<strong>分配一个对象</strong>并<strong>初始化</strong>，返回<strong>指向此对象的</strong><code>shared_ptr</code><br>3、当要用<code>make_shared</code>时，必须<strong>指定要创建的对象的类型</strong>，定义方式与<strong>模板</strong>类似<br>4、类似于<strong>顺序容器</strong>的<code>emplace</code><strong>成员函数</strong>，<code>make_shared</code>也可以用其参数来<strong>构造给定类型的对象</strong>，在其后面的<strong>小括号</strong>中<strong>给出参数</strong>调用该类的<strong>构造函数</strong>。如果不传递任何参数，则会进行<strong>值初始化</strong><br>5、我们通常用<code>auto</code><strong>定义一个对象</strong>保存<code>make_shared</code>的结果，这种定义方法比较简单</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 指向一个值为 42 的 int 的 shared_ptr</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 指向一个值为 "9999999999" 的 string</span>
shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 指向一个值初始化的 int，即值为 0</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 auto 定义对象更方便地保存结果</span>
<span class="token comment">// p4 指向一个动态分配的空 vector&lt;string></span>
<span class="token keyword">auto</span> p4 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>shared_ptr 的拷贝与赋值</strong></p>
<blockquote>
<p>1、当进行<strong>拷贝或赋值</strong>操作时，每个<code>shared_ptr</code>都会<strong>记录有多少个其他</strong><code>shared_ptr</code><strong>指向相同的对象</strong><br>2、我们可以认为，每个<code>shared_ptr</code>都有一个<strong>关联的计数器</strong>，通常称其为<strong>引用计数</strong>。无论何时我们<strong>拷贝一个</strong><code>shared_ptr</code>，<strong>计数器就会递增</strong><br>3、例如，当用一个<code>shared_ptr</code><strong>初始化另一个</strong><code>shared_ptr</code>时，或将它<strong>作为参数传递</strong>给一个函数时，或<strong>作为函数返回值</strong>时，它所关联的<strong>计数器就会递增</strong>。反之，当我们给<code>shared_ptr</code><strong>赋予新值</strong>，或者<strong>某个</strong><code>shared_ptr</code><strong>被销毁</strong>，<strong>计数器就会递减</strong><br>4、一旦一个<code>shared_ptr</code>的<strong>计数器变为 0</strong>，它就会<strong>自动释放自己所管理的对象</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// p 指向的对象只有 1 个引用者</span>
<span class="token keyword">auto</span> <span class="token function">q</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// q 和 p 指向相同对象，此对象有 2 个引用者</span>

<span class="token keyword">auto</span> r <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// r 指向的对象只有 1 个引用者</span>
r <span class="token operator">=</span> q<span class="token punctuation">;</span>                            <span class="token comment">// 给 r 赋值，令它指向另一个地址</span>
<span class="token comment">// 此时，将递增 q 指向对象的引用计数，递减 r 原先指向对象的引用计数</span>
<span class="token comment">// 而 r 原先指向的对象的引用计数变为 0，没有引用者，将自动释放内存</span></code></pre>
</li>
<li><p><strong>shared_ptr 的销毁与释放</strong></p>
<ul>
<li><p><strong>析构函数与销毁对象</strong></p>
<blockquote>
<p>1、当<strong>指向一个对象</strong>的<strong>最后一个</strong><code>shared_ptr</code><strong>被销毁</strong>时，<code>shared_ptr</code>会<strong>自动销毁此对象</strong>。它是通过另一个<strong>特殊的成员函数</strong>——<strong>析构函数</strong>完成<strong>销毁工作</strong>的<br>2、类似于<strong>构造函数</strong>，<strong>每个类</strong>都有一个<strong>析构函数</strong>。就像<strong>构造函数</strong>控制<strong>对象初始化</strong>一样，<strong>析构函数</strong>控制<strong>对象销毁时做的操作</strong><br>3、<strong>析构函数</strong>一般用来<strong>释放对象所分配的资源</strong>。例如<code>string</code>的<strong>构造函数</strong>会<strong>分配内存</strong>来保存字符，而<code>string</code>的<strong>析构函数</strong>就负责<strong>释放这些内存</strong><br>4、<code>shared_ptr</code>的<strong>析构函数</strong>会<strong>递减</strong>它指向的对象的<strong>引用计数</strong>，当<strong>引用计数变为 0</strong>，<strong>析构函数</strong>就会<strong>销毁对象</strong>，并<strong>释放内存</strong></p>
</blockquote>
</li>
<li><p><code>shared_ptr</code><strong>能自动释放相关联的内存</strong></p>
<blockquote>
<p>1、当<strong>动态内存不再使用时</strong>，<code>shared_ptr</code><strong>类</strong>会<strong>自动释放动态对象</strong>，这一特性使得<strong>动态内存的使用</strong>变得十分容易，如下例<br>2、由于<strong>最后一个</strong><code>shared_ptr</code><strong>销毁前</strong>内存都<strong>不会释放</strong>，所以<strong>保证</strong><code>shared_ptr</code><strong>无用后销毁</strong>十分重要。如果<strong>忘记销毁无用的</strong><code>shared_ptr</code>，程序仍能<strong>正确执行</strong>，但会<strong>浪费内存</strong><br>3、<code>shared_ptr</code><strong>无用后仍保留</strong>的一种可能情况是：将<code>shared_ptr</code><strong>存放在一个容器中</strong>，随后<strong>重排了容器</strong>，从而<strong>不再需要某些元素</strong>。这种情况下，应确保及时手动<strong>用</strong><code>erase</code><strong>删除无用的</strong><code>shared_ptr</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 该函数返回一个 shared_ptr，指向一个 Foo 类型的动态分配对象，对象通过一个类型为 T 的参数 arg 初始化</span>
shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">factory</span><span class="token punctuation">(</span>T arg<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">></span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">use_factory</span><span class="token punctuation">(</span>T arg<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...此处省略使用 p 的代码</span>
<span class="token punctuation">&#125;</span>   <span class="token comment">// p 离开了作用域，它指向的内存会被自动释放</span>

shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> <span class="token function">use_factory2</span><span class="token punctuation">(</span>T arg<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...此处省略使用 p 的代码</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>     <span class="token comment">// 返回 p 时，引用计数递增</span>
<span class="token punctuation">&#125;</span>   <span class="token comment">// p 离开了作用域，但引用递增不为 0，不会被销毁</span></code></pre></li>
</ul>
</li>
<li><p><strong>设计使用动态生存期资源的类</strong></p>
<ul>
<li><p><strong>使用动态内存的场景</strong></p>
<blockquote>
<p>1、程序不知道<strong>自己需要使用多少对象</strong><br>2、程序不知道<strong>所需对象的准确类型</strong><br>3、程序需要在<strong>多个对象间共享数据</strong></p>
</blockquote>
</li>
<li><p><strong>因共享数据而使用动态内存的情景</strong></p>
<blockquote>
<p>1、<strong>容器类</strong>是出于上述<strong>第一种原因</strong>而使用<strong>动态内存</strong>的典型例子；我们还将在 15 章见到出于<strong>第二种原因</strong>而使用<strong>动态内存</strong>的例子；而在此，我们将举出因<strong>第三种原因</strong>而使用<strong>动态内存</strong>的例子<br>2、到目前为止，我们<strong>使用过的类</strong>中，<strong>分配的资源</strong>具有<strong>与原对象一致的生存期</strong>。例如每个<code>vector</code>都<strong>拥有</strong>自己的<strong>元素</strong>，当我们<strong>拷贝</strong><code>vector</code>时，<strong>原</strong><code>vector</code>和<strong>副本</strong><code>vector</code>中的<strong>元素是相互分离的</strong>。此外，一个<code>vector</code><strong>的元素</strong>只有当这个<code>vector</code><strong>还存在时才存在</strong>，当<code>vector</code><strong>被销毁</strong>，则<strong>对应元素也销毁</strong><br>3、但<strong>某些类</strong>中，<strong>分配的资源</strong>具有<strong>与原对象相独立的生存期</strong>。例如，假设我们希望<strong>定义一个名为</strong><code>Blob</code><strong>的类</strong>，保存一组元素。与容器不同，我们希望<code>Blob</code><strong>对象</strong>的<strong>不同拷贝</strong>之间<strong>共享相同的元素</strong>。即，当我们<strong>拷贝一个</strong><code>Blob</code><strong>元素</strong>时，<strong>原</strong><code>Blob</code>和<strong>副本</strong><code>Blob</code>应该<strong>引用相同的底层元素</strong><br>4、一般而言，如果<strong>两个对象共享底层的数据</strong>，当<strong>某个对象被销毁</strong>时，不能<strong>单方面销毁底层数据</strong>。此外，<strong>允许多个对象共享相同的状态</strong>是<strong>使用动态内存</strong>的一个很常见的原因</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Blob<span class="token operator">&lt;</span>string<span class="token operator">></span> b1<span class="token punctuation">;</span>                              <span class="token comment">// 空 blob</span>
<span class="token comment">// 任意一个新作用域</span>
<span class="token punctuation">&#123;</span>
    Blob<span class="token operator">&lt;</span>string<span class="token operator">></span> b2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"an"</span><span class="token punctuation">,</span> <span class="token string">"the"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    b1 <span class="token operator">=</span> b2<span class="token punctuation">;</span>                                  <span class="token comment">// b1 和 b2 共享相同的元素</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 此时 b2 由于离开作用域而被销毁，但其元素不能被销毁，因为 b1 仍指向这些元素</span></code></pre>
</li>
<li><p><strong>定义</strong><code>StrBlob</code><strong>类</strong></p>
<blockquote>
<p>1、由于后续才会学习<strong>模板</strong>有关内容，因此现在我们先定义一个<strong>管理</strong><code>string</code><strong>的类</strong>，命名为<code>StrBlob</code>，如下例<br>2、实现一个新的<strong>集合类型</strong>的最简单方法是<strong>使用某个标准库容器来管理元素</strong>。采用这种方法，我们可以借助<strong>标准库类型</strong>管理<strong>元素所使用的内存</strong>。本例中，我们将<strong>使用</strong><code>vector</code><strong>保存元素</strong>。但是，我们不能在一个<code>Blob</code><strong>对象</strong>内<strong>直接保存</strong><code>vector</code>，因为一个<strong>对象的成员</strong>在<strong>对象销毁时</strong>也会<strong>被销毁</strong>。为了保证<strong>元素继续存在</strong>，我们将<code>vector</code>保存在<strong>动态内存</strong>中<br>3、为了实现我们希望的<strong>数据共享</strong>，我们为每个<code>StrBlob</code>设置了一个<code>shared_ptr</code>来<strong>管理动态分配的</strong><code>vector</code>，使用<strong>动态指针</strong>能自动完成对<code>vector</code>的<strong>管理与释放</strong>。此外，我们还需要为<strong>类</strong>定义一些<strong>操作</strong>和<strong>构造函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;initializer_list></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>initializer_list<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>make_shared<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">StrBlob</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 定义类型</span>
        <span class="token keyword">using</span> size_type <span class="token operator">=</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token double-colon punctuation">::</span>size_type<span class="token punctuation">;</span>

        <span class="token comment">// 构造函数(使用初始化列表构造)</span>
        <span class="token function">StrBlob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">StrBlob</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">></span> il<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span></span></span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 成员函数，其中 data-> 实际上就是使用 vector 的成员函数</span>
        size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> data<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> data<span class="token operator">-></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 添加或删除元素</span>
        <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            data<span class="token operator">-></span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 元素访问</span>
        string <span class="token operator">&amp;</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        string <span class="token operator">&amp;</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token comment">// 动态指针操控的动态内存数据成员</span>
        shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> data<span class="token punctuation">;</span>
        <span class="token comment">// 检查操作，如果 data[i] 不合法，抛出一个异常</span>
        <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span>size_type i<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>元素访问成员函数</strong></p>
<blockquote>
<p>1、由于要使用<code>pop_back</code>、<code>front</code>、<code>back</code><strong>操作访问</strong><code>vector</code><strong>中的元素</strong>，且它们在<strong>访问元素前</strong>都必须<strong>检查元素是否存在</strong>，因此我们定义了一个名为<code>check</code>的<code>private</code><strong>工具函数</strong>，用于<strong>检查给定索引是否在合法范围内</strong>。该函数还<strong>接受一个</strong><code>string</code>，会将此参数传递给<strong>异常处理程序</strong>，<code>string</code>用于<strong>描述错误内容</strong><br>2、<code>pop_back</code>和<strong>元素访问成员函数</strong>首先调用<code>check</code>，如果<code>check</code>成功，再继续<strong>利用底层</strong><code>vector</code><strong>的操作</strong>完成自己的工作</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">StrBlob</span><span class="token double-colon punctuation">::</span><span class="token function">check</span><span class="token punctuation">(</span>size_type i<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> data<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

string <span class="token operator">&amp;</span><span class="token class-name">StrBlob</span><span class="token double-colon punctuation">::</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 vector 为空，check 会抛出一个异常</span>
    <span class="token function">check</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"front on empty StrBlob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> data<span class="token operator">-></span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

string <span class="token operator">&amp;</span><span class="token class-name">StrBlob</span><span class="token double-colon punctuation">::</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 vector 为空，check 会抛出一个异常</span>
    <span class="token function">check</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"back on empty StrBlob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> data<span class="token operator">-></span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token class-name">StrBlob</span><span class="token double-colon punctuation">::</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 vector 为空，check 会抛出一个异常</span>
    <span class="token function">check</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"pop_back on empty StrBlob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token operator">-></span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><code>StrBlob</code><strong>的拷贝、赋值和销毁</strong></p>
<blockquote>
<p>1、类似先前设计的<code>Sales_data</code><strong>类</strong>，<code>StrBlob</code><strong>类</strong>也使用<strong>默认版本</strong>的拷贝、赋值和销毁<strong>成员函数</strong>来对<strong>此类对象</strong>进行<strong>这些操作</strong><br>2、我们的<code>StrBlob</code>只有一个<strong>数据成员</strong>，它是<code>shared_ptr</code>类型。因此当我们对<code>StrBlob</code><strong>对象</strong>执行这些操作时，它的<code>shared_ptr</code><strong>成员</strong>就会被执行这些操作<br>3、如前所述，使用了<strong>智能指针</strong>，其会<strong>自动统计引用计数</strong>，且会在<strong>引用计数为 0</strong>时<strong>自动销毁</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="直接管理内存-动态内存指针"><a href="#直接管理内存-动态内存指针" class="headerlink" title="直接管理内存(动态内存指针)"></a><strong>直接管理内存(动态内存指针)</strong></h4><ul>
<li><p><strong>new 动态分配和初始化对象</strong></p>
<ul>
<li><p><code>new</code><strong>的使用</strong></p>
<blockquote>
<p>1、<strong>C++<strong>定义了两个运算符来</strong>分配和释放动态内存</strong>：<code>new</code><strong>分配内存</strong>，<code>delete</code><strong>释放内存</strong>。但相对于<strong>智能指针</strong>，这两个运算符<strong>非常容易出错</strong>；而且，<strong>自己直接管理内存的类</strong>和<strong>使用智能指针的类</strong>不同，它们<strong>不能依赖类对象</strong>进行拷贝、赋值和销毁操作的<strong>任何默认定义</strong><br>2、在<strong>自由空间</strong>分配的内存是<strong>无名的</strong>，因此<code>new</code><strong>无法为其分配的对象命名</strong>，而是返回一个<strong>指向该对象的指针</strong>(动态内存指针&#x2F;内置指针)。默认情况下，<strong>动态分配</strong>的对象是<strong>默认初始化</strong>的，此外我们也可以用其他一些通用的初始化方式<br>3、对于<strong>定义了自己的构造函数</strong>的<strong>类类型</strong>，要求<strong>值初始化</strong>是<strong>没有意义</strong>的，不管采用什么形式，对象都会通过<strong>默认构造函数</strong>来<strong>初始化</strong>；但对于<strong>内置类型</strong>，两种形式就差别较大了，<strong>值初始化</strong>的<strong>内置类型对象</strong>有着<strong>已定义良好的值</strong>，而<strong>默认初始化</strong>的对象的<strong>值是未定义的</strong>；类似的，对于类中依赖于<strong>编译器合成的默认构造函数</strong>的<strong>内置类型成员</strong>，如果它们<strong>未在类内初始化</strong>，那么它们的<strong>值也是未定义的</strong><br>4、出于与<strong>变量初始化</strong>相同的原因，对<strong>动态分配的对象</strong>进行<strong>初始化</strong>通常总是个好主意</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                    <span class="token comment">// pi 指向一个动态分配的、未初始化的无名 int 对象</span>
string <span class="token operator">*</span>ps <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">;</span>              <span class="token comment">// 初始化为空 string</span>

<span class="token keyword">int</span> <span class="token operator">*</span>pi2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// pi2 指向的对象的值为 1024</span>
string <span class="token operator">*</span>ps2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ps2 指向的对象的值为 "9999999999"</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">*</span>pv2 <span class="token operator">=</span> <span class="token keyword">new</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

string <span class="token operator">*</span>ps3 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">;</span>             <span class="token comment">// 默认初始化为空的 string</span>
string <span class="token operator">*</span>ps4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 值初始化为空的 string</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                   <span class="token comment">// 默认初始化，但 *pi3 的值未定义</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 值初始化为 0，即 *pi4 的值为 0</span></code></pre>
</li>
<li><p><strong>有关</strong><code>auto</code><strong>和</strong><code>const</code></p>
<blockquote>
<p>1、如果我们提供了一个<strong>小括号包括</strong>的<strong>初始化器</strong>，就可以使用<code>auto</code>从该<strong>初始化器</strong>来推断我们<strong>想要分配的对象的类型</strong><br>2、由于编译器要用<strong>初始化器的类型</strong>来推断<strong>分配的类型</strong>，只有当括号中<strong>仅有单一初始化器</strong>时才可以使用<code>auto</code><br>3、用<code>new</code>分配<code>const</code><strong>对象</strong>是<strong>合法的</strong>。类似于其他任何<code>const</code><strong>对象</strong>，一个<strong>动态分配</strong>的<code>const</code><strong>对象必须进行初始化</strong>，且由于<strong>分配的对象</strong>是<code>const</code>的，其返回的指针也是<strong>指向</strong><code>const</code><strong>的指针</strong><br>4、对于一个定义了<strong>默认构造函数</strong>的<strong>类类型</strong>，其<code>const</code><strong>动态对象</strong>可以<strong>隐式初始化</strong>，而<strong>其他类型的对象</strong>必须<strong>显式初始化</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// p 指向一个与 obj 类型相同的对象，该对象用 obj 进行值初始化</span>
<span class="token keyword">auto</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 错误：括号中只能有单个初始化器</span>
<span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 分配并初始化一个 const int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 分配并默认初始化一个 const 的空 string</span>
<span class="token keyword">const</span> string <span class="token operator">*</span>pcs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> string<span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>内存耗尽</strong></p>
<blockquote>
<p>1、虽然现代计算机通常都配备了大容量内存，但<strong>自由空间被耗尽</strong>的情况还是<strong>有可能发生</strong>。一旦一个程序<strong>用光了所有可用内存</strong>，<code>new</code><strong>就会失败</strong>，并且默认情况下<strong>抛出类型为</strong><code>bad_alloc</code><strong>的异常</strong><br>2、我们可以改变使用<code>new</code>的方式来<strong>阻止它抛出异常</strong>(如下)，我们称<strong>这种形式</strong>的<code>new</code>为<strong>定位 new</strong>，<strong>定位 new</strong>允许我们<strong>向</strong><code>new</code><strong>传递额外的参数</strong><br>3、在此例中，我们传递给它一个<strong>标准库定义的</strong><code>nothrow</code><strong>对象</strong>，意图是告诉它<strong>不抛出异常</strong>。这种形式的<code>new</code>如果<strong>不能分配内存</strong>，就会<strong>返回一个空指针</strong><br>4、<code>bad_alloc</code>和<code>nothrow</code>都定义在<strong>头文件</strong><code>new</code>中</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>                <span class="token comment">// 如果分配失败，抛出 std::bad_alloc 异常</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">;</span>      <span class="token comment">// 如果分配失败，不抛出异常，返回空指针</span></code></pre></li>
</ul>
</li>
<li><p><strong>delete 释放内存</strong></p>
<ul>
<li><p><strong>释放动态内存</strong></p>
<blockquote>
<p>1、为了防止<strong>内存耗尽</strong>，在<strong>动态内存使用完毕</strong>后，必须将其<strong>归还给系统</strong>。我们通过<code>delete</code>来将<strong>动态内存归还</strong><br>2、<code>delete</code>接受一个<strong>指针</strong>，指向我们想要<strong>释放的对象</strong>：<code>delete p;</code>(p 必须指向动态分配对象或空指针)<br>3、与<code>new</code>类似，<code>delete</code>也执行<strong>两个动作</strong>：<strong>销毁对象</strong>和<strong>释放内存</strong></p>
</blockquote>
</li>
<li><p><strong>指针值与</strong><code>delete</code></p>
<blockquote>
<p>1、我们传递给<code>delete</code>的指针必须指向<strong>动态分配的内存</strong>或是<strong>空指针</strong>。释放一块并非<code>new</code>分配的内存，或者将相同指针值释放多次，其<strong>行为未定义</strong><br>2、如下例，对于<code>delete i;</code>的请求，<strong>编译器</strong>会<strong>生成错误信息</strong>，因为<strong>编译器知道 i 不是一个指针</strong>。但对于<code>pi1</code><strong>和</strong><code>pi2</code><strong>所产生的错误</strong>却更具有<strong>潜在危害</strong>：<br>3、通常情况下，<strong>编译器不能分辨</strong>一个指针指向的是<strong>静态分配</strong>还是<strong>动态分配</strong>的对象，类似的，它<strong>也不能分辨</strong>一个指针所指向的<strong>内存是否已经释放</strong>了。对于这些<code>delete</code>，大多数<strong>编译器</strong>会<strong>编译通过</strong>，但它们<strong>本身是错误的</strong><br>4、虽然一个<code>const</code>对象的值<strong>不能被改变</strong>，但它本身<strong>可以被销毁</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// i 是整型，pi1 是整型静态指针，pi2 是空指针</span>
<span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>pi1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">*</span>pi2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token comment">// pd 指向动态分配的 double 对象，pd2 与 pd 指向相同动态对象</span>
<span class="token keyword">double</span> <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>pd2 <span class="token operator">=</span> pd<span class="token punctuation">;</span>

<span class="token keyword">delete</span> i<span class="token punctuation">;</span>               <span class="token comment">// 错误：i 不是一个指针</span>
<span class="token keyword">delete</span> pi1<span class="token punctuation">;</span>             <span class="token comment">// 未定义：pi1 指向一个局部变量(不是动态对象)</span>
<span class="token keyword">delete</span> pi2<span class="token punctuation">;</span>             <span class="token comment">// 正确，可以释放空指针</span>
<span class="token keyword">delete</span> pd<span class="token punctuation">;</span>              <span class="token comment">// 正确</span>
<span class="token keyword">delete</span> pd2<span class="token punctuation">;</span>             <span class="token comment">// 未定义：pd2 指向的内存已经被释放了</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>pci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> pci<span class="token punctuation">;</span>             <span class="token comment">// 正确，可以释放 const 动态对象</span></code></pre>
</li>
<li><p><strong>生存期直到被释放</strong></p>
<blockquote>
<p>1、如前所述，由<code>shared_ptr</code><strong>管理的内存</strong>在最后一个<code>shared_ptr</code>销毁时<strong>会自动释放</strong>，但对于<strong>动态内存指针</strong>来说就不是这样了，其在被<strong>显式释放</strong>之前<strong>始终存在</strong><br>2、返回<strong>指向动态内存的指针</strong>的<strong>函数</strong>给其调用者增加了一个<strong>额外负担</strong>——调用者必须记得<strong>释放内存</strong><br>3、如下例，我们<strong>重写</strong>之前已定义的<code>factory</code>和<code>use_factory</code><strong>函数</strong>，必须做如下修改</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// factory 返回一个指针，指向一个动态分配的对象</span>
Foo <span class="token operator">*</span><span class="token function">factory</span><span class="token punctuation">(</span>T arg<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// ...此处省略处理 arg 的代码</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 调用者必须负责释放此内存</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">use_factory</span><span class="token punctuation">(</span>T arg<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Foo <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 调用了 factory，就必须记得释放 p 的内存</span>
    <span class="token comment">// ... 此处省略使用 p 的代码</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>                           <span class="token comment">// 如果已经不再需要 p，必须释放掉 p 的内存</span>
<span class="token punctuation">&#125;</span>   <span class="token comment">// 如果忘记 delete 的话，即使离开了作用域，p 的内存仍然没有被释放</span></code></pre>
</li>
<li><p><code>delete</code><strong>后重置指针值</strong></p>
<blockquote>
<p>1、当我们<code>delete</code>一个指针后，<strong>指针值</strong>就变得<strong>无效</strong>了。虽然指针已经无效，但在很多机器上<strong>指针仍然保存着动态内存的地址</strong>，这被称为<strong>空悬指针</strong><br>2、<strong>未初始化指针</strong>的所有缺点<strong>空悬指针</strong>都有(例如由于数据被释放，地址指向的数据未定义，但指针仍可能被不知情地调用)。有一种办法可以<strong>避免空悬指针</strong>的问题：在指针即将<strong>离开作用域之前释放内存</strong>，这样在<strong>关联内存被释放</strong>后就没有机会继续使用指针了<br>3、如果我们需要<strong>保留指针</strong>，可以在<code>delete</code>后将<code>nullptr</code><strong>赋予指针</strong>，这样就清楚地指出<strong>指针不指向任何对象</strong><br>4、<strong>动态内存</strong>的一个基本问题是<strong>可能多个指针指向相同内存</strong>。在<code>delete</code>后<strong>重置指针</strong>的方法只对<strong>被直接操作重置的指针</strong>有效，对于其他<strong>指向相同内存的指针</strong>无效。在实际系统中，查找<strong>指向相同内存</strong>的<strong>所有指针</strong>是<strong>异常困难</strong>的，因此<strong>查找所有指针</strong>再依次<strong>重置指针值</strong>也是很难实现的</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// p 指向动态内存</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>                 <span class="token comment">// q 和 p 指向相同内存</span>
<span class="token keyword">delete</span> p<span class="token punctuation">;</span>                   <span class="token comment">// p 和 q 都变得无效</span>
p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>                <span class="token comment">// 重置 p 指出其不再绑定到任何对象</span>
<span class="token comment">// q 并没有被重置，q 仍然是一个空悬指针</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="结合使用与异常"><a href="#结合使用与异常" class="headerlink" title="结合使用与异常"></a><strong>结合使用与异常</strong></h4><ul>
<li><p><strong>shared_ptr 和 new 结合使用</strong></p>
<ul>
<li><p><strong>有关结合使用</strong></p>
<blockquote>
<p>1、如前所述，如果我们<strong>不初始化</strong>一个<strong>智能指针</strong>，它就会被初始化为一个<strong>空指针</strong>，借此我们还可以用<code>new</code><strong>返回的指针</strong>来<strong>初始化智能指针</strong><br>2、<strong>接受指针参数</strong>的<strong>智能指针构造函数</strong>是<code>explicit</code>的，因此我们不能将一个<strong>内置指针</strong>通过<strong>隐式转换</strong>变成<strong>智能指针</strong>，必须使用<strong>直接初始化</strong>来<strong>初始化智能指针</strong><br>3、出于相同的原因，也不能在一个<strong>返回</strong><code>shared_ptr</code><strong>的函数</strong>的返回语句中<strong>隐式转换普通指针</strong>，必须将<code>shared_ptr</code><strong>显式绑定</strong>到一个<strong>想要返回的指针</strong>上</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> p1<span class="token punctuation">;</span>                      <span class="token comment">// p1 可以指向一个 double，目前指向空指针</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 正确：使用直接初始化，p2 指向一个值为 42 的 int</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 错误：必须使用直接初始化形式</span>

shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 错误：不能隐式转换为 shared_ptr&lt;int></span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 正确：显式地用 int* 创建 shared_ptr&lt;int></span>
<span class="token punctuation">&#125;</span></code></pre>

<table>
<thead>
<tr>
<th>定义和改变 shared_ptr 的方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>shared_ptr&lt;T&gt; p(q)</td>
<td>p 管理内置指针 q 所指向的对象。q 必须要指向 new 分配的内存，且能够转换为 T* 类型</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(u)</td>
<td>p 从 unique_ptr u 那里接管了对象的所有权，将 u 置空</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(q, d)</td>
<td>p 接管了内置指针 q 所指向对象的所有权。q 必须能转换为 T* 类型，p 将使用可调用对象 d(<code>lambda</code>表达式或对象)来代替 delete</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(p2, d)</td>
<td>与 p(p2) 类似，p 是 p2 的拷贝，但 p 将用可调用对象 d 代替 delete</td>
</tr>
<tr>
<td>p.reset()，p.reset(q)，p.reset(q, d)</td>
<td>若 p 是唯一指向其对象的 shared_ptr，reset 会释放此对象。若传递了可选的参数内置指针 q，会令 p 指向 q，否则将 p 置空。若还传递了参数 d，将用可调用对象 d 代替 delete</td>
</tr>
</tbody></table>
</li>
<li><p><strong>不要混合使用普通指针和智能指针</strong></p>
<blockquote>
<p>1、<code>shared_ptr</code>可以<strong>协调对象的析构</strong>，但仅限于其<strong>自身的拷贝</strong>，这也是<strong>推荐使用</strong><code>make_shared</code><strong>而不是</strong><code>new</code>的原因。这样，我们就能在<strong>分配对象</strong>同时将<code>shared_ptr</code><strong>与之绑定</strong>，避免无意中将<strong>同一块内存</strong>绑定到<strong>多个独立创建的</strong><code>shared_ptr</code>上<br>2、考虑下例的函数。虽然<strong>不能传递给</strong><code>process</code><strong>内置指针</strong>，但可以传递一个<strong>临时的</strong><code>shared_ptr</code>，它是用一个<strong>内置指针显式构造</strong>的，但是这样做<strong>可能会导致错误</strong>。当<strong>调用结束</strong>，<strong>临时对象</strong>会<strong>被销毁</strong>，但<strong>原先的指针</strong>仍指向<strong>已释放的内存地址</strong>，成为<strong>空悬指针</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用 ptr</span>
<span class="token punctuation">&#125;</span>   <span class="token comment">// ptr 离开作用域，被销毁</span>

shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建 p，此时引用计数为 1</span>
<span class="token function">process</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">// 拷贝 p 会递增它的引用计数，在 process 中引用计数为 2</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>                               <span class="token comment">// 正确：离开函数时引用计数为 1，没有被销毁</span>

<span class="token comment">// 显式构造临时的 shared_ptr</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 危险：x 是一个普通指针，不是一个智能指针</span>
<span class="token function">process</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">// 错误：不能将 int* 转换成一个 shared_ptr&lt;int></span>
<span class="token function">process</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 合法，但内存会被释放</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>                               <span class="token comment">// 未定义：x 是一个空悬指针</span></code></pre>
</li>
<li><p><strong>不要用</strong><code>get</code><strong>初始化另一个智能指针或为其赋值</strong></p>
<blockquote>
<p>1、<strong>智能指针</strong>类型定义了一个<code>get</code><strong>函数</strong>(前表中提过)，它返回一个<strong>内置指针</strong>，指向智能指针<strong>管理的对象</strong><br>2、此函数是为了向<strong>不能使用智能指针的代码</strong>中传递一个<strong>内置指针</strong>的情况而设计的，使用<code>get</code>返回的指针的代码<strong>不能</strong><code>delete</code><strong>此指针</strong><br>3、虽然<strong>编译器不会给出错误</strong>，但将<strong>另一个智能指针</strong>也<strong>绑定到</strong><code>get</code><strong>返回的指针</strong>上是<strong>错误</strong>的</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 此时引用计数为 1</span>
<span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 正确：q 是内置指针，但使用 q 时要注意，不要让它被管理的指针被释放</span>
<span class="token comment">// 新程序块</span>
<span class="token punctuation">&#123;</span>
    <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 未定义：两个独立的 shared_ptr 指向相同的内存</span>
<span class="token punctuation">&#125;</span>   <span class="token comment">// 程序块结束，q 被销毁，它指向的内存被释放</span>
<span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>                             <span class="token comment">// 未定义：p 指向的内存已经被释放了</span></code></pre>
</li>
<li><p><strong>其他</strong><code>shared_ptr</code><strong>操作</strong></p>
<blockquote>
<p>1、<code>shared_ptr</code>还定义了<strong>其他一些操作</strong>(具体看前表)，比如我们可以<strong>用</strong><code>reset</code><strong>将一个新指针赋予一个</strong><code>shared_ptr</code><br>2、与赋值类型，<code>reset</code>会<strong>更新引用计数</strong>，需要时会<strong>释放 p 指向的对象</strong>。因此，<code>reset</code>常常和<code>unique</code>一起使用，<code>unique</code>检查<strong>智能指针</strong>的<strong>引用计数是否为 1</strong>，这样便可以<strong>控制多个</strong><code>shared_ptr</code><strong>共享的对象</strong><br>3、在<strong>改变底层对象</strong>之前，我们检查自己是否是<strong>当前对象仅有的用户</strong>(使用<code>unique</code>)；如果不是，在改变之前要<strong>制作一份新的拷贝</strong>以<strong>保证其他用户正常指向当前内存</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p<span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 错误：不能将一个指针赋予 shared_ptr</span>
p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 正确：p 指向一个新对象</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 我们不是唯一用户，分配新的拷贝(通过 new 拷贝 p 的值到新的地址)</span>
<span class="token operator">*</span>p <span class="token operator">+=</span> newVal<span class="token punctuation">;</span>                             <span class="token comment">// 现在我们知道自己是唯一用户，可以改变对象的值</span></code></pre></li>
</ul>
</li>
<li><p><strong>智能指针和异常</strong></p>
<ul>
<li><p><strong>发生异常时的内存释放</strong></p>
<blockquote>
<p>1、先前介绍过<strong>异常处理程序</strong>能在<strong>异常发生后</strong>令<strong>程序流程继续</strong>，我们注意到这种程序<strong>需要确保</strong>异常发生后<strong>资源能够被正确释放</strong><br>2、一个简单的<strong>确保资源被释放</strong>的方式是<strong>使用智能指针</strong>，这样即使<strong>程序块过早结束</strong>，<strong>智能指针类</strong>也能确保<strong>内存不再需要时被释放</strong>。如下函数，无论函数<strong>正常处理退出</strong>，还是<strong>发生异常退出</strong>，<strong>局部对象</strong>都会<strong>被销毁</strong><br>3、与之相对，<strong>发生异常时</strong>我们<strong>直接管理的内存</strong>是<strong>不会自动释放</strong>的。如果<strong>在</strong><code>new</code><strong>和</strong><code>delete</code><strong>之间发生异常</strong>，且异常<strong>未被捕获</strong>，则内存就<strong>永远不会被释放</strong>了。在函数<code>f2</code>之外<strong>没有指针指向这块内存</strong>，因此就<strong>无法释放</strong>了</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 分配一个新对象</span>
    <span class="token comment">// 这段代码抛出异常，且在 f1 中未被捕获</span>
<span class="token punctuation">&#125;</span>   <span class="token comment">// 函数结束后，shared_ptr自动释放内存</span>

<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 动态分配一个新对象</span>
    <span class="token comment">// 这段代码抛出异常，且在 f2 中未被捕获</span>
    <span class="token keyword">delete</span> ip<span class="token punctuation">;</span>                            <span class="token comment">// 在退出之前释放内存</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>智能指针和哑类</strong></p>
<blockquote>
<p>1、包括所有<strong>标准库类</strong>在内的很多<strong>C++类</strong>都定义了<strong>析构函数</strong>，负责<strong>清理对象使用的资源</strong>，但并<strong>不是所有类都有</strong>这样的<strong>良好定义</strong>。特别是那些为<strong>C</strong>和<strong>C++<strong>两种语言设计的类，通常都要求用户</strong>显式地释放所使用的任何资源</strong><br>2、那些<strong>分配了资源</strong>，却<strong>没有定义析构函数</strong>释放资源的类，可能遇到与<strong>使用动态内存</strong>相同的错误——<strong>忘记释放资源</strong>。类似的，如果<strong>资源分配和释放</strong>之间<strong>发生异常</strong>，也会发生<strong>资源泄露</strong><br>3、与<strong>管理动态内存</strong>类似，我们可以使用<strong>类似的技术</strong>来<strong>管理这些类</strong>。例如下面一段<strong>使用网络库</strong>的代码，如果<code>connection</code>有<strong>析构函数</strong>，就可以在<code>f</code>结束时<strong>自动关闭链接</strong>，但它没有<br>4、这个问题与<strong>上一个程序</strong>中使用<code>shared_ptr</code><strong>避免内存泄漏</strong>等价，<strong>使用</strong><code>shared_ptr</code><strong>来保证</strong><code>connection</code><strong>被正确关闭</strong>，已被证明是一种<strong>有效的方法</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">destination</span><span class="token punctuation">;</span>                       <span class="token comment">// 表示正在连接什么</span>
<span class="token keyword">struct</span> <span class="token class-name">connection</span><span class="token punctuation">;</span>                        <span class="token comment">// 使用连接所需的信息</span>
connection <span class="token function">connect</span><span class="token punctuation">(</span>destination<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 打开链接</span>
<span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 关闭给定链接</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>destination <span class="token operator">&amp;</span>d <span class="token comment">/* 其他参数 */</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    connection c <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 获得链接，但要使用后关闭</span>
    <span class="token comment">// ...使用连接</span>
    <span class="token comment">// 如果退出 f 前忘记调用 disconnect，就无法关闭 c 了</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>使用自定义的释放操作</strong></p>
<blockquote>
<p>1、默认情况下，<code>shared_ptr</code>假定它们指向的是<strong>动态内存</strong>，因此<strong>当其被销毁时</strong>默认对它管理的内存<strong>执行</strong><code>delete</code><strong>操作</strong><br>2、为了用<code>shared_ptr</code>管理一个<code>connection</code>，必须<strong>自定义一个函数</strong>来代替<code>delete</code>。这个<strong>删除器函数</strong>必须能完成<strong>对</strong><code>shared_ptr</code><strong>中保存的指针进行释放</strong>的操作<br>3、在本例中，我们的<strong>删除器</strong>必须接受<strong>单个类型为</strong><code>connection</code><strong>的参数</strong>。改写<code>f</code>函数，当创建一个<code>shared_ptr</code>时，可以传递一个可选的<strong>指向删除器函数</strong>的<strong>参数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">end_connection</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token comment">// 调用上面写好的关闭函数</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>destination <span class="token operator">&amp;</span>d <span class="token comment">/* 其他参数 */</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    connection c <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>connection<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> end_connection<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 传递第二个指向删除器函数的参数</span>
    <span class="token comment">// ...使用连接</span>
    <span class="token comment">// 当 f 退出时(即使因为异常)，connection 会被正确关闭</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="其他智能指针"><a href="#其他智能指针" class="headerlink" title="其他智能指针"></a><strong>其他智能指针</strong></h4><ul>
<li><p><strong>unique_ptr 类</strong></p>
<ul>
<li><p><code>unique_ptr</code><strong>操作</strong></p>
<blockquote>
<p>1、一个<code>unique_ptr</code><strong>拥有</strong>它所指向的对象，与<code>shared_ptr</code>不同，某个时刻<strong>只能有一个</strong><code>unique_ptr</code><strong>指向一个给定对象</strong>。当<code>unique_ptr</code><strong>被销毁</strong>时，其指向的<strong>对象也被销毁</strong>。下表列出了<code>unique_ptr</code><strong>特有的操作</strong>(通用操作同前表)<br>2、与<code>shared_ptr</code>不同，<strong>没有</strong>类似<code>make_shared</code>的<strong>标准库函数</strong>，因此当我们<strong>定义</strong><code>unique_ptr</code>时，需要将其<strong>绑定到</strong><code>new</code><strong>返回的指针</strong>上<br>3、初始化<code>unique_ptr</code>必须采用<strong>直接初始化</strong>，此外其<strong>不支持普通拷贝或赋值</strong>。虽然我们<strong>不能拷贝或赋值</strong><code>unique_ptr</code>，但可以通过<code>release</code>或<code>reset</code>将<strong>指针所有权</strong>转移给另一个<code>unique_ptr</code>。但注意如果我们不用<strong>另一个智能指针</strong>来<strong>保存</strong><code>release</code><strong>返回的指针</strong>，程序就要负责<strong>释放资源</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>unique_ptr 独有的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>unique_ptr&lt;T&gt; u1，unique_ptr&lt;T, D&gt; u2</td>
<td>空 unique_ptr，可以指向类型为 T 的对象。u1 会使用 delete 释放它的指针；u2 会使用类型为 D 的可调用对象释放指针</td>
</tr>
<tr>
<td>unique_ptr&lt;T, D&gt; u(d)</td>
<td>空 unique_ptr，指向类型为 T 的对象，用类型为 D 的对象 d 代替 delete</td>
</tr>
<tr>
<td>u &#x3D; nullptr</td>
<td>释放 u 指向的对象，将 u 置空</td>
</tr>
<tr>
<td>u.release()</td>
<td>u 放弃对指针的控制权，返回指针，并将 u 置空</td>
</tr>
<tr>
<td>u.reset()，u.reset(q)，u.reset(nullptr)</td>
<td>释放 u 指向的对象。如果提供了内置指针 q，则令 u 指向这个对象，否则将 u 置空</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> p1<span class="token punctuation">;</span>                              <span class="token comment">// 定义可以指向 double 的空 unique_ptr</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// p2 指向一个值为 42 的 int</span>

unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p4</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 错误：不支持拷贝</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p5<span class="token punctuation">;</span>
p5 <span class="token operator">=</span> p3<span class="token punctuation">;</span>                                            <span class="token comment">// 错误：不支持赋值</span>

<span class="token comment">// 将所有权从 ps1 转移给 ps2</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">ps1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">ps2</span><span class="token punctuation">(</span>ps1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// release 将 ps1 置空，并返回指针</span>
<span class="token comment">// 将所有权从 ps3 转移给 ps2</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">ps3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ps2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>ps3<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">// reset 释放了 ps2 原来指向的内存</span>

<span class="token comment">// 易错：不使用智能指针接收 release 返回的指针</span>
ps2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment">// 错误：ps2 不会释放内存，而且我们丢失了指针</span>
<span class="token keyword">auto</span> ps <span class="token operator">=</span> ps2<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 正确：但也要记得 delete(ps)</span></code></pre>
</li>
<li><p><strong>局部变量和返回值可以拷贝</strong></p>
<blockquote>
<p>1、<strong>不能拷贝</strong><code>unique_ptr</code>的规则有一个例外：我们<strong>可以拷贝或赋值</strong>一个<strong>将要被销毁的</strong><code>unique_ptr</code><br>2、最常见的例子是<strong>从函数返回一个</strong><code>unique_ptr</code>，此外还可以<strong>返回一个局部变量的拷贝</strong><br>3、对于这两种情况，<strong>编译器</strong>知道<strong>要返回的对象即将被销毁</strong>，这种情况下，编译器会执行一种<strong>特殊的拷贝</strong>，后续介绍</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 正确：从 int* 创建一个 unique_ptr&lt;int>，并作为返回值拷贝</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 正确：也可以将局部变量作为返回值拷贝</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ret</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>向</strong><code>unique_ptr</code><strong>传递删除器</strong></p>
<blockquote>
<p>1、类似<code>shared_ptr</code>，<code>unique_ptr</code><strong>默认情况</strong>下用<code>delete</code>释放它<strong>指向的对象</strong>。与<code>shared_ptr</code>相同，我们<strong>可以重载</strong>一个<code>unique_ptr</code><strong>默认的删除器</strong>，但其<strong>管理删除器的方式</strong>与<code>shared_ptr</code>不同，其原因后续介绍<br>2、<strong>重载</strong>一个<code>unique_ptr</code><strong>删除器</strong>会影响到其<strong>类型</strong>以及<strong>如何构造</strong>(或<code>reset</code>)<strong>该类型对象</strong>。与<strong>重载关联容器</strong>的<strong>比较操作</strong>类似，必须在<strong>尖括号中</strong>提供<strong>删除器类型</strong>。在<strong>创建</strong>和<code>reset</code>一个对象时，必须提供一个<strong>指定类型的可调用对象</strong>(删除器)<br>3、作为更具体的例子，我们将<strong>重写先前用</strong><code>shared_ptr</code><strong>写的连接程序</strong>，用<code>unique_ptr</code>代替<code>shared_ptr</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// p 指向一个类型为 objT 的对象，并使用一个类型为 delT 的对象释放 objT 对象</span>
<span class="token comment">// 它会调用一个名为 fcn 的 delT 类型对象</span>
unique_ptr<span class="token operator">&lt;</span>objT<span class="token punctuation">,</span> delT<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> objT<span class="token punctuation">,</span> fcn<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>destination <span class="token operator">&amp;</span>d <span class="token comment">/* 其他需要的参数 */</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    connection c <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打开链接</span>
    <span class="token comment">// 当 p 被销毁，链接将自动关闭</span>
    unique_ptr<span class="token operator">&lt;</span>connection<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>end_connection<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> end_connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...使用连接</span>
    <span class="token comment">// 当 f 退出时(即使由于异常)，connection 会被正确关闭</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>weak_ptr 类</strong></p>
<ul>
<li><p><code>weak_ptr</code><strong>操作</strong></p>
<blockquote>
<p>1、<code>weak_ptr</code>是一种<strong>不控制所指向对象生存期</strong>的<strong>智能指针</strong>，他指向由<code>shared_ptr</code><strong>管理的对象</strong>。将一个<code>weak_ptr</code><strong>绑定到</strong><code>shared_ptr</code><strong>不会增加其引用计数</strong>，当<code>shared_ptr</code><strong>被释放</strong>，即使还有<code>weak_ptr</code><strong>指向对象</strong>，<strong>对象也会被释放</strong>。因此<code>weak_ptr</code>具有<strong>弱共享对象</strong>的特点<br>2、下表列出了<code>weak_ptr</code>的操作。当我们<strong>创建一个</strong><code>weak_ptr</code>时，要<strong>用</strong><code>shared_ptr</code><strong>初始化</strong>它<br>3、由于对象<strong>可能不存在</strong>，我们<strong>不能使用</strong><code>weak_ptr</code><strong>直接访问对象</strong>，<strong>必须调用</strong><code>lock</code>检查<strong>指向的对象是否存在</strong>。如果存在，<code>lock</code>返回一个<strong>指向共享对象的</strong><code>shared_ptr</code>。与其他任何<code>shared_ptr</code>类似，只要此<code>shared_ptr</code><strong>存在</strong>，其指向的<strong>底层对象就一直存在</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>weak_ptr 独有的操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>weak_ptr&lt;T&gt; w</td>
<td>空 weak_ptr 可以指向类型为 T 的对象</td>
</tr>
<tr>
<td>weak_ptr&lt;T&gt; w(sp)</td>
<td>与 shared_ptr sp 指向相同对象的 weak_ptr。T 必须能转换为 sp 指向的类型</td>
</tr>
<tr>
<td>w &#x3D; p</td>
<td>p 可以是一个 shared_ptr 或一个 weak_ptr。赋值后 w 与 p 共享对象</td>
</tr>
<tr>
<td>w.reset()</td>
<td>将 w 置空</td>
</tr>
<tr>
<td>w.use_count()</td>
<td>与 w 共享对象的 shared_ptr 的数量</td>
</tr>
<tr>
<td>w.expired()</td>
<td>若 w.use_count() 为 0，返回 true，否则返回 false</td>
</tr>
<tr>
<td>w.lock()</td>
<td>如果 expired 为 true，返回一个空 shared_ptr，否则返回一个指向 w 的对象的 shared_ptr</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// wp 弱共享 p，p 的引用计数未改变</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> np <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// 如果 np 不为空则条件成立</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 在 if 中，np 与 p 共享对象</span>
    <span class="token comment">// ...使用 np</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>设计核查指针类</strong></p>
<ul>
<li><p><strong>核查指针类</strong></p>
<blockquote>
<p>1、作为<code>weak_ptr</code>用途的一个展示，我们将为<strong>先前定义过的</strong><code>StrBlob</code><strong>类</strong>定义一个<strong>伴随指针类</strong>。该类命名为<code>StrBlobPtr</code>，保存一个<code>weak_ptr</code>，<strong>指向</strong><code>StrBlob</code>的<code>data</code><strong>成员</strong>，且是<strong>初始化时提供给它</strong>的<br>2、通过使用<code>weak_ptr</code>，<strong>不会影响</strong>一个给定的<code>StrBlob</code><strong>所指向的</strong><code>vector</code><strong>的生存期</strong>，但可以<strong>阻止用户访问</strong>一个<strong>不再存在的</strong><code>vector</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 对于访问一个不存在元素的尝试，StrBlobPtr 抛出一个异常</span>
<span class="token keyword">class</span> <span class="token class-name">StrBlobPtr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 构造函数</span>
        <span class="token function">StrBlobPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">curr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">StrBlobPtr</span><span class="token punctuation">(</span>StrBlob <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> size_t sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">wptr</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">curr</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 成员函数</span>
        string <span class="token operator">&amp;</span><span class="token function">deref</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// 解引用</span>
        StrBlobPtr <span class="token operator">&amp;</span><span class="token function">incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 前缀递增</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token comment">// 若检查成功，check 返回一个指向 vector 的 shared_ptr</span>
        shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">check</span><span class="token punctuation">(</span>size_t i<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
        <span class="token comment">// 保存一个 weak_ptr，意味着底层 vector 可能被销毁</span>
        weak_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> wptr<span class="token punctuation">;</span>
        <span class="token comment">// 在数组中的当前位置</span>
        size_t curr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token class-name">StrBlobPtr</span><span class="token double-colon punctuation">::</span><span class="token function">check</span><span class="token punctuation">(</span>size_t i<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> ret <span class="token operator">=</span> wptr<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断 vector 是否存在</span>

    <span class="token comment">// 抛出错误</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"unbound StrBlobPtr"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> ret<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span> <span class="token comment">// 返回指向 vector 的 shared_ptr</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>指针操作</strong></p>
<blockquote>
<p>1、我们将在 14 章学习如何<strong>定义自己的运算符</strong>。现在我们将定义名为<code>deref</code>和<code>incr</code>的<strong>函数</strong>，分别用来<strong>解引用</strong>和<strong>递增</strong><code>StrBlobPtr</code>，且这两个函数<strong>都将调用</strong><code>check</code><strong>函数</strong><br>2、当然，为了<strong>访问</strong><code>StrBlob</code>的<code>data</code><strong>成员</strong>，我们的<code>StrBlobStr</code><strong>类</strong>必须声明为<code>StrBlob</code>的<strong>友元</strong>。我们还要为<code>StrBlob</code>定义<code>begin</code>和<code>end</code><strong>操作</strong>，返回<strong>指向它自身</strong>的<code>StrBlobPtr</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token operator">&amp;</span><span class="token class-name">StrBlobPtr</span><span class="token double-colon punctuation">::</span><span class="token function">deref</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> <span class="token string">"dereference past end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// (*p) 是对象所指向的 vector</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 前缀递增：返回递增后对象的引用</span>
StrBlobPtr <span class="token operator">&amp;</span><span class="token class-name">StrBlobPtr</span><span class="token double-colon punctuation">::</span><span class="token function">incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 curr 已经指向容器尾后位置，就不能递增它</span>
    <span class="token function">check</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> <span class="token string">"increment past end of StrBlobPtr"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>curr<span class="token punctuation">;</span> <span class="token comment">// 推进当前位置</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">StrBlobPtr</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">StrBlob</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 友元</span>
        <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">StrBlobPtr</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回指向首元素和尾后元素的 StrBlobPtr</span>
        StrBlobPtr <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token function">StrBlobPtr</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        StrBlobPtr <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">auto</span> ret <span class="token operator">=</span> <span class="token function">StrBlobPtr</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> data<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token comment">// ...相同部分省略</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a><strong>动态数组</strong></h4><ul>
<li><p><strong>动态数组</strong></p>
<blockquote>
<p>1、<code>new</code>和<code>delete</code>运算符一次<strong>分配&#x2F;释放</strong>一个对象，但有些应用需要<strong>一次为很多对象分配内存</strong>的功能(例如<code>vector</code>和<code>string</code>需要在连续内存中保存它们的元素)。因此，当容器需要<strong>重新分配内存</strong>时，必须<strong>一次性为很多元素分配内存</strong><br>2、对此，<strong>C++语言</strong>和<strong>标准库</strong>提供了<strong>两种方式</strong>：<strong>C++语言</strong>定义了另一种<code>new</code><strong>表达式语法</strong>，可以<strong>分配并初始化</strong>一个<strong>对象数组</strong>；而<strong>标准库</strong>中提供了<code>allocator</code><strong>类</strong>，允许我们<strong>将分配和初始化分离</strong>，并且使用<code>allocator</code>通常会提供<strong>更好的性能</strong>和<strong>更灵活的内存管理能力</strong><br>3、事实上，<strong>大多数应用</strong>都没有<strong>直接访问动态数组</strong>的需求。当一个应用<strong>需要可变数量的对象</strong>时，我们先前在<code>StrBlob</code>中使用<strong>标准库</strong><code>vector</code>的方法会<strong>更安全快速可靠</strong>。<strong>大多数应用</strong>都应当首先使用<strong>标准库容器</strong>而不是<strong>动态分配的数组</strong></p>
</blockquote>
</li>
<li><p><strong>new 和动态数组</strong></p>
<ul>
<li><p><strong>用</strong><code>new</code><strong>分配动态数组</strong></p>
<blockquote>
<p>1、为了让<code>new</code>分配一个<strong>对象数组</strong>，我们要在<strong>类型名</strong>后跟上一对<strong>方括号</strong>指明<strong>分配对象的数目</strong>。<code>new</code>将返回<strong>指向第一个对象的指针</strong>。<strong>方括号</strong>中的大小<strong>必须是整型</strong>，但<strong>不必是常量</strong><br>2、也可以用一个<strong>表示数组类型</strong>的<strong>类型别名</strong>来分配一个数组，这样<code>new</code>表达式中就<strong>不必使用方括号</strong>了<br>3、<strong>分配一个数组</strong>会得到<strong>一个元素类型</strong>的<strong>指针</strong>：虽然我们称<code>new T[]</code><strong>分配的内存</strong>为<strong>动态数组</strong>，但它<strong>不是</strong>一个<strong>数组类型的对象</strong>，而是一个<strong>数组元素类型</strong>的<strong>指针</strong><br>4、由于分配的内存<strong>不是数组类型</strong>，因此<strong>不能</strong>对<strong>动态数组</strong>调用<code>begin</code>或<code>end</code>(它们使用数组维度返回指针)。出于相同原因，也不能用<strong>范围</strong><code>for</code>来处理<strong>动态数组的元素</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>pia <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// pia 指向一个 int，调用 get_size() 确定分配多少个 int</span>

<span class="token keyword">using</span> arrT <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                     <span class="token comment">// arrT 表示 42 个 int 的数组类型</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> arrT<span class="token punctuation">;</span>                        <span class="token comment">// 分配一个 42 个 int 的数组</span></code></pre>
</li>
<li><p><strong>初始化动态数组</strong></p>
<blockquote>
<p>1、默认情况下<code>new</code><strong>分配的对象</strong>都是<strong>默认初始化</strong>的，也可以对<strong>数组元素</strong>进行<strong>值初始化</strong>，方法是在<strong>数组大小</strong>后跟一对<strong>空括号</strong>。在新标准中，我们还可以提供一个<strong>元素初始化器</strong>的<strong>花括号列表</strong><br>2、如果<strong>初始化器数目</strong>小于<strong>元素数目</strong>，<strong>剩余元素</strong>将进行<strong>值初始化</strong>；如果<strong>大于元素数目</strong>，则<code>new</code><strong>失败</strong>，不会分配任何内存，<strong>抛出</strong><code>bad_array_new_length</code><strong>异常</strong><br>3、虽然我们用<strong>空括号</strong>对数组中元素进行<strong>值初始化</strong>，但<strong>不能在括号中</strong>给出<strong>初始化器</strong>，这意味着<strong>不能用</strong><code>auto</code><strong>分配数组</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>pia <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment">// 10 个未初始化的 int</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pia2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 10 个值初始化为 0 的 int</span>
string <span class="token operator">*</span>psa <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">// 10 个空 string</span>
string <span class="token operator">*</span>psa2 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 10 个空 string</span>

<span class="token comment">// 10 个 int 分别用列表中对应的初始化器初始化</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pia3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 10 个 string，前 4 个用给定的初始化器初始化，剩余的进行值初始化</span>
string <span class="token operator">*</span>psa3 <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"an"</span><span class="token punctuation">,</span> <span class="token string">"the"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token char">'x'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>可以动态分配空数组</strong></p>
<blockquote>
<p>1、如下例，可以用<strong>任意表达式</strong>来确定要<strong>分配的对象的数目</strong>。但该例中，如果<code>get_size</code><strong>返回 0</strong>，代码<strong>仍能正常运行</strong>。虽然我们不能创建<strong>大小为 0</strong>的<strong>静态数组</strong>，但当<code>n = 0</code>时调用<code>new[n]</code><strong>是合法的</strong><br>2、当我们用<code>new</code>分配一个<strong>大小为 0 的数组</strong>时，<code>new</code>返回一个<strong>合法的非空指针</strong>，此指针保证与<code>new</code><strong>返回的其他指针</strong>都<strong>不相同</strong>。对于<strong>零长度数组</strong>来说，此<strong>指针</strong>就像<strong>尾后指针</strong>一样<br>3、我们可以像使用<strong>尾后迭代器</strong>一样使用这个指针。可以用其进行<strong>比较操作</strong>(如样例中循环)，也可以向其<strong>加&#x2F;减 0</strong>，也可以从此指针<strong>减去自身得到 0</strong>。但此指针<strong>不能解引用</strong>——它<strong>不指向任何元素</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">size_t n <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// get_size 返回需要的元素数目</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                      <span class="token comment">// 分配数组保存元素</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token punctuation">;</span> q <span class="token operator">!=</span> p <span class="token operator">+</span> n<span class="token punctuation">;</span> q<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// ...处理数值</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                              <span class="token comment">// 错误：不能定义长度为 0 的静态数组</span>
<span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment">// 正确：但 cp 不能解引用</span></code></pre>
</li>
<li><p><strong>释放动态数组</strong></p>
<blockquote>
<p>1、为了<strong>释放动态数组</strong>，我们是用一种<strong>特殊形式的</strong><code>delete</code>，其在<strong>指针前</strong>加上一个<strong>空方括号</strong><br>2、这种<code>delete</code><strong>销毁</strong>参数<strong>指向的数组的元素</strong>，并<strong>释放内存</strong>。数组中的元素将按<strong>逆序销毁</strong><br>3、当我们<strong>释放</strong>一个<strong>指向数组的指针</strong>时，<strong>空方括号是必须的</strong>：它<strong>指示编译器</strong>此指针<strong>指向一个对象数组的首元素</strong>。如果<strong>忽略了方括号</strong>，其<strong>行为未定义</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">delete</span> p<span class="token punctuation">;</span>                                 <span class="token comment">// p 必须指向一个动态分配的对象或为空</span>
<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> pa<span class="token punctuation">;</span>                             <span class="token comment">// pa 必须指向一个动态分配的数组或为空</span></code></pre></li>
</ul>
</li>
<li><p><strong>智能指针管理动态数组</strong></p>
<ul>
<li><p><code>unique_ptr</code><strong>管理</strong></p>
<blockquote>
<p>1、<strong>标准库</strong>提供了一个可以<strong>管理</strong><code>new</code><strong>动态数组</strong>的<code>unique_ptr</code><strong>版本</strong>。为了使用<code>unique_ptr</code><strong>管理动态数组</strong>，必须在<strong>对象类型后</strong>跟一对<strong>空方括号</strong><br>2、<strong>类型说明符</strong>中的<strong>方括号</strong><code>&lt;T []&gt;</code>指出其指向一个<strong>T 类型数组</strong>而不是<strong>单个 T 类型</strong><br>3、下表列出了<strong>指向动态数组</strong>的<code>unique_ptr</code>的<strong>操作</strong>。与先前版本有些不同，我们<strong>不能使用</strong><code>.</code><strong>和</strong><code>-&gt;</code><strong>运算符</strong>，但我们可以使用<strong>下标运算符</strong>来<strong>访问数组元素</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// up 指向一个包含 10 个未初始化 int 的数组</span>
up<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">// 自动用 delete[] 销毁其指针</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                            <span class="token comment">// 可以使用下标运算符为其赋值</span>
<span class="token punctuation">&#125;</span></code></pre>

<table>
<thead>
<tr>
<th>指向数组的 unique_ptr 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>unique_ptr&lt;T []&gt; u</td>
<td>u 可以指向一个动态分配的数组吗，数组元素类型为 T</td>
</tr>
<tr>
<td>unique_ptr&lt;T []&gt; u(p)</td>
<td>u 指向内置指针 p 所指向的动态分配的数组。p 必须能转换为类型 T*</td>
</tr>
<tr>
<td>u[i]</td>
<td>返回 u 拥有的数组中位置 i 处的对象</td>
</tr>
<tr>
<td>除去<code>.</code>和<code>-&gt;</code>外的<code>unique_ptr</code>操作</td>
<td>仍然支持</td>
</tr>
</tbody></table>
</li>
<li><p><code>shared_ptr</code><strong>管理</strong></p>
<blockquote>
<p>1、与<code>unique_ptr</code>不同，<code>shared_ptr</code><strong>不直接支持</strong>管理<strong>动态数组</strong>，如果希望使用，必须提供<strong>自定义的删除器</strong><br>2、如下例，我们传递给<code>shared_ptr</code>一个<code>lambda</code>作为<strong>删除器</strong>，它使用<code>delete[]</code><strong>释放数组</strong>。如果<strong>未提供删除器</strong>，这段代码是<strong>未定义</strong>的<br>3、<strong>有关</strong><code>delete[]</code>：默认情况下，<code>shared_ptr</code><strong>只将使用</strong><code>delete</code>释放对象，如果对<strong>动态数组</strong>使用<code>delete</code>，其后果与<strong>直接释放动态数组指针时忘记</strong><code>[]</code>一样<br>4、<code>shared_ptr</code><strong>不直接支持动态数组</strong>的特性使得<strong>访问元素</strong>比较麻烦，其<strong>未定义下标运算符</strong>，且智能指针类<strong>不支持指针算术运算</strong>。因此，为了<strong>访问元素</strong>，必须用<code>get</code>获取<strong>内置指针</strong>，再用它<strong>访问数组元素</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 为了使用 shared_ptr，必须提供删除器</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用提供的 lambda 释放数组，它使用 delete[]</span>

<span class="token comment">// 访问元素</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 使用 get 获取内置指针，再进行指针算术运算来选择元素，解引用后赋值</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>allocator 类</strong></p>
<ul>
<li><p><strong>分配与构造组合的缺点</strong></p>
<blockquote>
<p>1、<code>new</code>有一些<strong>灵活性</strong>上的<strong>局限</strong>，其中一方面表现在它将<strong>内存分配</strong>和<strong>对象构造</strong>组合在了一起；类似的，<code>delete</code>也将<strong>对象析构</strong>和<strong>内存释放</strong>组合在了一起<br>2、当<strong>分配一大块内存</strong>时，我们通常计划在这块内存上<strong>按需构造对象</strong>，这种情况下，我们希望<strong>内存分配</strong>和<strong>对象构造</strong>能够<strong>分离</strong>。意味着，我们可以<strong>提前分配</strong>大块内存，但只在<strong>真正需要时</strong>才执行<strong>创建对象</strong><br>3、一般情况下，<strong>内存分配</strong>和<strong>对象构造</strong>组合可能会<strong>导致不必要的浪费</strong>(如下例)。我们可能创建了一些<strong>永远用不到的对象</strong>，而对于<strong>能用到的对象</strong>，也都<strong>被赋值了两次</strong>(初始化+赋值)。更重要的是，那些<strong>没有默认构造函数</strong>的<strong>类</strong>就不能<strong>动态分配数组</strong>了</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> string<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">// 构造 n 个空 string</span>
string s<span class="token punctuation">;</span>
string <span class="token operator">*</span>q <span class="token operator">=</span> p<span class="token punctuation">;</span>                              <span class="token comment">// q 指向第一个 string</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> s <span class="token operator">&amp;&amp;</span> q <span class="token operator">!=</span> p <span class="token operator">+</span> n<span class="token punctuation">)</span>
    <span class="token operator">*</span>q<span class="token operator">++</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>                               <span class="token comment">// 赋予 *q 一个新值(可能读取数远小于分配数，造成浪费)</span>
size_t size <span class="token operator">=</span> q <span class="token operator">-</span> p<span class="token punctuation">;</span>                        <span class="token comment">// 记住我们读取了多少个 string</span>
<span class="token comment">// ...使用数组</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span>                                 <span class="token comment">// 释放内存</span></code></pre>
</li>
<li><p><code>allocator</code><strong>操作</strong></p>
<blockquote>
<p>1、<strong>标准库</strong><code>allocator</code>定义在<strong>头文件</strong><code>memory</code>中，用于将<strong>内存分配</strong>和<strong>对象构造</strong>相<strong>分离</strong><br>2、<code>allocator</code>提供一种<strong>类型感知</strong>的<strong>内存分配方法</strong>，其分配的内存是<strong>原始的</strong>、<strong>未构造的</strong>，下表列出了该类的操作</p>
</blockquote>
<table>
<thead>
<tr>
<th>allocator 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>allocator&lt;T&gt; a</td>
<td>定义一个名为 a 的 allocator 对象，可以为类型为 T 的对象分配内存</td>
</tr>
<tr>
<td>a.allocate(n)</td>
<td>分配一段原始的、未构造的内存，保存 n 个类型为 T 的对象</td>
</tr>
<tr>
<td>a.deallocate(p, n)</td>
<td>释放从 T* 指针 p 中地址开始的内存，这块内存保存了 n 个类型为 T 的对象。p 必须是先前由 allocate 返回的指针，且 n 必须是 p 创建时所要求的大小。在调用 deallocate 之前，用户必须对每个在这块内存中创建的对象调用 destroy</td>
</tr>
<tr>
<td>a.construct(p, args)</td>
<td>p 必须是一个类型为 T* 的指针，指向一块原始内存。args 被传递给类型为 T 的构造函数，用来在 p 指向的内存中构造一个对象</td>
</tr>
<tr>
<td>a.destroy(p)</td>
<td>p 为 T* 类型的指针，此算法对 p 指向的对象执行析构函数</td>
</tr>
</tbody></table>
</li>
<li><p><strong>分配未构造的内存</strong></p>
<blockquote>
<p>1、<code>allocator</code>是一个<strong>模板</strong>，要<strong>定义</strong><code>allocator</code><strong>对象</strong>，必须指明其<strong>可以分配的对象类型</strong>。当它分配内存时，会根据<strong>给定对象类型</strong>确定恰当的<strong>内存大小</strong>和<strong>对其位置</strong><br>2、创建<code>allocator</code><strong>对象</strong>后，要先使用<code>allocate</code><strong>分配一段原始内存</strong>，其<strong>分配的内存</strong>是<strong>未构造的</strong>，我们在这些内存中<strong>按需构造对象</strong>。<strong>新标准库</strong>中，<code>construct</code><strong>成员函数</strong>接受<strong>一个指针</strong>，用于在给定位置<strong>构造一个元素</strong>，还接受<strong>可选的额外参数</strong>，用于<strong>初始化构造的对象</strong><br>3、为了使用<code>allocate</code><strong>返回的内存</strong>，必须先用<code>construct</code><strong>构造对象</strong>，使用<strong>未构造的内存</strong>的行为是<strong>未定义的</strong>。当用完对象后，必须对<strong>每个元素</strong>调用<code>destroy</code><strong>销毁</strong>，且只能对<strong>真正构造了的元素</strong>进行<code>destroy</code><br>4、一旦<strong>元素</strong>被<code>destroy</code><strong>销毁</strong>后，就可以<strong>重新使用这部分内存</strong>来保存其他<code>string</code>，也可以将其<strong>归还系统</strong>。<strong>释放内存</strong>通过调用<code>deallocate</code>完成</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 分配一段原始内存</span>
allocator<span class="token operator">&lt;</span>string<span class="token operator">></span> alloc<span class="token punctuation">;</span>                    <span class="token comment">// 可以分配 string 的 allocator 对象</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 分配 n 个未初始化的 string</span>

<span class="token comment">// 在未分配的内存中构造对象</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> p<span class="token punctuation">;</span>                                 <span class="token comment">// q 指向最后构造的元素之后的位置</span>
alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// *q 为空字符串</span>
alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// *q 为 cccccccccc</span>
alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>q<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// *q 为 hi</span>

<span class="token comment">// 使用构造的对象</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                         <span class="token comment">// 正确：使用 string 的输出运算符</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>q <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                         <span class="token comment">// 灾难：当前 q 还未构造对象，其指向未构造的内存</span>

<span class="token comment">// 销毁元素</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">!=</span> p<span class="token punctuation">)</span>
    alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 销毁元素，释放真正构造的 string</span>

<span class="token comment">// 归还内存给系统</span>
alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 归还内存</span></code></pre>
</li>
<li><p><strong>拷贝和填充未初始化内存的算法</strong></p>
<blockquote>
<p>1、<strong>标准库</strong>还为<code>allocator</code>定义了<strong>两个伴随算法</strong>，可以在<strong>未初始化内存</strong>中<strong>创建对象</strong>，它们都定义在<strong>头文件</strong><code>memory</code>中。这些函数在<strong>给定目的位置创建元素</strong>，而不是由系统<strong>分配内存</strong>给它们。其<strong>返回值</strong>是<strong>目标范围</strong>的<strong>尾后迭代器</strong><br>2、作为一个例子，假定有一个<strong>int</strong>的<code>vector</code>，希望将其内容<strong>拷贝到动态内存</strong>中。我们将分配一块<strong>两倍于</strong><code>vector</code><strong>空间</strong>的<strong>动态内存</strong>，将<strong>原</strong><code>vector</code>拷贝到<strong>前一半空间</strong>，再用一个<strong>给定值</strong>填充<strong>后一半空间</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>allocator 算法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>uninitialized_copy(b, e, b2)</td>
<td>从迭代器 b 和 e 指出的输入范围中拷贝元素到迭代器 b2 指定的未构造的原始内存中。b2 指向的内存必须足够大，能容纳输入序列中元素的拷贝</td>
</tr>
<tr>
<td>uninitialized_copy_n(b, n, b2)</td>
<td>从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的内存中</td>
</tr>
<tr>
<td>uninitialized_fill(b, e, t)</td>
<td>在迭代器 b 和 e 指定的原始内存范围中创建对象，对象的值均为 t 的拷贝</td>
</tr>
<tr>
<td>uninitialized_fill_n(b, n, t)</td>
<td>从迭代器 b 指向的内存地址开始创建 n 个对象。b 必须指向足够大的未构造的原始内存，能够容纳给定数量的对象</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 分配两倍于 vector 空间的动态内存</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通过拷贝 vi 中的元素构造从 p 开始的前一半元素</span>
<span class="token keyword">auto</span> q <span class="token operator">=</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将剩余一半元素初始化为 42</span>
<span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="使用标准库：文本查询程序"><a href="#使用标准库：文本查询程序" class="headerlink" title="使用标准库：文本查询程序"></a><strong>使用标准库：文本查询程序</strong></h4><ul>
<li><p><strong>描述</strong></p>
<blockquote>
<p>1、我们将实现一个简单的<strong>文本查询程序</strong>，作为<strong>标准库相关内容</strong>学习的总结<br>2、程序允许用户在一个<strong>给定文件</strong>中<strong>查询单词</strong>，查询结果是<strong>当前单词</strong>在文件中<strong>出现的次数</strong>，以及其<strong>所在行的列表</strong>。如果一个单词在<strong>一行中出现多次</strong>，<strong>此行只列出一次</strong>。<strong>行</strong>会按照<strong>升序输出</strong><br>3、例如，我们可能<strong>读入一个文件</strong>，在其中<strong>寻找单词 element</strong>，该程序的<strong>前几行输出</strong>是这样的：</p>
</blockquote>
<pre class="language-none"><code class="language-none">element occurs 112 times
    (line 36) A set element contians only a key;
    (line 158) operator creates a new element
    (line 160) Regardless of whether the element
    (line 168) When we fetch an element from a map, we
    (line 214) If the element is not found, find returns
    ...</code></pre>
</li>
<li><p><strong>文本查询程序设计</strong></p>
<ul>
<li><p>从需求入手，我们的程序需要<strong>完成以下任务</strong>：</p>
<blockquote>
<p>1、当程序需要<strong>读取输入文件</strong>时，它必须记住<strong>单词出现的每一行</strong>。因此程序需要<strong>逐行读取文件</strong>，并将每一行<strong>分解为独立的单词</strong><br>2、当<strong>程序生成输出</strong>时：<br>—-它必须能<strong>提取</strong>每个单词<strong>所关联的行号</strong><br>—-<strong>行号</strong>必须<strong>按升序出现</strong>且<strong>无重复</strong><br>—-它必须能<strong>打印给定行号中的文本</strong></p>
</blockquote>
</li>
<li><p>利用标准库，我们可以<strong>实现这些要求</strong>：</p>
<blockquote>
<p>1、我们将使用一个<code>vector&lt;string&gt;</code><strong>保存</strong>整个输入文件的<strong>一份拷贝</strong>。输入文件中的<strong>每行保存为</strong><code>vector</code><strong>一个元素</strong>。当需要<strong>打印一行</strong>时，可以用<strong>行号作为下标</strong>来<strong>提取文本行</strong><br>2、我们使用一个<code>istringstream</code>来<strong>将每行分解为单词</strong><br>3、我们使用一个<code>set</code><strong>保存每个单词</strong>在输入文本中<strong>出现的行号</strong>。这保证了<strong>每行只出现一次</strong>且<strong>行号升序排列</strong><br>4、我们使用一个<code>map</code>将<strong>单词</strong>与它<strong>出现的行号</strong><code>set</code><strong>关联起来</strong>。这样就可以方便地<strong>提取任意单词的</strong><code>set</code><br>5、我们的解决方案还使用<code>shared_ptr</code>，原因稍后解释</p>
</blockquote>
</li>
<li><p><strong>数据结构</strong></p>
<blockquote>
<p>1、虽然我们可以用<code>vector</code>、<code>set</code>和<code>map</code><strong>直接编写程序</strong>，但如果定义一个<strong>更抽象的解决方案</strong>，会更为有效<br>2、我们将从定义一个<strong>保存输入文件的类</strong>——<code>TextQuery</code>开始，这会令<strong>文件查询更为容易</strong>。它包含一个<code>vector</code>和一个<code>map</code>，<code>vector</code>保存<strong>输入文件的文本</strong>，<code>map</code>关联<strong>每个单词</strong>和它<strong>出现的行号</strong><code>set</code>。这个类将有一个用来<strong>读取给定输入文件</strong>的<strong>构造函数</strong>和一个<strong>执行查询</strong>的<strong>操作</strong><br>3、<strong>返回所有内容</strong>的最简单的方式是<strong>再定义另一个类</strong>——<code>QueryResult</code>，<strong>保存查询结果</strong>。这个类会有一个<code>print</code><strong>函数</strong>，完成<strong>结果打印</strong>工作</p>
</blockquote>
</li>
<li><p><strong>类之间共享数据</strong></p>
<blockquote>
<p>1、我们的<code>QueryResult</code>要表达<strong>查询的结果</strong>，其中包括<strong>行号的</strong><code>set</code>和<strong>行对应的文本</strong>，而这些数据都<strong>保存在</strong><code>TextQuery</code><strong>类型对象</strong>中，因此我们必须确定<strong>如何访问它们</strong><br>2、可能我们可以<strong>拷贝</strong><code>set</code>，但这样<strong>非常耗时</strong>，而且我们<strong>不希望拷贝</strong><code>vector</code>，这可能引起<strong>整个文件的拷贝</strong>。而通过返回<strong>指向</strong><code>TextQuery</code><strong>对象内部</strong>的<strong>迭代器</strong>(或指针)，虽然可以<strong>避免拷贝</strong>，但会开启<strong>新的陷阱</strong>：如果<code>TextQuery</code><strong>对象</strong>在对应的<code>QueryResult</code><strong>对象</strong>之前<strong>被销毁</strong>，<code>QueryResult</code>将引用一个<strong>不存在的对象</strong>中的数据<br>3、因此，对于这两个类<strong>生存期应该同步</strong>，考虑到两个类<strong>概念上共享了数据</strong>，就可以使用<code>shared_ptr</code>反映<strong>数据结构</strong>中的这种<strong>共享关系</strong></p>
</blockquote>
</li>
<li><p><strong>使用</strong><code>TextQuery</code><strong>类</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用文本查询程序</span>
<span class="token keyword">void</span> <span class="token function">runQueries</span><span class="token punctuation">(</span>ifstream <span class="token operator">&amp;</span>infile<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// infile 是一个 ifstream，指向我们要处理的文件</span>
    TextQuery <span class="token function">tq</span><span class="token punctuation">(</span>infile<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存文件并建立查询 map</span>
    <span class="token comment">// 与用户交互：提示用户输入要查询的单词，完成查询并打印结果</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"enter word to look for, or q to quit: "</span><span class="token punctuation">;</span>
        string s<span class="token punctuation">;</span>
        <span class="token comment">// 若遇到文件末尾或用户输入了 q，终止循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> s<span class="token punctuation">)</span> <span class="token operator">||</span> s <span class="token operator">==</span> <span class="token string">"q"</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token comment">// 指向查询并打印结果</span>
        <span class="token function">print</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> tq<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>程序详细的类定义</strong></p>
<ul>
<li><p><code>TextQuery</code><strong>类定义</strong></p>
<blockquote>
<p>1、我们先从<code>TextQuery</code><strong>类定义</strong>开始。<strong>创建类对象</strong>时<strong>构造函数</strong>接受一个<code>istream</code>，用来<strong>读取输入文件</strong>。该类还提供<code>query</code><strong>操作</strong>，接受一个<code>string</code>，返回<code>QueryResult</code><strong>表示</strong><code>string</code><strong>出现的那些行</strong><br>2、设计类的<strong>数据成员</strong>时，要考虑<code>QueryResult</code><strong>共享数据</strong>的需求，其共享<strong>保存输入文件</strong>的<code>vector</code>和<strong>保存单词关联行号</strong>的<code>set</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> line_no <span class="token operator">=</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token double-colon punctuation">::</span>size_type<span class="token punctuation">;</span> <span class="token comment">// 行号</span>

<span class="token keyword">class</span> <span class="token class-name">QueryResult</span><span class="token punctuation">;</span> <span class="token comment">// 为了定义 TextQuery::query() 的返回类型，这个定义是必须的</span>

<span class="token comment">// TextQuery 类定义</span>
<span class="token keyword">class</span> <span class="token class-name">TextQuery</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">TextQuery</span><span class="token punctuation">(</span>ifstream <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 构造函数</span>
        QueryResult <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>       <span class="token comment">// 查询操作</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> file<span class="token punctuation">;</span>          <span class="token comment">// 输入文件</span>
        map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span>line_no<span class="token operator">>></span><span class="token operator">></span> wm<span class="token punctuation">;</span> <span class="token comment">// 每个单词到它所在行号的集合的映射</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>TextQuery</code><strong>构造函数</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// TextQuery 类构造函数：读取输入文件并建立单词到行号的映射</span>
<span class="token class-name">TextQuery</span><span class="token double-colon punctuation">::</span><span class="token function">TextQuery</span><span class="token punctuation">(</span>ifstream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">file</span><span class="token punctuation">(</span><span class="token keyword">new</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string text<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 对文件中的每一行</span>
    <span class="token punctuation">&#123;</span>
        file<span class="token operator">-></span><span class="token function">push_back</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存此行文本</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> file<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 当前行号</span>

        istringstream <span class="token function">line</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于将行文本分解为单词</span>
        string word<span class="token punctuation">;</span>              <span class="token comment">// 用于接收并处理行中每个单词</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">>></span> word<span class="token punctuation">)</span> <span class="token comment">// 对行中每个单词</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">// 如果单词不在 wm 中，以之为下标在 wm 中添加一项</span>
            <span class="token keyword">auto</span> <span class="token operator">&amp;</span>lines <span class="token operator">=</span> wm<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// lines 是一个 shared_ptr</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lines<span class="token punctuation">)</span>                        <span class="token comment">// 第一次遇到这个单词时，此指针为空</span>
                lines<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> set<span class="token operator">&lt;</span>line_no<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配一个新的 set</span>
            lines<span class="token operator">-></span><span class="token function">insert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 将此行号插入 set 中</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><code>QueryResult</code><strong>类</strong></p>
<blockquote>
<p>1、<code>QueryResult</code><strong>类</strong>有三个<strong>数据成员</strong>：一个<code>string</code>，<strong>保存查询单词</strong>；一个<code>shared_ptr</code>，指向<strong>保存输入文件</strong>的<code>vector</code>；一个<code>shared_ptr</code>，指向<strong>保存单词出现行号</strong>的<code>set</code><br>2、它唯一的一个<strong>成员函数</strong>是一个<strong>构造函数</strong>，其工作是<strong>将参数保存</strong>在<strong>对应的数据成员</strong>中</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// QueryResult 类</span>
<span class="token keyword">class</span> <span class="token class-name">QueryResult</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 打印函数的友元</span>
        <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span>qr<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 构造函数</span>
        <span class="token function">QueryResult</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span>line_no<span class="token operator">>></span> p<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sought</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lines</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">file</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        string sought<span class="token punctuation">;</span>                   <span class="token comment">// 查询单词</span>
        shared_ptr<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span>line_no<span class="token operator">>></span> lines<span class="token punctuation">;</span>  <span class="token comment">// 出现的行号</span>
        shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> file<span class="token punctuation">;</span> <span class="token comment">// 输入文件</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><code>TextQuery::query</code><strong>函数</strong></p>
<blockquote>
<p>1、<code>query</code><strong>函数</strong>接受一个<code>string</code><strong>参数</strong>，即<strong>要查询的单词</strong>，<code>query</code>用它在<code>map</code>中<strong>定位对应行号</strong>的<code>set</code>。如果找到了这个<code>string</code>，该函数<strong>构造并返回</strong><code>QueryResult</code><br>2、唯一的问题是：如果给定<code>string</code><strong>未找到</strong>，应该返回什么？此时<strong>没有可返回的</strong><code>set</code>，为此我们定义了一个<strong>局部</strong><code>static</code><strong>对象</strong>，它是一个指向<strong>空行号</strong><code>set</code><strong>的</strong><code>shared_ptr</code>。当<strong>未找到给定单词</strong>时，<strong>返回此对象的一个拷贝</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// TextQuery::query() 函数</span>
QueryResult <span class="token class-name">TextQuery</span><span class="token double-colon punctuation">::</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>sought<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果找到 sought，我们将返回一个指向此 set 的指针</span>
    <span class="token keyword">static</span> shared_ptr<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span>line_no<span class="token operator">>></span> <span class="token function">nodata</span><span class="token punctuation">(</span><span class="token keyword">new</span> set<span class="token operator">&lt;</span>line_no<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用 find 而不是下标运算符来查找单词，避免将单词添加到 wm 中</span>
    <span class="token keyword">auto</span> loc <span class="token operator">=</span> wm<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>sought<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loc <span class="token operator">==</span> wm<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">QueryResult</span><span class="token punctuation">(</span>sought<span class="token punctuation">,</span> nodata<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未找到</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">QueryResult</span><span class="token punctuation">(</span>sought<span class="token punctuation">,</span> loc<span class="token operator">-></span>second<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>打印结果</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 打印结果：print() 函数</span>
ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span>qr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果找到了单词，打印出现次数和所有出现的位置</span>
    os <span class="token operator">&lt;&lt;</span> qr<span class="token punctuation">.</span>sought <span class="token operator">&lt;&lt;</span> <span class="token string">" occurs "</span> <span class="token operator">&lt;&lt;</span> qr<span class="token punctuation">.</span>lines<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" time"</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>qr<span class="token punctuation">.</span>lines<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">"s"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 打印单词出现的每一行</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> num <span class="token operator">:</span> <span class="token operator">*</span>qr<span class="token punctuation">.</span>lines<span class="token punctuation">)</span> <span class="token comment">// 对 set 中每个单词</span>
        <span class="token comment">// 避免行号从 0 开始给用户带来困惑</span>
        os <span class="token operator">&lt;&lt;</span> <span class="token string">"\t(line "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">") "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>qr<span class="token punctuation">.</span>file<span class="token operator">-></span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> num<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> os<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>完整的类</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>ifstream<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>istringstream<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>map<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>set<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">;</span>

<span class="token keyword">using</span> line_no <span class="token operator">=</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token double-colon punctuation">::</span>size_type<span class="token punctuation">;</span> <span class="token comment">// 行号</span>

<span class="token keyword">class</span> <span class="token class-name">QueryResult</span><span class="token punctuation">;</span> <span class="token comment">// 为了定义 TextQuery::query() 的返回类型，这个定义是必须的</span>

<span class="token comment">// TextQuery 类定义</span>
<span class="token keyword">class</span> <span class="token class-name">TextQuery</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">TextQuery</span><span class="token punctuation">(</span>ifstream <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 构造函数</span>
        QueryResult <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>       <span class="token comment">// 查询操作</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> file<span class="token punctuation">;</span>          <span class="token comment">// 输入文件</span>
        map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span>line_no<span class="token operator">>></span><span class="token operator">></span> wm<span class="token punctuation">;</span> <span class="token comment">// 每个单词到它所在行号的集合的映射</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// TextQuery 类构造函数：读取输入文件并建立单词到行号的映射</span>
<span class="token class-name">TextQuery</span><span class="token double-colon punctuation">::</span><span class="token function">TextQuery</span><span class="token punctuation">(</span>ifstream <span class="token operator">&amp;</span>is<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">file</span><span class="token punctuation">(</span><span class="token keyword">new</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string text<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 对文件中的每一行</span>
    <span class="token punctuation">&#123;</span>
        file<span class="token operator">-></span><span class="token function">push_back</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存此行文本</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> file<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 当前行号</span>

        istringstream <span class="token function">line</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于将行文本分解为单词</span>
        string word<span class="token punctuation">;</span>              <span class="token comment">// 用于接收并处理行中每个单词</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">>></span> word<span class="token punctuation">)</span> <span class="token comment">// 对行中每个单词</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">// 如果单词不在 wm 中，以之为下标在 wm 中添加一项</span>
            <span class="token keyword">auto</span> <span class="token operator">&amp;</span>lines <span class="token operator">=</span> wm<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// lines 是一个 shared_ptr</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lines<span class="token punctuation">)</span>                        <span class="token comment">// 第一次遇到这个单词时，此指针为空</span>
                lines<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> set<span class="token operator">&lt;</span>line_no<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配一个新的 set</span>
            lines<span class="token operator">-></span><span class="token function">insert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 将此行号插入 set 中</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// QueryResult 类</span>
<span class="token keyword">class</span> <span class="token class-name">QueryResult</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 打印函数的友元</span>
        <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span>qr<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 构造函数</span>
        <span class="token function">QueryResult</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span>line_no<span class="token operator">>></span> p<span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sought</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lines</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">file</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        string sought<span class="token punctuation">;</span>                   <span class="token comment">// 查询单词</span>
        shared_ptr<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span>line_no<span class="token operator">>></span> lines<span class="token punctuation">;</span>  <span class="token comment">// 出现的行号</span>
        shared_ptr<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> file<span class="token punctuation">;</span> <span class="token comment">// 输入文件</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// TextQuery::query() 函数</span>
QueryResult <span class="token class-name">TextQuery</span><span class="token double-colon punctuation">::</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>sought<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果找到 sought，我们将返回一个指向此 set 的指针</span>
    <span class="token keyword">static</span> shared_ptr<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span>line_no<span class="token operator">>></span> <span class="token function">nodata</span><span class="token punctuation">(</span><span class="token keyword">new</span> set<span class="token operator">&lt;</span>line_no<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用 find 而不是下标运算符来查找单词，避免将单词添加到 wm 中</span>
    <span class="token keyword">auto</span> loc <span class="token operator">=</span> wm<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>sought<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loc <span class="token operator">==</span> wm<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">QueryResult</span><span class="token punctuation">(</span>sought<span class="token punctuation">,</span> nodata<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未找到</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">QueryResult</span><span class="token punctuation">(</span>sought<span class="token punctuation">,</span> loc<span class="token operator">-></span>second<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 打印结果：print() 函数</span>
ostream <span class="token operator">&amp;</span><span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> QueryResult <span class="token operator">&amp;</span>qr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果找到了单词，打印出现次数和所有出现的位置</span>
    os <span class="token operator">&lt;&lt;</span> qr<span class="token punctuation">.</span>sought <span class="token operator">&lt;&lt;</span> <span class="token string">" occurs "</span> <span class="token operator">&lt;&lt;</span> qr<span class="token punctuation">.</span>lines<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" time"</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>qr<span class="token punctuation">.</span>lines<span class="token operator">-></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">"s"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 打印单词出现的每一行</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> num <span class="token operator">:</span> <span class="token operator">*</span>qr<span class="token punctuation">.</span>lines<span class="token punctuation">)</span> <span class="token comment">// 对 set 中每个单词</span>
        <span class="token comment">// 避免行号从 0 开始给用户带来困惑</span>
        os <span class="token operator">&lt;&lt;</span> <span class="token string">"\t(line "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">") "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>qr<span class="token punctuation">.</span>file<span class="token operator">-></span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> num<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> os<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用文本查询程序</span>
<span class="token keyword">void</span> <span class="token function">runQueries</span><span class="token punctuation">(</span>ifstream <span class="token operator">&amp;</span>infile<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// infile 是一个 ifstream，指向我们要处理的文件</span>
    TextQuery <span class="token function">tq</span><span class="token punctuation">(</span>infile<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保存文件并建立查询 map</span>
    <span class="token comment">// 与用户交互：提示用户输入要查询的单词，完成查询并打印结果</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"enter word to look for, or q to quit: "</span><span class="token punctuation">;</span>
        string s<span class="token punctuation">;</span>
        <span class="token comment">// 若遇到文件末尾或用户输入了 q，终止循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> s<span class="token punctuation">)</span> <span class="token operator">||</span> s <span class="token operator">==</span> <span class="token string">"q"</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token comment">// 指向查询并打印结果</span>
        <span class="token function">print</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> tq<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string filename <span class="token operator">=</span> <span class="token string">"passage.txt"</span><span class="token punctuation">;</span>
    ifstream <span class="token function">infile</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">runQueries</span><span class="token punctuation">(</span>infile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<hr>
<h3 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a><strong>拷贝控制</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：拷贝、赋值与销毁；拷贝控制；拷贝构造函数；拷贝赋值运算符；重载赋值运算符；析构函数；三&#x2F;五法则；阻止拷贝；定义删除的函数；拷贝控制和资源管理；行为像值的类；行为像指针的类；交换操作；类的<code>swap</code>；拷贝控制示例；动态内存管理类；对象移动；右值引用；<code>std::move</code>；移动构造函数和移动赋值运算符；移动迭代器；右值引用和成员函数；引用限定符</p>
</blockquote>
</div>

<h4 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a><strong>拷贝、赋值与销毁</strong></h4><ul>
<li><p><strong>拷贝控制</strong></p>
<blockquote>
<p>1、当<strong>定义一个类</strong>时，我们<strong>显式地</strong>或<strong>隐式地</strong>指定在此类型的对象<strong>拷贝</strong>、<strong>移动</strong>、<strong>赋值</strong>、<strong>销毁</strong>时要做什么<br>2、一个类通过定义<strong>五种特殊的成员函数</strong>来<strong>控制这些操作</strong>：<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>、<strong>移动构造函数</strong>、<strong>移动赋值运算符</strong>、<strong>析构函数</strong><br>3、<strong>拷贝&#x2F;移动构造函数</strong>定义当<strong>用同类型对象初始化本对象</strong>时的操作；<strong>拷贝&#x2F;移动赋值运算符</strong>定义<strong>将一个对象赋予同类型另一个对象</strong>时的操作；<strong>析构函数</strong>定义当<strong>此类型对象销毁时</strong>的操作。我们称<strong>这些操作</strong>称为<strong>拷贝控制</strong>操作</p>
</blockquote>
</li>
<li><p><strong>拷贝构造函数</strong></p>
<ul>
<li><p><strong>定义拷贝构造函数</strong></p>
<blockquote>
<p>1、如果一个<strong>构造函数</strong>的<strong>第一个参数</strong>是<strong>自身类类型的引用</strong>，且<strong>额外参数</strong>都有<strong>默认值</strong>，则此构造函数是<strong>拷贝构造函数</strong><br>2、虽然我们可以定义一个<strong>接受非</strong><code>const</code><strong>引用</strong>的<strong>拷贝构造函数</strong>，但此参数几乎总是一个<code>const</code><strong>的引用</strong><br>3、<strong>拷贝构造函数</strong>在几种情况下都会被<strong>隐式使用</strong>。因此，<strong>拷贝构造函数</strong>通常<strong>不应该是</strong><code>explicit</code>的</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 默认构造函数</span>
        <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 拷贝构造函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>合成拷贝构造函数</strong></p>
<blockquote>
<p>1、如果我们<strong>没有定义</strong>一个类的<strong>拷贝构造函数</strong>，<strong>编译器</strong>会为我们定义一个<strong>合成的拷贝构造函数</strong><br>2、对于<strong>某些类</strong>来说，<strong>合成拷贝构造函数</strong>用于<strong>阻止拷贝该类对象</strong>；而<strong>一般情况</strong>下，<strong>合成的拷贝构造函数</strong>会将其<strong>参数的成员逐个拷贝</strong>到正在创建的对象中，<strong>编译器</strong>从<strong>给定对象</strong>中依次将<strong>每个非</strong><code>static</code><strong>成员</strong>拷贝到<strong>当前创建的对象</strong>中<br>3、每个成员的<strong>类类型</strong>决定了它<strong>如何拷贝</strong>：对<strong>类类型</strong>的成员，会使用其<strong>拷贝构造函数</strong>来拷贝；对于<strong>内置类型</strong>的成员，则<strong>直接拷贝</strong>。虽然我们<strong>不能直接拷贝</strong>一个数组，但<strong>合成拷贝构造函数</strong>会<strong>逐个拷贝数组元素</strong><br>4、作为例子，下面的代码等价于先前定义的<code>Sales_data</code>的<strong>合成拷贝构造函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">Sales_data</span><span class="token double-colon punctuation">::</span><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>orig<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bookNo</span><span class="token punctuation">(</span>orig<span class="token punctuation">.</span>bookNo<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">units_sold</span><span class="token punctuation">(</span>orig<span class="token punctuation">.</span>units_sold<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">revenue</span><span class="token punctuation">(</span>orig<span class="token punctuation">.</span>revenue<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>拷贝初始化</strong></p>
<blockquote>
<p>1、现在，我们可以完全理解<strong>直接初始化</strong>和<strong>拷贝初始化</strong>之间的差异了，如下例<br>2、当使用<strong>直接初始化</strong>时，我们实际上是要求<strong>编译器</strong>使用<strong>普通的函数匹配</strong>来选择<strong>与提供参数最匹配</strong>的<strong>构造函数</strong>；而使用<strong>拷贝初始化</strong>时，我们要求<strong>编译器</strong>将<strong>右侧运算对象</strong>拷贝到正在创建的对象中，如果需要的话还要进行<strong>类型转换</strong><br>3、<strong>拷贝初始化</strong>在以下情况时会发生：使用<code>=</code><strong>定义变量</strong>；将<strong>对象</strong>作为<strong>实参</strong>传递给一个<strong>非引用类型</strong>的<strong>形参</strong>；从<strong>返回类型为非引用类型</strong>的函数返回对象；用<strong>花括号列表初始化数组元素</strong>或<strong>聚合类成员</strong><br>4、此外，<strong>某些类类型</strong>会对它们<strong>分配的对象</strong>使用<strong>拷贝初始化</strong>：当我们<strong>初始化标准库容器</strong>，或调用其<code>insert</code>或<code>push</code><strong>成员</strong>，容器会对其元素进行<strong>拷贝初始化</strong>。与之相对，用<code>emplace</code><strong>创建的元素</strong>都进行<strong>直接初始化</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">dots</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'.'</span><span class="token punctuation">)</span>                      <span class="token comment">// 直接初始化</span>
string <span class="token function">s</span><span class="token punctuation">(</span>dots<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">// 直接初始化</span>
string s2 <span class="token operator">=</span> dots<span class="token punctuation">;</span>                         <span class="token comment">// 拷贝初始化</span>
string null_book <span class="token operator">=</span> <span class="token string">"9-999-99999-9"</span><span class="token punctuation">;</span>       <span class="token comment">// 拷贝初始化</span>
string nines <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 拷贝初始化</span></code></pre>
</li>
<li><p><strong>参数、返回值、引用与限制</strong></p>
<blockquote>
<p>1、在<strong>参数调用</strong>过程中，具有<strong>非引用类型</strong>的<strong>参数</strong>要进行<strong>拷贝初始化</strong>；类似的，当一个函数具有<strong>非引用的返回类型</strong>时，<strong>返回值</strong>会被用来<strong>初始化调用者的结果</strong><br>2、<strong>拷贝构造函数</strong>被用来<strong>初始化非引用类类型参数</strong>，这也是<strong>拷贝构造函数</strong>的<strong>参数必须是引用</strong>的原因：为了<strong>调用拷贝构造函数</strong>，我们必须<strong>拷贝它的实参</strong>，而为了<strong>拷贝它的实参</strong>，就必须<strong>调用拷贝构造函数</strong><br>3、因此，如果我们使用的<strong>初始化值</strong>要求<strong>通过一个</strong><code>explicit</code><strong>的构造函数</strong>来进行<strong>类型转换</strong>，那么使用<strong>拷贝初始化</strong>还是<strong>直接初始化</strong>就<strong>不是无关紧要的</strong>了，如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 正确：直接初始化</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                      <span class="token comment">// 错误：(已知前提)接受大小参数的构造函数是 explicit 的</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 函数 f 的参数进行拷贝初始化</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 正确：从一个 int 直接构造一个临时 vector 作为参数</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">// 错误：不能用一个 explicit 的构造函数拷贝一个实参</span></code></pre></li>
</ul>
</li>
<li><p><strong>拷贝赋值运算符</strong></p>
<ul>
<li><p><strong>描述</strong></p>
<blockquote>
<p>1、与<strong>类</strong>控制<strong>其对象如何初始化</strong>一样，<strong>类</strong>也可以<strong>控制其对象如何赋值</strong><br>2、与<strong>拷贝构造函数</strong>一样，如果类<strong>未定义</strong>自己的<strong>拷贝赋值运算符</strong>，<strong>编译器</strong>会为它<strong>合成一个</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Sales_data trans<span class="token punctuation">,</span> accum<span class="token punctuation">;</span>
trans <span class="token operator">=</span> accum<span class="token punctuation">;</span>  <span class="token comment">// 使用 Sales_data 的拷贝赋值运算符</span></code></pre>
</li>
<li><p><strong>重载赋值运算符</strong></p>
<blockquote>
<p>1、介绍<strong>合成赋值运算符</strong>之前，我们需要了解一些有关<strong>重载运算符</strong>的知识，详细内容将在 14 章介绍<br>2、<strong>重载运算符</strong>本质上是<strong>函数</strong>，其名字由<code>operator</code>后接<strong>表示要定义的运算符的符号</strong>组成。因此，<strong>赋值运算符</strong>就是一个名为<code>operator=</code>的<strong>函数</strong>。类似于其他函数，<strong>运算符函数</strong>也有一个<strong>返回类型</strong>和一个<strong>参数列表</strong><br>3、<strong>重载运算符</strong>的<strong>参数</strong>表示运算符的<strong>运算对象</strong>。<strong>某些运算符</strong>(包括赋值运算符)必须定义为<strong>成员函数</strong>。如果是一个<strong>运算符</strong>是一个<strong>成员函数</strong>，其<strong>左侧运算对象</strong>就会<strong>绑定到</strong>隐式的<code>this</code><strong>参数</strong>。对于一个<strong>二元运算符</strong>(例如赋值运算符)，其<strong>右侧运算对象</strong>作为<strong>显式参数</strong>传递<br>4、为了与<strong>内置类型赋值</strong>保持一致，<strong>赋值运算符</strong>通常返回一个<strong>其左侧运算对象的引用</strong>；此外<strong>标准库</strong>通常要求<strong>保存在容器中的类型</strong>要<strong>具有赋值运算符</strong>，且其<strong>返回值</strong>是<strong>左侧运算对象的引用</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 赋值运算符</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>合成拷贝赋值运算符</strong></p>
<blockquote>
<p>1、与<strong>拷贝构造函数</strong>一样，如果类<strong>未定义</strong>自己的<strong>拷贝赋值运算符</strong>，<strong>编译器</strong>会为它生成一个<strong>合成拷贝赋值运算符</strong><br>2、类似<strong>拷贝构造函数</strong>，对于<strong>某些类</strong>，<strong>合成拷贝赋值运算符</strong>用来<strong>禁止类型对象赋值</strong>。如果<strong>并非出于此目的</strong>，它会将<strong>右侧运算对象</strong>的每个<strong>非</strong><code>static</code><strong>成员</strong>赋予<strong>左侧运算对象</strong>的对应成员，这一工作通过<strong>拷贝赋值运算符</strong>来完成<br>3、对于<strong>数组类型</strong>的成员，<strong>逐个赋值</strong>数组元素，<strong>合成拷贝赋值运算符</strong>返回一个<strong>左侧运算对象的引用</strong><br>4、作为例子，下面的代码等价于先前定义的<code>Sales_data</code>的<strong>合成拷贝赋值运算符</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Sales_data<span class="token operator">&amp;</span> Sales_data<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    bookNo <span class="token operator">=</span> rhs<span class="token punctuation">.</span>bookNo<span class="token punctuation">;</span>                        <span class="token comment">// 调用 string::operator=</span>
    units_sold <span class="token operator">=</span> rhs<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>                <span class="token comment">// 使用内置的 int 赋值</span>
    revenue <span class="token operator">=</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>                      <span class="token comment">// 使用内置的 double 赋值</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                               <span class="token comment">// 返回一个此对象的引用</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>析构函数</strong></p>
<ul>
<li><p><strong>定义析构函数</strong></p>
<blockquote>
<p>1、<strong>析构函数</strong>执行与<strong>构造函数</strong>相反的操作，其<strong>释放对象使用的资源</strong>，并<strong>销毁对象</strong>的<strong>非</strong><code>static</code><strong>数据成员</strong><br>2、<strong>析构函数</strong>是<strong>类</strong>的一个<strong>成员函数</strong>，名字由<strong>波浪号</strong><code>~</code>后接<strong>类名</strong>构成。它<strong>没有返回值</strong>，也<strong>不接受参数</strong><br>3、由于<strong>析构函数不接收参数</strong>，因此它<strong>不能被重载</strong>。对一个<strong>给定类</strong>，只有<strong>唯一一个析构函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 析构函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>析构函数的工作</strong></p>
<blockquote>
<p>1、如同<strong>构造函数</strong>有一个<strong>初始化部分</strong>和一个<strong>函数体</strong>，<strong>析构函数</strong>也有一个<strong>函数体</strong>和一个<strong>析构部分</strong><br>2、在一个<strong>构造函数</strong>中，<strong>成员初始化</strong>是在<strong>函数体执行之前</strong>完成的，且按照它们<strong>在类中出现的顺序</strong>初始化。而在一个<strong>析构函数</strong>中，<strong>首先执行函数体</strong>，然后<strong>销毁成员</strong>，成员按<strong>初始化顺序逆序</strong>销毁<br>3、在一个<strong>析构函数</strong>中，不存在类似<strong>构造函数</strong>中<strong>初始化列表</strong>的东西来<strong>控制成员如何销毁</strong>。<strong>析构部分</strong>是<strong>隐式的</strong>，成员<strong>销毁时发生什么</strong>完全依赖于<strong>成员的类型</strong>：销毁<strong>类类型成员</strong>需要执行<strong>成员自己的析构函数</strong>；而<strong>内置类型没有析构函数</strong>，因此销毁<strong>内置类型成员</strong>什么也不需要做<br>4、<strong>隐式销毁内置指针</strong>不会<code>delete</code>其<strong>指向的对象</strong>。而与<strong>普通指针</strong>不同，<strong>智能指针</strong>是<strong>类类型</strong>，所以<strong>有析构函数</strong>，因此其在<strong>析构阶段会被自动销毁</strong></p>
</blockquote>
</li>
<li><p><strong>什么时候会调用析构函数</strong></p>
<blockquote>
<p>1、无论何时<strong>一个对象被销毁</strong>，就会<strong>自动调用其析构函数</strong><br>2、例如：<strong>变量离开作用域</strong>；<strong>对象被销毁</strong>时，其<strong>成员被销毁</strong>；<strong>容器被销毁</strong>时，其<strong>元素被销毁</strong>；对<strong>指向动态分配对象的指针</strong>应用<code>delete</code>时；<strong>创建临时对象</strong>的<strong>完整表达式结束</strong>时<br>3、由于<strong>析构函数自动运行</strong>，我们的程序可以<strong>按需分配资源</strong>，<strong>通常无需担心</strong>何时释放这些资源<br>4、注意：当<strong>指向一个对象</strong>的<strong>引用或指针</strong>离开作用域时，<strong>析构函数不会执行</strong></p>
</blockquote>
</li>
<li><p><strong>合成析构函数</strong></p>
<blockquote>
<p>1、当一个类<strong>未定义</strong>自己的<strong>析构函数</strong>时，<strong>编译器</strong>会为它定义一个<strong>合成析构函数</strong>。在<strong>析构函数体</strong>(无论是否为空)<strong>执行完毕后</strong>，成员才会被<strong>自动销毁</strong><br>2、要认识到<strong>析构函数体</strong>自身<strong>并不直接销毁成员</strong>，成员是在<strong>析构函数体之后</strong>的<strong>析构阶段</strong>中<strong>被销毁</strong>的，<strong>析构函数体</strong>是作为<strong>成员销毁步骤之外</strong>的另一部分而进行的<br>3、下面的代码等价于先前定义的<code>Sales_data</code>的<strong>析构函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Sales_data</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 成员会被自动销毁，除此之外不需要做其他事情</span>
        <span class="token operator">~</span><span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>三&#x2F;五法则</strong></p>
<ul>
<li><p><strong>描述</strong></p>
<blockquote>
<p>1、如前所述，有<strong>三个基本操作</strong>可以<strong>控制类的拷贝</strong>：<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>、<strong>析构函数</strong>，称为<strong>三法则</strong><br>2、<strong>新标准</strong>下，还可以定义<strong>两个操作</strong>：<strong>移动构造函数</strong>和一个<strong>移动赋值运算符</strong>，在<strong>三法则</strong>基础上<strong>加上这两个操作</strong>称为<strong>五法则</strong><br>3、<strong>C++<strong>虽然</strong>不要求</strong>我们<strong>定义所有操作</strong>，但<strong>三&#x2F;五法则</strong>的操作<strong>通常被看作整体</strong>。通常，<strong>只需要其中一个操作</strong>而<strong>不需要定义所有操作</strong>的情况是<strong>很少见的</strong>，其需要满足两项<strong>基本原则</strong></p>
</blockquote>
</li>
<li><p><strong>基本原则</strong></p>
<blockquote>
<p>1、<strong>需要析构函数</strong>的类<strong>也需要拷贝和赋值操作</strong>：通常，对<strong>析构函数</strong>的需求比对<strong>拷贝构造函数</strong>或<strong>赋值运算符</strong>的需求<strong>更为明显</strong>，如果一个类<strong>需要析构函数</strong>，几乎可以肯定它<strong>也需要拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong><br>2、需要<strong>拷贝操作</strong>的类也需要<strong>赋值操作</strong>，<strong>反之亦然</strong>：如果一个类<strong>需要拷贝构造函数</strong>，几乎可以肯定它<strong>也需要拷贝赋值运算符</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>阻止拷贝</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、虽然<strong>大多数类</strong>应该定义<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>，但对<strong>某些类</strong>来说，这些操作<strong>没有合理的意义</strong><br>2、此情况下，<strong>定义类</strong>时必须采用某种机制<strong>阻止拷贝或赋值</strong>。例如，<code>iostream</code><strong>阻止了拷贝</strong>，以<strong>避免</strong>多个对象<strong>写入或读取相同</strong><code>IO</code><strong>缓冲</strong><br>3、但是<strong>如何阻止拷贝</strong>？即使<strong>不定义拷贝控制成员</strong>，<strong>编译器</strong>也会为其生成<strong>合成版本</strong></p>
</blockquote>
</li>
<li><p><strong>定义删除的函数</strong></p>
<blockquote>
<p>1、<strong>新标准</strong>下，我们可以通过将<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>定义为<strong>删除的函数</strong>来<strong>阻止拷贝</strong><br>2、<strong>删除的函数</strong>是这样一种函数：我们虽然<strong>声明了它</strong>，但<strong>不能以任何方式使用</strong>它。在函数的<strong>参数列表后</strong>加上<code>=delete</code>来定义<strong>删除的函数</strong><br>3、与<code>=default</code><strong>不同</strong>，<code>=delete</code>必须出现在<strong>函数首次声明</strong>时，此外我们<strong>可以对任何函数指定</strong><code>=delete</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">NoCopy</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>                         <span class="token comment">// 使用合成的默认构造函数</span>
    <span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token keyword">const</span> NoCopy<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>             <span class="token comment">// 将拷贝构造函数定义为删除，阻止拷贝</span>
    NoCopy <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NoCopy<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>  <span class="token comment">// 将拷贝赋值运算符定义为删除，阻止赋值</span>
    <span class="token operator">~</span><span class="token function">NoCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>                        <span class="token comment">// 使用合成的析构函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>析构函数不能删除</strong></p>
<blockquote>
<p>1、注意：我们<strong>不能删除析构函数</strong>。如果<strong>析构函数被删除</strong>，就<strong>无法销毁此类对象</strong>了<br>2、对于一个<strong>删除了析构函数的类</strong>，<strong>编译器</strong>将<strong>不允许</strong>定义该类<strong>变量</strong>或创建该类<strong>临时对象</strong>，而且我们也<strong>不能定义该类变量或临时对象</strong><br>3、虽然我们<strong>不能定义</strong>这种类型的<strong>变量或成员</strong>，但<strong>可以动态分配</strong>这种类型的<strong>对象</strong>。但注意，<strong>不能释放这些对象</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">NoDtor</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">NoDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>               <span class="token comment">// 使用合成的默认构造函数</span>
    <span class="token operator">~</span><span class="token function">NoDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>               <span class="token comment">// 删除了析构函数，我们将不能销毁 NoDtor 对象</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

NoDtor nd<span class="token punctuation">;</span>                            <span class="token comment">// 错误：NoDtor 的析构函数被删除，不能定义该类对象</span>
NoDtor <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">NoDtor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 正确：可以动态分配该类对象，但不能销毁</span>
<span class="token keyword">delete</span> p<span class="token punctuation">;</span>                             <span class="token comment">// 错误：NoDtor 的析构函数是删除的</span></code></pre>
</li>
<li><p><code>private</code><strong>拷贝控制</strong></p>
<blockquote>
<p>1、在<strong>新标准发布前</strong>，<strong>类</strong>通过将其<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>声明为<code>private</code>来<strong>阻止拷贝</strong>(现在也可以这样做)<br>2、如下例：由于<strong>析构函数</strong>是<code>public</code>的，用户<strong>可以定义该类型对象</strong>；由于<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>是<code>private</code>的，用户代码<strong>不能拷贝该类型对象</strong>，但注意<strong>友元</strong>和<strong>成员函数</strong>仍<strong>可以拷贝对象</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrivateCopy</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token function">PrivateCopy</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrivateCopy<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        PrivateCopy <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PrivateCopy<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">PrivateCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
        <span class="token operator">~</span><span class="token function">PrivateCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a><strong>拷贝控制和资源管理</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、通常，管理<strong>类外资源的类</strong>必须<strong>定义拷贝控制成员</strong>(三&#x2F;五法则的成员)。为了<strong>定义这些成员</strong>，我们首先必须<strong>定义此类对象</strong>的<strong>拷贝语义</strong>：通过<strong>定义拷贝操作</strong>，使<strong>类的行为</strong>看起来像<strong>一个值</strong>或<strong>一个指针</strong><br>2、<strong>类的行为像一个值</strong>：类<strong>有自己的状态</strong>，当<strong>拷贝像值的对象</strong>时，副本与原对象<strong>完全独立</strong>，改变副本<strong>不会对原对象有影响</strong>，反之亦然<br>3、<strong>类的行为像一个指针</strong>：类<strong>共享状态</strong>，当<strong>拷贝像指针的对象</strong>时，副本和原对象<strong>使用相同底层数据</strong>，改变副本<strong>也会改变原对象</strong>，反之亦然<br>4、为了说明这两种方式，我们将为<code>HasPtr</code><strong>类</strong>定义<strong>拷贝控制成员</strong>，该类有<strong>两个成员</strong>：一个<strong>int</strong>和一个<code>string</code><strong>指针</strong>。这些成员<strong>本身就是值</strong>，因此通常<strong>应该让它们的行为像值</strong>。而我们<strong>如何拷贝指针成员</strong>决定了像<code>HasPtr</code><strong>这样的类</strong>是具有<strong>类值行为</strong>还是<strong>类指针行为</strong></p>
</blockquote>
</li>
<li><p><strong>行为像值的类</strong></p>
<ul>
<li><p><strong>定义行为像值的类</strong></p>
<blockquote>
<p>1、为了提供<strong>类值的行为</strong>，对于<strong>类管理的资源</strong>，每个对象都应该有一份<strong>自己的拷贝</strong>。如下例<code>HasPtr</code>，对于<strong>ps</strong>指向的<code>string</code>，每个<code>HasPtr</code><strong>对象</strong>都要有<strong>自己的拷贝</strong><br>2、为了实现<strong>类值类型</strong>，<code>HasPtr</code>需要：定义<strong>拷贝构造函数</strong>，完成<code>string</code><strong>拷贝</strong>，而<strong>不是拷贝指针</strong>；定义<strong>析构函数</strong>来<strong>释放</strong><code>string</code>；定义<strong>拷贝赋值运算符</strong>来<strong>释放对象当前</strong><code>string</code>，并<strong>从右侧运算对象拷贝</strong><code>string</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HasPtr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 默认构造函数</span>
        <span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 拷贝构造函数：对 ps 指向的 string，每个 HasPtr 对象都有自己的拷贝</span>
        <span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 拷贝赋值运算符(还未定义)</span>
        HasPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 析构函数</span>
        <span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">delete</span> ps<span class="token punctuation">;</span>  <span class="token comment">// 记得释放内置的动态指针，其不会自动释放</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        string <span class="token operator">*</span>ps<span class="token punctuation">;</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>类值拷贝赋值运算符</strong></p>
<blockquote>
<p>1、<strong>赋值运算符</strong>通常组合了<strong>析构函数</strong>和<strong>构造函数</strong>的操作。其<strong>销毁左侧运算对象</strong>并<strong>从右侧运算对象拷贝数据</strong>，但要<strong>特别注意</strong>这些操作要<strong>按正确顺序</strong>执行，有关的大多错误<strong>编译器不会提示</strong><br>2、如下例，定义了<code>HasPtr</code>的<strong>赋值运算符</strong>。此外为了说明<strong>防范自赋值操作</strong>的重要性，思考下面列出的<strong>第二个反例</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">HasPtr<span class="token operator">&amp;</span> HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> newp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝底层 string</span>
    <span class="token keyword">delete</span> ps<span class="token punctuation">;</span>                          <span class="token comment">// 释放旧内存</span>
    ps <span class="token operator">=</span> newp<span class="token punctuation">;</span>                          <span class="token comment">// 从右侧运算对象拷贝数据到本对象</span>
    i <span class="token operator">=</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                       <span class="token comment">// 返回本对象</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 反例，这样编写是错误的！</span>
HasPtr<span class="token operator">&amp;</span> HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">delete</span> ps<span class="token punctuation">;</span>                          <span class="token comment">// 释放对象指向的 string</span>
    <span class="token comment">// 注意：如果 rhs 和 *this 是同一个对象，我们将从已释放的内存中拷贝数据</span>
    ps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
    i <span class="token operator">=</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>行为像指针的类</strong></p>
<ul>
<li><p><strong>定义行为像指针的类</strong></p>
<blockquote>
<p>1、对于<strong>行为类似指针的类</strong>，我们需要为其定义<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>，用来<strong>拷贝指针成员本身</strong>而不是<strong>它指向的</strong><code>string</code><br>2、我们的类虽然<strong>仍然需要析构函数</strong>来<strong>释放</strong>构造函数<strong>分配的内存</strong>，但<strong>不能单方面释放</strong>，只有当<strong>最后一个指向</strong><code>string</code><strong>的</strong><code>HasPtr</code><strong>被销毁</strong>才能释放<br>3、令一个类展现<strong>类指针行为</strong>的<strong>最好办法</strong>是用<code>shared_ptr</code>来<strong>管理资源</strong>。<strong>拷贝</strong><code>shared_ptr</code>便会<strong>拷贝指针</strong>，且<code>shared_ptr</code>自带<strong>引用计数</strong>，能<strong>在恰当时间释放内存</strong><br>4、但有时我们希望<strong>直接管理资源</strong>，这时使用<strong>引用计数</strong>就很有用了。我们将<strong>重新定义</strong><code>HasPtr</code>使其具有<strong>类指针行为</strong>，并不使用<code>shared_ptr</code></p>
</blockquote>
</li>
<li><p><strong>引用计数的工作方式</strong></p>
<blockquote>
<p>1、除了<strong>初始化对象</strong>外，每个<strong>构造函数</strong>(拷贝构造函数除外)还要<strong>创建一个引用计数</strong>，用于记录<strong>有多少对象</strong>与创建的对象<strong>共享状态</strong>。当我们<strong>创建一个对象</strong>时，只有一个对象<strong>共享状态</strong>因此将<strong>计数器初始化为 1</strong><br>2、<strong>拷贝构造函数</strong>不分配<strong>新的计数器</strong>，而是<strong>拷贝</strong>给定对象的<strong>数据成员</strong>，也包括<strong>计数器</strong>。其递增<strong>共享的计数器</strong>，指出<strong>给定对象</strong>的状态又被一个<strong>新用户所共享</strong><br>3、<strong>析构函数</strong>将<strong>递减计数器</strong>，指出<strong>共享状态</strong>的<strong>用户少了一个</strong>。如果<strong>计数器变为 0</strong>，则<strong>析构函数</strong>就必须<strong>销毁状态</strong><br>4、<strong>拷贝赋值运算符</strong>将<strong>递增右侧对象计数器</strong>，<strong>递减左侧对象计数器</strong>。如果<strong>左侧对象计数器为 0</strong>，则它<strong>没有共享用户</strong>，<strong>拷贝赋值运算符</strong>就必须<strong>销毁状态</strong></p>
</blockquote>
</li>
<li><p><strong>定义使用引用计数的类</strong></p>
<blockquote>
<p>1、通过使用<strong>引用计数</strong>，我们就可以编写<strong>类指针行为</strong>的<code>HasPtr</code>了<br>2、在此，我们添加了名为<code>use</code>的<strong>数据成员</strong>，用于记录<strong>有多少对象共享相同</strong><code>string</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HasPtr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 构造函数分配新的 string 和新的计数器，将计数器置为 1</span>
        <span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 拷贝构造函数拷贝所有三个数据成员，并递增计数器</span>
        <span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ps</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">i</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">use</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>use<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token operator">++</span><span class="token operator">*</span>use<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        HasPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        string <span class="token operator">*</span>ps<span class="token punctuation">;</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        size_t <span class="token operator">*</span>use<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>类指针析构函数和拷贝赋值运算符</strong></p>
<blockquote>
<p>1、<strong>析构函数</strong>不能<strong>无条件地</strong><code>delete</code>，因为<strong>可能还有其他对象</strong>指向这块内存。其应该先<strong>递减引用计数</strong>，然后判断如果<strong>计数器变为 0</strong>，再<strong>释放动态指针</strong>的内存<br>2、<strong>拷贝赋值运算符</strong>与往常一样执行类似<strong>拷贝构造函数</strong>和<strong>析构函数</strong>的工作。它<strong>递增右侧对象计数</strong>，<strong>递减左侧对象计数</strong>，必要时<strong>释放左侧对象内存</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">HasPtr</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">HasPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span><span class="token operator">*</span>use <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>           <span class="token comment">// 如果引用计数变为 0</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">delete</span> ps<span class="token punctuation">;</span>            <span class="token comment">// 释放 string 内存</span>
        <span class="token keyword">delete</span> use<span class="token punctuation">;</span>           <span class="token comment">// 释放计数器内存</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

HasPtr<span class="token operator">&amp;</span> HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token operator">++</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>use<span class="token punctuation">;</span>               <span class="token comment">// 递增右侧对象计数</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span><span class="token operator">*</span>use <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>           <span class="token comment">// 递减本对象计数</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">delete</span> ps<span class="token punctuation">;</span>            <span class="token comment">// 释放 string 内存</span>
        <span class="token keyword">delete</span> use<span class="token punctuation">;</span>           <span class="token comment">// 释放计数器内存</span>
    <span class="token punctuation">&#125;</span>

    ps <span class="token operator">=</span> rhs<span class="token punctuation">.</span>ps<span class="token punctuation">;</span>              <span class="token comment">// 将数据从 rhs 拷贝到本对象</span>
    i <span class="token operator">=</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    use <span class="token operator">=</span> rhs<span class="token punctuation">.</span>use<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>             <span class="token comment">// 返回本对象</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a><strong>交换操作</strong></h4><ul>
<li><p><strong>交换操作</strong></p>
<blockquote>
<p>1、除了定义<strong>拷贝控制成员</strong>，<strong>管理资源的类</strong>通常还要定义一个<code>swap</code><strong>函数</strong>。对于要与<strong>重排元素顺序的算法</strong>一起使用的<strong>类</strong>，定义<code>swap</code><strong>尤为重要</strong>，<strong>这类算法</strong>在<strong>交换两个元素</strong>时会<strong>调用</strong><code>swap</code><br>2、如果一个类<strong>定义了自己的</strong><code>swap</code>，那么<strong>算法</strong>将使用<strong>类自定义版本的</strong><code>swap</code>；否则，<strong>算法</strong>将使用<strong>标准库定义的</strong><code>swap</code><br>3、我们虽然<strong>不知道</strong><code>swap</code>是<strong>如何实现</strong>的，但<strong>理论上</strong>很容易理解：其进行<strong>一次拷贝</strong>和<strong>两次赋值</strong>。例如<strong>交换两个</strong><code>HasPtr</code>的代码可能如下<br>4、但理论上，这些<strong>内存分配</strong>都是<strong>不必要的</strong>，我们更希望<code>swap</code><strong>交换指针</strong>，而不是<strong>分配</strong><code>string</code><strong>的副本</strong>。如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 分配副本的方式</span>
HasPtr temp <span class="token operator">=</span> v1<span class="token punctuation">;</span>               <span class="token comment">// 创建 v1 的值的一个临时副本</span>
v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span>                        <span class="token comment">// 将 v2 的值赋给 v1</span>
v2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>                      <span class="token comment">// 将保存的 v1 的值赋予 v2</span>

<span class="token comment">// 交换指针的方式</span>
string <span class="token operator">*</span>temp <span class="token operator">=</span> v1<span class="token punctuation">.</span>ps<span class="token punctuation">;</span>           <span class="token comment">// 为 v1.ps 中的指针创建一个副本</span>
v1<span class="token punctuation">.</span>ps <span class="token operator">=</span> v2<span class="token punctuation">.</span>ps<span class="token punctuation">;</span>                  <span class="token comment">// 将 v2.ps 的指针赋给 v1.ps</span>
v2<span class="token punctuation">.</span>ps <span class="token operator">=</span> temp<span class="token punctuation">;</span>                   <span class="token comment">// 将保存的 v1.ps 的指针赋予 v2.ps</span></code></pre>
</li>
<li><p><strong>类的 swap</strong></p>
<blockquote>
<p>1、可以在我们的<strong>类</strong>上定义一个<strong>自定义的</strong><code>swap</code>来<strong>重载</strong><code>swap</code>的<strong>默认行为</strong>，其类型实现如下<br>2、我们首先将<code>swap</code><strong>定义为</strong><code>friend</code>，以便访问<strong>数据成员</strong>。由于<code>swap</code>的存在就是为了<strong>优化代码</strong>，因此我们将其声明为<code>inline</code><strong>内联函数</strong>。<code>swap</code><strong>函数体</strong>对给定对象的<strong>每个数据成员</strong>调用了<code>swap</code><br>3、<code>swap</code><strong>函数</strong>应调用<strong>对应类</strong><code>swap</code>，而不是<code>std::swap</code>。具体原因在下一小节介绍</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">HasPtr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>HasPtr <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...省略成员定义</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>HasPtr <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> HasPtr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>ps<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 变换指针，而不是 string 数据</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>i<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 变换 int 成员</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>应调用对应类 swap，而不是 std::swap</strong></p>
<blockquote>
<p>1、上例中，<strong>数据成员</strong>是<strong>内置类型</strong>的，而<strong>内置类型</strong>没有特定版本<code>swap</code>。因此，<strong>对</strong><code>swap</code><strong>的调用</strong>会调用<strong>标准库</strong><code>std::swap</code><br>2、但如果一个类<strong>有特定的</strong><code>swap</code>，那么调用<code>std::swap</code>就是<strong>错误</strong>的了。如果有一个名为<code>Foo</code><strong>类</strong>，他有一个<strong>类型为</strong><code>HasPtr</code>的<strong>成员 h</strong>，如果<strong>未定义</strong><code>Foo</code>的<code>swap</code>，就会使用<strong>标准库版本</strong><code>swap</code>，但其会对<code>HasPtr</code><strong>管理的</strong><code>string</code>进行<strong>不必要的拷贝</strong><br>3、我们可以<strong>为</strong><code>Foo</code><strong>编写</strong><code>swap</code>，来<strong>避免这些拷贝</strong>。但如下<strong>第一段代码</strong>，<strong>此版本</strong>与简单使用<strong>默认版本</strong><code>swap</code><strong>没有任何性能差异</strong>，问题在于我们<strong>显式调用了标准库</strong><code>swap</code>。我们<strong>不希望使用</strong><code>std::swap</code>，而是<strong>希望使用</strong><code>HasPtr</code>的<code>swap</code>，因此<strong>正确的定义</strong>应如<strong>第二段代码</strong><br>4、<strong>特别注意</strong>：每个<code>swap</code><strong>调用</strong>都应该是<strong>未加限定的</strong>，即每个调用都应该是<code>swap</code>而不是显式的<code>std::swap</code>。这种情况下，只要<strong>存在类型特定的</strong><code>swap</code>，其<strong>匹配程度</strong>会<strong>优先于</strong><code>std</code><strong>版本</strong>(即使使用<code>using</code>)。如果<strong>没有特定匹配</strong>，且<strong>作用域内有</strong><code>using std::swap;</code>，才会使用<code>std</code><strong>版本</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 第一段(缺陷)</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Foo <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> Foo <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 错误：该函数使用了 std::swap，而不是 HasPtr 版本的 swap</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>h<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...交换类型 Foo 的其他成员</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 第二段(正确)</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Foo <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> Foo <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>
    <span class="token comment">// 正确：即使使用 using 声明，只要不显式指定使用 std::swap，仍优先使用 HasPtr 版本的 swap</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>h<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...交换类型 Foo 的其他成员</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>赋值运算符中使用 swap</strong></p>
<blockquote>
<p>1、<strong>定义</strong><code>swap</code><strong>的类</strong>通常用<code>swap</code>来<strong>定义赋值运算符</strong>。<strong>这些运算符</strong>使用了一种名为<strong>拷贝并交换</strong>的技术，将<strong>左侧对象</strong>与<strong>右侧对象的副本</strong>进行交换<br>2、这个技术的有趣之处是他<strong>自动处理了自赋值情况</strong>且天然就能<strong>保证异常安全</strong>。它在<strong>改变左侧对象</strong>之前<strong>拷贝右侧对象</strong>，保证了<strong>自赋值的正确</strong>；能<strong>保证异常安全</strong>的原因是代码唯一可能<strong>抛出异常</strong>的是<strong>拷贝构造函数</strong>中的<code>new</code>，而它<strong>就算发生异常</strong>会也在<strong>改变左侧对象</strong>之前发生</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 注意 rhs 是按值传递的，意味着 HasPtr 的拷贝构造函数将右侧对象的 string 拷贝到 rhs 中</span>
HasPtr <span class="token operator">&amp;</span>HasPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>HasPtr rhs<span class="token punctuation">)</span>   <span class="token comment">// rhs 是右侧对象的一个副本</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 交换左侧对象和局部变量 rhs 的内容</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// rhs 现在指向本对象曾经使用的内存</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                       <span class="token comment">// rhs 被销毁，从而 delete 了 rhs 中的指针</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="拷贝控制示例"><a href="#拷贝控制示例" class="headerlink" title="拷贝控制示例"></a><strong>拷贝控制示例</strong></h4><ul>
<li><p><strong>描述</strong></p>
<blockquote>
<p>1、虽然通常来说<strong>分配资源</strong>的类更需要<strong>拷贝控制</strong>，但<strong>资源管理</strong>不是一个<strong>类需要拷贝控制</strong>的<strong>唯一原因</strong>，一些类也需要<strong>拷贝控制</strong>来进行<strong>簿记工作</strong>和<strong>其他操作</strong><br>2、作为类需要<strong>拷贝控制</strong>来进行<strong>簿记工作</strong>的例子，我们将定义<code>Message</code>和<code>Folder</code><strong>类</strong>，分别表示<strong>电子邮件消息</strong>和<strong>消息目录</strong>。每个<code>Message</code>的内容<strong>只有一个副本</strong>，以确保<strong>从任何</strong><code>Folder</code>查看此<code>Message</code>都会看到<strong>修改后的内容</strong>。为了记录<code>Message</code><strong>位于哪些</strong><code>Folder</code>中，每个<code>Message</code>都保存一个<strong>它所在</strong><code>Folder</code><strong>的</strong><code>set</code>；同样，每个<code>Folder</code>都保存一个<strong>它包含</strong><code>Message</code><strong>的指针的</strong><code>set</code><br>3、篇幅原因，我们在此只设计<code>Message</code>类，但我们假定<code>Folder</code>类有<code>addMsg</code>和<code>remMsg</code>两个<strong>成员函数</strong>，分别用于在<strong>给定</strong><code>Folder</code><strong>对象</strong>中<strong>添加或删除</strong><code>Message</code></p>
</blockquote>
</li>
<li><p><strong>Message 类的设计</strong></p>
<blockquote>
<p>1、<code>Message</code>将提供<code>save</code>和<code>remove</code><strong>操作</strong>，向一个<strong>给定</strong><code>Folder</code><strong>添加或删除</strong><code>Message</code>。创建<code>Message</code>时<strong>只需指明消息内容</strong>，<strong>不会指出</strong><code>Folder</code>，而将<code>Message</code><strong>放到特定</strong><code>Folder</code>中<strong>必须调用</strong><code>save</code><br>2、当<strong>拷贝</strong><code>Message</code>时，<strong>副本</strong>和<strong>原对象</strong>是<strong>不同的</strong><code>Message</code><strong>对象</strong>，但两个<code>Message</code>出现在<strong>相同的</strong><code>Folder</code>中。因此，<strong>拷贝操作</strong>包括<strong>消息内容</strong>和<code>Folder</code><strong>指针</strong><code>set</code>的拷贝，而且我们必须在<strong>所有其所在的</strong><code>Folder</code>中<strong>添加指向新创建</strong><code>Message</code><strong>的指针</strong><br>3、<strong>销毁一个</strong><code>Message</code>，它将<strong>不复存在</strong>。因此，我们必须从<strong>所有其所在的</strong><code>Folder</code>中<strong>删除指向该</strong><code>Message</code><strong>的指针</strong><br>4、当将<strong>一个</strong><code>Message</code><strong>赋予另一个</strong><code>Message</code><strong>对象</strong>时，<strong>左侧对象内容</strong>会被<strong>右侧对象内容</strong>所替代。我们还<strong>必须更新</strong><code>Folder</code><strong>的</strong><code>set</code>，从原来<strong>左侧对象</strong>的<code>Folder</code>中<strong>将它删除</strong>，并将它<strong>添加到右侧对象</strong>的<code>Folder</code>中</p>
</blockquote>
</li>
<li><p><strong>定义 Message 类</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Message</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Folder</span><span class="token punctuation">;</span>                          <span class="token comment">// 友元 Folder 类</span>
        <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Message <span class="token operator">&amp;</span><span class="token punctuation">,</span> Message <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 友元 swap 函数</span>

        <span class="token comment">// 默认构造函数：数据成员 folders 被隐式初始化为空 set</span>
        <span class="token keyword">explicit</span> <span class="token function">Message</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">contents</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 拷贝控制成员：管理指向本 Message 的指针</span>
        <span class="token function">Message</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 拷贝构造函数</span>
        Message<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 拷贝赋值运算符</span>
        <span class="token operator">~</span><span class="token function">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token comment">// 析构函数</span>
        <span class="token comment">// 从给定 Folder 的 set 中增加/删除本 Message</span>
        <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>Folder <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Folder <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        string contents<span class="token punctuation">;</span>                              <span class="token comment">// 实际消息文本</span>
        set<span class="token operator">&lt;</span>Folder<span class="token operator">*</span><span class="token operator">></span> folders<span class="token punctuation">;</span>                         <span class="token comment">// 包含本 Message 的 Folder</span>
        <span class="token comment">// 拷贝控制对象所使用的工具函数</span>
        <span class="token keyword">void</span> <span class="token function">add_to_Folders</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 将 Message 添加到指向参数的 Folder 中</span>
        <span class="token keyword">void</span> <span class="token function">remove_from_Folders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 从 folders 中的每个 Folder 中移除本 Message</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>save 和 remove 成员函数</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 将 Message 保存到 Folder</span>
<span class="token keyword">void</span> <span class="token class-name">Message</span><span class="token double-colon punctuation">::</span><span class="token function">save</span><span class="token punctuation">(</span>Folder <span class="token operator">&amp;</span>f<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    folders<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 将给定 Folder 添加到 folders 中</span>
    f<span class="token punctuation">.</span><span class="token function">addMsg</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 将本 Message 添加到 f 的 set 中</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 将 Message 从 Folder 移除</span>
<span class="token keyword">void</span> <span class="token class-name">Message</span><span class="token double-colon punctuation">::</span><span class="token function">remove</span><span class="token punctuation">(</span>Folder <span class="token operator">&amp;</span>f<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    folders<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 将给定 Folder 从 folders 中移除</span>
    f<span class="token punctuation">.</span><span class="token function">remMsg</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 将本 Message 从 f 的 set 中移除</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>拷贝构造函数</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 公共操作：将 Message 添加到指向参数的 Folder 中</span>
<span class="token keyword">void</span> <span class="token class-name">Message</span><span class="token double-colon punctuation">::</span><span class="token function">add_to_Folders</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message <span class="token operator">&amp;</span>m<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> f <span class="token operator">:</span> m<span class="token punctuation">.</span>folders<span class="token punctuation">)</span> <span class="token comment">// 对每个包含 m 的 Folder</span>
        f<span class="token operator">-></span><span class="token function">addMsg</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 向该 Folder 添加指向本 Message 的指针</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 拷贝构造函数：拷贝 contents 和 folders 数据成员</span>
<span class="token class-name">Message</span><span class="token double-colon punctuation">::</span><span class="token function">Message</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">contents</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>contents<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">folders</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>folders<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">add_to_Folders</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将本 Message 添加到指向 m 的 Folder 中</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>析构函数</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 公共操作：从 folders 中的每个 Folder 中移除本 Message</span>
<span class="token keyword">void</span> <span class="token class-name">Message</span><span class="token double-colon punctuation">::</span><span class="token function">remove_from_Folders</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> f <span class="token operator">:</span> folders<span class="token punctuation">)</span> <span class="token comment">// 对 folders 中每个指针</span>
        f<span class="token operator">-></span><span class="token function">remMsg</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 从该 Folder 中移除本 Message</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 析构函数</span>
<span class="token class-name">Message</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">remove_from_Folders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>拷贝复制运算符</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 拷贝赋值运算符</span>
Message <span class="token operator">&amp;</span>Message<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Message <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 通过先删除指针再插入对象，来处理自赋值情况</span>
    <span class="token function">remove_from_Folders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 更新 folders，删除左侧对象所在的 Folder 的记录</span>
    contents <span class="token operator">=</span> rhs<span class="token punctuation">.</span>contents<span class="token punctuation">;</span> <span class="token comment">// 从 rhs 拷贝消息内容</span>
    folders <span class="token operator">=</span> rhs<span class="token punctuation">.</span>folders<span class="token punctuation">;</span>   <span class="token comment">// 从 rhs 拷贝 folders</span>
    <span class="token function">add_to_Folders</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 将该 Message 添加到指向 rhs 的 Folder 中</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>swap 函数</strong></p>
<blockquote>
<p>1、<strong>标准库</strong>中<strong>定义了</strong><code>string</code><strong>和</strong><code>set</code><strong>的</strong><code>swap</code>版本。因此如果我们的<code>Message</code><strong>自定义它的</strong><code>swap</code>，那么它将<strong>从中受益</strong>，<strong>避免</strong>对<code>contents</code>和<code>folders</code>进行<strong>不必要的拷贝</strong><br>2、但同时，我们的<strong>自定义的</strong><code>swap</code>还要<strong>管理被交换的指针</strong>，在<code>Message</code><strong>被交换后</strong>，<strong>原本指向</strong><code>m1</code><strong>的</strong><code>Folder</code>就要<strong>指向</strong><code>m2</code>，反之亦然。这需要我们在<code>swap</code>中<strong>定义相关操作</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// swap 函数</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Message <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> Message <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span> <span class="token comment">// 本例中严格来说并不需要，但这是一个好习惯</span>

    <span class="token comment">// 将每个 Message 的指针从它原来所在 Folder 中删除</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> f <span class="token operator">:</span> lhs<span class="token punctuation">.</span>folders<span class="token punctuation">)</span>
        f<span class="token operator">-></span><span class="token function">remMsg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> f <span class="token operator">:</span> rhs<span class="token punctuation">.</span>folders<span class="token punctuation">)</span>
        f<span class="token operator">-></span><span class="token function">remMsg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 交换 contents 和 folders</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>contents<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>contents<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用 string 类的 swap(string&amp;, string&amp;)</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>folders<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>folders<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 使用 set 类的 swap(set&amp;, set&amp;)</span>

    <span class="token comment">// 将每个 Message 的指针添加到新的 Folder 中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> f <span class="token operator">:</span> lhs<span class="token punctuation">.</span>folders<span class="token punctuation">)</span>
        f<span class="token operator">-></span><span class="token function">addMsg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> f <span class="token operator">:</span> rhs<span class="token punctuation">.</span>folders<span class="token punctuation">)</span>
        f<span class="token operator">-></span><span class="token function">addMsg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a><strong>动态内存管理类</strong></h4><ul>
<li><p><strong>描述</strong>、</p>
<blockquote>
<p>1、某些类需要<strong>在运行时</strong>分配<strong>可变大小</strong>的内存。这种类通常可以使用<strong>标准库容器</strong>来<strong>保存</strong>它们的<strong>数据</strong>，例如之前定义的<code>StrBlob</code>使用<code>vector</code>来<strong>管理其元素</strong>的<strong>底层内存</strong><br>2、但是，这一策略并<strong>不适用于全部类</strong>，某些类需要<strong>自己分配内存</strong>，这些类通常必须<strong>自定义拷贝控制成员</strong>来<strong>管理分配的内存</strong><br>3、我们将实现<strong>标准库</strong><code>vector</code>的<strong>简化版本</strong>，我们只实现其<strong>针对</strong><code>string</code><strong>的版本</strong>，命名为<code>StrVec</code>(只实现部分功能)</p>
</blockquote>
</li>
<li><p><strong>StrVec 类的设计</strong></p>
<blockquote>
<p>1、回忆<code>std::vector</code><strong>的行为</strong>：其将<strong>元素</strong>保存在<strong>连续内存</strong>中，<strong>预先分配足够内存</strong>来保存可能需要的更多元素。<strong>添加元素</strong>的<strong>成员函数</strong>将检查<strong>是否有空间容纳更多元素</strong>：如果有，将在下个可用位置<strong>构造一个对象</strong>；如果没有，则<strong>重新分配空间</strong>，将<strong>已有元素移入新获得的空间</strong>，<strong>释放旧内存</strong>，<strong>添加新元素</strong><br>2、<code>StrVec</code><strong>类</strong>使用<strong>类似的策略</strong>，我们将使用一个<code>allocator</code>来<strong>获得原始内存</strong>。由于<code>allocator</code><strong>分配的内存</strong>是<strong>未构造</strong>的，我们将在需要<strong>添加元素</strong>时用其<code>construct</code><strong>成员</strong>创建对象；类似的，我们将使用<code>destroy</code><strong>成员</strong>销毁元素<br>3、每个<code>StrVec</code>有<strong>三个指针</strong>指向<strong>其元素所使用的内存</strong>：<code>elements</code>指向<strong>已分配的内存</strong>的<strong>首元素</strong>；<code>first_free</code>指向<strong>最后一个实际元素之后的位置</strong>(已分配内存的尾后，未分配内存的首)；<code>cap</code>指向<strong>分配的整个内存的尾后位置</strong>。除了这些指针，<code>StrVec</code>还有一个类型为<code>allocator&lt;string&gt;</code>的<code>alloc</code><strong>静态成员</strong>，用于<strong>分配</strong><code>StrVec</code><strong>使用的内存</strong><br>4、该类还有<strong>四个工具函数</strong>：<code>alloc_n_copy</code>会<strong>分配内存</strong>，并<strong>拷贝给定范围的元素</strong>；<code>free</code>会<strong>销毁构造的元素</strong>并<strong>释放内存</strong>；<code>chk_n_alloc</code><strong>保证</strong><code>StrVec</code>至少有<strong>容纳一个新元素的空间</strong>，如果不够则<strong>添加新元素</strong>，调用<code>reallocate</code><strong>分配内存</strong>；<code>reallocate</code>的<strong>内存用完时</strong>为<code>StrVec</code><strong>分配新内存</strong></p>
</blockquote>
</li>
<li><p><strong>定义 StrVec 类</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 类 vector 的内存分配策略的简化实现</span>
<span class="token keyword">class</span> <span class="token class-name">StrVec</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// allocator 成员进行默认初始化</span>
        <span class="token function">StrVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">elements</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">first_free</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">StrVec</span><span class="token punctuation">(</span><span class="token keyword">const</span> StrVec <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 拷贝构造函数</span>
        StrVec <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> StrVec <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝赋值运算符</span>
        <span class="token operator">~</span><span class="token function">StrVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 析构函数</span>
        <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝元素</span>

        size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> first_free <span class="token operator">-</span> elements<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        size_t <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> cap <span class="token operator">-</span> elements<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        string <span class="token operator">*</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> elements<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        string <span class="token operator">*</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> first_free<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// ...</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        <span class="token keyword">static</span> allocator<span class="token operator">&lt;</span>string<span class="token operator">></span> alloc<span class="token punctuation">;</span> <span class="token comment">// 分配元素</span>

        <span class="token comment">// 被添加元素的函数所使用</span>
        <span class="token keyword">void</span> <span class="token function">chk_n_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 工具函数，被拷贝构造函数、赋值运算符和析构函数所使用</span>
        pair<span class="token operator">&lt;</span>string <span class="token operator">*</span><span class="token punctuation">,</span> string <span class="token operator">*</span><span class="token operator">></span> <span class="token function">alloc_n_copy</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 销毁元素并释放内存</span>
        <span class="token keyword">void</span> <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获得更多内存并拷贝已有元素</span>
        string <span class="token operator">*</span>elements<span class="token punctuation">;</span>   <span class="token comment">// 指向数组首元素的指针</span>
        string <span class="token operator">*</span>first_free<span class="token punctuation">;</span> <span class="token comment">// 指向数组第一个空闲元素的指针(未分配内存的首)</span>
        string <span class="token operator">*</span>cap<span class="token punctuation">;</span>        <span class="token comment">// 指向数组尾后位置的指针</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>使用 construct</strong></p>
<blockquote>
<p>1、函数<code>push_back</code><strong>调用</strong><code>chk_n_alloc</code>确保<strong>有空间容纳新元素</strong>，如果需要，<code>chk_n_alloc</code>会调用<code>reallocate</code>。当<code>chk_n_alloc</code><strong>返回</strong>时，<code>push_back</code>知道<strong>必定有空间</strong>容纳新元素，便可以要求<code>allocator</code><strong>类型成员</strong>来<code>construct</code><strong>新的尾元素</strong><br>2、<code>construct</code><strong>第一个参数</strong>是一个<strong>指针</strong>，指向调用<code>allocate</code>所分配的<strong>未构造内存空间</strong>；<strong>剩余参数</strong>用于确定<strong>用哪个构造函数</strong>来<strong>构造对象</strong><br>3、值得注意的是，对<code>construct</code><strong>的调用</strong>也会<strong>递增</strong><code>first_free</code>，表示<strong>已经构造了新元素</strong>，其使用<strong>前置递增</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// push_back 函数</span>
<span class="token keyword">void</span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">chk_n_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 确保有空间分配元素</span>
    alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>first_free<span class="token operator">++</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在 first_free 指向的元素中构造 s 的副本</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>alloc_n_copy 成员</strong></p>
<blockquote>
<p>1、我们在<strong>拷贝或赋值</strong><code>StrVec</code>时，可能会调用<code>alloc_n_copy</code><strong>成员函数</strong>。类似<code>vector</code>，我们的<code>StrVec</code>也要有<strong>类值的行为</strong>。当我们<strong>拷贝或赋值</strong><code>StrVec</code>时必须<strong>分配独立的内存</strong>，并从原<code>StrVec</code>中<strong>拷贝元素至新对象</strong><br>2、<code>alloc_n_copy</code>会<strong>分配足够内存</strong>来保存给定范围的元素，并将这些元素<strong>拷贝到新分配的内存</strong>中。其返回一个<strong>指针的</strong><code>pair</code>，分别指向<strong>新空间</strong>的<strong>开始位置</strong>和<strong>尾后位置</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// alloc_n_copy 函数</span>
pair<span class="token operator">&lt;</span>string <span class="token operator">*</span><span class="token punctuation">,</span> string <span class="token operator">*</span><span class="token operator">></span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">alloc_n_copy</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 分配空间保存给定范围中的元素</span>
    <span class="token keyword">auto</span> data <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>e <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化并返回一个 pair，该 pair 由 data 和 uninitialized_copy 的返回值(都是指针)构成</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>data<span class="token punctuation">,</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>free 成员</strong></p>
<blockquote>
<p>1、<code>free</code>有<strong>两个责任</strong>：首先<code>destroy</code><strong>元素</strong>，然后<strong>释放</strong><code>StrVec</code><strong>自己分配的内存空间</strong><br>2、<code>for</code>调用<code>allocator</code>的<code>destroy</code><strong>成员</strong>(其会运行<code>string</code>的析构函数)，从构造的<strong>尾元素开始</strong>，到<strong>首元素为止</strong>，<strong>逆序销毁所有元素</strong>。一旦<strong>元素被销毁</strong>，我们就调用<code>deallocate</code>来<strong>释放本</strong><code>StrVec</code><strong>分配的内存</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// free 函数</span>
<span class="token keyword">void</span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 不能传递给 deallocate 空指针，如果 elements 为 0，函数什么也不做</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 逆序销毁旧元素</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">=</span> first_free<span class="token punctuation">;</span> p <span class="token operator">!=</span> elements<span class="token punctuation">;</span> <span class="token comment">/* 空 */</span><span class="token punctuation">)</span>
            alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> cap <span class="token operator">-</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>拷贝控制成员</strong></p>
<blockquote>
<p>1、实现了<code>alloc_n_copy</code>和<code>free</code><strong>成员</strong>后，想要实现<strong>拷贝控制成员</strong>就很简单了<br>2、<strong>拷贝构造函数</strong>调用<code>alloc_n_copy</code>，将<strong>返回结果</strong>赋予<strong>数据成员</strong>：<code>alloc_n_copy</code>的<strong>返回值</strong>是一个<strong>指针的</strong><code>pair</code>，其<code>first</code>指向<strong>新构造空间的首元素</strong>，<code>second</code>指向<strong>尾后位置</strong><br>3、<strong>析构函数</strong>调用<code>free</code><br>4、<strong>拷贝赋值运算符</strong>在<strong>释放已有内存</strong>前调用<code>alloc_n_copy</code>，以正确处理<strong>自赋值问题</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 拷贝构造函数</span>
<span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">StrVec</span><span class="token punctuation">(</span><span class="token keyword">const</span> StrVec <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 调用 alloc_n_copy 分配空间</span>
    <span class="token keyword">auto</span> newdata <span class="token operator">=</span> <span class="token function">alloc_n_copy</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    elements <span class="token operator">=</span> newdata<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
    first_free <span class="token operator">=</span> cap <span class="token operator">=</span> newdata<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 析构函数</span>
<span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">StrVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 拷贝赋值运算符</span>
StrVec <span class="token operator">&amp;</span>StrVec<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> StrVec <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 调用 alloc_n_copy 分配空间</span>
    <span class="token keyword">auto</span> data <span class="token operator">=</span> <span class="token function">alloc_n_copy</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rhs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    elements <span class="token operator">=</span> data<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
    first_free <span class="token operator">=</span> cap <span class="token operator">=</span> data<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>reallocate 成员</strong></p>
<ul>
<li><p><strong>在重新分配内存过程中移动而不是拷贝元素</strong></p>
<blockquote>
<p>1、在编写用于<strong>重新分配内存</strong>的<code>reallocate</code>之前，我们先思考此函数<strong>应该做什么</strong>：为一个<strong>新的更大的</strong><code>string</code><strong>分配内存</strong>；在内存空间前一部分<strong>构造对象</strong>，<strong>保存现有元素</strong>；<strong>销毁原内存元素</strong>，<strong>释放这块内存</strong><br>2、我们可以看出，为一个<code>StrVec</code><strong>重新分配内存</strong>会引起<strong>从旧内存到新内存逐个拷贝</strong><code>string</code>。虽然我们不知道<code>string</code><strong>具体实现细节</strong>，但知道<code>string</code>具有<strong>类值行为</strong>，因此<strong>拷贝</strong><code>string</code>就<strong>必须真的拷贝数据</strong><br>3、但对于<code>reallocate</code><strong>要拷贝</strong><code>StrVec</code>的<code>string</code>时，一旦将<strong>旧空间元素</strong>拷贝到新空间后，这些<strong>旧空间元素</strong>就<strong>不再需要</strong>了，而又<strong>被释放</strong>。因此<strong>拷贝这些</strong><code>string</code><strong>的数据</strong>是<strong>多余</strong>的，如果我们能<strong>避免分配和释放</strong><code>string</code>的<strong>额外开销</strong>，<code>StrVec</code>的<strong>性能会好得多</strong></p>
</blockquote>
</li>
<li><p><strong>移动构造函数和 std::move</strong></p>
<blockquote>
<p>1、通过使用<strong>新标准库</strong>引入的<strong>两种机制</strong>，我们就可以避免<code>string</code><strong>拷贝的花销</strong><br>2、首先，有一些<strong>标准类</strong>(包括<code>string</code>)，都定义了<strong>移动构造函数</strong>。虽然关于其<strong>工作的细节</strong>和<strong>具体实现</strong>都未公开，但我们知道<strong>移动构造函数</strong>用于<strong>将资源移动</strong>(而不是拷贝)<strong>到正在创建的对象</strong>，且<strong>移后源</strong><code>string</code>仍<strong>保持有效</strong>、<strong>可析构的状态</strong><br>3、第二个机制是名为<code>move</code>的<strong>标准库函数</strong>，它定义在<code>utility</code><strong>头文件</strong>中。目前关于<code>move</code>我们<strong>需要了解两点</strong>：首先，当<code>reallocate</code><strong>在新内存构造</strong><code>string</code>时，<strong>必须调用</strong><code>move</code>来<strong>表示希望使用移动构造函数</strong>，否则将使用<strong>拷贝构造函数</strong>；其次，我们<strong>通常不为</strong><code>move</code><strong>提供</strong><code>using</code><strong>声明</strong>，原因后续解释，当我们使用<code>move</code>时一般<strong>直接调用</strong><code>std::move</code></p>
</blockquote>
</li>
<li><p><strong>定义 reallocate 成员</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// reallocate 成员</span>
<span class="token keyword">void</span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 我们将分配当前两倍大小的内存</span>
    <span class="token keyword">auto</span> newcapacity <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 分配新内存</span>
    <span class="token keyword">auto</span> newdata <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>newcapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将数据从旧内存移动到新内存</span>
    <span class="token keyword">auto</span> dest <span class="token operator">=</span> newdata<span class="token punctuation">;</span>  <span class="token comment">// 指向新数组中下一个空闲位置</span>
    <span class="token keyword">auto</span> elem <span class="token operator">=</span> elements<span class="token punctuation">;</span> <span class="token comment">// 指向旧数组中下一个元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token comment">// 使用 move 表明使用移动构造函数</span>
        alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>dest<span class="token operator">++</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>elem<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放旧内存</span>

    <span class="token comment">// 更新数据结构，执行新元素</span>
    elements <span class="token operator">=</span> newdata<span class="token punctuation">;</span>
    first_free <span class="token operator">=</span> dest<span class="token punctuation">;</span>
    cap <span class="token operator">=</span> elements <span class="token operator">+</span> newcapacity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a><strong>对象移动</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>新标准</strong>一个最主要的特性是<strong>可以移动</strong>(而非拷贝)<strong>对象</strong>。很多情况下都会发生<strong>对象拷贝</strong>，但某些情况下<strong>对象拷贝后就立刻被销毁</strong>，这时<strong>移动对象</strong>(相比拷贝对象)会<strong>大幅提升性能</strong><br>2、使用<strong>移动</strong>而不是<strong>拷贝</strong>的<strong>另一个原因</strong>是：对于像<code>IO</code><strong>类</strong>和<code>unique_ptr</code><strong>类</strong>这样的类，都<strong>包含不能被共享的资源</strong>(指针或 IO 缓冲)。因此，这类对象<strong>不能拷贝但可以移动</strong></p>
</blockquote>
</li>
<li><p><strong>右值引用</strong></p>
<ul>
<li><p><strong>右值引用</strong></p>
<blockquote>
<p>1、为了支持<strong>移动操作</strong>，<strong>新标准</strong>引入了一种<strong>新的引用类型</strong>——<strong>右值引用</strong>。所谓<strong>右值引用</strong>就是<strong>必须绑定到右值</strong>的引用，我们<strong>通过</strong><code>&amp;&amp;</code>(而不是<code>&amp;</code>)来<strong>获得右值引用</strong><br>2、<strong>右值引用</strong>有一个<strong>重要性质</strong>：只能绑定到一个<strong>将要销毁的对象</strong>。因此我们可以自由地将一个<strong>右值引用</strong>的资源<strong>移动到另一个对象</strong><br>3、<strong>右值引用</strong>也只是<strong>某个对象的另一个名字</strong>。如我们所知，对于<strong>常规引用</strong>(为了区分，我们可称其为左值引用)，我们<strong>不能</strong>将其绑定到<strong>要求转换的表达式</strong>、<strong>字面常量</strong>或<strong>返回右值的表达式</strong>；而<strong>右值引用</strong>与之相反，我们<strong>可以</strong>将它<strong>绑定到这类表达式上</strong>，但<strong>不能</strong>直接将它<strong>绑定到一个左值上</strong><br>4、返回<strong>左值引用</strong>的<strong>函数</strong>，连同<strong>赋值</strong>、<strong>下标</strong>、<strong>解引用</strong>和<strong>前置递增</strong>&#x2F;<strong>递减运算符</strong>，都是返回<strong>左值表达式</strong>的例子，我们可以将<strong>左值引用</strong>绑定到这类表达式；返回<strong>非引用类型</strong>的<strong>函数</strong>，连同<strong>算术</strong>、<strong>关系</strong>、<strong>位</strong>以及<strong>后置递增</strong>&#x2F;<strong>递减运算符</strong>，都生成<strong>右值</strong>，我们可以将<strong>右值引用</strong>或<code>const</code><strong>的左值引用</strong>绑定到这类表达式<br>5、<strong>左值持久</strong>，<strong>右值短暂</strong>：<strong>左值</strong>有<strong>持久的状态</strong>，而<strong>右值</strong>要么是<strong>字面常量</strong>，要么是表达式<strong>求值过程中</strong>创建的<strong>临时变量</strong>。由于<strong>右值引用</strong>只能绑定到<strong>临时对象</strong>，我们得知所引用的对象<strong>将要被销毁</strong>且其<strong>没有其他用户</strong>，这意味着使用<strong>右值引用</strong>的代码可以<strong>自由地接管</strong>所引用对象的<strong>资源</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>                   <span class="token comment">// 正确：r 引用 i</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr <span class="token operator">=</span> i<span class="token punctuation">;</span>                 <span class="token comment">// 错误：不能把一个右值引用绑定到左值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span>             <span class="token comment">// 错误：i * 42 是一个右值</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">42</span><span class="token punctuation">;</span>       <span class="token comment">// 正确：我们可以将一个 const 的引用绑定到右值上</span></code></pre>
</li>
<li><p><strong>变量是左值</strong></p>
<blockquote>
<p>1、<strong>变量</strong>可以看作<strong>只有一个运算对象</strong>而<strong>没有运算符</strong>的<strong>表达式</strong>，类似其他任何表达式，<strong>变量表达式</strong>也有<strong>左值</strong>&#x2F;<strong>右值属性</strong><br>2、<strong>变量表达式</strong>都是<strong>左值</strong>。带来的结果是，我们<strong>不能</strong>将一个<strong>右值引用</strong>绑定到<strong>右值引用类型变量</strong>上<br>3、在了解到<strong>右值表示临时对象</strong>这一结果后，<strong>变量是左值</strong>这一结论就并不令人惊讶了，毕竟<strong>变量是持久的</strong>，直到<strong>离开作用域</strong>才<strong>被销毁</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>               <span class="token comment">// 正确：字面常量是右值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr2 <span class="token operator">=</span> rr1<span class="token punctuation">;</span>              <span class="token comment">// 错误：表达式 rr1 是左值</span></code></pre>
</li>
<li><p><code>std::move</code></p>
<blockquote>
<p>1、虽然不能将<strong>右值引用</strong>直接绑定到<strong>左值</strong>，但可以<strong>显式地</strong>将<strong>左值</strong>转换为<strong>对应右值引用类型</strong>。我们还可以通过调用<code>move</code><strong>标准库函数</strong>来获得<strong>绑定到左值上的右值引用</strong>。<code>move</code>定义在<strong>头文件</strong><code>utility</code>中，其使用将在 16 章描述的机制来<strong>返回给定对象的右值引用</strong><br>2、如下例，<code>move</code>调用<strong>告诉编译器</strong>，我们有一个<strong>左值</strong>，但我们希望<strong>像右值一样处理它</strong>。调用<code>move</code>就意味着承诺<strong>除了对</strong><code>rr1</code><strong>赋值或销毁</strong>外，我们将<strong>不再使用它</strong><br>3、在调用<code>move</code>后，我们不能对<strong>移后源对象的值</strong>做任何假设。我们<strong>可以销毁</strong>一个<strong>移后源对象</strong>，或<strong>赋予它新值</strong>，但<strong>不能使用</strong>一个<strong>移后源对象的值</strong><br>4、如前所述，与大多数<strong>标准库名字</strong>不同，我们通常<strong>不对</strong><code>move</code><strong>使用</strong><code>using</code><strong>声明</strong>，而<strong>直接调用</strong><code>std::move</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>rr3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确：但只可以对 rr1 进行赋值或销毁，不能使用 rr1 的值</span></code></pre></li>
</ul>
</li>
<li><p><strong>移动构造函数和移动赋值运算符</strong></p>
<ul>
<li><p><strong>移动构造函数</strong></p>
<blockquote>
<p>1、类似<code>string</code><strong>类</strong>或其他<strong>标准库类</strong>，如果我们<strong>自定义的类</strong>也<strong>同时支持移动和拷贝</strong>，那么也能<strong>从中受益</strong>。为此需要定义<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，这两个成员<strong>类似对应的拷贝操作</strong>，但它们从给定对象“<strong>窃取</strong>”<strong>资源</strong>而不是<strong>拷贝资源</strong><br>2、<strong>移动构造函数</strong>的<strong>第一个参数</strong>也是<strong>该类类型的引用</strong>，但它是一个<strong>右值引用</strong>，且函数的任何<strong>额外参数</strong>都<strong>必须有默认实参</strong><br>3、除了<strong>资源移动</strong>，<strong>移动构造函数</strong>还必须确保<strong>移后源对象</strong>是<strong>销毁后无害</strong>的。特别是，一旦资源完成移动，<strong>源对象</strong>必须不再指向<strong>被移动的资源</strong>——这些资源的<strong>所属权</strong>已经归属了<strong>新的对象</strong><br>4、如下例，我们为<code>StrVec</code>定义了<strong>移动构造函数</strong>。其中<code>noexcept</code>用于<strong>通知标准库</strong>我们的构造函数<strong>不会抛出任何异常</strong>，具体将在后续介绍<br>5、移动构造函数<strong>不分配任何内存</strong>，它<strong>接管给定</strong><code>StrVec</code><strong>的内存</strong>。接管内存后，它将<strong>给定对象中的指针</strong>置为<code>nullptr</code>，这样就完成了<strong>从给定对象的移动操作</strong>，此对象将<strong>继续存在</strong>。最终，<strong>源对象</strong>会<strong>被销毁</strong>并运行其<strong>析构函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">StrVec</span><span class="token punctuation">(</span>StrVec <span class="token operator">&amp;&amp;</span>s<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>   <span class="token comment">// 表示移动操作不会抛出任何异常</span>
    <span class="token operator">:</span> <span class="token function">elements</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>elements<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">first_free</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>first_free<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>cap<span class="token punctuation">)</span>  <span class="token comment">// 初始化成员接管 s 中的资源</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 令 s 进入“对其运行析构函数是安全的”的状态</span>
    s<span class="token punctuation">.</span>elements <span class="token operator">=</span> s<span class="token punctuation">.</span>first_free <span class="token operator">=</span> s<span class="token punctuation">.</span>cap <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>移动操作、标准库容器和异常</strong></p>
<blockquote>
<p>1、由于移动操作<strong>不分配任何资源</strong>，因此<strong>移动操作</strong>通常<strong>不会抛出任何异常</strong>，我们应当<strong>将此事通知标准库</strong>，否则<strong>标准库会认为</strong>类对象随时<strong>可能抛出异常</strong>，并为了处理这种可能<strong>额外做一些准备</strong><br>2、一种<strong>通知标准库</strong>的方法是<strong>在构造函数中指明</strong><code>noexcept</code>。<code>noexcept</code>是<strong>新标准</strong>引入的，我们将在 18 章讨论更多细节<br>3、目前重要的是，知道<code>noexcept</code>是我们<strong>承诺函数不抛出异常</strong>的一种方法，且我们在一个函数的<strong>参数列表后指定</strong><code>noexcept</code>。对于<strong>构造函数</strong>，其出现在<strong>参数列表</strong>和<strong>初始化列表的冒号</strong>之间，且如果要<strong>分开声明和定义</strong>构造函数，必须在<strong>类的声明</strong>和<strong>定义</strong>中<strong>都指定</strong><code>noexcept</code></p>
</blockquote>
</li>
<li><p><strong>移动赋值运算符</strong></p>
<blockquote>
<p>1、<strong>移动赋值运算符</strong>执行与<strong>析构函数</strong>和<strong>移动构造函数</strong>相同的工作。与<strong>移动构造函数</strong>一样，如果其<strong>不抛出任何异常</strong>，应把它<strong>标记为</strong><code>noexcept</code>；类似<strong>拷贝赋值运算符</strong>，<strong>移动赋值运算符</strong>也必须<strong>正确处理自赋值</strong><br>2、如下例，我们直接检查<code>this</code><strong>指针</strong>与<code>rhs</code><strong>的地址</strong>是否相同。如果相同，则<strong>左右两侧的对象</strong>指向<strong>相同的对象</strong>，不需要做任何事情；否则，我们<strong>释放左侧对象的内存</strong>，并<strong>接管右侧对象的内存</strong>，再将<strong>右侧对象的指针置空</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">StrVec <span class="token operator">&amp;</span>StrVec<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>StrVec <span class="token operator">&amp;&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 直接检测自赋值</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 释放已有元素</span>
        elements <span class="token operator">=</span> rhs<span class="token punctuation">.</span>elements<span class="token punctuation">;</span>  <span class="token comment">// 从 rhs 接管资源</span>
        first_free <span class="token operator">=</span> rhs<span class="token punctuation">.</span>first_free<span class="token punctuation">;</span>
        cap <span class="token operator">=</span> rhs<span class="token punctuation">.</span>cap<span class="token punctuation">;</span>
        <span class="token comment">// 将 rhs 置于可析构状态</span>
        rhs<span class="token punctuation">.</span>elements <span class="token operator">=</span> rhs<span class="token punctuation">.</span>first_free <span class="token operator">=</span> rhs<span class="token punctuation">.</span>cap <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>移后源对象必须可析构</strong></p>
<blockquote>
<p>1、从一个对象<strong>移动数据</strong>并不会<strong>销毁对象</strong>，但有时在<strong>移动操作完成后</strong>，<strong>源对象会被销毁</strong>。因此，当我们编写一个<strong>移动操作</strong>时，必须确保<strong>移后源对象</strong>进入<strong>可析构状态</strong>。如上例中，我们将<strong>右侧对象的指针全部置空</strong><br>2、除了将<strong>移后源对象</strong>置为<strong>析构安全</strong>的状态外，<strong>移动操作</strong>还必须<strong>保证对象仍然有效</strong>。一般来说，<strong>对象有效</strong>就是指可以<strong>安全地为其赋值</strong>或可以<strong>安全地使用</strong>而<strong>不依赖其当前值</strong>。另一方面，<strong>移动操作</strong>对<strong>移后源对象</strong>留下的值<strong>没有任何要求</strong>，因此程序<strong>不应该依赖于移后源对象的数据</strong><br>3、例如，当我们从<code>string</code><strong>对象移动数据</strong>时，我们知道<strong>移后源对象</strong>仍然有效，因此我们可以执行<code>empty</code><strong>或</strong><code>size</code><strong>这些操作</strong>。但是我们<strong>不知道会得到什么结果</strong>，我们可能期望一个<strong>移后源对象</strong>是空的，但这<strong>并没有保证</strong>。因此<strong>移后源对象</strong>虽然保持<strong>有效</strong>、<strong>可析构</strong>的状态，但用户<strong>不能对其值进行任何假设</strong></p>
</blockquote>
</li>
<li><p><strong>合成的移动操作</strong></p>
<blockquote>
<p>1、与处理<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>一样，编译器也会<strong>合成移动构造函数</strong>和<strong>移动赋值运算符</strong>。但是<strong>合成移动操作的条件</strong>与前者<strong>大不相同</strong><br>2、不同于拷贝操作，当我们<strong>不声明移动操作</strong>时，编译器<strong>不会</strong>为某些类<strong>合成移动操作</strong>，特别如果一个类<strong>定义了自己的拷贝操作</strong>，编译器<strong>更不会为其合成移动操作</strong>。因此，<strong>某些类</strong>就<strong>没有移动操作</strong>，而这些类会用对应的<strong>拷贝操作</strong>代替<strong>移动操作</strong><br>3、只有当一个类<strong>没有定义</strong>任何自己的<strong>拷贝控制成员</strong>，且每个<strong>非</strong><code>static</code><strong>数据成员</strong>都<strong>可以移动</strong>时，编译器才会<strong>合成移动构造函数</strong>或<strong>移动赋值运算符</strong>。编译器可以<strong>移动内置类型成员</strong>，如果一个成员是<strong>类类型</strong>且有<strong>对应的移动操作</strong>，那么也能<strong>移动这个类成员</strong><br>4、移动操作<strong>永远不会隐式定义为删除的函数</strong>。但是如果我们<strong>显式</strong>要求编译器<strong>生成</strong><code>=default</code><strong>的移动操作</strong>，且编译器<strong>不能移动所有成员</strong>，则会将其定义为<strong>删除的函数</strong>。定义一个<strong>移动操作</strong>的类也<strong>必须定义了拷贝操作</strong>，否则这些成员<strong>默认地被定义为删除</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 编译器会为 X 和 hasX 合成移动操作</span>
<span class="token keyword">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>                        <span class="token comment">// 内置类型可以移动</span>
    std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">;</span>                <span class="token comment">// string 定义了自己的移动操作</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">hasX</span>
<span class="token punctuation">&#123;</span>
    X mem<span class="token punctuation">;</span>                        <span class="token comment">// X 有合成的移动操作</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

X x1<span class="token punctuation">,</span> x2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 使用合成的移动构造函数</span>
hasX hx1<span class="token punctuation">,</span> hx2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>hx1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 使用合成的移动构造函数</span></code></pre>
</li>
<li><p><strong>移动与拷贝操作的选择</strong></p>
<blockquote>
<p>1、<strong>移动右值</strong>，<strong>拷贝左值</strong>：如果一个类既有<strong>拷贝操作</strong>又有<strong>移动操作</strong>，<strong>编译器</strong>将使用普通的<strong>函数匹配规则</strong>来确定使用哪个函数。<strong>赋值操作</strong>的情况类似<br>2、<strong>没有移动操作</strong>，<strong>右值也被拷贝</strong>：没有<strong>移动操作</strong>时，编译器<strong>不会合成移动操作</strong>，<strong>函数匹配规则</strong>保证该类型<strong>对象会被拷贝</strong>，即使试图<strong>调用</strong><code>move</code><strong>也是如此</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 移动右值，拷贝左值</span>
StrVec v1<span class="token punctuation">,</span> v2<span class="token punctuation">;</span>
v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span>                          <span class="token comment">// v2 是左值，所以匹配拷贝赋值操作</span>
StrVec <span class="token function">getVec</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 假定 getVec 返回一个右值</span>
v2 <span class="token operator">=</span> <span class="token function">getVec</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// getVec(cin) 是一个右值，匹配移动赋值操作</span>

<span class="token comment">// 右值也被拷贝</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
        <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 拷贝构造函数</span>
        <span class="token comment">// 其他成员定义，但 Foo 未定义移动构造函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Foo x<span class="token punctuation">;</span>
Foo <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 拷贝构造函数，x 是一个左值</span>
Foo <span class="token function">z</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 拷贝构造函数，因为未定义移动构造函数</span></code></pre>
</li>
<li><p><strong>定义</strong><code>Message</code><strong>类的移动操作</strong></p>
<blockquote>
<p>1、回想<strong>先前定义的</strong><code>Message</code>和<code>Folder</code><strong>类</strong>就应该定义<strong>移动操作</strong>，这样<code>Message</code>就可以<strong>使用</strong><code>string</code><strong>和</strong><code>set</code><strong>的移动操作</strong>来<strong>避免拷贝</strong><code>contents</code><strong>和</strong><code>folders</code><strong>成员</strong>的额外开销<br>2、但是，除了<strong>移动</strong><code>folder</code><strong>成员</strong>，我们还必须<strong>更新每个指向原</strong><code>Message</code>的<code>Folder</code>。我们必须<strong>删除旧</strong><code>Message</code><strong>指针</strong>，并<strong>添加新</strong><code>Message</code><strong>指针</strong>。由于<strong>两个移动操作</strong>都需要<strong>更新指针</strong>，我们先定义这一操作，如下<br>3、<code>Message</code>的<strong>移动构造函数</strong>调用<code>move</code>来<strong>移动</strong><code>contents</code>，并<strong>默认初始化</strong>自己的<code>folders</code><strong>成员</strong>；而<strong>移动赋值运算符</strong>直接检查<strong>自赋值情况</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 从本 Message 移动 Folder 指针</span>
<span class="token keyword">void</span> <span class="token class-name">Message</span><span class="token double-colon punctuation">::</span><span class="token function">move_Folders</span><span class="token punctuation">(</span>Message <span class="token operator">*</span>m<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    folders <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>m<span class="token operator">-></span>folders<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用 set 的移动赋值运算符</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> f <span class="token operator">:</span> folders<span class="token punctuation">)</span>              <span class="token comment">// 对于每个 Folder</span>
    <span class="token punctuation">&#123;</span>
        f<span class="token operator">-></span><span class="token function">remMsg</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 从 Folder 中删除旧 Message</span>
        f<span class="token operator">-></span><span class="token function">addMsg</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 将本 Message 添加到 Folder 中</span>
    <span class="token punctuation">&#125;</span>
    m<span class="token operator">-></span>folders<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 确保销毁 m 是无害的</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 移动构造函数</span>
<span class="token class-name">Message</span><span class="token double-colon punctuation">::</span><span class="token function">Message</span><span class="token punctuation">(</span>Message <span class="token operator">&amp;&amp;</span>m<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">contents</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>contents<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">move_Folders</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动 folders 并更新 Folder 指针</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 移动赋值运算符</span>
Message<span class="token operator">&amp;</span> Message<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Message <span class="token operator">&amp;&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>  <span class="token comment">// 直接检查自赋值情况</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">remove_from_Folders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        contents <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>contents<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动赋值运算符</span>
        <span class="token function">move_Folders</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置 Folders 指向本 Message</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>移动迭代器</strong></p>
<blockquote>
<p>1、先前<code>StrVec</code>的<code>reallocate</code><strong>成员</strong>使用了一个<code>for</code>来调用<code>construct</code>从<strong>旧内存</strong>将元素<strong>拷贝到新内存</strong>。作为一种替换方法，我们可以调用<code>uninitialized_copy</code>来<strong>构造新分配的内存</strong>，且<strong>更为简单</strong>。但是，<code>uninitialized_copy</code>对元素进行<strong>拷贝操作</strong>(而不是移动)，标准库中并<strong>没有类似的函数</strong>将对象<strong>移动</strong>到未构造内存<br>2、<strong>新标准库</strong>定义了一种<strong>移动迭代器</strong>适配器，其通过<strong>改变</strong>给定迭代器的<strong>解引用运算符的行为</strong>来适配此迭代器，<strong>移动迭代器</strong>的<strong>解引用运算符</strong>生成一个<strong>右值引用</strong><br>3、我们通过<strong>调用标准库</strong><code>make_move_iterator</code><strong>函数</strong>将一个普通迭代器转换为一个<strong>移动迭代器</strong>。其接受一个<strong>迭代器参数</strong>，返回一个<strong>移动迭代器</strong><br>4、<strong>原迭代器</strong>的<strong>所有操作</strong>在<strong>移动迭代器</strong>都能<strong>正常工作</strong>，因此我们<strong>可以将其传递给算法</strong>，比如<code>uninitialized_copy</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 分配大小两倍于当前规模的内存空间</span>
    <span class="token keyword">auto</span> newcapacity <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> first <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>newcapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 移动元素</span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span><span class="token function">make_move_iterator</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">make_move_iterator</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 释放旧空间</span>
    elements <span class="token operator">=</span> first<span class="token punctuation">;</span>           <span class="token comment">// 更新指针</span>
    first_free <span class="token operator">=</span> last<span class="token punctuation">;</span>
    cap <span class="token operator">=</span> elements <span class="token operator">+</span> newcapacity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>右值引用和成员函数</strong></p>
<ul>
<li><p><strong>移动版本的成员函数</strong></p>
<blockquote>
<p>1、除了<strong>构造函数</strong>和<strong>赋值运算符</strong>，如果一个<strong>成员函数</strong>同时提供<strong>拷贝和移动</strong>版本，它也能<strong>从中受益</strong>。这种<strong>允许移动的成员函数</strong>需要遵循一种参数模式：一个版本接受一个<strong>指向</strong><code>const</code><strong>的左值引用</strong>，第二个版本接受一个<strong>指向非</strong><code>const</code><strong>的右值引用</strong><br>2、一般来说，我们<strong>不需要定义接受</strong><code>const X&amp;&amp;</code><strong>或</strong><code>X&amp;</code><strong>参数</strong>的函数版本。当我们希望从实参<strong>窃取数据</strong>时，通常传递一个<strong>右值引用</strong>，因此实参<strong>不能是</strong><code>const</code>的；类似的，从一个对象<strong>拷贝数据</strong>不应该改变对象，因此<strong>不需要接受</strong><code>X&amp;</code>的版本<br>3、如下例，我们为先前<code>StrVec</code>的<code>push_back</code><strong>函数</strong>定义<strong>拷贝和移动版本</strong>。当我们<strong>调用</strong><code>push_back</code>时，<strong>实参类型决定</strong>新元素是<strong>拷贝还是移动</strong>到容器中</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 简单示例</span>
<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 拷贝：绑定到任意类型的 X</span>
<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 移动：只能绑定到类型 X 的可修改的右值</span>

<span class="token comment">// StrVec 的 push_back</span>
<span class="token keyword">class</span> <span class="token class-name">StrVec</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 拷贝元素</span>
        <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>string<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 移动元素</span>
        <span class="token comment">// ...其他成员定义，如前</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 拷贝版本的 push_back</span>
<span class="token keyword">void</span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">chk_n_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 确保有足够空间容纳元素</span>
    alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>first_free<span class="token operator">++</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 在 first_free 指向的元素中构造 s 的一个副本</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 移动版本的 push_back</span>
<span class="token keyword">void</span> <span class="token class-name">StrVec</span><span class="token double-colon punctuation">::</span><span class="token function">push_back</span><span class="token punctuation">(</span>string <span class="token operator">&amp;&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">chk_n_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 确保有足够空间容纳元素</span>
    alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>first_free<span class="token operator">++</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

StrVec vec<span class="token punctuation">;</span>                                 <span class="token comment">// 空 vec</span>
string s <span class="token operator">=</span> <span class="token string">"some string or another"</span><span class="token punctuation">;</span>
vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">// 调用拷贝版本</span>
vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 调用移动版本</span></code></pre>
</li>
<li><p><strong>左&#x2F;右值引用成员函数与函数重载</strong></p>
<blockquote>
<p>1、通常，我们在一个<strong>对象</strong>上<strong>调用成员函数</strong>，而不管<strong>该对象是左值还是右值</strong>，如下例。在<strong>旧标准</strong>中，我们<strong>没法阻止</strong>这种使用方式，为了维持<strong>向后兼容性</strong>，<strong>新标准库</strong>仍然允许<strong>向右值赋值</strong>。但是，我们可能希望在<strong>自定义的类</strong>中<strong>阻止这种用法</strong>，希望<strong>强制左侧运算对象</strong>(即<code>this</code>指向的对象)<strong>是左值</strong><br>2、我们指出<code>this</code>的<strong>左&#x2F;右值属性</strong>的方式与<strong>定义</strong><code>const</code><strong>成员函数</strong>类似，即在<strong>参数列表后</strong>放置一个<strong>引用限定符</strong>。<strong>引用限定符</strong>可以是<code>&amp;</code>或<code>&amp;&amp;</code>，分别指出<code>this</code>可以指向<strong>一个左值</strong>或<strong>一个右值</strong><br>3、<strong>引用限定符</strong>只能用于<strong>非</strong><code>static</code><strong>成员函数</strong>，且<strong>必须同时出现</strong>在<strong>函数声明和定义</strong>中。一个函数<strong>可以同时用</strong><code>const</code>和<strong>引用限定</strong>，但<strong>引用限定符</strong>必须跟在<code>const</code><strong>后面</strong><br>4、就像一个<strong>成员函数</strong>可以根据<strong>是否</strong><code>const</code>来<strong>区分重载版本</strong>，<strong>引用限定符</strong>也可以<strong>区分重载版本</strong>。而且我们可以综合<strong>引用限定符</strong>和<code>const</code>来<strong>区分</strong>一个成员函数的<strong>重载版本</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 令人惊讶的调用方式</span>
string s1 <span class="token operator">=</span> <span class="token string">"a value"</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">"another"</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 在一个右值 (s1 + s2)，即两个字符串组合的结果上调用了 find 成员</span>
s1 <span class="token operator">+</span> s2 <span class="token operator">=</span> <span class="token string">"wow!"</span><span class="token punctuation">;</span>                 <span class="token comment">// 对一个右值 (s1 + s2)，即两个字符串组合的结果上进行了赋值</span>

<span class="token comment">// 引用限定符</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        Foo <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>   <span class="token comment">// 只能向可修改的左值赋值</span>
        Foo <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>                  <span class="token comment">// 只能操作不可修改的右值</span>
        Foo <span class="token function">someMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token keyword">const</span><span class="token punctuation">;</span>          <span class="token comment">// 错误：const 限定符必须在前</span>
        Foo <span class="token function">anotherMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>       <span class="token comment">// 正确：const 限定符在前</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<hr>
<h3 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a><strong>重载运算与类型转换</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：重载运算符；使用重载运算符；重载运算符的设计；输入输出运算符；算术和关系运算符；赋值运算符；下标运算符；递增递减运算符；成员访问运算符；<code>lambda</code>是函数对象；标准库函数对象；可调用对象与<code>function</code>；标准库<code>function</code>类型；重载、类型转换与运算符；类型转换运算符；避免有二义性的类型转换；函数匹配与重载运算符</p>
</blockquote>
</div>

<h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a><strong>重载运算符</strong></h4><ul>
<li><p><strong>使用重载运算符</strong></p>
<ul>
<li><p><strong>重载运算符</strong></p>
<blockquote>
<p>1、<strong>重载运算符</strong>是具有特殊名字的<strong>函数</strong>：它们的名字由<strong>关键字</strong><code>operator</code>后接<strong>要定义的运算符</strong>共同组成。<strong>重载运算符</strong>也包含<strong>返回类型</strong>、<strong>参数列表</strong>和<strong>函数体</strong><br>2、<strong>重载运算符</strong>的<strong>参数数量</strong>与其作用的<strong>运算对象数量</strong>一样，<strong>一元运算符</strong>有<strong>一个参数</strong>，<strong>二元运算符</strong>有<strong>两个参数</strong>。且对于<strong>二元运算符</strong>，<strong>左侧对象</strong>传递给<strong>第一个参数</strong>，<strong>右侧对象</strong>传递给<strong>第二个参数</strong>。除了重载的<strong>函数调用运算符</strong><code>operator()</code>之外，其他<strong>重载运算符</strong>都<strong>不能含有默认参数</strong>。如果一个<strong>运算符函数</strong>是<strong>成员函数</strong>，那它的<strong>左侧对象</strong>绑定到<strong>隐式的</strong><code>this</code><strong>指针</strong>上<br>3、对于一个<strong>运算符函数</strong>，它要么是<strong>类的成员</strong>，要么<strong>至少含有一个类类型参数</strong>，这意味着当<strong>运算符</strong>作用于<strong>内置类型运算对象</strong>时，我们<strong>无法改变其含义</strong>。我们<strong>只能重载</strong>运算符，<strong>不能发明</strong>运算符。对于一个<strong>重载运算符</strong>来说，其<strong>优先级</strong>和<strong>结合律</strong>与对应的<strong>内置运算符</strong>一致<br>4、对于<code>+</code>、<code>-</code>、<code>*</code>、<code>&amp;</code>这四个<strong>既是一元也是二元</strong>的运算符来说，也<strong>可以被重载</strong>，其会<strong>从参数数量判断</strong>我们定义的是哪种运算符。我们<strong>不能重载</strong><code>::</code>、<code>.*</code>、<code>.</code>、<code>?:</code><strong>运算符</strong>，其余<strong>可被重载</strong>的运算符如下表</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">可重载</th>
<th align="center">可重载</th>
<th align="center">可重载</th>
<th align="center">可重载</th>
<th align="center">可重载</th>
<th align="center">可重载</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">-</td>
<td align="center">*</td>
<td align="center">&#x2F;</td>
<td align="center">%</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">|</td>
<td align="center">~</td>
<td align="center">!</td>
<td align="center">,</td>
<td align="center">&#x3D;</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">&gt;</td>
<td align="center">&lt;&#x3D;</td>
<td align="center">&gt;&#x3D;</td>
<td align="center">++</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">&gt;&gt;</td>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">!&#x3D;</td>
<td align="center">&amp;&amp;</td>
<td align="center">||</td>
</tr>
<tr>
<td align="center">+&#x3D;</td>
<td align="center">-&#x3D;</td>
<td align="center">&#x2F;&#x3D;</td>
<td align="center">%&#x3D;</td>
<td align="center">^&#x3D;</td>
<td align="center">&amp;&#x3D;</td>
</tr>
<tr>
<td align="center">|&#x3D;</td>
<td align="center">*&#x3D;</td>
<td align="center">&lt;&lt;&#x3D;</td>
<td align="center">&gt;&gt;&#x3D;</td>
<td align="center">[]</td>
<td align="center">()</td>
</tr>
<tr>
<td align="center">-&gt;</td>
<td align="center">-&gt;*</td>
<td align="center">new</td>
<td align="center">new[]</td>
<td align="center">delete</td>
<td align="center">delete[]</td>
</tr>
</tbody></table>
</li>
<li><p><strong>直接调用重载运算符函数</strong></p>
<blockquote>
<p>1、通常情况下，我们<strong>将运算符作用于</strong>类型正确的<strong>实参</strong>，用这种<strong>间接方式</strong>调用<strong>重载运算符函数</strong><br>2、然而，我们也可以像<strong>调用普通函数</strong>那样<strong>直接调用</strong>运算符函数，先<strong>指定函数名</strong>，然后传入<strong>数量正确</strong>、<strong>类型适当</strong>的<strong>实参</strong><br>3、我们也可以像调用<strong>其他成员函数</strong>一样显式调用<strong>成员运算符函数</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">data1 <span class="token operator">+</span> data2<span class="token punctuation">;</span>                  <span class="token comment">// 普通的表达式</span>
<span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>data1<span class="token punctuation">,</span> data2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 等价的函数调用</span>

data1 <span class="token operator">+=</span> data2<span class="token punctuation">;</span>                 <span class="token comment">// 基于调用的表达式</span>
data1<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span>data2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 对成员运算符函数的等价调用</span></code></pre>
</li>
<li><p><strong>某些运算符不应被重载</strong></p>
<blockquote>
<p>1、由于<strong>某些运算符指定了</strong>运算对象<strong>求值的顺序</strong>，又因为<strong>重载运算符</strong>本质上是<strong>函数调用</strong>，所以这些<strong>关于求值顺序的规则</strong>无法应用到<strong>重载运算符</strong>上。比如<code>&amp;&amp;</code>、<code>||</code>、<code>,</code><strong>运算符</strong><br>2、此外，<code>&amp;&amp;</code>和<code>||</code>的<strong>重载版本</strong>也<strong>无法保留</strong>内置运算符的<strong>短路求值属性</strong>，两个运算对象<strong>总是会被求值</strong>，因此<strong>不建议重载</strong>它们<br>3、还有一个原因使得我们一般<strong>不重载</strong><code>,</code><strong>和</strong><code>&amp;</code><strong>运算符</strong>：<strong>C++<strong>语言已经定义了这两种运算符用于</strong>类类型对象</strong>的<strong>特殊含义</strong>，所以它们<strong>不应该被重载</strong>，否则它们的<strong>异常行为</strong>将导致<strong>类的用户无法适应</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>重载运算符的设计</strong></p>
<ul>
<li><p><strong>使用与内置类型一致的含义</strong></p>
<blockquote>
<p>1、当你开始<strong>设计一个类</strong>时，首先应该考虑的是这个类将<strong>提供哪些操作</strong>，然后再思考应该把<strong>每个操作</strong>定义为<strong>普通函数</strong>还是<strong>重载运算符</strong>。如果<strong>某些操作</strong>在逻辑上<strong>与运算符相关</strong>，才适合定义成<strong>重载运算符</strong><br>2、具体如下：如果类<strong>执行</strong><code>IO</code><strong>操作</strong>，则定义<strong>移位运算符</strong>使其<strong>与内置类型</strong><code>IO</code><strong>保持一致</strong>；如果某个操作<strong>检查相等性</strong>，则<strong>定义</strong><code>operator==</code>，并且通常它<strong>也应该有</strong><code>operator!=</code>；如果类包含一个内在的<strong>单序比较操作</strong>，则<strong>定义</strong><code>operator&lt;</code>，并且通常它<strong>也应该有其他关系操作</strong><br>3、除此之外，<strong>重载运算符</strong>的<strong>返回类型</strong>通常应该与<strong>内置版本返回类型</strong>兼容：<strong>逻辑运算符</strong>和<strong>关系运算符</strong>应返回<code>bool</code>；<strong>算术运算符</strong>应返回<strong>类类型的值</strong>；<strong>赋值运算符</strong>和<strong>复合赋值运算符</strong>应该返回<strong>左侧对象引用</strong></p>
</blockquote>
</li>
<li><p><strong>选择作为成员或非成员</strong></p>
<blockquote>
<p>1、当我们<strong>定义重载运算符</strong>时，首先要决定将其声明为<strong>类的成员函数</strong>还是一个<strong>普通的非成员函数</strong>。某些情况下我们别无选择，因为有的运算符<strong>必须作为成员</strong>；另一些情况下，运算符<strong>作为普通函数</strong>比作为成员函数<strong>更好</strong><br>2、这些准则有助于我们做出抉择：<code>=</code>、<code>[]</code>、<code>()</code>、<code>-&gt;</code>运算符<strong>必须是成员</strong>；<strong>复合赋值运算符</strong>与<code>=</code>略有不同，其<strong>一般是成员</strong>(并非必须)；<strong>改变对象状态</strong>的运算符或者<strong>与给定类型密切相关</strong>的运算符，例如<code>++</code>、<code>--</code>、<code>*</code>运算符，<strong>通常是成员</strong>；<strong>具有对称性</strong>的运算符<strong>可能转换</strong>任意一端的<strong>运算对象</strong>，例如<strong>算术</strong>、<strong>相等性</strong>、<strong>关系</strong>、<strong>位运算</strong>等，<strong>通常是普通非成员</strong><br>3、程序员希望能在<strong>含有混合类型</strong>的<strong>表达式</strong>中使用<strong>对称性运算符</strong>。例如，我们能求一个<code>int</code>和一个<code>double</code>的和，因为它们中<strong>任意一个</strong>都可以是<strong>左侧对象</strong>或<strong>右侧对象</strong>，所以<strong>加法是对称的</strong>。如果我们想提供<strong>含有类对象</strong>的<strong>混合类型表达式</strong>，则运算符<strong>必须</strong>定义成<strong>非成员函数</strong>，原因如下<br>4、如果我们把<strong>运算符</strong>定义为<strong>成员函数</strong>，他的<strong>左侧对象</strong>必须是<strong>运算符所属类对象</strong>，如下例。现实中，因为<code>string</code>将<code>operator+</code>定义成<strong>普通的非成员函数</strong>，所以<code>&quot;hi&quot; + s</code>才能<strong>等价于</strong><code>operator+(&quot;hi&quot;, s)</code>正常执行操作</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 假设 operator+ 只是 string 类的成员</span>
string s <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
string t <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">;</span>     <span class="token comment">// 正确：左侧对象是 string，可以调用 operator+ 将一个 const char* 添加到 string 中</span>
string u <span class="token operator">=</span> <span class="token string">"hi"</span> <span class="token operator">+</span> s<span class="token punctuation">;</span>    <span class="token comment">// 错误：左侧对象是 const char*，其本身作为内置类型根本没有成员函数，也无法调用到 string 重载的 operator+ 运算符</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a><strong>输入输出运算符</strong></h4><ul>
<li><p><strong>概述</strong></p>
<blockquote>
<p>1、如我们所知，<code>IO</code><strong>库</strong>分别使用<code>&gt;&gt;</code>和<code>&lt;&lt;</code>来执行<strong>输入输出操作</strong><br>2、对于这两个操作，<code>IO</code><strong>库</strong>定义了其<strong>读写内置类型</strong>的版本，而对于<strong>类</strong>则需要<strong>自定义新版本</strong>以<strong>支持</strong><code>IO</code><strong>操作</strong></p>
</blockquote>
</li>
<li><p><strong>输出运算符 &lt;&lt;</strong></p>
<blockquote>
<p>1、通常情况下，输出运算符<strong>第一个形参</strong>是<strong>非常量</strong><code>ostream</code><strong>的引用</strong>(表示左侧对象)；<strong>第二个形参</strong>是一个<strong>类类型常量引用</strong>(表示右侧对象)；为了与内置类型一致，一般<strong>返回它的</strong><code>ostream</code><strong>形参</strong>。如下例，是<strong>重载</strong>的<code>Sales_data</code>的<strong>输出运算符</strong><br>2、用于<strong>内置类型</strong>的<strong>输出运算符</strong>不太考虑<strong>格式化操作</strong>，尤其<strong>不会打印换行符</strong>，用户也希望<strong>重载的输出运算符</strong>也能如此行事。令<strong>输出运算符</strong>尽量<strong>减少格式化操作</strong>，可以<strong>使用户有权控制输出的细节</strong><br>3、<strong>输入输出运算符</strong>必须是<strong>非成员函数</strong>，否则它们的<strong>左侧对象</strong>将是我们的<strong>类对象</strong>(成员重载运算符的左侧对象绑定到<code>this</code>)，即<strong>调用会变成</strong><code>data &lt;&lt; cout</code>，违背平常的使用习惯</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 必须定义为非成员函数，参数第一个形参是左侧对象，第二个形参是右侧对象</span>
ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    os <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>units_sold <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>revenue <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span><span class="token function">avg_price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> os<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>输入运算符 &gt;&gt;</strong></p>
<blockquote>
<p>1、通常情况下，输入运算符<strong>第一个形参</strong>是<strong>将读取的流的引用</strong>；<strong>第二个形参</strong>是<strong>类类型非常量引用</strong>；通常<strong>返回给定流的引用</strong>。如下例，是<strong>重载</strong>的<code>Sales_data</code>的<strong>输入运算符</strong><br>2、注意，<strong>输入运算符</strong>必须处理<strong>输入可能失败</strong>的情况，在<strong>执行输入运算符</strong>时可能出现<strong>以下错误</strong>：当<strong>流</strong>含有<strong>错误类型数据</strong>时，读取操作可能失败；当<strong>读取操作到达文件末尾</strong>或者遇到<strong>输入流其他错误</strong>时也会失败<br>3、在该程序中，我们<strong>没有逐个检查</strong>读取操作，而是等<strong>读取结束后</strong>赶在<strong>使用数据前</strong>直接<strong>一次性检查</strong>。当<strong>读取操作发生错误</strong>时，<strong>输入运算符</strong>应当<strong>负责从错误中恢复</strong>，如该例中将对象<strong>置为合法状态</strong>(尽管数据错误，但技术上正确)，我们能略微保护使用者<strong>免受错误影响</strong><br>4、但是，一些<strong>输入运算符</strong>需要做更多<strong>数据验证工作</strong>来<strong>标示错误</strong>，例如该例中<strong>发生错误丢弃数据</strong>时，应当设置<strong>流的条件状态</strong>来<strong>标示失败信息</strong>。通常情况下，输入运算符<strong>只设置</strong><code>failbit</code><strong>表示出现错误</strong>，但此外还可以设置<code>eofbit</code><strong>表示文件耗尽</strong>，设置<code>badbit</code><strong>表示流被破坏</strong>。最好的方式是<strong>由</strong><code>IO</code><strong>库自己标示这些错误</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">istream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">>></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> Sales_data <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> price<span class="token punctuation">;</span>                                   <span class="token comment">// 先把数据读入 price 再使用</span>
    is <span class="token operator">>></span> item<span class="token punctuation">.</span>bookNo <span class="token operator">>></span> item<span class="token punctuation">.</span>units_sold <span class="token operator">>></span> price<span class="token punctuation">;</span>  <span class="token comment">// 读入所有数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">)</span>                                         <span class="token comment">// 检查输入是否成功</span>
        item<span class="token punctuation">.</span>revenue <span class="token operator">=</span> item<span class="token punctuation">.</span>units_sold <span class="token operator">*</span> price<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        item <span class="token operator">=</span> <span class="token function">Sales_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 输入失败：对象被赋予默认状态</span>
    <span class="token keyword">return</span> is<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a><strong>算术和关系运算符</strong></h4><ul>
<li><p><strong>概述</strong></p>
<blockquote>
<p>1、通常情况下，我们把<strong>算术运算符</strong>和<strong>关系运算符</strong>定义为<strong>非成员函数</strong>以允许<strong>左右侧对象进行转换</strong><br>2、这些运算符一般<strong>不需要改变运算符对象的状态</strong>，所以<strong>形参</strong>都是<strong>常量引用</strong></p>
</blockquote>
</li>
<li><p><strong>算术运算符 +</strong></p>
<blockquote>
<p>1、<strong>算术运算符</strong>通常会<strong>计算两个运算对象</strong>并<strong>得到一个新值</strong>，这个值常常<strong>位于一个局部变量内</strong>，操作完成后<strong>返回该局部变量的副本</strong>作为结果<br>2、如果类定义使用<strong>算术运算符</strong>，则它一般<strong>也会定义</strong>对应的<strong>复合赋值运算符</strong>，此时使用<strong>复合赋值运算符</strong>来定义<strong>算术运算符</strong>是最有效的方法，如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Sales_data <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Sales_data sum <span class="token operator">=</span> lhs<span class="token punctuation">;</span>         <span class="token comment">// 把 lhs 的数据成员拷贝给 sum</span>
    sum <span class="token operator">+=</span> rhs<span class="token punctuation">;</span>                   <span class="token comment">// 使用复合赋值运算符(前提是已定义)</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>相等运算符 &#x3D;&#x3D;</strong></p>
<blockquote>
<p>1、通常情况下，类通过定义<strong>相等运算符</strong>来检验<strong>两个对象是否相等</strong>。也就是说，它们会<strong>比较</strong>对象的<strong>每一个数据成员</strong>，只有<strong>全部相等</strong>时才认为<strong>两个类相等</strong><br>2、据此，我们的<code>Sales_data</code>的<strong>相等运算符</strong>不但应该比较<code>bookNo</code>，还应该比较<strong>具体销售数据</strong>，如下<br>3、这体现了<strong>相等运算符</strong>的<strong>设计准则</strong>：如果一个类含有<strong>判断两个对象是否相等</strong>的操作，一定要<strong>重载运算符</strong>而不是定义为<strong>普通函数</strong>，以方便用户使用；如果类<strong>定义了</strong><code>operator==</code>，则其应该<strong>能判断</strong>一组对象中<strong>是否含有重复数据</strong>；通常情况下，<strong>相等运算符</strong>应该具有<strong>传递性</strong>；如果类<strong>定义了</strong><code>operator==</code>，<strong>也应该定义</strong><code>operator!=</code>；<strong>相等</strong>和<strong>不相等</strong>中的<strong>其中一个</strong>应该<strong>把工作委托给另一个</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> lhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> rhs<span class="token punctuation">.</span><span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        lhs<span class="token punctuation">.</span>units_sold <span class="token operator">==</span> rhs<span class="token punctuation">.</span>units_sold <span class="token operator">&amp;&amp;</span>
        lhs<span class="token punctuation">.</span>revenue <span class="token operator">==</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>lhs <span class="token operator">==</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>关系运算符 &lt;</strong></p>
<blockquote>
<p>1、定义了<strong>相等运算符</strong>的类也常常(但不总是)包含<strong>关系运算符</strong>。特别是，因为<strong>关联容器</strong>和<strong>一些算法</strong>要用到<code>&lt;</code>，因此<strong>定义</strong><code>operator&lt;</code>会<strong>比较有用</strong><br>2、通常情况下<strong>关系运算符</strong>应该：定义<strong>顺序关系</strong>，令其<strong>与关联容器</strong>中<strong>对关键字的要求一致</strong>，并且如果类<strong>同时含有</strong><code>==</code>，则<strong>定义一种关系</strong>令其<strong>与</strong><code>==</code><strong>保持一致</strong>。特别是，如果<strong>两个对象</strong>是<code>!=</code>的，那么<strong>一个对象</strong>应该<code>&lt;</code><strong>另一个对象</strong><br>3、尽管我们可能认为<code>Sales_data</code>也应该支持<strong>关系运算符</strong>，但其<strong>并不需要</strong>，因为其<strong>不存在一种可靠的</strong><code>&lt;</code><strong>定义</strong>(按照什么排序，需要用到什么的排序)，因此这个类<strong>不定义</strong><code>&lt;</code><strong>也许更好</strong><br>4、如果存在<strong>唯一一种逻辑可靠的</strong><code>&lt;</code><strong>定义</strong>，则应该考虑<strong>为这个类定义</strong><code>&lt;</code>；如果这个类<strong>同时还包含</strong><code>==</code>，则当且仅当<code>&lt;</code><strong>的定义和</strong><code>==</code><strong>产生一致结果</strong>时才定义<code>&lt;</code></p>
</blockquote>
</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h4><ul>
<li><p><strong>赋值运算符 &#x3D;</strong></p>
<blockquote>
<p>1、之前在 13 章已经介绍过<strong>拷贝复制运算符</strong>和<strong>移动赋值运算符</strong>，它们可以把<strong>类对象</strong>赋值给<strong>该类另一个对象</strong>。此外，类还可以定义<strong>其他赋值运算符</strong>以使用<strong>别的类型</strong>作为<strong>右侧对象</strong><br>2、例如，<strong>标准库</strong><code>vector</code>还允许<strong>接受花括号列表作为参数</strong>(如下)，我们也可以把<strong>这个运算符</strong>加到我们自定义的<code>StrVec</code>中，其<strong>返回左侧对象引用</strong><br>3、通常情况下，我们更倾向于将<strong>赋值运算符</strong>定义在<strong>类的内部</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// vector 接受花括号列表作为参数</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">></span> v<span class="token punctuation">;</span>
v <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"an"</span><span class="token punctuation">,</span> <span class="token string">"the"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 在 StrVec 中定义</span>
<span class="token keyword">class</span> <span class="token class-name">StrVec</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        StrVec<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...其他成员不变</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
StrVec<span class="token operator">&amp;</span> StrVec<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">></span> il<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// alloc_n_copy 分配内存空间并从给定范围拷贝元素</span>
    <span class="token keyword">auto</span> data <span class="token operator">=</span> <span class="token function">alloc_n_copy</span><span class="token punctuation">(</span>il<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> il<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 销毁对象中的元素并释放内存空间</span>
    elements <span class="token operator">=</span> data<span class="token punctuation">.</span>first<span class="token punctuation">;</span>    <span class="token comment">// 更新数据成员使其指向新空间</span>
    first_free <span class="token operator">=</span> cap <span class="token operator">=</span> data<span class="token punctuation">.</span>sencond<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>复合赋值运算符 +&#x3D;</strong></p>
<blockquote>
<p>1、复合赋值运算符<strong>不非得是类成员</strong>，但我们也还是<strong>更倾向于</strong>将其<strong>定义在类内</strong>。其<strong>返回左侧对象引用</strong><br>2、下面是<code>Sales_data</code>中<strong>复合赋值运算符</strong>的定义</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 作为成员的二元运算符，左侧对象绑定到隐式的 this</span>
<span class="token comment">// 假定两个对象表示的是同一本书</span>
Sales_data<span class="token operator">&amp;</span> Sales_data<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Sales_data <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    units_sold <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>units_sold<span class="token punctuation">;</span>
    revenue <span class="token operator">+=</span> rhs<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a><strong>下标运算符</strong></h4><ul>
<li><p><strong>下标运算符 []</strong></p>
<blockquote>
<p>1、<strong>下标运算符</strong><code>operator[]</code><strong>必须是成员函数</strong>。为了与<strong>原始定义</strong>兼容，<strong>下标运算符</strong>通常以<strong>所访问元素的引用</strong>作为<strong>返回值</strong>，这样的好处是<strong>下标</strong>可以出现在<strong>赋值运算符任意一端</strong><br>2、进一步，我们最好<strong>同时定义</strong>下标运算符的<strong>常量版本</strong>和<strong>非常量版本</strong>，以返回<strong>对应类型</strong>的数值。由于<strong>下标运算符</strong>返回<strong>元素的引用</strong>，因此当<strong>元素是常量</strong>，我们便<strong>不能为其赋值</strong>了。如下，我们<strong>定义</strong><code>StrVec</code>的<strong>下标运算符</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">StrVec</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 必须是成员函数，通常有 const 和非 const 版本</span>
        string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> elements<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">const</span> string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> elements<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// ...其他成员</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        string <span class="token operator">*</span>elements<span class="token punctuation">;</span> <span class="token comment">// 指向数组首元素的指针</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 假设 svec 是一个 StrVec 对象</span>
<span class="token keyword">const</span> StrVec cvec <span class="token operator">=</span> svec<span class="token punctuation">;</span>
<span class="token comment">// 如果 svec 含有元素，对第一个元素运行 string 的 empty 函数</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> svec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    svec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"zero"</span><span class="token punctuation">;</span>   <span class="token comment">// 正确：下标运算符返回 string 的引用</span>
    cvec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"zip"</span><span class="token punctuation">;</span>    <span class="token comment">// 错误：对 cvec 取下标返回的是常量引用</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a><strong>递增递减运算符</strong></h4><ul>
<li><p><strong>前置递增递减运算符</strong></p>
<blockquote>
<p>1、为了说明<strong>递增递减运算符</strong>，我们直接在<code>StrBlobPtr</code>中<strong>定义它们</strong>，其应<strong>返回递增递&#x2F;减后的对象引用</strong>，如下例<br>2、<strong>递增运算符</strong>中，我们把<code>curr</code>的值<strong>传递给</strong><code>check</code>，如果其<strong>小于</strong><code>vector</code><strong>的大小</strong>，则<code>check</code><strong>正常返回</strong>；否则说明<strong>已到达末尾</strong>，<strong>抛出异常</strong><br>3、<strong>递减运算符</strong>先递减<code>curr</code>，再<strong>调用</strong><code>check</code>。此时，如果<strong>递减前</strong><code>curr</code>(无符号数)<strong>已经是 0 了</strong>，则传给<code>check</code>的值将是一个<strong>表示无效下标</strong>的<strong>非常大的正数</strong>，也一定<strong>超过</strong><code>vector</code><strong>大小</strong>而<strong>抛出异常</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">StrBlobPtr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 前置递增递减运算符</span>
        StrBlobPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        StrBlobPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...其他成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 前置递增递减运算符</span>
StrBlobPtr<span class="token operator">&amp;</span> StrBlobPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 curr 已经指向尾后位置，则无法递增</span>
    <span class="token function">check</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> <span class="token string">"increment past end of StrBlobPtr"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 检查 curr</span>
    <span class="token operator">++</span>curr<span class="token punctuation">;</span>                                             <span class="token comment">// 递增 curr</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
StrBlobPtr<span class="token operator">&amp;</span> StrBlobPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 curr 是 0，则继续递减会产生一个无效下标</span>
    <span class="token operator">--</span>curr<span class="token punctuation">;</span>                                             <span class="token comment">// 递减 curr</span>
    <span class="token function">check</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> <span class="token string">"decrement past begin of StrBlobPtr"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 检查 curr</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>区分前置和后置运算符</strong></p>
<blockquote>
<p>1、想要<strong>同时定义前置和后置运算符</strong>，必须首先解决<strong>区分问题</strong>，因为<strong>普通的重载形式无法区分这两种情况</strong><br>2、为此，<strong>后置版本</strong>接受一个<strong>额外的</strong>(不被使用的)<code>int</code><strong>形参</strong>。当我们<strong>使用后置运算符</strong>时，<strong>编译器</strong>为这个形参提供一个<strong>值为 0 的实参</strong><br>3、这个形参的<strong>唯一作用</strong>就是<strong>区分前置和后置版本</strong>，<strong>而不是</strong>真的要在<strong>实现后置版本</strong>时<strong>参与运算</strong></p>
</blockquote>
</li>
<li><p><strong>后置递增递减运算符</strong></p>
<blockquote>
<p>1、对于<strong>后置版本</strong>来说，在<strong>递增&#x2F;递减</strong>之前需要先<strong>记录对象的状态</strong>，以<strong>供返回值使用</strong><br>2、后置版本<strong>不需要直接检查范围</strong>，我们将<strong>调用前置版本</strong>来实现操作，在<strong>前置版本</strong>中才会<strong>检查范围</strong>和<strong>递增&#x2F;递减</strong><br>3、操作执行后，<strong>对象</strong>将<strong>被递增&#x2F;递减</strong>，但我们将<strong>返回提前记录下的对象的状态</strong>，因此<strong>返回一个对应对象</strong>(而无须对象引用)</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">StrBlobPtr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 后置递增递减运算符</span>
        StrBlobPtr <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 后置运算符的 int 形参</span>
        StrBlobPtr <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...其他成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 后置递增递减运算符</span>
StrBlobPtr StrBlobPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>                  <span class="token comment">// 后置运算符的 int 形参</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 此处无须检查有效性，调用前置递增运算时才需要</span>
    StrBlobPtr ret <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                             <span class="token comment">// 记录当前值</span>
    <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                                            <span class="token comment">// 调用前置运算符前移一个元素(需要保证前置运算符已定义)</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>                                         <span class="token comment">// 返回当前记录的值，且源对象的值已递增</span>
<span class="token punctuation">&#125;</span>
StrBlobPtr StrBlobPtr<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 此处无须检查有效性，调用前置递减运算时才需要</span>
    StrBlobPtr ret <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                             <span class="token comment">// 记录当前值</span>
    <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                                            <span class="token comment">// 调用前置运算符后移一个元素(需要保证前置运算符已定义)</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>                                         <span class="token comment">// 返回当前记录的值，且源对象的值已递减</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a><strong>成员访问运算符</strong></h4><ul>
<li><p><strong>成员访问运算符 *和-&gt;</strong></p>
<blockquote>
<p>1、在<strong>迭代器</strong>和<strong>智能指针</strong>中常常用到<strong>解引用运算符</strong><code>*</code>和<strong>箭头运算符</strong><code>-&gt;</code>，我们以如下形式<strong>向</strong><code>StrBlobPtr</code><strong>添加这两种运算符</strong><br>2、<code>-&gt;</code><strong>必须是类的成员</strong>。<code>*</code><strong>通常也是类的成员</strong>，尽管并非必须如此，但几乎也总是这样<br>3、值得注意的是，这两个运算符<strong>定义成了</strong><code>const</code><strong>成员</strong>，因为<strong>获取元素</strong>并不会改变<strong>对象状态</strong>；此外它们的<strong>返回值</strong>分别是<strong>非常量</strong>的<strong>对象引用</strong>和<strong>对象指针</strong>，因为一个<code>StrBlobPtr</code><strong>只能绑定到非常量</strong><code>StrBlobPtr</code><strong>对象</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">StrBlobPtr</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        string<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> <span class="token string">"dereference past end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// (*p) 是对象所指的 vector</span>
        <span class="token punctuation">&#125;</span>
        string<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">// 将实际工作委托给解引用运算符</span>
            <span class="token keyword">return</span> <span class="token operator">&amp;</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// ...其他成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
</ul>
<h4 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a><strong>函数调用运算符</strong></h4><ul>
<li><p><strong>函数调用运算符</strong></p>
<ul>
<li><p><strong>描述</strong></p>
<blockquote>
<p>1、如果类重载了<strong>函数调用运算符</strong>，则我们可以像<strong>使用函数</strong>一样<strong>使用该类对象</strong>。因为这样的类<strong>同时也能存储状态</strong>，所以与<strong>普通函数</strong>相比它们<strong>更灵活</strong><br>2、<strong>函数调用运算符</strong>必须是<strong>成员函数</strong>。如下例，我们设计<code>absInt</code>类含有一个<strong>调用运算符</strong>，其<strong>返回参数的绝对值</strong>。使用时，令一个<code>absInt</code>的<strong>对象</strong><code>absObj</code>作用于一个<strong>实参列表</strong>，这一过程看起来<strong>非常像函数调用</strong>的过程。即使<code>absObj</code><strong>只是一个对象</strong>，<strong>而非函数</strong>，但我们也能<strong>调用该对象</strong><br>3、如果类<strong>定义了调用运算符</strong>，则<strong>该类对象</strong>称作<strong>函数对象</strong>，因为<strong>可以调用</strong>这些对象，所以说这些对象<strong>行为像函数一样</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">absInt</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 函数调用运算符 operator()</span>
    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> val <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span>val <span class="token operator">:</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">42</span><span class="token punctuation">;</span>
absInt absObj<span class="token punctuation">;</span>        <span class="token comment">// 含有函数调用运算符的对象</span>
<span class="token keyword">int</span> ui <span class="token operator">=</span> <span class="token function">absObj</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 将 i 传递给 absObj.operator()</span></code></pre>
</li>
<li><p><strong>含有状态的函数对象类</strong></p>
<blockquote>
<p>1、和其他类一样，<strong>函数对象类</strong>除了<code>operator()</code>之外也可以包含其他成员。<strong>函数对象类</strong>通常含有一些<strong>数据成员</strong>，这些成员被用于<strong>定制调用运算符中的操作</strong><br>2、如下例，我们定义一个<strong>打印</strong><code>string</code><strong>实参内容</strong>的类。该类的<strong>构造函数</strong>接受一个<strong>输出流引用</strong>和一个<strong>用于分隔的字符</strong>，且都设置了<strong>默认值</strong>，之后的<strong>函数调用运算符</strong>中使用<strong>数据成员</strong>来协助打印给定的<code>string</code><br>3、<strong>函数对象</strong>常常作为<strong>泛型算法</strong>的<strong>实参</strong>，例如可以使用<strong>标准库</strong><code>for_each</code><strong>算法</strong>和我们的<code>PrintString</code>来<strong>打印容器内容</strong>：<code>for_each(vs.begin(), vs.end(), PrintString(cerr, &#39;\n&#39;))</code>。其中<strong>第三个实参</strong>是<code>PrintString</code>的一个<strong>临时对象</strong>，用<code>cerr</code>和<code>&#39;\n&#39;</code><strong>初始化该对象</strong>，我们将把<strong>容器</strong><code>vs</code><strong>中的元素</strong>依次<strong>打印到</strong><code>cout</code><strong>中</strong>并<strong>用换行符分隔</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PrintString</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 默认构造函数</span>
        <span class="token function">PrintString</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>o <span class="token operator">=</span> cout<span class="token punctuation">,</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">os</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sep</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 函数调用运算符</span>
        <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            os <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> sep<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        ostream <span class="token operator">&amp;</span>os<span class="token punctuation">;</span>  <span class="token comment">// 用于写入的目的流</span>
        <span class="token keyword">char</span> sep<span class="token punctuation">;</span>     <span class="token comment">// 用于将不同输出隔开的字符</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

PrintString printer<span class="token punctuation">;</span>              <span class="token comment">// 使用默认值，打印到 cout</span>
<span class="token function">printer</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 在 cout 中打印 s，后面跟一个空格</span>
PrintString <span class="token function">errors</span><span class="token punctuation">(</span>cerr<span class="token punctuation">,</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 构造新的 PrintString 函数对象并初始化</span>
<span class="token function">errors</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 在 cerr 中打印 s，后面跟一个换行符</span></code></pre></li>
</ul>
</li>
<li><p><strong>lambda 是函数对象</strong></p>
<ul>
<li><p><strong>描述</strong></p>
<blockquote>
<p>1、上一小节，我们使用一个<code>PrintString</code><strong>对象</strong>作为调用<code>for_each</code><strong>的实参</strong>，这个用法和我们先前编写的<strong>使用</strong><code>lambda</code><strong>表达式</strong>的程序类似。实际上，当我们编写了一个<code>lambda</code>后，<strong>编译器</strong>将该表达式<strong>翻译成</strong>一个<strong>未命名类</strong>的<strong>未命名对象</strong><br>2、在<code>lambda</code><strong>表达式</strong>产生的类中含有一个<strong>重载的函数调用运算符</strong>。如下例，对于我们传递给<code>stable_sort</code>作为<strong>最后一个实参</strong>的<code>lambda</code><strong>表达式</strong>来说，其行为类似于下面的<strong>类</strong>的一个<strong>未命名对象</strong>，我们也可以用<strong>这个对象</strong>替换实参中的<code>lambda</code></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 根据单词长度对其排序，对于长度相同的单词按照字母表顺序排序</span>
<span class="token function">stable_sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// lambda 等同于下面的类的未命名对象</span>
<span class="token keyword">class</span> <span class="token class-name">ShorterString</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 可以用这个对象替换 lambda</span>
<span class="token function">stable_sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ShorterString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>表示</strong><code>lambda</code><strong>及相应捕获行为的类</strong></p>
<blockquote>
<p>1、当一个<code>lambda</code><strong>通过引用捕获变量</strong>时，将由程序负责<strong>确保</strong><code>lambda</code><strong>执行时</strong>引用的对象<strong>确实存在</strong>，因此编译器可以<strong>直接使用该引用</strong>而<strong>无须在</strong><code>lambda</code><strong>产生的类中</strong>将其<strong>存储为数据成员</strong>。相反，<strong>通过值捕获变量</strong>时，变量被<strong>拷贝到</strong><code>lambda</code>中，则必须为每个值<strong>建立对应的数据成员</strong>，同时创建<strong>构造函数</strong>以<strong>初始化数据成员</strong><br>2、如下例，有一个<code>lambda</code>，作用是<strong>找到第一个长度不小于给定值的</strong><code>string</code>，其<strong>产生的类</strong>类似于下面的类。与上面的<code>ShorterString</code><strong>不同</strong>，该类含有<strong>数据成员</strong>和<strong>构造函数</strong>，合成的类不含有<strong>默认构造函数</strong>，因此要使用这个类<strong>必须提供一个实参</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 获得第一个指向满足条件元素的迭代器，该元素满足 size() >= sz</span>
<span class="token keyword">auto</span> wc <span class="token operator">=</span> <span class="token function">find_if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> sz<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 该 lambda 产生的类类似于下面的类</span>
<span class="token keyword">class</span> <span class="token class-name">SizeComp</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 构造函数，形参对应捕获的变量，没有默认值</span>
        <span class="token function">SizeComp</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sz</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 函数调用运算符</span>
        <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> sz<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        size_t sz<span class="token punctuation">;</span>  <span class="token comment">// 对应通过值捕获的变量</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 使用该类必须提供实参</span>
<span class="token keyword">auto</span> wc <span class="token operator">=</span> <span class="token function">find_if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SizeComp</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>标准库函数对象</strong></p>
<ul>
<li><p><strong>介绍</strong></p>
<blockquote>
<p>1、<strong>标准库</strong>定义了一组表示<strong>算术运算符</strong>、<strong>关系运算符</strong>、<strong>逻辑运算符</strong>的<strong>类</strong>，每个<strong>类</strong>分别定义了一个<strong>执行命名操作</strong>的<strong>调用运算符</strong>。例如<code>plus</code>类定义<strong>函数调用运算符</strong>用于对一些对象<strong>执行</strong><code>+</code><strong>操作</strong>，<code>modulus</code>类<strong>执行二元的</strong><code>%</code><strong>操作</strong>，<code>equal_to</code>类<strong>执行</strong><code>==</code><strong>操作</strong>等<br>2、这些<strong>类</strong>都被定义成<strong>模板</strong>，我们可以为其<strong>指定具体应用类型</strong>，即<strong>调用运算符</strong>的<strong>形参类型</strong>，类似于使用<code>vector</code><br>3、下标列出了这些<strong>标准库函数对象</strong>，它们定义在<strong>头文件</strong><code>functional</code>中</p>
</blockquote>
<table>
<thead>
<tr>
<th>算术运算</th>
<th>关系运算</th>
<th>逻辑运算</th>
</tr>
</thead>
<tbody><tr>
<td>plus<Type></td>
<td>equal_to<Type></td>
<td>logical_and<Type></td>
</tr>
<tr>
<td>minus<Type></td>
<td>not_equal_to<Type></td>
<td>logical_or<Type></td>
</tr>
<tr>
<td>multiplies<Type></td>
<td>greater<Type></td>
<td>logical_not<Type></td>
</tr>
<tr>
<td>divides<Type></td>
<td>greater_equal<Type></td>
<td></td>
</tr>
<tr>
<td>modulus<Type></td>
<td>less<Type></td>
<td></td>
</tr>
<tr>
<td>negate<Type></td>
<td>less_equal<Type></td>
<td></td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">plus<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> intAdd<span class="token punctuation">;</span>                   <span class="token comment">// 可执行 int 加法的函数对象</span>
negate<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> intNegate<span class="token punctuation">;</span>              <span class="token comment">// 可对 int 值取相反数的函数对象</span>
<span class="token comment">// 使用 intAdd::operator(int, int) 求和</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">intAdd</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// sum = 30</span>
sum <span class="token operator">=</span> <span class="token function">intNegate</span><span class="token punctuation">(</span><span class="token function">intAdd</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// sum = -30</span>
<span class="token comment">// 使用 intNegate::operator(int) 生成 -10，再将 -10 作为 intAdd 的第二个参数</span>
sum <span class="token operator">=</span> <span class="token function">intAdd</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token function">intNegate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// sum = 0</span></code></pre>
</li>
<li><p><strong>在算法中使用标准库函数对象</strong></p>
<blockquote>
<p>1、<strong>表示运算符</strong>的<strong>函数对象类</strong>常用来<strong>替换</strong>算法中的<strong>默认运算符</strong>。如我们所知，默认情况下<strong>标准库排序算法</strong>使用<code>operator&lt;</code>将序列<strong>升序排列</strong>。现在，如果要<strong>降序排列</strong>，我们可以传入一个<code>greater</code><strong>类型对象</strong>，该类将产生一个<strong>调用运算符</strong>并负责执行<strong>待排序类型</strong>的<code>&gt;</code><strong>运算</strong>，如下<br>2、需要注意的是，<strong>标准库</strong>规定其函数<strong>对于指针同样适用</strong>。我们之前介绍过<strong>比较两个无关指针</strong>将产生<strong>未定义行为</strong>，然而我们可能会希望通过<strong>比较指针内存地址</strong>来排序<strong>指针的</strong><code>vector</code>。<strong>直接这么做</strong>将产生<strong>未定义行为</strong>，因此我们可以使用<strong>标准库函数对象</strong>来实现此目的，如下</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用 greater 降序排列</span>
<span class="token function">sort</span><span class="token punctuation">(</span>svec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> svec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 有关指针的排序</span>
vector<span class="token operator">&lt;</span>string <span class="token operator">*</span><span class="token operator">></span> nameTable<span class="token punctuation">;</span>       <span class="token comment">// 指针的 vector</span>
<span class="token comment">// 错误：直接比较将产生未定义行为</span>
<span class="token function">sort</span><span class="token punctuation">(</span>nameTable<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nameTable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>string <span class="token operator">*</span>a<span class="token punctuation">,</span> string <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 正确：标准库规定指针的 less 是定义良好的</span>
<span class="token function">sort</span><span class="token punctuation">(</span>nameTable<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nameTable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span>string <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>可调用对象与 function</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>C++<strong>中有几种</strong>可调用对象</strong>：<strong>函数</strong>、<strong>函数指针</strong>、<code>lambda</code><strong>表达式</strong>、<code>bind</code><strong>对象</strong>、<strong>重载了函数调用运算符</strong>的<strong>类</strong><br>2、和其他对象一样，<strong>可调用对象</strong>也有<strong>类型</strong>。例如，每个<code>lambda</code>都有他自己<strong>唯一的类类型</strong>，<strong>函数</strong>及<strong>函数指针</strong>的类型则由其<strong>返回值类型</strong>和<strong>实参类型</strong>决定等等<br>3、然而，两个<strong>不同类型</strong>的<strong>可调用对象</strong>有可能<strong>共享同一种调用形式</strong>，<strong>调用形式</strong>指明了调用<strong>返回值类型</strong>以及<strong>实参类型</strong>。例如<code>int(int, int)</code>是一个<strong>函数类型</strong>，接受两个<code>int</code>返回一个<code>int</code></p>
</blockquote>
</li>
<li><p><strong>不同类型可能具有相同调用形式</strong></p>
<blockquote>
<p>1、对于多个<strong>可调用对象</strong>共享<strong>同种调用形式</strong>的情况，我们会希望把它们看成<strong>具有相同的类型</strong>。如下，这些<strong>调用对象</strong>分别对其参数执行了<strong>不同的算术运算</strong>，尽管<strong>类型各不相同</strong>，但仍共享<strong>同一种调用形式</strong><code>int(int, int)</code><br>2、我们可能希望使用这些<strong>可调用对象</strong>构建一个简单的<strong>桌面计算器</strong>。为此需要定义一个<strong>函数表</strong>，用于存储指向这些<strong>可调用对象</strong>的<strong>指针</strong>，当程序需要<strong>特定操作</strong>时，<strong>从该表中查找</strong>调用的函数。<strong>C++<strong>中，</strong>函数表</strong>很容易通过<code>map</code>实现<br>3、对于本例，我们使用表示<strong>运算符符号</strong>的<code>string</code>作为<strong>关键字</strong>，使用<strong>实现运算符</strong>的<strong>函数</strong>作为<strong>值</strong>，假定<strong>所有函数相互独立</strong>，且只处理<strong>关于</strong><code>int</code><strong>的二元运算</strong>，则可以定义成下例中的形式。但是，我们<strong>不能将</strong><code>mod</code><strong>或</strong><code>divice</code><strong>存入</strong><code>binops</code>，因为它们都是<strong>类类型</strong>(<code>lambda</code>也有自己的类类型)，与<code>binops</code>的<strong>值类型不匹配</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 普通函数</span>
<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// lambda，产生一个未命名的函数对象类</span>
<span class="token keyword">auto</span> mod <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> i <span class="token operator">%</span> j<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 函数对象类</span>
<span class="token keyword">struct</span> <span class="token class-name">divide</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> denominator<span class="token punctuation">,</span> <span class="token keyword">int</span> divisor<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> denominator <span class="token operator">/</span> divisor<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 构建从运算符到函数指针的映射，函数接受两个 int，返回一个 int</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> binops<span class="token punctuation">;</span>
<span class="token comment">// 正确：add 是一个指向正确类型的指针</span>
binops<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"+"</span><span class="token punctuation">,</span> add<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// &#123;"+", add&#125; 是一个 pair</span>
<span class="token comment">// 错误：mod 不是一个函数指针</span>
binops<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"%"</span><span class="token punctuation">,</span> mod<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>标准库</strong><code>function</code><strong>类型</strong></p>
<blockquote>
<p>1、我们可以使用<code>function</code><strong>标准库类型</strong>来解决上述问题，它定义在<strong>头文件</strong><code>functional</code>中，<code>function</code>是一个<strong>模板</strong>，下表列出了它的操作<br>2、如下例，我们声明了一个<code>function</code><strong>类型</strong>，它可以表示<strong>接受两个</strong><code>int</code>、<strong>返回一个</strong><code>int</code>的<strong>可调用对象</strong>，使用这个<code>function</code>可以<strong>重新定义</strong>上一小节的<code>map</code>，并将所有<strong>相同调用形式</strong>的<strong>可调用对象</strong>都添加到这个<code>map</code><br>3、一如往常，当我们<strong>索引</strong><code>map</code>时将得到<strong>关联值的引用</strong>，如果我们<strong>索引</strong><code>binops</code>，将得到<code>function</code><strong>对象的引用</strong>。<code>function</code><strong>重载了调用运算符</strong>，其<strong>接受自己的实参</strong>然后将<strong>传递给</strong>存好的<strong>可调用对象</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>function 操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>function&lt;T&gt; f;</td>
<td>f 是一个用来存储可调用对象的空 function，这些可调用对象的调用形式应该与 T 相同，即 T 应该为 retType(args)</td>
</tr>
<tr>
<td>function&lt;T&gt; f(nullptr);</td>
<td>显式构造一个空 function</td>
</tr>
<tr>
<td>function&lt;T&gt; f(obj);</td>
<td>在 f 中存储可调用对象 obj 的副本</td>
</tr>
<tr>
<td>f</td>
<td>将 f 作为条件：当 f 含有一个可调用对象时为真，否则为假</td>
</tr>
<tr>
<td>f(args)</td>
<td>调用 f 中的对象，参数是 args</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>function&lt;T&gt;的成员类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>result_type</td>
<td>该 function 类型的可调用对象的返回类型</td>
</tr>
<tr>
<td>argument_type</td>
<td>当 T 只有一个实参时定义的类型，如果 T 只有一个实参，arguement_type 便是该实参类型的同义词</td>
</tr>
<tr>
<td>first_argument_type，second_argument_type</td>
<td>当 T 只有两个实参时定义的类型，如果 T 有两个实参，则 first_argument_type 和 second_argument_type 分别代表两个实参的类型</td>
</tr>
</tbody></table>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// function 对象的使用</span>
function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> add<span class="token punctuation">;</span>                                 <span class="token comment">// 函数指针</span>
function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 函数对象类的对象</span>
function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> i <span class="token operator">*</span> j<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// lambda</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 打印 6</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 打印 2</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 打印 8</span>

<span class="token comment">// 重新定义上一小节的 map，值变成了 function 对象</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span> binops <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token string">"+"</span><span class="token punctuation">,</span> add<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                              <span class="token comment">// 函数指针</span>
                                            <span class="token punctuation">&#123;</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">minus</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                        <span class="token comment">// 标准库函数对象</span>
                                            <span class="token punctuation">&#123;</span><span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> i <span class="token operator">*</span> j<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// 未命名的 lambda</span>
                                            <span class="token punctuation">&#123;</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                            <span class="token comment">// 用户定义的函数对象</span>
                                            <span class="token punctuation">&#123;</span><span class="token string">"%"</span><span class="token punctuation">,</span> mod<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                                <span class="token comment">// 命名了的 lambda</span>
<span class="token comment">// 使用 binops</span>
binops<span class="token punctuation">[</span><span class="token string">"+"</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 调用 add(10, 5)</span>
binops<span class="token punctuation">[</span><span class="token string">"-"</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 使用 minus&lt;int> 对象的调用运算符</span>
binops<span class="token punctuation">[</span><span class="token string">"*"</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 使用 lambda 函数对象</span>
binops<span class="token punctuation">[</span><span class="token string">"/"</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 使用 divide 对象的调用运算符</span>
binops<span class="token punctuation">[</span><span class="token string">"%"</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 使用 lambda 函数对象</span></code></pre>
</li>
<li><p><strong>重载函数的二义性问题</strong></p>
<blockquote>
<p>1、我们<strong>不能</strong>直接将<strong>重载函数名</strong>存入<code>function</code><strong>对象</strong>中，原因如下例<br>2、解决这种<strong>二义性问题</strong>的一种途径是<strong>存储函数指针</strong>而非函数名，另一种方式是<strong>使用</strong><code>lambda</code><strong>指定版本</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 二义性问题</span>
<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>                         <span class="token comment">// 普通函数</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
Sales_data <span class="token function">add</span><span class="token punctuation">(</span>Sales_data<span class="token operator">&amp;</span><span class="token punctuation">,</span> Sales_data<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 重载的另一个函数</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span> binops<span class="token punctuation">;</span>
binops<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token punctuation">&#123;</span><span class="token string">"+"</span><span class="token punctuation">,</span> tp<span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 错误：哪个 add</span>

<span class="token comment">// 方法 1：函数指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> add<span class="token punctuation">;</span>                    <span class="token comment">// 指针所指的 add 是接受两个 int 的版本</span>
binops<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token punctuation">&#123;</span><span class="token string">"+"</span><span class="token punctuation">,</span> fp<span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 正确：指向一个正确的 add 版本</span>

<span class="token comment">// 方法 2：使用 lambda 指定版本</span>
binops<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token punctuation">&#123;</span><span class="token string">"+"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a><strong>重载、类型转换与运算符</strong></h4><ul>
<li><p><strong>类型转换运算符</strong></p>
<ul>
<li><p><strong>描述</strong></p>
<blockquote>
<p>1、<strong>类型转换运算符</strong>是类的一种<strong>特殊成员函数</strong>，负责将一个<strong>类类型</strong>的值转换成<strong>其他类型</strong>。<strong>类型转换函数</strong>的一般形式如：<code>operator type() const;</code>，其中<code>type</code>表示<strong>某种类型</strong><br>2、<strong>类型转换运算符</strong>可以面向<strong>任意类型</strong>(除了<code>void</code>)进行定义，只要<strong>该类型</strong>能作为<strong>函数的返回类型</strong>。因此，<strong>不允许</strong>转换成<strong>数组</strong>或<strong>函数类型</strong>，但<strong>允许</strong>转换成<strong>指针</strong>或<strong>引用</strong><br>3、<strong>类型转换运算符</strong>没有显式的<strong>返回类型</strong>和<strong>形参</strong>，而且必须定义成<strong>类的成员函数</strong>。因其<strong>不应改变</strong>转换对象的<strong>内容</strong>，所以一般被定义成<code>const</code><strong>成员</strong></p>
</blockquote>
</li>
<li><p><strong>定义含有类型转换运算符的类</strong></p>
<blockquote>
<p>1、我们首先定义一个<strong>简单的类</strong>，令其表示<strong>0 到 255</strong>之间的一个整数，如下。<code>SmallInt</code><strong>类</strong>既定义了<strong>向类类型的转换</strong>(构造函数)，也定义了<strong>类类型向其他类型的转换</strong>(类型转换运算符)<br>2、尽管<strong>编译器</strong>一次只能执行一个<strong>自定义类型转换</strong>，但是<strong>隐式的自定义类型转换</strong>可以置于一个<strong>内置类型转换</strong>之前或之后，并与其<strong>一起使用</strong>，如下例<br>3、由于<strong>类型转换运算符</strong>是<strong>隐式执行</strong>的，所以<strong>无法</strong>给这些函数<strong>传参</strong>，定义中也<strong>不能使用任何形参</strong>。同时，尽管类型转换函数<strong>不负责指定返回类型</strong>，但实际上每个<strong>类型转换函数</strong>都应该<strong>返回一个对应类型值</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SmallInt</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 构造函数：从 int 转换成类类型对象</span>
        <span class="token function">SmallInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> <span class="token number">255</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">"Bad SmallInt value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 类型转换运算符：从类类型对象转换成 int</span>
        <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> val<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        size_t val<span class="token punctuation">;</span>   <span class="token comment">// size_t 类型对象</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

SmallInt si<span class="token punctuation">;</span>
si <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment">// 首先将 4 隐式转换成 SmallInt，然后调用 SmallInt::operator=</span>
si <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>       <span class="token comment">// 首先将 si 隐式转换成 int，然后执行整数加法</span>
si <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>    <span class="token comment">// 内置类型转换先将 double 转换成 int，然后调用 SmallInt(int) 构造函数</span>
si <span class="token operator">+</span> <span class="token number">3.14</span><span class="token punctuation">;</span>    <span class="token comment">// SmallInt 的类型转换运算符先将 si 转换成 int，然后内置类型转换将 int 转换成 double</span></code></pre>
</li>
<li><p><strong>可能产生意外结果</strong></p>
<blockquote>
<p>1、在实践中，类很少提供<strong>类型转换运算符</strong>。大多情况下，如果<strong>类型发生自动转换</strong>，用户会<strong>感到比较意外</strong>，而不是受到了帮助。然而<strong>存在一种例外</strong>：对于类，定义<strong>向</strong><code>bool</code><strong>的类型转换</strong>仍然比较普遍<br>2、<strong>早期版本</strong>中，如果<strong>类</strong>想定义一个<strong>向</strong><code>bool</code><strong>的类型转换</strong>，则常常遇到一个问题：<code>bool</code>是一种<strong>算术类型</strong>，<strong>类类型</strong>转换成<code>bool</code>后可以被用在<strong>任何需要算术类型</strong>的上下文中。这样的<strong>类型转换</strong>可能引发<strong>意想不到的结果</strong>，特别是当<code>istream</code><strong>含有向</strong><code>bool</code><strong>的类型转换</strong>时，如下例<br>3、该例中，程序试图<strong>将</strong><code>&lt;&lt;</code><strong>作用于输入流</strong>。因为<code>istream</code>本身<strong>没有定义</strong><code>&lt;&lt;</code>，本身应该<strong>产生错误</strong>。但是，该代码能使用<code>istream</code><strong>的</strong><code>bool</code><strong>类型转换运算符</strong>，将<code>cin</code><strong>转换成</strong><code>bool</code>，然后<code>bool</code>又会接着<strong>被提升成</strong><code>int</code>，并被用作<strong>内置的左移运算符</strong>(位运算)的<strong>左侧运算对象</strong>，这一行为与我们的预期大相径庭</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
cin <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>     <span class="token comment">// 如果 istream 向 bool 的类型转换不是显式的，则该代码在编译器看来是合法的</span></code></pre>
</li>
<li><p><strong>显式的类型转换运算符</strong></p>
<blockquote>
<p>1、为了防止上面的异常情况发生，新标准引入了<strong>显式的类型转换运算符</strong>，如下例<br>2、和<strong>显式的构造函数</strong>一样，<strong>编译器</strong>(通常)也不会将<strong>显式的类型转换运算符</strong>用于<strong>隐式类型转换</strong>。当<strong>类型转换运算符</strong>是<strong>显式</strong>时，必须通过<strong>显式的强制类型转换</strong>才可以使用<br>3、但<strong>有一个例外</strong>：如果<strong>表达式被用作条件</strong>，则<strong>编译器</strong>会将<strong>显式类型转换</strong>自动应用于它</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SmallInt</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 编译器不会自动执行这一类型转换</span>
        <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> val<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// ...其他成员一致</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

SmallInt si <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token comment">// 正确：SmallInt 的构造函数不是显式的</span>
si <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>                     <span class="token comment">// 错误：此处需要隐式的类型转换，但类的运算符是显式的</span>
<span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>si<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token comment">// 正确：显式地请求类型转换</span></code></pre></li>
</ul>
</li>
<li><p><strong>避免有二义性的类型转换</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、如果类中包含<strong>一个或多个类型转换</strong>，就必须确保在<strong>类类型</strong>和<strong>目标类型</strong>之间只存在<strong>唯一一种转换方式</strong>。否则，我们的代码很可能具有<strong>二义性</strong>。有<strong>两种情况</strong>可能产生<strong>多重转换路径</strong><br>2、第一种情况是<strong>两个类提供相同类型转换</strong>。例如<strong>A 类</strong>定义了接受<strong>B 类对象</strong>的<strong>转换构造函数</strong>，同时<strong>B 类</strong>定义了转换目标是<strong>A 类类型</strong>的<strong>类型转换运算符</strong>时，我们就说它们提供了<strong>相同的类型转换</strong><br>3、第二种情况是<strong>类定义了多个转换规则</strong>，而这些转换<strong>涉及的类型</strong>本身就可以通过<strong>其他类型转换</strong>联系在一起。典型例子是<strong>算术运算符</strong>，对于某个给定类来说，最好只定义<strong>最多一个</strong>与<strong>算术类型有关</strong>的<strong>转换规则</strong></p>
</blockquote>
</li>
<li><p><strong>实参匹配和相同类型转换</strong></p>
<blockquote>
<p>1、在下面例子中，我们定义了<strong>两种将 B 转换成 A 的方法</strong>：一种使用<strong>B</strong>的<strong>类型转换运算符</strong>，一种使用<strong>A</strong>的<strong>以 B 为参数的构造函数</strong><br>2、该例中<strong>对 f 的调用</strong>存在<strong>二义性</strong>。如果确实想<strong>执行该调用</strong>，就必须<strong>显式地调用指定函数</strong>了<br>3、值得注意的是，我们无法使用<strong>强制类型转换</strong>来解决<strong>二义性问题</strong>，因为<strong>强制类型转换</strong>本身也面临<strong>二义性</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 最好不要在两个类之间构建相同的类型转换</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 把 B 转换成 A 的构造函数</span>
    <span class="token comment">// ...其他数据成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">operator</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>     <span class="token comment">// 把 B 转换成 A 的类型转换运算符</span>
    <span class="token comment">// ... 其他数据成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

A <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
B b<span class="token punctuation">;</span>
A a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 二义性错误：含义是 f(B::operator A()) 还是 f(A::A(const B&amp;))</span>

A a1 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token keyword">operator</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确：使用 B 的类型转换运算符</span>
A a2 <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">A</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 正确：使用 A 的构造函数</span></code></pre>
</li>
<li><p><strong>转换目标为内置类型的多重类型转换</strong></p>
<blockquote>
<p>1、如果类定义了一组<strong>类型转换</strong>，它们的<strong>转换源</strong>(转换目标)<strong>类型</strong>本身就可以通过<strong>其他类型转换</strong>联系在一起，则同样会产生<strong>二义性问题</strong>。最简单的也最常见的例子就是<strong>类</strong>中定义了多个<strong>参数都是算术类型</strong>的<strong>构造函数</strong>，或者多个<strong>转换目标都是算数类型</strong>的<strong>类型转换运算符</strong><br>2、如下例，如对<code>f2</code>的调用中，无论哪个<strong>类型转换</strong>都<strong>无法精确匹配</strong><code>long double</code>，然而<strong>两个类型转换都能使用</strong>，因此哪个都不比另一个更好，调用将产生<strong>二义性</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 最好不要创建两个转换源都是算数类型的类型转换</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 最好不要创建两个转换目标都是算数类型的类型转换</span>
    <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token comment">// ...其他成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
A a<span class="token punctuation">;</span>
<span class="token function">f2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 二义性错误：含义是 f(A::operator int()) 还是 f(A::operator double())</span>

<span class="token keyword">long</span> lg<span class="token punctuation">;</span>
A <span class="token function">a2</span><span class="token punctuation">(</span>lg<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 二义性错误：含义是 A::A(int) 还是 A::A(double)</span></code></pre>
</li>
<li><p><strong>重载函数与转换构造函数</strong></p>
<blockquote>
<p>1、当我们<strong>调用重载函数</strong>时，从多个<strong>类型转换</strong>中进行选择将变得<strong>更加复杂</strong>。如果两个或多个<strong>类型转换</strong>都提供了<strong>同一种可行匹配</strong>，则<strong>这些类型转换一样好</strong><br>2、举个例子，当几个<strong>重载函数</strong>的<strong>参数分属不同类类型</strong>时，如果<strong>这些类</strong>恰好定义了<strong>同样的转换构造函数</strong>，则<strong>二义性问题</strong>将进一步提升，如下例。我们可以<strong>显式地构造正确的类型</strong>以消除二义性</p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">C</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...其他成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">D</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...其他成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">manip</span><span class="token punctuation">(</span><span class="token keyword">const</span> D<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 重载版本的 manip</span>
<span class="token function">manip</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 二义性错误：含义是 manip(C(10)) 还是 manip(D(10))</span>
<span class="token function">manip</span><span class="token punctuation">(</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 正确：调用 manip(const C&amp;)</span></code></pre></li>
</ul>
</li>
<li><p><strong>函数匹配与重载运算符</strong></p>
<blockquote>
<p>1、<strong>重载运算符</strong>也是<strong>重载的函数</strong>，因此，通用的<strong>函数匹配规则</strong>通常适用于在表达式中使用<strong>内置运算符</strong>还是<strong>重载运算符</strong>。不过当<strong>运算符函数</strong>出现在表达式中时，<strong>候选函数集</strong>的规模比我们使用<strong>调用运算符</strong>调用函数时更大<br>2、如果<code>a</code>是一种<strong>类类型</strong>，则<strong>表达式</strong><code>a sym b</code>(<code>sym</code>代表一种运算符)的<strong>含义可能是</strong>：<code>a.operatorsym(b);</code><strong>或</strong><code>operatorsym(a, b);</code>，且<strong>后者</strong>可能是一个<strong>非成员函数</strong>。和<strong>普通函数</strong>不同，我们不能通过<strong>调用形式</strong>来区分调用的是<strong>成员函数</strong>还是<strong>非成员函数</strong><br>3、当我们使用<strong>重载运算符</strong>作用于<strong>类类型对象</strong>时，<strong>候选函数</strong>中包含<strong>该运算符</strong>的<strong>普通非成员版本</strong>和<strong>内置版本</strong>。此外，如果<strong>左侧对象</strong>是<strong>类类型</strong>，则<strong>定义在该类中</strong>的<strong>重载运算符</strong>也包含在<strong>候选函数</strong>内<br>4、当我们调用一个<strong>命名的函数</strong>时，具有该名字的<strong>成员函数</strong>和<strong>非成员函数</strong>之间<strong>不会彼此重载</strong>。当我们通过<strong>类类型对象</strong>进行<strong>函数调用</strong>时，只考虑<strong>该类的成员函数</strong>；当我们在<strong>表达式中</strong>使用<strong>重载运算符</strong>时，<strong>无法判断</strong>正在使用的是<strong>哪个版本</strong>，因此<strong>二者都应该在考虑范围内</strong><br>5、举个例子，我们为先前的<code>SmallInt</code>定义一个<strong>加法运算符</strong>，如下。我们可以使用这个类<strong>将两个</strong><code>SmallInt</code><strong>对象相加</strong>，但如果我们试图执行<strong>混合模式的算术运算</strong>，就会遇到<strong>二义性问题</strong></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SmallInt</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token comment">// 重载运算符，定义在类外(定义已省略)，返回 SmallInt</span>
        <span class="token keyword">friend</span> SmallInt <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>SmallInt<span class="token operator">&amp;</span><span class="token punctuation">,</span> SmallInt<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">SmallInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 转换源为 int 的类型转换</span>
        <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token comment">// 转换目标为 int 的类型转换</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> val<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        size_t val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

SmallInt s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>
SmallInt s3 <span class="token operator">=</span> s1 <span class="token operator">+</span> s2<span class="token punctuation">;</span>          <span class="token comment">// 使用重载的 operator+</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> s3 <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">;</span>                 <span class="token comment">// 二义性错误：是把 0 转换成 SmallInt 然后使用 SmallInt 重载的加法，还是把 s3 转换成 int 然后使用内置加法</span></code></pre></li>
</ul>
<hr>
<h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a><strong>面向对象程序设计</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：<code>OOP</code>概述；</p>
</blockquote>
</div>

<h4 id="OOP-概述"><a href="#OOP-概述" class="headerlink" title="OOP 概述"></a><strong>OOP 概述</strong></h4><hr>
<h3 id="页底评论"><a href="#页底评论" class="headerlink" title="页底评论"></a><strong>页底评论</strong></h3><hr>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">手头阔绰?点这点这!money得斯!</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/wechatpay.png"><img loading="lazy" src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/alipay.png"><img loading="lazy" src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/alipay.png" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><span class="icon iconify" data-icon="ri:alipay-line"></span></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/QQpay.png"><img loading="lazy" src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/QQpay.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>山暮云秋</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://blog.muyun.space/posts/46cf02c7/" title="Cpp基础教程">https://blog.muyun.space/posts/46cf02c7/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/f3215fef/" rel="prev" title="算法复杂度分析"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">算法复杂度分析</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/6981023b/" rel="next" title="C语言类型声明黄金法则"><span class="post-nav-text">C语言类型声明黄金法则</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，也可以去B站私信我哦</span><br><span>如果较为紧急，建议添加微信或QQ，并注明来意</span><br><span>评论系统可能加载较慢，请耐心等待或刷新重试</span><br></div><div id="waline"></div><link rel="stylesheet" href="https://jsd.vxo.im/npm/@waline/client@v2/dist/waline.css"><script>window.CONFIG.waline.config.path = "/posts/46cf02c7/"</script><div class="js-Pjax"><script src="/js/comments/waline.js" type="module" defer></script></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 – 2025 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 山暮云秋</span></div><div class="live-time"><span>本博客已历经风霜坚持了</span><span id="display_live_time"></span><span class="moe-text">(￣▽￣)／</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-04-15T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="footer-custom-text"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="18px" height="18px" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve" style="vertical-align: middle;margin-right: 4px"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z" data-darkreader-inline-fill="" style="--darkreader-inline-fill:#4cc3ff;"></path></svg>Hexo</a> v6.3.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="yun-logo" stroke="#000" width="18px" height="18px" viewBox="40 40 320 320" stroke-width="16" style="vertical-align: middle; margin-right: 4px; --darkreader-inline-stroke:#fffffe;" data-darkreader-inline-stroke=""> <defs> <line id="eye" x1="0" y1="-35" x2="0" y2="35" stroke-linecap="round"> <animateTransform attributeName="transform" additive="sum" attributeType="XML" type="scale" from="1 1" to="1 0" dur="0.15s" repeatCount="2"></animateTransform> </line> </defs> <polygon stroke-linejoin="round" fill="none" points="50,250 50,150 100,150 100,100 300,100 300,150 350,150 350,250 300,250 300,300 100,300 100,250 50,250"></polygon> <use xlink:href="#eye" transform="translate(150,200)"></use> <use xlink:href="#eye" transform="translate(250,200)"></use></svg><span>Yun</span></a> v1.10.11</span><span class="footer-separator">|</span>Deploys by<a href="https://vercel.com" target="_blank" rel="noopener noreferrer"><svg width="66.33" height="15" viewBox="0 0 283 64" id="vercel-logo" fill="#000" xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle; --darkreader-inline-fill:#060606;" data-darkreader-inline-fill=""><path d="M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z"><br> <!-- 萌ICP备案 --><font style="font-size:14px"><img style="width:24px;height:24px;margin-bottom:-8px" src="https://moe.blog/content/uploadfile/Links/icp.gov.moe.png" /><a href="https://icp.gov.moe/?keyword=20245835" target="_blank"><span style="color:#ff3333">萌</span><span style="color:#ff8533">I</span><span style="color:#1f991f">C</span><span style="color:#3385ff">P</span><span style="color:#8533ff">备</span> </a><a href="https://icp.gov.moe/?keyword=20245835" target="_blank"> <span style="color:#ff3333">20</span><span style="color:#ff8533">24</span><span style="color:#1f991f">58</span><span style="color:#3385ff">35</span><span style="color:#ff3333">号</span></a></font></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="	#ff8533" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="https://jsd.vxo.im/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div class="search-result-container"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script><div id="aplayer"></div><script>function initAplayer() {
  const ap = new APlayer({
    container: document.getElementById('aplayer'),
    fixed: true,
    autoplay: true,
    theme: "	#ff8533",
    loop: "all",
    order: "random",
    preload: "auto",
    audio: [{"name":"夏天，再见","artist":"暮色 / 诗岸","url":"https://music.163.com/song/media/outer/url?id=1861068892.mp3","cover":"http://p2.music.126.net/65hyLjIBv5qFhSpQ3KlOiA==/109951166175266739.jpg","lrc":"/lrc/夏天，再见.lrc"},{"name":"流霰(星尘Infinity Version)","artist":"旅行的蜗牛 / 星尘","url":"https://music.163.com/song/media/outer/url?id=1925101032.mp3","cover":"http://p1.music.126.net/O8s988XrtOxiN30TWyAyiQ==/109951167951585729.jpg","lrc":"/lrc/流霰(星尘Infinity Version).lrc"},{"name":"巫山云(星尘Infinity Version)","artist":"旅行的蜗牛 / 星尘","url":"https://music.163.com/song/media/outer/url?id=1921741824.mp3","cover":"http://p2.music.126.net/pjre_OsOEZOglF57MKVArw==/109951167068514633.jpg","lrc":"/lrc/巫山云(星尘Infinity Version).lrc"},{"name":"月巷","artist":"星葵77 / 乐正绫","url":"https://music.163.com/song/media/outer/url?id=2123816639.mp3","cover":"http://p2.music.126.net/gGlxMNxHKkCwJeD--vKvNQ==/109951169310962799.jpg","lrc":"/lrc/月巷.lrc"},{"name":"东京不太热","artist":"Z新豪 / 洛天依Official","url":"/lrc/东京不太热.mp3","cover":"http://p1.music.126.net/8Sk3EpucLC9e8KheMe_GcQ==/109951165315088091.jpg","lrc":"/lrc/东京不太热.lrc"},{"name":"藏蓝-（绫）","artist":"残杨如血","url":"/lrc/藏蓝-（绫）.mp3","cover":"http://p2.music.126.net/qPt2fkD4DSYIgE2JfkoXdA==/109951166568711712.jpg","lrc":"/lrc/藏蓝-（绫）.lrc"},{"name":"碎梦（short ver.）","artist":"COP / 乐正绫","url":"https://music.163.com/song/media/outer/url?id=515964379.mp3","cover":"http://p1.music.126.net/MBUOR-eADofn53ksY3takw==/109951163052186407.jpg","lrc":"/lrc/碎梦（short ver.）.lrc"},{"name":"旧时约","artist":"WOVOP / 乐正绫","url":"https://music.163.com/song/media/outer/url?id=2037885601.mp3","cover":"http://p1.music.126.net/X5-IU5fcCQbJFWZ67rfpEg==/109951168535887842.jpg","lrc":"/lrc/旧时约.lrc"},{"name":"听雨（AI）","artist":"WOVOP / 洛天依","url":"https://music.163.com/song/media/outer/url?id=1962600810.mp3","cover":"http://p2.music.126.net/Atb91zHjpmraNZE7BHdtMA==/109951167646461688.jpg","lrc":"/lrc/听雨（AI）.lrc"},{"name":"淋完这场雨就忘记你吧","artist":"WOVOP / 洛天依","url":"https://music.163.com/song/media/outer/url?id=2136164855.mp3","cover":"http://p1.music.126.net/MTd6fmN9E_p4suM_VS3CqA==/109951169415944765.jpg","lrc":"/lrc/淋完这场雨就忘记你吧.lrc"},{"name":"啥啊","artist":"星葵77 / 洛天依Official","url":"https://music.163.com/song/media/outer/url?id=1963526955.mp3","cover":"http://p1.music.126.net/-Mkgn-OfUd2Q-to55fvsHA==/109951167663201782.jpg","lrc":"/lrc/啥啊.lrc"},{"name":"夏霞 (Acoustic ver.)","artist":"あたらよ","url":"/lrc/夏霞 (Acoustic ver.).mp3","cover":"http://p1.music.126.net/HymDERNi6HQa0PHVxhvstQ==/109951167607871650.jpg","lrc":"/lrc/夏霞 (Acoustic ver.).lrc"},{"name":"DROP","artist":"美波","url":"/lrc/DROP.mp3","cover":"http://p1.music.126.net/tWZUuc87BMfRDayQIYXEew==/109951166189424848.jpg","lrc":"/lrc/DROP.lrc"},{"name":"アイスクリーム","artist":"花譜","url":"/lrc/アイスクリーム.mp3","cover":"http://p2.music.126.net/M6JINT-YzbR95liqI13oBw==/109951168551085464.jpg","lrc":"/lrc/アイスクリーム.lrc"},{"name":"それを世界と言うんだね","artist":"花譜","url":"/lrc/それを世界と言うんだね.mp3","cover":"http://p2.music.126.net/vlT1L_p5ExPSydDE8HUPpQ==/109951168436884742.jpg","lrc":"/lrc/それを世界と言うんだね.lrc"},{"name":"it's 6pm but I miss u already.","artist":"bbbluelee / Furyl / Siren","url":"https://music.163.com/song/media/outer/url?id=1890756154.mp3","cover":"http://p2.music.126.net/vfArwmf4yUKmZhi-ZCwOXA==/109951166569406479.jpg","lrc":"/lrc/it's 6pm but I miss u already..lrc"},{"name":"下一个拥抱 (past times)","artist":"艾纳德 / Diorbin","url":"https://music.163.com/song/media/outer/url?id=2049786420.mp3","cover":"http://p1.music.126.net/fSCIbOxlbwHwON2cMaDbkA==/109951168633034946.jpg","lrc":"/lrc/下一个拥抱 (past times).lrc"},{"name":"鲸歌（Cover 萨满乐队）","artist":"陈亮 宋依凡","url":"https://music.163.com/song/media/outer/url?id=474667755.mp3","cover":"http://p2.music.126.net/je0ZQVB8GAKscWQOXw0B7g==/109951162814733915.jpg","lrc":"/lrc/鲸歌（Cover 萨满乐队）.lrc"},{"name":"漫步","artist":"UnicornPhantom","url":"https://music.163.com/song/media/outer/url?id=1990251011.mp3","cover":"http://p2.music.126.net/tpSYVkCGmQxbmlkJYfRrvA==/109951167975764401.jpg","lrc":"/lrc/漫步.lrc"},{"name":"独角","artist":"UnicornPhantom","url":"https://music.163.com/song/media/outer/url?id=1934213146.mp3","cover":"http://p1.music.126.net/1HOpmf61G-QHQmm5xIv9rg==/109951167230524234.jpg","lrc":"/lrc/独角.lrc"},{"name":"青空","artist":"THE ROLLING GIRLS","url":"https://music.163.com/song/media/outer/url?id=474567081.mp3","cover":"http://p1.music.126.net/_lMvCfJvymqXqI5d6R9esQ==/109951163597998554.jpg","lrc":"/lrc/青空.lrc"},{"name":"夕暮れ(カバー)","artist":"THE ROLLING GIRLS","url":"/lrc/夕暮れ(カバー).mp3","cover":"http://p1.music.126.net/3K3K5wWj3v9IjOn5TkTyPw==/109951163597992477.jpg","lrc":"/lrc/夕暮れ(カバー).lrc"},{"name":"Polaris","artist":"Asia D / JAMMERC","url":"https://music.163.com/song/media/outer/url?id=1824513851.mp3","cover":"http://p1.music.126.net/34x_GGDI47WYG-sZobR8dw==/109951165775251579.jpg","lrc":"/lrc/Polaris.lrc"},{"name":"Seasons","artist":"Rival / Cadmium / Harley Bird","url":"https://music.163.com/song/media/outer/url?id=1313014216.mp3","cover":"http://p1.music.126.net/Aeh-xCT2sl-i0tF8K5qU7w==/109951163571120456.jpg","lrc":"/lrc/Seasons.lrc"},{"name":"Miracle","artist":"Tiborg","url":"/lrc/Miracle.mp3","cover":"http://p1.music.126.net/Yr28yJDbF_Pi5Mr108Od3A==/109951164548560768.jpg","lrc":"/lrc/Miracle.lrc"},{"name":"Dirty Paws - 电影《白日梦想家》插曲","artist":"Of Monsters And Men","url":"/lrc/Dirty Paws.mp3","cover":"http://p2.music.126.net/yU_pXqN1KAjjNdKa_fXveQ==/2534374302309080.jpg","lrc":"/lrc/Dirty Paws.lrc"},{"name":"Stay Alive - 电影《白日梦想家》插曲","artist":"José González","url":"/lrc/Stay Alive.mp3","cover":"http://p2.music.126.net/yU_pXqN1KAjjNdKa_fXveQ==/2534374302309080.jpg","lrc":"/lrc/Stay Alive.lrc"},{"name":"Can We Kiss Forever?","artist":"Kina / Adriana Proenza","url":"/lrc/Can We Kiss Forever？.mp3","cover":"http://p1.music.126.net/BgsCl01scHEbWJG0ijOS4A==/109951165687403090.jpg","lrc":"/lrc/Can We Kiss Forever？.lrc"},{"name":"小孩小孩","artist":"刷牙 / ilem","url":"/lrc/小孩小孩.mp3","cover":"http://p1.music.126.net/2l6NtMgh9saAaPe3W11PdA==/109951168268946674.jpg","lrc":"/lrc/小孩小孩.lrc"},{"name":"白鸟过河滩","artist":"洛天依 / ilem","url":"/lrc/白鸟过河滩.mp3","cover":"http://p2.music.126.net/jIrh3oXTi5Yu7Xx4gKXtlw==/109951167486432220.jpg","lrc":"/lrc/白鸟过河滩.lrc"},{"name":"Wings of Piano","artist":"V.K克","url":"/lrc/Wings of Piano.mp3","cover":"https://p2.music.126.net/nxVZ033DIAM7JNHvT-DRMA==/109951163598059944.jpg","lrc":"/lrc/Wings of Piano.lrc"},{"name":"Daylight","artist":"Seredris","url":"https://music.163.com/song/media/outer/url?id=1372188635.mp3","cover":"http://p1.music.126.net/OjiWGpbpC80EbQgkxEayiA==/109951164152228527.jpg","lrc":"/lrc/Daylight.lrc"},{"name":"第105天","artist":"Pianoboy高至豪","url":"https://music.163.com/song/media/outer/url?id=139737.mp3","cover":"http://p1.music.126.net/3HT3AxHq8uXHPbFbH7Qoyw==/109951167208222169.jpg","lrc":"/lrc/第105天.lrc"},{"name":"De Ortu Solis","artist":"Charun","url":"https://music.163.com/song/media/outer/url?id=4015520.mp3","cover":"http://p1.music.126.net/qSZds9TgolZf51XpcYsciw==/703687441819461.jpg","lrc":"/lrc/De Ortu Solis.lrc"},{"name":"Long Journey","artist":"JINBAO","url":"https://music.163.com/song/media/outer/url?id=1857012588.mp3","cover":"http://p1.music.126.net/nVyoxD5yriYaDJPzhaN8Eg==/109951166129162887.jpg","lrc":"/lrc/Long Journey.lrc"},{"name":"Welcome Home","artist":"Radical Face","url":"/lrc/Welcome Home.mp3","cover":"http://p1.music.126.net/TRW7_0KbJXHsb5t3sqZsaw==/6659741930385748.jpg","lrc":"/lrc/Welcome Home.lrc"},{"name":"What U Do","artist":"Wild Culture / Shel Bee","url":"/lrc/What U Do.mp3","cover":"http://p2.music.126.net/oK9lZOiyKUlSSk7vBP7HpQ==/109951165104873935.jpg","lrc":"/lrc/What U Do.lrc"},{"name":"花と水飴、最終電車","artist":"n-buna / 初音ミク","url":"https://music.163.com/song/media/outer/url?id=33367346.mp3","cover":"http://p2.music.126.net/MLoChdXEUHXrpZSwsFPqYw==/7814229139683634.jpg","lrc":"/lrc/花と水飴、最終電車.lrc"},{"name":"ハレハレヤ-朗朗晴天","artist":"鹿小丸","url":"https://music.163.com/song/media/outer/url?id=1346946492.mp3","cover":"http://p1.music.126.net/JRZD6Yb5AVtIcTX7ocyF5w==/109951163872790053.jpg","lrc":"/lrc/ハレハレヤ-朗朗晴天.lrc"},{"name":"飞","artist":"大神慧 / 十七草","url":"https://music.163.com/song/media/outer/url?id=1412030522.mp3","cover":"http://p1.music.126.net/moCls2ann4OX8aAoffXEyg==/109951164579487317.jpg","lrc":"/lrc/飞.lrc"},{"name":"Antisocial","artist":"BEAUZ / Heather Sommer","url":"https://music.163.com/song/media/outer/url?id=550124208.mp3","cover":"http://p2.music.126.net/An4OF_5qGdI0t5MDDSNNwQ==/109951168223377068.jpg","lrc":"/lrc/Antisocial.lrc"},{"name":"Void","artist":"Kirara Magic","url":"https://music.163.com/song/media/outer/url?id=1465790878.mp3","cover":"http://p2.music.126.net/nc5H97uZ-OXgjGW45XtiJA==/109951165172063291.jpg","lrc":"/lrc/Void.lrc"},{"name":"Freefall","artist":"暴君de","url":"https://music.163.com/song/media/outer/url?id=1392203256.mp3","cover":"http://p1.music.126.net/_6L3TL_r61aU9HcjnWeoFw==/109951164376305943.jpg","lrc":"/lrc/Freefall.lrc"},{"name":"Carousel","artist":"DEAMN","url":"https://music.163.com/song/media/outer/url?id=1406443093.mp3","cover":"http://p2.music.126.net/JiQHxzcKFEJ6s8Ge_QHp5Q==/109951164515259189.jpg","lrc":"/lrc/Carousel.lrc"},{"name":"17さいのうた。","artist":"『ユイカ』","url":"https://music.163.com/song/media/outer/url?id=1951665069.mp3","cover":"http://p1.music.126.net/1bcwLzrrKPWcs137biKbpw==/109951167488734005.jpg","lrc":"/lrc/17さいのうた。.lrc"},{"name":"ただ声一つ","artist":"ロクデナシ","url":"/lrc/ただ声一つ.mp3","cover":"http://p1.music.126.net/WMAHZRjSjackfXUmA5GVWw==/109951166778043030.jpg","lrc":"/lrc/ただ声一つ.lrc"},{"name":"懒人","artist":"三无MarBlue","url":"https://music.163.com/song/media/outer/url?id=1462427219.mp3","cover":"http://p2.music.126.net/ExC40_fFwxUgydQINzjqAQ==/109951164669111492.jpg","lrc":"/lrc/懒人.lrc"},{"name":"An Old Song","artist":"MoreanP","url":"https://music.163.com/song/media/outer/url?id=462177081.mp3","cover":"http://p2.music.126.net/JoPwp8la7lf2bFi0UQKn_g==/109951162866713272.jpg","lrc":"/lrc/An Old Song.lrc"},{"name":"雨道","artist":"Otokaze","url":"https://music.163.com/song/media/outer/url?id=493903.mp3","cover":"http://p2.music.126.net/fEvTj3iuLsIcoFWBNFTC4w==/4447524534356140.jpg","lrc":"/lrc/雨道.lrc"},{"name":"夏恋","artist":"Otokaze","url":"https://music.163.com/song/media/outer/url?id=493911.mp3","cover":"http://p2.music.126.net/5gNt0nW6l-2hSAtJAnaNCw==/4450823069239492.jpg","lrc":"/lrc/夏恋.lrc"},{"name":"Cold Winter","artist":"July","url":"/lrc/Cold Winter.mp3","cover":"http://p2.music.126.net/-VVoBbON0-XHXnTg-PVXSw==/7946170535465788.jpg","lrc":"/lrc/Cold Winter.lrc"},{"name":"Where are you","artist":"AniFace","url":"https://music.163.com/song/media/outer/url?id=453843751.mp3","cover":"http://p1.music.126.net/AUfXMljLBgB3PBV731IzRg==/109951162857118370.jpg","lrc":"/lrc/Where are you.lrc"},{"name":"青空","artist":"Candy_Wind","url":"https://music.163.com/song/media/outer/url?id=32717172.mp3","cover":"http://p1.music.126.net/1uWLxBVZ5MLunwuVo5hrzg==/8002245627462629.jpg","lrc":"/lrc/青空1.lrc"},{"name":"Feeling The Rain","artist":"MoreanP","url":"https://music.163.com/song/media/outer/url?id=496774187.mp3","cover":"http://p1.music.126.net/p9Frozdg_luAkO6ENOtTXg==/109951162997219545.jpg","lrc":"/lrc/Feeling The Rain.lrc"},{"name":"森林","artist":"灰澈","url":"/lrc/森林.mp3","cover":"http://p1.music.126.net/gtnxIZw1IKVV6UoxYQoA5A==/109951163393955301.jpg","lrc":"/lrc/森林.lrc"},{"name":"Umbrella","artist":"Matte / Ember Island","url":"/lrc/Umbrella.mp3","cover":"http://p1.music.126.net/1LrtvH8EpKb5iHKR9qEU0Q==/109951163063843501.jpg","lrc":"/lrc/Umbrella.lrc"},{"name":"说书人","artist":"暗杠 / 寅子","url":"https://music.163.com/song/media/outer/url?id=1303019637.mp3","cover":"http://p1.music.126.net/JHXgLgO7SIaVYacrW_wJuw==/109951165246765187.jpg","lrc":"/lrc/说书人.lrc"},{"name":"听书","artist":"暗杠 / 寅子","url":"https://music.163.com/song/media/outer/url?id=1843986876.mp3","cover":"http://p2.music.126.net/djVhMQ8TgaI517Lrg4Fm9w==/109951165968113069.jpg","lrc":"/lrc/听书.lrc"},{"name":"神のまにまに","artist":"初音ミク / 鏡音リン / GUMI / れるりり","url":"https://music.163.com/song/media/outer/url?id=32431066.mp3","cover":"http://p2.music.126.net/DCxO3b9pfFQ8wkREgg16UQ==/109951163743139874.jpg","lrc":"/lrc/神のまにまに.lrc"},{"name":"ふわふわ時間","artist":"放課後ティータイム","url":"https://music.163.com/song/media/outer/url?id=26201899.mp3","cover":"http://p1.music.126.net/B_sCLXthAHgoVEMIRNU1hw==/109951163559682176.jpg","lrc":"/lrc/ふわふわ時間.lrc"},{"name":"朝焼けのスターマイン","artist":"今井麻美","url":"https://music.163.com/song/media/outer/url?id=35345760.mp3","cover":"http://p2.music.126.net/UrHFbNNr1e96Z9EWTQPX7w==/2912606303912879.jpg","lrc":"/lrc/朝焼けのスターマイン.lrc"},{"name":"鼓動","artist":"カグラナナ","url":"https://music.163.com/song/media/outer/url?id=1872078983.mp3","cover":"http://p1.music.126.net/D-3JSGUU_pdOn6c91Wkb6w==/109951166313861666.jpg","lrc":"/lrc/鼓動.lrc"},{"name":"In Your Eyes","artist":"DG812","url":"https://music.163.com/song/media/outer/url?id=1397502846.mp3","cover":"http://p2.music.126.net/anSN1ptUo10Jj2tltSrqew==/109951164432466046.jpg","lrc":"/lrc/In Your Eyes.lrc"},{"name":"YUMEND","artist":"MYUKKE.","url":"https://music.163.com/song/media/outer/url?id=1474404251.mp3","cover":"http://p1.music.126.net/TjCQkgXcQ7WgyYPgb1FquA==/109951166330371133.jpg","lrc":"/lrc/YUMEND.lrc"},{"name":"RyAL-All I know","artist":"Champer","url":"https://music.163.com/song/media/outer/url?id=1824058027.mp3","cover":"http://p2.music.126.net/5gerzS_NGUn3TPbgha5rbQ==/109951165770952681.jpg","lrc":"/lrc/RyAL-All I know.lrc"},{"name":"“Fall Silent”","artist":"Game Tape","url":"https://music.163.com/song/media/outer/url?id=1498957758.mp3","cover":"http://p1.music.126.net/fFUKQs4fLeBNWZA-jAhTgg==/109951165505365193.jpg","lrc":"/lrc/“Fall Silent”.lrc"},{"name":4038,"artist":"JuggShots_RADI8 / 夏璃夜 / Reggie Yang / RADI8","url":"https://music.163.com/song/media/outer/url?id=1406885246.mp3","cover":"http://p1.music.126.net/ntaw2ZudfFxKzFFAPV0OKQ==/109951164985255855.jpg","lrc":"/lrc/4038.lrc"},{"name":"Outerspace","artist":"BEAUZ","url":"/lrc/Outerspace.mp3","cover":"http://p1.music.126.net/nnhkuAvDHZI44e1xFLuLHQ==/109951165308881338.jpg","lrc":"/lrc/Outerspace.lrc"},{"name":"Bring Me Back","artist":"Miles Away","url":"/lrc/Bring Me Back.mp3","cover":"http://p1.music.126.net/m8u6XqT7V8Db8sXdw7d3ow==/109951165400340890.jpg","lrc":"/lrc/Bring Me Back.lrc"},{"name":"Starry Skies","artist":"The Darkmaker / GY","url":"https://music.163.com/song/media/outer/url?id=1836533888.mp3","cover":"http://p2.music.126.net/EOiPbTxVJJCwtj-ftKePhQ==/109951165881650817.jpg","lrc":"/lrc/Starry Skies.lrc"},{"name":"Way To You","artist":"Gareth Emery","url":"https://music.163.com/song/media/outer/url?id=1430240225.mp3","cover":"http://p2.music.126.net/MolpIGnZNmfLSxE0a4A0kg==/109951164795136845.jpg","lrc":"/lrc/Way To You.lrc"},{"name":1984,"artist":"Forwe兰斯 / WERECORDS","url":"https://music.163.com/song/media/outer/url?id=1823013624.mp3","cover":"http://p1.music.126.net/DfhuVKpiFwtzjsC6N-IUmQ==/109951165759178585.jpg","lrc":"/lrc/1984.lrc"},{"name":"Every Day","artist":"VESRIX / The Darkmaker / 赵曼伊mï","url":"https://music.163.com/song/media/outer/url?id=1804141508.mp3","cover":"http://p2.music.126.net/_ARlb95O7dWCnpmMUwpUtQ==/109951165539401727.jpg","lrc":"/lrc/Every Day.lrc"},{"name":"PLANET","artist":"ラムジ","url":"/lrc/PLANET.mp3","cover":"http://p2.music.126.net/cCyPSxi-BE2h-SmpLBztbA==/18635622580993683.jpg","lrc":"/lrc/PLANET.lrc"},{"name":"Hall of Fame","artist":"The Script / will.i.am","url":"/lrc/Hall of Fame.mp3","cover":"http://p2.music.126.net/y3NzeUWXbuHI9Mm5mghD6A==/109951165967126686.jpg","lrc":"/lrc/Hall of Fame.lrc"},{"name":"回る空うさぎ","artist":"Orangestar / 初音ミク","url":"https://music.163.com/song/media/outer/url?id=458231455.mp3","cover":"http://p2.music.126.net/WT3eISFoAum31NVAIKgKWg==/109951165868174091.jpg","lrc":"/lrc/回る空うさぎ.lrc"},{"name":"雨き声残響","artist":"Orangestar / IA","url":"https://music.163.com/song/media/outer/url?id=31830625.mp3","cover":"http://p1.music.126.net/FGYCo9ZtZd-vcOBZXeu-Cg==/109951165868160762.jpg","lrc":"/lrc/雨き声残響.lrc"},{"name":"Surges","artist":"Orangestar / IA","url":"https://music.163.com/song/media/outer/url?id=1872393298.mp3","cover":"http://p1.music.126.net/brRQMx-FhXwW1APZtmNeuw==/109951166317376612.jpg","lrc":"/lrc/Surges.lrc"},{"name":"天ノ弱","artist":"鹿乃","url":"https://music.163.com/song/media/outer/url?id=27602841.mp3","cover":"http://p1.music.126.net/ZvUIE8dl3iM15BXurWgqAg==/5507453743618637.jpg","lrc":"/lrc/天ノ弱.lrc"},{"name":"天ノ弱（Piano ver.）","artist":"Akie秋绘","url":"/lrc/天ノ弱（Piano ver.）.mp3","cover":"http://p1.music.126.net/z68-4CoPo6UQVSPPUKQjeQ==/109951167762964914.jpg","lrc":"/lrc/天ノ弱（Piano ver.）.lrc"},{"name":"アイロニ","artist":"H△G","url":"/lrc/アイロニ.mp3","cover":"http://p1.music.126.net/knuZxQIl0tWXn8bHjnyq_w==/17770306928531115.jpg","lrc":"/lrc/アイロニ.lrc"},{"name":"STAY","artist":"The Kid LAROI / Justin Bieber","url":"/lrc/STAY.mp3","cover":"http://p2.music.126.net/e5cvcdgeosDKTDrkTfZXnQ==/109951166155165682.jpg","lrc":"/lrc/STAY.lrc"},{"name":"Million Days","artist":"Sabai / Hoang / Claire Ridgely","url":"/lrc/Million Days.mp3","cover":"http://p1.music.126.net/OCXJq2VEytCN6xIuS7Raag==/109951164630509914.jpg","lrc":"/lrc/Million Days.lrc"},{"name":"Returns","artist":"Poppin'Party","url":"https://music.163.com/song/media/outer/url?id=1365428127.mp3","cover":"http://p2.music.126.net/fh55GPh3tXUS9Wt0rFNhbw==/109951164971293108.jpg","lrc":"/lrc/Returns.lrc"},{"name":"她追逐着月光的尽头","artist":"warma","url":"https://music.163.com/song/media/outer/url?id=1868711061.mp3","cover":"http://p1.music.126.net/-5kwASaP2-LcTr9VrmnmTg==/109951166273496994.jpg","lrc":"/lrc/她追逐着月光的尽头.lrc"},{"name":"帰路 - KaeriMichi -","artist":"Otokaze","url":"https://music.163.com/song/media/outer/url?id=493945.mp3","cover":"http://p1.music.126.net/tkQc2-C4KT1H8iRSrEyY9g==/858718581293350.jpg","lrc":"/lrc/帰路 - KaeriMichi -.lrc"},{"name":"儿时的夏日","artist":"余日秋山","url":"https://music.163.com/song/media/outer/url?id=467744316.mp3","cover":"http://p1.music.126.net/AoxdNp812wLheBzLBm-zXw==/109951163871163517.jpg","lrc":"/lrc/儿时的夏日.lrc"},{"name":"春日","artist":"四季音色","url":"https://music.163.com/song/media/outer/url?id=409649183.mp3","cover":"http://p2.music.126.net/IzwWL-ULrEKH9FK3pEFLFA==/17857168346938270.jpg","lrc":"/lrc/春日.lrc"},{"name":"夏夜","artist":"四季音色","url":"https://music.163.com/song/media/outer/url?id=410042763.mp3","cover":"http://p2.music.126.net/pk-xo-6Nu5bwrA-ylVJFUA==/17885755649212510.jpg","lrc":"/lrc/夏夜.lrc"},{"name":"心动讯息","artist":"BlackDD","url":"https://music.163.com/song/media/outer/url?id=1458639005.mp3","cover":"http://p2.music.126.net/7inlikcI5GuMLcOl-Zj12w==/109951168185876251.jpg","lrc":"/lrc/心动讯息.lrc"},{"name":"Forever (Epic Edition)","artist":"PIKASONIC","url":"https://music.163.com/song/media/outer/url?id=1462341831.mp3","cover":"http://p2.music.126.net/4eciQbmCZ6AH1GB39SlIfQ==/109951165133997929.jpg","lrc":"/lrc/Forever (Epic Edition).lrc"},{"name":"Never Gonna Give You Up (Piano Version)","artist":"LittleTranscriber","url":"https://music.163.com/song/media/outer/url?id=1870402236.mp3","cover":"http://p1.music.126.net/QkBjOd1aM5aw4GnRmcOUqw==/109951166294709668.jpg","lrc":"/lrc/Never Gonna Give You Up (Piano Version).lrc"},{"name":"Revolution","artist":"高仕超","url":"https://music.163.com/song/media/outer/url?id=1426163928.mp3","cover":"http://p1.music.126.net/qw1ycZSYlBv2CBh4U1H4PQ==/109951164883021091.jpg","lrc":"/lrc/Revolution.lrc"}],
    volume: 0.7,
    mutex: true,
    lrcType: 3,
    listFolded: false,
    listMaxHeight: "340px",
    storageName: "aplayer-setting"
  });
}
document.addEventListener("DOMContentLoaded", initAplayer);
document.addEventListener("pjax:success", initAplayer);</script><script src="https://jsd.vxo.im/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%85%B6%E4%BB%96/">
          其他
        </a>
      <span class="tree-list-count">1</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/c794d1e9/" title="hexo-encrypt密码插件测试"><i class="post-icon gg-file-document"></i>hexo-encrypt密码插件测试</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%85%B6%E4%BB%96%E6%95%99%E7%A8%8B/">
          其他教程
        </a>
      <span class="tree-list-count">7</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/33de6690/" title="Github Calendar教程文档"><i class="post-icon gg-file-document"></i>Github Calendar教程文档</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/7fa36b92/" title="Hexo博客SEO相关收录教程"><i class="post-icon gg-file-document"></i>Hexo博客SEO相关收录教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/b010393c/" title="PicGO图床配置"><i class="post-icon gg-file-document"></i>PicGO图床配置</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/5df1183b/" title="云游君Hexo部署教程"><i class="post-icon gg-file-document"></i>云游君Hexo部署教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/e5a21006/" title="云游君yun主题配置教程"><i class="post-icon gg-file-document"></i>云游君yun主题配置教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/d5012c8c/" title="搜索引擎搜索技巧"><i class="post-icon gg-file-document"></i>搜索引擎搜索技巧</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/f6c193b6/" title="解决Vercel CORS跨域问题"><i class="post-icon gg-file-document"></i>解决Vercel CORS跨域问题</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/">
          开发技能
        </a>
      <span class="tree-list-count">6</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/941aaef3/" title="$\KaTeX$ 公式大全"><i class="post-icon gg-file-document"></i>$\KaTeX$ 公式大全</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/c6c59c74/" title="Cmake基础教程"><i class="post-icon gg-file-document"></i>Cmake基础教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/249d705/" title="$\KaTeX$ 速查手册"><i class="post-icon gg-file-document"></i>$\KaTeX$ 速查手册</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/6bc3d8a/" title="Linux常用命令手册"><i class="post-icon gg-file-document"></i>Linux常用命令手册</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/cf058d62/" title="Markdown语法教程"><i class="post-icon gg-file-document"></i>Markdown语法教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/c4eece1e/" title="git基础教程"><i class="post-icon gg-file-document"></i>git基础教程</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
          开发环境
        </a>
      <span class="tree-list-count">3</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/f9bb8de7/" title="Qt 开发环境配置"><i class="post-icon gg-file-document"></i>Qt 开发环境配置</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/54ce768c/" title="VScode基本环境配置"><i class="post-icon gg-file-document"></i>VScode基本环境配置</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/e8dec52a/" title="VScode配置Clang和Cmake环境"><i class="post-icon gg-file-document"></i>VScode配置Clang和Cmake环境</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
          数据结构与算法
        </a>
      <span class="tree-list-count">30</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/b30456ca/" title="01Trie"><i class="post-icon gg-file-document"></i>01Trie</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/1d03a887/" title="AVL树与哈夫曼树"><i class="post-icon gg-file-document"></i>AVL树与哈夫曼树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/394de44a/" title="gcd 和 lcm"><i class="post-icon gg-file-document"></i>gcd 和 lcm</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/bfaab9bd/" title="乘法逆元"><i class="post-icon gg-file-document"></i>乘法逆元</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/b81a161a/" title="二分枚举"><i class="post-icon gg-file-document"></i>二分枚举</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8b3a7218/" title="倍增LCA与Tarjan"><i class="post-icon gg-file-document"></i>倍增LCA与Tarjan</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/77a88a6b/" title="前缀和与差分"><i class="post-icon gg-file-document"></i>前缀和与差分</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/a80d0031/" title="动态规划"><i class="post-icon gg-file-document"></i>动态规划</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/a6add1c4/" title="单调栈与单调队列"><i class="post-icon gg-file-document"></i>单调栈与单调队列</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/33e6ada9/" title="图与回溯"><i class="post-icon gg-file-document"></i>图与回溯</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/91a7e4d1/" title="双指针"><i class="post-icon gg-file-document"></i>双指针</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/e8bacb09/" title="差分约束与二分图"><i class="post-icon gg-file-document"></i>差分约束与二分图</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/c517589e/" title="并查集"><i class="post-icon gg-file-document"></i>并查集</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/735e5788/" title="排序算法"><i class="post-icon gg-file-document"></i>排序算法</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/9acb5cb3/" title="最小生成树"><i class="post-icon gg-file-document"></i>最小生成树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/f216fabe/" title="最短路"><i class="post-icon gg-file-document"></i>最短路</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/6d73f605/" title="权值线段树和主席树"><i class="post-icon gg-file-document"></i>权值线段树和主席树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/263f4c38/" title="树与二叉树"><i class="post-icon gg-file-document"></i>树与二叉树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/20c47d09/" title="快速幂"><i class="post-icon gg-file-document"></i>快速幂</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/59a0de58/" title="树状数组与ST表"><i class="post-icon gg-file-document"></i>树状数组与ST表</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/89c44d72/" title="欧拉路径与哈密顿路径"><i class="post-icon gg-file-document"></i>欧拉路径与哈密顿路径</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/515818b4/" title="离散化"><i class="post-icon gg-file-document"></i>离散化</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/f3215fef/" title="算法复杂度分析"><i class="post-icon gg-file-document"></i>算法复杂度分析</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8893d943/" title="线段树"><i class="post-icon gg-file-document"></i>线段树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/9ac1aea8/" title="组合数"><i class="post-icon gg-file-document"></i>组合数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/b2626942/" title="背包问题"><i class="post-icon gg-file-document"></i>背包问题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/554f2221/" title="质数筛"><i class="post-icon gg-file-document"></i>质数筛</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/a4ce31d2/" title="贪心算法"><i class="post-icon gg-file-document"></i>贪心算法</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/5499b3ee/" title="重链剖分与启发式合并"><i class="post-icon gg-file-document"></i>重链剖分与启发式合并</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/5c43c6e5/" title="高精度算法"><i class="post-icon gg-file-document"></i>高精度算法</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">
          算法题
        </a>
      <span class="tree-list-count">13</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/5c63dfdb/" title="C. LR-remainders"><i class="post-icon gg-file-document"></i>C. LR-remainders</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8e48091a/" title="D - K-th Nearest"><i class="post-icon gg-file-document"></i>D - K-th Nearest</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/d9ea786c/" title="D - Synchronized Players"><i class="post-icon gg-file-document"></i>D - Synchronized Players</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/86fe45f1/" title="D. Find the Different Ones!"><i class="post-icon gg-file-document"></i>D. Find the Different Ones!</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8abc54c0/" title="E. Final Countdown"><i class="post-icon gg-file-document"></i>E. Final Countdown</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/21e58d4f/" title="P10126 「Daily OI Round 3」Pigeon"><i class="post-icon gg-file-document"></i>P10126 「Daily OI Round 3」Pigeon</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/9120d4e8/" title="P1031 [NOIP2002 提高组] 均分纸牌"><i class="post-icon gg-file-document"></i>P1031 [NOIP2002 提高组] 均分纸牌</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/cdc4662f/" title="P1036 [NOIP2002 普及组] 选数"><i class="post-icon gg-file-document"></i>P1036 [NOIP2002 普及组] 选数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8cb1d9bf/" title="P1037 [NOIP2002 普及组] 产生数"><i class="post-icon gg-file-document"></i>P1037 [NOIP2002 普及组] 产生数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/6cd8f33d/" title="P1060 [NOIP2006 普及组] 开心的金明"><i class="post-icon gg-file-document"></i>P1060 [NOIP2006 普及组] 开心的金明</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/59ee5a77/" title="P1090 [NOIP2004 提高组] 合并果子"><i class="post-icon gg-file-document"></i>P1090 [NOIP2004 提高组] 合并果子</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/2ad6a038/" title="P1147 连续自然数和"><i class="post-icon gg-file-document"></i>P1147 连续自然数和</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/d3586754/" title="P1364 医院设置"><i class="post-icon gg-file-document"></i>P1364 医院设置</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
          编程语言
        </a>
      <span class="tree-list-count">5</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/6981023b/" title="C语言类型声明黄金法则"><i class="post-icon gg-file-document"></i>C语言类型声明黄金法则</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/245b3756/" title="Python3爬虫基础"><i class="post-icon gg-file-document"></i>Python3爬虫基础</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/19856b4f/" title="Python3基础教程"><i class="post-icon gg-file-document"></i>Python3基础教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/46cf02c7/" title="Cpp基础教程"><i class="post-icon gg-file-document"></i>Cpp基础教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/7e973705/" title="C语言基础教程"><i class="post-icon gg-file-document"></i>C语言基础教程</a></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div>
  <script data-pjax src="https://jsd.vxo.im/gh/barry-flynn/hexo-github-calendar/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://calendar.muyun.space/api/?user=ShanMuYunQiu";
            var git_color =['#ebedf0', '#ffd1b3', '#ffb380', '#ffa366', '#ff9c59', '#ff944d', '#ff8c40', '	#ff8533', '#ff7d26', '#ff7519', '#ff6600'];
            var git_user ="ShanMuYunQiu";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<head><style type="text/css">@media (max-width: 1000px){.recent-post-item{width:90% !important;}}@media (min-width: 1000px){.recent-post-item{max-width:940px;width:100%;margin:0 auto;}}@media (max-width: 480px){.recent-post-item{padding:10px;}}</style><link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml,sitemap.txt"></head><div class="recent-post-item" style="width:100%;height:auto;padding:20px;"><div id="github_loading" style="text-align:center;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" style="width:50px;height:50px;margin:0 auto;"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --><script src="https://jsd.vxo.im/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://jsd.vxo.im/npm/live2d-widget-model-wanko@latest/assets/wanko.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"right","hOffset":0,"vOffset":-100},"mobile":{"show":false},"dialog":{"enable":false,"hitokoto":false},"log":false});</script></body></html>