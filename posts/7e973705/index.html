<!DOCTYPE html><html lang="zh-CN"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="	#ff8533"><meta name="author" content="山暮云秋"><meta name="copyright" content="山暮云秋"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>C语言基础教程 | 山暮云秋 | Blog</title><link rel="stylesheet" href="https://jsd.vxo.im/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://jsd.vxo.im/npm/prism-theme-vars/base.css"><script src="https://jsd.vxo.im/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://jsd.vxo.im/npm/katex@latest/dist/katex.min.css"><script defer src="https://jsd.vxo.im/npm/katex@latest/dist/katex.min.js"></script><link rel="stylesheet" type="text/css" href="https://jsd.vxo.im/npm/katex@latest/dist/contrib/copy-tex.min.css"><script defer src="https://jsd.vxo.im/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><script defer src="https://jsd.vxo.im/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script type="module">import { renderKatex } from '/js/utils.js'
document.addEventListener("DOMContentLoaded", () => {
  renderKatex({
    ...{},
    ...undefined?.options,
  });
});</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://jsd.vxo.im/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://jsd.vxo.im/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script src="https://jsd.vxo.im/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer type="module"></script><script src="https://jsd.vxo.im/npm/vue@2.6.14"></script><link rel="icon" type="image/png" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/info/user.jpg"><link rel="mask-icon" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/info/user.jpg" color="	#ff8533"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://jsd.vxo.im/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"blog.muyun.space","root":"/","title":"山暮云秋的空间","version":"1.10.11","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn?c=a&c=d&c=e&c=f&c=i&c=j&c=k","hitokoto":true},"local_search":{"path":"/search.xml"},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"fireworks":{"colors":["255, 117, 25","255, 163, 102","255, 209, 179"]},"waline":{"config":{"enable":true,"serverURL":"https://waline.muyun.space/","comment":true,"visitor":false,"emoji":["https://emoji.shojo.cn/bili/webp/仓鼠","https://emoji.shojo.cn/bili/webp/仓鼠松鼠","https://emoji.shojo.cn/bili/webp/东爱璃Lovely","https://emoji.shojo.cn/bili/webp/星汐seki","https://emoji.shojo.cn/bili/webp/咩栗","https://emoji.shojo.cn/bili/webp/呜米","https://emoji.shojo.cn/bili/webp/枕边童话","https://emoji.shojo.cn/bili/webp/美月もも","https://emoji.shojo.cn/bili/webp/雫るる制服ver","https://emoji.shojo.cn/bili/webp/雫るる","https://emoji.shojo.cn/bili/webp/梦音茶糯","https://unpkg.com/@waline/emojis@1.2.0/bilibili","https://unpkg.com/@waline/emojis@1.2.0/bmoji","https://unpkg.com/@waline/emojis@1.2.0/weibo","https://unpkg.com/@waline/emojis@1.2.0/qq"],"locale":{"placeholder":"填写邮箱，可以收到回复通知哦～"},"requiredMeta":["nick"],"el":"#waline","lang":"zh-CN"},"cdn":"https://jsd.vxo.im/npm/@waline/client@v2/dist/waline.js","dark":"html.dark"},"vendors":{"host":"https://jsd.vxo.im/npm/","darken":"https://jsd.vxo.im/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="stylesheet" href="https://fonts.font.im/css2?family=Noto+Serif+SC:wght@900&amp;display=swap"><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="有关于C语言的基础教程，包括基本语法、基础的底层逻辑知识与部分数据结构内容">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言基础教程">
<meta property="og:url" content="https://blog.muyun.space/posts/7e973705/index.html">
<meta property="og:site_name" content="山暮云秋 | Blog">
<meta property="og:description" content="有关于C语言的基础教程，包括基本语法、基础的底层逻辑知识与部分数据结构内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E7%BC%96%E8%AF%91.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%87%BD%E6%95%B0%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E6%95%B4%E6%95%B0.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%B0%8F%E6%95%B0.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BC%A0%E5%8F%82%E8%AF%B4%E6%98%8E.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/if%E9%85%8D%E5%AF%B9.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E7%BC%93%E5%86%B2%E5%8C%BA.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E7%BB%93%E5%B0%BE%E6%A0%87%E8%AE%B0.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%80%92%E5%BD%92.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%A3%B0%E6%98%8E%E6%8C%87%E9%92%88.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E6%8C%87%E9%92%88%E8%A1%A8%E7%A4%BA%E6%B3%95.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BE%93%E5%87%BA.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E6%8E%A9%E7%A0%81.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%98%9F%E5%88%971.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%98%9F%E5%88%972.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%910.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%911.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%912.png">
<meta property="og:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8D%E5%B9%B3%E8%A1%A1.png">
<meta property="article:published_time" content="2022-05-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-12-19T16:00:00.000Z">
<meta property="article:author" content="山暮云秋">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="基础语法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E7%BC%96%E8%AF%91.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://jsd.vxo.im/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="山暮云秋"><img width="96" loading="lazy" src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/info/user.jpg" alt="山暮云秋"><span class="site-author-status" title="精神状态美丽">😇</span></a><div class="site-author-name"><a href="/about/">山暮云秋</a></div><a class="site-name" href="/about/site.html">山暮云秋 | Blog</a><sub class="site-subtitle">千里关山边草暮，一星烽火朔云秋</sub><div class="site-description">知识分享与生活记录</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">65</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">83</span></a></div><a class="site-state-item hty-icon-button" href="/talks/" title="《道是寻常》——我的说说"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:chat-smile-3-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://muyun.space" title="个人主页" target="_blank" style="color:#ff8533"><span class="icon iconify" data-icon="ri:account-circle-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/wechat.png" title="微信" target="_blank" style="color:#1AAD19"><span class="icon iconify" data-icon="ri:wechat-2-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/QQ.png" title="QQ" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ShanMuYunQiu" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/347061710" title="Bilibili" target="_blank" style="color:#FB7299"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=509242587" title="网易云音乐" target="_blank" style="color:#E60026"><span class="icon iconify" data-icon="ri:netease-cloud-music-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://500px.com.cn/ShanMuYunQiu" title="500px" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:number-5"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://tuchong.com/28695963/" title="图虫" target="_blank" style="color:#E9357B"><span class="icon iconify" data-icon="ri:multi-image-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://waline.muyun.space/ui" title="评论管理" target="_blank" style="color:#66b3ff"><span class="icon iconify" data-icon="ri:chat-settings-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://bk.muyun.space/talks.html" title="后台管理" target="_blank" style="color:#bb99ff"><span class="icon iconify" data-icon="ri:terminal-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="《萤火虫小巷》——友情链接" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="《泡沫之夏》——喜欢的角色" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a><a class="links-item hty-icon-button" href="/donate/" title="《月亮与六便士》——打赏与鸣谢" style="color:#ff8533"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-C-%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">初识 C 语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">通俗了解计算机工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">高级计算机语言与编译器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E7%9A%84-7-%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.4.</span> <span class="toc-text">使用 C 语言的 7 个步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">编程机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">C 语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84-C-%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">简单的 C 程序示例及分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8-C"><span class="toc-number">2.2.</span> <span class="toc-text">进一步使用 C</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">多个函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">关键字和保留标识符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%92%8C-C"><span class="toc-number">3.</span> <span class="toc-text">数据和 C</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">交互式程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.</span> <span class="toc-text">变量与常量数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.</span> <span class="toc-text">数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.</span> <span class="toc-text">数据类型关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">C 语言基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.6.</span> <span class="toc-text">获取类型大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.</span> <span class="toc-text">字符串和格式化输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.1.</span> <span class="toc-text">引入示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.</span> <span class="toc-text">字符串简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#char-%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E4%B8%8E-null-%E5%AD%97%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">char 类型数组与 null 字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8E-C-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">常量与 C 预处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#printf-%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">printf()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">4.6.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scanf-%E5%87%BD%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">scanf()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.</span> <span class="toc-text">运算符、表达式和语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF%E7%AE%80%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">while 循环简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%9D%97"><span class="toc-number">5.3.</span> <span class="toc-text">表达式、语句和块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.4.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">带参数的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.</span> <span class="toc-text">C 控制语句:循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2-while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.1.</span> <span class="toc-text">再探 while 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.2.</span> <span class="toc-text">while 循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">关系运算符与关系表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.4.</span> <span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.5.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E5%8F%A3%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF-do-while"><span class="toc-number">6.6.</span> <span class="toc-text">出口条件循环 do-while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97"><span class="toc-number">6.7.</span> <span class="toc-text">循环嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%AE%80%E4%BB%8B"><span class="toc-number">6.8.</span> <span class="toc-text">数组简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.9.</span> <span class="toc-text">函数返回值的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-%E5%88%86%E6%94%AF%E5%92%8C%E8%B7%B3%E8%BD%AC"><span class="toc-number">7.</span> <span class="toc-text">C 控制语句:分支和跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.</span> <span class="toc-text">if 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if-else-%E8%AF%AD%E5%8F%A5%E4%B8%8E-else-if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.2.</span> <span class="toc-text">if-else 语句与 else-if 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if-%E4%B8%8E-else-%E7%9A%84%E9%85%8D%E5%AF%B9%E5%92%8C%E5%B5%8C%E5%A5%97-if"><span class="toc-number">7.3.</span> <span class="toc-text">if 与 else 的配对和嵌套 if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getchar-%E4%B8%8E-putchar-%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">getchar()与 putchar()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ctype-h-%E7%B3%BB%E5%88%97%E7%9A%84%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">ctype.h 系列的字符函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.6.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6-%E4%B8%89%E7%9B%AE-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.7.</span> <span class="toc-text">条件(三目)运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%BE%85%E5%8A%A9%EF%BC%9Acontinue-%E5%92%8C-break"><span class="toc-number">7.8.</span> <span class="toc-text">循环辅助：continue 和 break</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.9.</span> <span class="toc-text">switch 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goto-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.10.</span> <span class="toc-text">goto 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%B8%8E%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81"><span class="toc-number">8.</span> <span class="toc-text">字符输入输出与输入验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%AD%97%E7%AC%A6-I-x2F-O-getchar-%E4%B8%8E-putchar"><span class="toc-number">8.1.</span> <span class="toc-text">单字符 I&#x2F;O:getchar 与 putchar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">8.2.</span> <span class="toc-text">缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5-C-%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">结束键盘输入(C 处理文件的方式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.</span> <span class="toc-text">重定向和文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9B%B4%E5%8F%8B%E5%A5%BD%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">8.5.</span> <span class="toc-text">创建更友好的用户界面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81"><span class="toc-number">8.6.</span> <span class="toc-text">输入验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">复习函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ANSI-C-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">9.2.</span> <span class="toc-text">ANSI C 函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">9.3.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%A4%9A%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.4.</span> <span class="toc-text">编译多源代码文件的程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%9C%B0%E5%9D%80%EF%BC%9A-amp-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.5.</span> <span class="toc-text">查找地址：&amp;运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E4%B8%BB%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">9.6.</span> <span class="toc-text">更改主调函数中的变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B"><span class="toc-number">9.7.</span> <span class="toc-text">指针简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">10.</span> <span class="toc-text">数组与指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">10.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">10.2.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">10.3.</span> <span class="toc-text">指针和数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88-%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">10.4.</span> <span class="toc-text">函数、数组与指针(声明数组形参)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82"><span class="toc-number">10.5.</span> <span class="toc-text">使用指针形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="toc-number">10.6.</span> <span class="toc-text">指针操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">10.7.</span> <span class="toc-text">保护数组中的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">10.8.</span> <span class="toc-text">指针和多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E3%80%81%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E6%B7%B1%E5%85%A5"><span class="toc-number">10.9.</span> <span class="toc-text">数组指针与指针、多维数组深入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84-VLA"><span class="toc-number">10.10.</span> <span class="toc-text">变长数组(VLA)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">10.11.</span> <span class="toc-text">复合字面量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">字符串和字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2-I-x2F-O"><span class="toc-number">11.1.</span> <span class="toc-text">表示字符串和字符串 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5"><span class="toc-number">11.2.</span> <span class="toc-text">字符串输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA"><span class="toc-number">11.3.</span> <span class="toc-text">字符串输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">11.4.</span> <span class="toc-text">自定义输入&#x2F;输出函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">11.5.</span> <span class="toc-text">字符串函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F"><span class="toc-number">11.6.</span> <span class="toc-text">字符串示例：字符串排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">11.7.</span> <span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97"><span class="toc-number">11.8.</span> <span class="toc-text">字符串转换为数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">储存类别、链接和内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%82%A8%E5%AD%98%E7%B1%BB%E5%88%AB-%E5%BC%95%E5%85%A5"><span class="toc-number">12.1.</span> <span class="toc-text">储存类别(引入)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-number">12.2.</span> <span class="toc-text">作用域、链接与存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">12.3.</span> <span class="toc-text">C 的存储类别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E8%A1%A5%E5%85%85"><span class="toc-number">12.4.</span> <span class="toc-text">存储类别补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">12.5.</span> <span class="toc-text">随机数函数和静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9Amalloc-%E5%92%8C-free"><span class="toc-number">12.6.</span> <span class="toc-text">分配内存：malloc()和 free()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ANSI-C-%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">12.7.</span> <span class="toc-text">ANSI C 类型限定符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA"><span class="toc-number">13.</span> <span class="toc-text">文件输入&#x2F;输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">13.1.</span> <span class="toc-text">与文件进行通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86-I-x2F-O"><span class="toc-number">13.2.</span> <span class="toc-text">标准 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E7%A8%8B%E5%BA%8F"><span class="toc-number">13.3.</span> <span class="toc-text">简单的文件压缩程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-I-x2F-O"><span class="toc-number">13.4.</span> <span class="toc-text">文件 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%EF%BC%9Afseek-%E5%92%8C-stell"><span class="toc-number">13.5.</span> <span class="toc-text">随机访问：fseek()和 stell()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%A0%87%E5%87%86-I-x2F-O-%E5%87%BD%E6%95%B0"><span class="toc-number">13.6.</span> <span class="toc-text">其他标准 I&#x2F;O 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">结构和其他数据形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">14.1.</span> <span class="toc-text">初识结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-number">14.2.</span> <span class="toc-text">结构数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84"><span class="toc-number">14.3.</span> <span class="toc-text">嵌套结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">14.4.</span> <span class="toc-text">指向结构的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">14.5.</span> <span class="toc-text">向函数传递结构的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">14.6.</span> <span class="toc-text">结构与内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E7%BB%93%E6%9E%84%E5%86%85%E5%AE%B9%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">14.7.</span> <span class="toc-text">把结构内容保存到文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">14.8.</span> <span class="toc-text">链式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%AE%80%E4%BB%8B"><span class="toc-number">14.9.</span> <span class="toc-text">联合简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.10.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef-%E7%AE%80%E4%BB%8B"><span class="toc-number">14.11.</span> <span class="toc-text">typedef 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">14.12.</span> <span class="toc-text">其他复杂的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">14.13.</span> <span class="toc-text">函数指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">15.</span> <span class="toc-text">位操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E3%80%81%E4%BD%8D%E3%80%81%E5%AD%97%E8%8A%82"><span class="toc-number">15.1.</span> <span class="toc-text">二进制数、位、字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">15.2.</span> <span class="toc-text">其他进制数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.3.</span> <span class="toc-text">C 按位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95"><span class="toc-number">15.4.</span> <span class="toc-text">运算符常用用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">15.5.</span> <span class="toc-text">位字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7"><span class="toc-number">15.6.</span> <span class="toc-text">对齐特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C-C-%E5%BA%93"><span class="toc-number">16.</span> <span class="toc-text">C 预处理器和 C 库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="toc-number">16.1.</span> <span class="toc-text">翻译程序的第一步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%8E%E7%A4%BA%E5%B8%B8%E9%87%8F%EF%BC%9A-define"><span class="toc-number">16.2.</span> <span class="toc-text">明示常量：#define</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-define-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">16.3.</span> <span class="toc-text">在 #define 中使用参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%9A-include"><span class="toc-number">16.4.</span> <span class="toc-text">文件包含：#include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-number">16.5.</span> <span class="toc-text">其他指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">16.6.</span> <span class="toc-text">函数说明符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%BA%93"><span class="toc-number">16.7.</span> <span class="toc-text">C 库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">17.</span> <span class="toc-text">高级数据表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">17.1.</span> <span class="toc-text">研究数据表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E7%BB%84%E5%88%B0%E9%93%BE%E8%A1%A8"><span class="toc-number">17.2.</span> <span class="toc-text">从数组到链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-ADT"><span class="toc-number">17.3.</span> <span class="toc-text">抽象数据类型(ADT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97-ADT"><span class="toc-number">17.4.</span> <span class="toc-text">队列 ADT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F"><span class="toc-number">17.5.</span> <span class="toc-text">用队列进行模拟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">17.6.</span> <span class="toc-text">链表和数组与查找方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">17.7.</span> <span class="toc-text">二叉查找树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">18.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">18.1.</span> <span class="toc-text">C 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ANSI-C-%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%8F%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">18.2.</span> <span class="toc-text">ANSI C 库函数、宏和类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8Binttypes-h"><span class="toc-number">18.3.</span> <span class="toc-text">拓展整数类型inttypes.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E5%AD%97%E7%AC%A6%E6%94%AF%E6%8C%81"><span class="toc-number">18.4.</span> <span class="toc-text">拓展字符支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BA%95%E8%AF%84%E8%AE%BA"><span class="toc-number">19.</span> <span class="toc-text">页底评论</span></a></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/01Trie/" style="font-size: 12px; color: #ffc299">01Trie</a> <a href="/tags/AVL%E6%A0%91/" style="font-size: 12px; color: #ffc299">AVL树</a> <a href="/tags/BFS/" style="font-size: 21px; color: #ffa466">BFS</a> <a href="/tags/Bellman-Ford/" style="font-size: 12px; color: #ffc299">Bellman-Ford</a> <a href="/tags/C/" style="font-size: 30px; color: #ff8533">C++</a> <a href="/tags/Cmake/" style="font-size: 16.5px; color: #ffb380">Cmake</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 25.5px; color: #ff944d">C语言</a> <a href="/tags/DFS/" style="font-size: 21px; color: #ffa466">DFS</a> <a href="/tags/DP/" style="font-size: 12px; color: #ffc299">DP</a> <a href="/tags/Dijkstra/" style="font-size: 12px; color: #ffc299">Dijkstra</a> <a href="/tags/Fleury/" style="font-size: 12px; color: #ffc299">Fleury</a> <a href="/tags/Floyd/" style="font-size: 12px; color: #ffc299">Floyd</a> <a href="/tags/Hexo/" style="font-size: 25.5px; color: #ff944d">Hexo</a> <a href="/tags/Hexo%E5%8D%9A%E5%AE%A2/" style="font-size: 12px; color: #ffc299">Hexo博客</a> <a href="/tags/Hierholzer/" style="font-size: 12px; color: #ffc299">Hierholzer</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:	#ff8533;"><link itemprop="mainEntityOfPage" href="https://blog.muyun.space/posts/7e973705/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="山暮云秋"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="山暮云秋 | Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C语言基础教程<a class="post-edit-link" href="https://github.com/ShanMuYunQiu/MuYun_Blog/tree/hexo/source/_posts/编程语言/C语言基础教程.md" target="_blank" title="编辑" rel="noopener"><span class="icon iconify" data-icon="ri:edit-line"></span></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <span class="post-meta-icon-text">发表于</span> <time title="创建时间：2022-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-09T00:00:00+08:00">2022-05-09</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <span class="post-meta-icon-text">更新于</span> <time title="修改时间：2022-12-20 00:00:00" itemprop="dateModified" datetime="2022-12-20T00:00:00+08:00">2022-12-20</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="本文字数">123.3k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="阅读时长">481m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><span class="icon iconify" data-icon="ri:eye-line"></span> <span id="busuanzi_value_page_pv"></span></span></span><span class="post-meta-divider">-</span><a href="#comment"><span class="post-meta-item-icon" title="评论数"><span class="icon iconify" data-icon="ri:chat-3-line"></span> <span class="waline-comment-count" id="/posts/7e973705/"></span></span></a><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="--text-color:#ff944d" itemprop="url" rel="index"><span itemprop="text">编程语言</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/C%E8%AF%AD%E8%A8%80/" style="--text-color:#6699ff"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">C语言</span></a><a class="tag-item" href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" style="--text-color:#cc33ff"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">基础语法</span></a></span></div><div class="post-author"><span class="author-name">山暮云秋</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><hr>
<h3 id="初识-C-语言"><a href="#初识-C-语言" class="headerlink" title="初识 C 语言"></a><strong>初识 C 语言</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：C 语言的特点；计算机工作原理；高级计算机语言；编译器；编程步骤；C 编程机制</p>
</blockquote>
</div>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><p><strong>设计特性</strong>：</p>
<blockquote>
<p>C 语言融合了<strong>计算机科学理论</strong>和<strong>实践的控制特性</strong><br>C 语言的设计理念让用户轻松完成<strong>自顶向下的规划</strong>、<strong>结构化编程</strong>和<strong>模块化设计</strong></p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p><strong>高效性</strong>：</p>
<blockquote>
<p>C 语言充分利用计算机的优势，因此<strong>程序更紧凑</strong>，<strong>运行速度很快</strong><br>C 语言具有通常汇编语言才具有的微调控制能力，可以更具具体情况<strong>微调程序</strong>以获得<strong>最大运行速度</strong>或<strong>最有效地使用内存</strong></p>
</blockquote>
</li>
<li><p><strong>可移植性</strong>：</p>
<blockquote>
<p>C 是可移植的语言，这意味着，在一种系统中编写的 C 程序<strong>稍作修改</strong>或<strong>不修改</strong>就能在其他系统上运行<br>注意程序中针对<strong>特殊硬件设备</strong>(如显示监视器)或<strong>操作系统特殊功能</strong>编写的部分<strong>通常不可移植</strong><br>C 语言与 UNIX 关系密切，<strong>UNIX 系统</strong>通常会将 C 编译器作为<strong>软件包</strong>的一部分<br>供个人计算机使用的 C 编译器很多，因此在<strong>各个版本的操作系统</strong>上，都可以找到合适的 C 编译器</p>
</blockquote>
</li>
<li><p><strong>强大而灵活</strong>：</p>
<blockquote>
<p>C 语言功能<strong>强大而灵活</strong><br>UNIX 操作系统、其他语言(FORTRAN、Perl、Python、Pascal)等的<strong>编译器</strong>和<strong>解释器</strong>都是<strong>用 C 语言编写</strong>的</p>
</blockquote>
</li>
<li><p><strong>面向程序员</strong>：</p>
<blockquote>
<p>C 语言是为了满足程序员的需求而设计的，程序员可以利用 C <strong>访问硬件</strong>、<strong>操控内存中的位</strong><br>大多数 C 实现都有一个<strong>大型的库</strong>，包含众多有用的 <strong>C 函数</strong>，可以让程序员更加方便地使用 C 语言</p>
</blockquote>
</li>
</ul>
<h4 id="通俗了解计算机工作原理"><a href="#通俗了解计算机工作原理" class="headerlink" title="通俗了解计算机工作原理"></a><strong>通俗了解计算机工作原理</strong></h4><ul>
<li>简而言之，计算机的<strong>工作原理</strong>是：如果希望计算机做某些事，就必须为其提供<strong>特殊的指令列表</strong>(<strong>程序</strong>)，确切地告诉计算机要做的事以及如何做。你必须用<strong>计算机能直接明白的语言</strong>(<strong>机器语言</strong>)创建程序。这是一项繁杂、乏味、费力的任务</li>
</ul>
<h4 id="高级计算机语言与编译器"><a href="#高级计算机语言与编译器" class="headerlink" title="高级计算机语言与编译器"></a><strong>高级计算机语言与编译器</strong></h4><ul>
<li><strong>高级编程语言</strong>(如 C 语言)以多种方式<strong>简化了编程工作</strong>。首先，不必用数字码表示指令；其次，使用的指令更贴近你如何想这个问题，而不是类似计算机那样繁琐的步骤</li>
<li><strong>编译器</strong>是把<strong>高级语言</strong>程序<strong>翻译</strong>成计算机能理解的<strong>机器语言</strong>指令集的程序，在计算机看来，高级语言指令就是一堆无法理解的无用数据。由此，程序员进行高级思维活动，而编译器则负责处理冗长乏味的细节工作</li>
</ul>
<h4 id="使用-C-语言的-7-个步骤"><a href="#使用-C-语言的-7-个步骤" class="headerlink" title="使用 C 语言的 7 个步骤"></a><strong>使用 C 语言的 7 个步骤</strong></h4><ul>
<li><p>C 是<strong>编译型语言</strong>，我们把编写 C 语言的程序分解为七个步骤：</p>
<blockquote>
<p>1、定义程序的目标<br>2、设计程序<br>3、编写代码<br>4、编译<br>5、运行程序<br>6、测试与调试程序<br>7、维护和修改代码</p>
</blockquote>
</li>
</ul>
<h4 id="编程机制"><a href="#编程机制" class="headerlink" title="编程机制"></a><strong>编程机制</strong></h4><ul>
<li>用 C 语言编写程序时，编写的内容被储存在文本文件中，该文件被称为<strong>源代码文件</strong>(<strong>source code file</strong>)。大部分 C 系统，都要求文件名以<code>.c</code>结尾</li>
<li>C 编程的<strong>基本策略</strong>是，用程序把<strong>源代码</strong>文件<strong>转换</strong>成<strong>可执行文件</strong>(其中包含可直接运行的机器语言代码)<br>典型的 C 实现通过<strong>编译</strong>和<strong>链接</strong>两个步骤来完成这一过程。<strong>编译器</strong>把源代码转换成<strong>中间代码</strong>，<strong>连接器</strong>把中间代码和其他代码<strong>合并</strong>，生成可执行文件<br><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E7%BC%96%E8%AF%91.png" loading="lazy"></li>
</ul>
<hr>
<h3 id="C-语言概述"><a href="#C-语言概述" class="headerlink" title="C 语言概述"></a><strong>C 语言概述</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：C 语言程序简单示例；<code>#include</code>与头文件；主函数<code>main</code>；注释；花括号；声明与变量；赋值；<code>printf</code>函数；<code>return</code>语句；C 语言程序基础结构；多条声明；打印多个值；多个函数；关键字和保留标识符</p>
</blockquote>
</div>

<h4 id="简单的-C-程序示例及分析"><a href="#简单的-C-程序示例及分析" class="headerlink" title="简单的 C 程序示例及分析"></a><strong>简单的 C 程序示例及分析</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                <span class="token comment">//一个简单的C程序</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>                  <span class="token comment">//定义一个名为num的变量</span>
    num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                  <span class="token comment">//为num赋一个值</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am a simple "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用printf函数</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"computer.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my favourite number is %d because it is first.\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>程序分析及知识概要</strong></p>
<ul>
<li><p><code>#include</code>指令和<strong>头文件</strong></p>
<blockquote>
<p>1、<code>#include &lt;stdio.h&gt;</code>在程序的<strong>第一行</strong>，该语句作用相当于把<code>stdio.h</code><strong>文件</strong>中的<strong>所有内容</strong>都<strong>输入该行所在位置</strong>，本质上是一种“<strong>拷贝-粘贴</strong>”的操作。<code>include</code>文件提供了一种方便的途径共享许多程序共有的信息<br>2、<code>#include</code>这行代码是一条 C<strong>预处理器命令</strong>，通常，C 编译器在编译前会对源码做一些<strong>准备工作</strong>，即<strong>预处理</strong><br>3、所有的 C 编译器软件都提供<code>stdio.h</code>头文件，该文件包含供编译器使用的<strong>IO 函数</strong>(<strong>I:input 输入，O:output 输出</strong>)。该文件名含义为<strong>标准输入&#x2F;输出头文件</strong>。通常，C 程序顶部的信息集合被称为<strong>头文件</strong></p>
</blockquote>
</li>
<li><p><code>main()</code>函数</p>
<blockquote>
<p>1、<code>main()</code>函数是程序的<strong>主函数</strong>，它是程序的入口点，<strong>从这里开始执行</strong><br>2、<code>int main()</code>中<code>int</code>是函数的<strong>返回类型</strong>，表明函数<strong>返回操作系统</strong>的是<strong>整数</strong>，此处将在后续探讨<br>3、如果浏览旧式的 C 代码，会发现程序如<code>main()</code>开始，C90 标准勉强接受这种形式，但 C99 和 C11 标准不允许，因此不要这样写<br>4、你还会看到<code>void main()</code>的形式，部分编译器允许这样写，但所有标准都未认可，因此也不要这样写</p>
</blockquote>
</li>
<li><p><strong>注释</strong></p>
<blockquote>
<p>1、注释是一种<strong>记录程序信息</strong>的方式，<strong>被注释的部分不会被程序运行</strong><br>2、可以使用<code>/*注释内容*/</code>进行注释，此类注释可以换行注释，直到<code>*/</code>为止<br>3、也可以使用<code>//</code>进行注释(C99 新加入)，此类注释不能换行，直到行尾为止</p>
</blockquote>
</li>
<li><p><strong>花括号</strong></p>
<blockquote>
<p>1、程序中花括号<code>&#123;&#125;</code>把<code>main()</code>括起来，一般而言，所有的<strong>C 函数</strong>都<strong>使用花括号标记</strong>函数体的<strong>开始和结束</strong><br>2、花括号还可用于把函数中<strong>多条语句</strong>合并为一个<strong>单元</strong>和<strong>块</strong></p>
</blockquote>
</li>
<li><p><strong>声明与变量</strong></p>
<blockquote>
<p>1、<code>int num;</code>这行代码叫做<strong>声明</strong>，声明是 C 语言中最重要的特性之一<br>2、该条例中，声明<strong>完成了两件事</strong>。其一，函数中<strong>有一个</strong>名为<code>num</code>的<strong>变量</strong>，其二，<code>int</code>表示<code>num</code>的<strong>数据类型</strong>是一个<strong>整数</strong><br>3、<code>int</code>是 C 语言中的一个<strong>关键字</strong>，表示一种基本的 C 语言<strong>数据类型</strong>。关键字是<strong>语言定义的单词</strong>，不能用做其他用途，例如不可作为函数名或变量名<br>4、<code>num</code>是一个<strong>标识符</strong>，也就是一个<strong>变量、函数或其他实体</strong>的<strong>名称</strong><br>5、把<strong>变量</strong>声明正确的为<strong>数据类型</strong>(整型、浮点型、字符等)，<strong>计算机</strong>才能正确的<strong>存储、读取和解释数据</strong><br>6、变量的<strong>命名</strong>，要尽可能使用<strong>有意义</strong>的变量名或标识符，如程序需要一个变量属羊，则可起名<strong>sheep_count</strong>。变量命名时仅可以使用<strong>大小写字母、数字和下划线</strong>，且第一个字母不能是数字</p>
</blockquote>
</li>
<li><p><strong>赋值</strong></p>
<blockquote>
<p>1、<code>num = 1</code>是<strong>赋值表达式语句</strong>，<strong>赋值</strong>是 C 语言的<strong>基本操作</strong>之一，意为“<strong>把值 1 赋给变量</strong><code>num</code>”<br>2、在执行<code>int num</code>声明时，编译器在计算机<strong>内存</strong>中为变量<code>num</code><strong>预留了空间</strong>，然后执行赋值表达式语句时，把值存储在<strong>预留的位置</strong><br>3、注意，赋值表达式语句<strong>从右侧把值赋给左侧</strong>，另外，该语句以分号<code>;</code>结尾</p>
</blockquote>
</li>
<li><p><code>printf</code>函数</p>
<blockquote>
<p>1、<code>printf</code>是 C 语言的一个<strong>标准函数</strong>，圆括号<code>()</code>表明<code>printf</code>是一个<strong>函数名</strong>，<strong>圆括号中的内容</strong>是从<code>main()</code>函数<strong>传递</strong>给<code>printf</code>函数的信息<br>2、<code>printf</code>函数会查看<strong>双引号中的内容</strong>(<strong>字符串</strong>)，并将其<strong>打印</strong>到屏幕上<br>3、<code>\n</code>的作用是<strong>换行</strong>，<code>\n</code>组合代表一个<strong>换行符</strong>。换行符是一个<strong>转义列表</strong>，用于代表<strong>难以表示</strong>或<strong>无法输入</strong>的字符。如<code>\t</code>代表<strong>Tab 键</strong>，<code>\b</code>代表<strong>Backspace 键</strong>，每个转义序列都以<strong>反斜杠</strong><code>\</code>开始<br>4、对比发现，参数中的<code>%d</code>被数字 1<strong>代替</strong>了，而 1 就是<code>num</code>的值。<code>%d</code>是一个<strong>占位符</strong>，其作用是<strong>指明</strong>输入<code>num</code>的<strong>位置</strong></p>
</blockquote>
</li>
<li><p><code>return</code>语句</p>
<blockquote>
<p>1、<code>int main(void)</code>中的<code>int</code>表明函数<code>main</code>要<strong>返回一个整数</strong>，C 标准<strong>要求</strong><code>main()</code>这样做。<br>2、<strong>有返回值</strong>的 C 函数要有<code>return</code>语句，该语句以<code>return</code>关键字<strong>开始</strong>，后面是<strong>待返回的值</strong>，并以分号<code>;</code><strong>结尾</strong><br>3、如果遗漏<code>main</code>函数末尾的<code>return</code>语句，程序在运行至最外面的<code>&#125;</code>时，会自动<strong>返回</strong>一个<strong>默认值</strong>，<strong>即 0</strong>。因此此处<strong>可以省略</strong>，但在<strong>其他</strong>有返回值的函数中<strong>不可省略</strong>，所以<strong>建议保留</strong>此习惯</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>简单程序的结构</strong></p>
<ul>
<li>程序由<strong>一个或多个函数</strong>组成，<strong>必须有</strong><code>main()</code>函数。</li>
<li>函数由<strong>函数头</strong>和<strong>函数体</strong>组成，函数头包括<strong>函数名</strong>、<strong>传入该函数的信息类型</strong>和<strong>函数的返回值类型</strong></li>
<li>通过<strong>函数名后</strong>的<strong>圆括号</strong>可以识别出函数，圆括号里<strong>可能为空</strong>，<strong>可能有参数</strong></li>
<li><strong>函数体</strong>被<strong>花括号</strong>括起来，由一系列<strong>语句</strong>、<strong>声明</strong>组成</li>
</ul>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%87%BD%E6%95%B0%E7%BB%93%E6%9E%84.png" loading="lazy"></p>
<ul>
<li><p>简言之，一个简单的 C 语言程序格式如下(<strong>大部分语句</strong>都以<strong>分号</strong><code>;</code><strong>结尾</strong>)：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//语句</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="进一步使用-C"><a href="#进一步使用-C" class="headerlink" title="进一步使用 C"></a><strong>进一步使用 C</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//把2英寻转换成英尺</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> feet<span class="token punctuation">,</span> fathoms<span class="token punctuation">;</span>
    fathoms <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    feet <span class="token operator">=</span> <span class="token number">6</span> <span class="token operator">*</span> fathoms<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"There are %d feet in %d fathoms!\n"</span><span class="token punctuation">,</span> feet<span class="token punctuation">,</span> fathoms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Yes,I said %d feet!\n"</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">*</span> fathoms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>程序分析及知识概要</strong></p>
<ul>
<li><p><strong>多条声明</strong></p>
<blockquote>
<p>1、<code>int feet, fathoms;</code>语句，使用<strong>多条声明</strong>声明了<strong>两个变量</strong>，使用<strong>逗号</strong><code>,</code>隔开，此语句与<code>int feet;</code>+<code>int fathoms;</code>等价</p>
</blockquote>
</li>
<li><p><strong>打印多个值</strong></p>
<blockquote>
<p>1、程序的<strong>第一个</strong><code>printf()</code>进行了<strong>两次替换</strong>，<strong>按顺序</strong>将<code>feet</code>、<code>fathoms</code>替换了两个<code>%d</code><br>2、第二个<code>printf()</code>说明待打印的值<strong>不一定是变量</strong>，只要<strong>可求值</strong>得出<strong>合适类型值的项</strong>即可</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="多个函数"><a href="#多个函数" class="headerlink" title="多个函数"></a><strong>多个函数</strong></h4><ul>
<li><p>把<strong>自己的函数</strong>添加到程序中，此处只做简单了解，后续学习：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">void</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">def</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="关键字和保留标识符"><a href="#关键字和保留标识符" class="headerlink" title="关键字和保留标识符"></a><strong>关键字和保留标识符</strong></h4><ul>
<li><p>下表中<strong>粗体</strong> 表示<code>C90</code>标准新增关键字，<em>斜体</em> 表示<code>C99</code>标准新增关键字，<strong>粗斜体</strong> 表示<code>C11</code>标准新增关键字</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">auto</td>
<td align="center">extern</td>
<td align="center">short</td>
<td align="center">while</td>
</tr>
<tr>
<td align="center">break</td>
<td align="center">float</td>
<td align="center"><strong>signed</strong></td>
<td align="center"><strong><em>_Alignas</em></strong></td>
</tr>
<tr>
<td align="center">case</td>
<td align="center">for</td>
<td align="center">sizeof</td>
<td align="center"><strong><em>_Alignof</em></strong></td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">goto</td>
<td align="center">static</td>
<td align="center"><strong><em>_Atomic</em></strong></td>
</tr>
<tr>
<td align="center"><strong>const</strong></td>
<td align="center">if</td>
<td align="center">struct</td>
<td align="center"><strong><em>_Bool</em></strong></td>
</tr>
<tr>
<td align="center">continue</td>
<td align="center"><em>inline</em></td>
<td align="center">switch</td>
<td align="center"><strong><em>_Complex</em></strong></td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">int</td>
<td align="center">typedef</td>
<td align="center"><strong><em>_Generic</em></strong></td>
</tr>
<tr>
<td align="center">do</td>
<td align="center">long</td>
<td align="center">union</td>
<td align="center"><strong><em>_Imaginary</em></strong></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">register</td>
<td align="center">unsigned</td>
<td align="center"><strong><em>_Noreturn</em></strong></td>
</tr>
<tr>
<td align="center">else</td>
<td align="center">restrict</td>
<td align="center"><strong>void</strong></td>
<td align="center"><strong><em>_Static_assert</em></strong></td>
</tr>
<tr>
<td align="center"><strong>enum</strong></td>
<td align="center">return</td>
<td align="center"><strong>volatile</strong></td>
<td align="center"><strong><em>_Thread_local</em></strong></td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="数据和-C"><a href="#数据和-C" class="headerlink" title="数据和 C"></a><strong>数据和 C</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：交互式程序；变量与常量数据；数据；位、字节、字；存储单元换算；数据类型关键字；C 语言基本数据类型；进制打印显示；可移植类型；使用程序获得数据类型大小</p>
</blockquote>
</div>

<h4 id="交互式程序"><a href="#交互式程序" class="headerlink" title="交互式程序"></a><strong>交互式程序</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">float</span> weight<span class="token punctuation">;</span>
    <span class="token keyword">float</span> value<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Please enter your weight in pounds:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
    value <span class="token operator">=</span> <span class="token number">1700.0</span> <span class="token operator">*</span> weight <span class="token operator">*</span> <span class="token number">14.5833</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"your weight in platinum is worth $%.2f.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>新元素简单分析</strong></p>
<blockquote>
<p>1、新的<strong>变量声明</strong>，使用<code>float</code><strong>浮点数</strong>类型，浮点类型可以<strong>储存带小数的数字</strong>，详细说明见本章后面部分<br>2、为了打印<strong>新类型</strong>的变量(<strong>浮点数</strong>)，<code>printf</code>处使用<code>%f</code><strong>处理浮点值</strong>了<br>3、<code>%.2f</code>用于<strong>精确控制输出</strong>，指定<strong>保留小数</strong>后两位<br>4、<code>scanf()</code>函数用于<strong>读取键盘的输入</strong>，<code>%f</code>说明<code>scanf()</code><strong>读取输入浮点数</strong>，<code>&amp;weight</code>告诉<code>scanf()</code>把输入的值<strong>赋给</strong>名为<code>weight</code>的<strong>变量</strong><br>5、<code>scanf()</code>函数使用<code>&amp;</code><strong>符号</strong>表明找到<code>weight</code>变量的地点，下章将详细讨论，目前请按照这样写</p>
</blockquote>
</li>
</ul>
<h4 id="变量与常量数据"><a href="#变量与常量数据" class="headerlink" title="变量与常量数据"></a><strong>变量与常量数据</strong></h4><ul>
<li><strong>变量</strong>：有些<strong>数据类型</strong>在程序运行期间<strong>可能会改变</strong>或<strong>被赋值</strong>，这些称为<strong>变量</strong></li>
<li><strong>常量</strong>：有些<strong>数据类型</strong>在程序使用之前已经<strong>预先设定</strong>好了，整个程序运行过程中<strong>没有变化</strong>，称为<strong>常量</strong></li>
</ul>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a><strong>数据</strong></h4><ul>
<li><p><strong>位、字节、字</strong></p>
<blockquote>
<p><strong>位、字节、字</strong>是描述<strong>计算机数据单元</strong>或<strong>存储单元</strong>的术语，这里主要指<strong>储存单元</strong></p>
<p><strong>位</strong>(<strong>bit</strong>)：<strong>最小的储存单元</strong>。可以储存<strong>0 或 1</strong>，是计算机内存的<strong>基本构成块</strong><br><strong>字节</strong>(<strong>byte</strong>)：<strong>常用的</strong>计算机存储单位，<strong>字节</strong>是<strong>位</strong>的<strong>集合</strong>，一个<strong>字节</strong>可以储存<strong>8 位</strong>。这是字节的<strong>标准定义</strong>，至少在衡量存储单位时是这样<br><strong>字</strong>(<strong>word</strong>)：是<strong>设计计算机时</strong>给定的<strong>自然存储单位</strong>，对于 8 位的微型计算机，一个字长只有 8 位。从那以后，个人计算机字节增至 16 位、32 位，直至目前的 64 位。计算机的<strong>字长越大</strong>，<strong>数据转移越快</strong>，允许的<strong>内存访问也更多</strong></p>
</blockquote>
</li>
<li><p><strong>存储单元换算</strong></p>
<blockquote>
<p>1 TB&#x3D;1024 GB<br>1 GB&#x3D;1024 MB<br>1 MB&#x3D;1024 KB<br>1 KB&#x3D;1024 Bytes(字节)<br>1 Byte(字节)&#x3D;8 bits(位)<br>1 Word(字)&#x3D;2 Bytes(字节)</p>
</blockquote>
</li>
<li><p><strong>整数</strong></p>
<ul>
<li>和数学概念一样，<strong>整数是没有小数部分的数</strong>，例如 2、-23、2456 都是整数</li>
<li>计算机以<strong>二进制数字</strong>存储整数，如整数 <strong>7</strong> 二进制写为 <strong>111</strong>，因此要在<strong>8 位字节</strong>中存储该数字，需要<strong>前 5 位</strong>设置为<strong>0</strong>，<strong>后 3 位</strong>设置为<strong>1</strong></li>
</ul>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E6%95%B4%E6%95%B0.png" loading="lazy"></p>
</li>
<li><p><strong>浮点数</strong></p>
<ul>
<li><strong>带有小数点的数</strong>就是<strong>浮点数</strong>，例如 2.75、3.16E7、7.00、2e-8 都是浮点数</li>
<li>注意，在一个值后面<strong>加上小数点</strong>，该值就成为一个<strong>浮点数</strong>，所以<strong>7 是整数</strong>，<strong>7.00 是浮点数</strong></li>
<li>此处简要介绍 <strong>e&#x2F;E 计数法</strong>(<strong>科学计数法</strong>)：<strong>3.16E7</strong> 或 <strong>3.16e7</strong> 表示 <strong>3.16 * 10<sup>7</sup></strong></li>
<li>这里关键要理解<strong>浮点数</strong>与<strong>整数</strong>的<strong>储存方案不同</strong>，计算机把浮点数分成<strong>小数部分</strong>和<strong>指数部分</strong>表示，而且<strong>分开存储这两部分</strong>。<strong>7.0</strong>写成<strong>0.7E1</strong>，这里，<strong>0.7 是小数部分</strong>，<strong>1 是指数部分</strong>。计算机在内部使用<strong>二进制</strong>和<strong>2 的幂</strong>进行储存，后续探讨(<strong>此处图例以十进制下理解为例</strong>)</li>
</ul>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%B0%8F%E6%95%B0.png" loading="lazy"></p>
</li>
</ul>
<h4 id="数据类型关键字"><a href="#数据类型关键字" class="headerlink" title="数据类型关键字"></a><strong>数据类型关键字</strong></h4><table>
<thead>
<tr>
<th align="center">最初 K&amp;R 给出的关键字</th>
<th align="center">C90 标准添加的关键字</th>
<th align="center">C99 标准添加的关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">signed</td>
<td align="center">_Bool</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">void</td>
<td align="center">_Complex</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center"></td>
<td align="center">_Imaginary</td>
</tr>
<tr>
<td align="center">unsigned</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">char</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">float</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="C-语言基本数据类型"><a href="#C-语言基本数据类型" class="headerlink" title="C 语言基本数据类型"></a><strong>C 语言基本数据类型</strong></h4><ul>
<li><p><code>int</code><strong>类型</strong></p>
<blockquote>
<p>1、C 语言中的<strong>整数类型</strong>可表示<strong>不同的取值范围</strong>和<strong>正负值</strong>，一般情况下使用<code>int</code>能应付绝大多数情况<br>2、<code>int</code>类型是<strong>有符号整型</strong>，即<code>int</code>的值<strong>必须是整数</strong>，可以是正整数、负整数、0<br>3、<code>int</code>类型的<strong>取值范围</strong>因<strong>计算机系统而异</strong>，一般而言，储存一个<code>int</code>要<strong>占用一个机器字长</strong><br>4、早期<strong>16 位</strong>的取值范围为-2<sup>15</sup> ~ 2<sup>15</sup>-1，即<code>-32768 ~ 32767</code>，<strong>ISO C 规定</strong><code>int</code><strong>最小范围</strong>为<code>-32768 ~ 32767</code><br>5、一般来说，系统会用一个<strong>特殊位的值</strong>(<strong>未使用的第 16 位</strong>)表示<strong>有符号整数</strong>的<strong>正负号</strong><br>6、使用<code>%d</code><strong>打印</strong>整数类型，<code>%d</code>称为<strong>转换说明</strong>，他<strong>指定</strong>应该用什么<strong>格式</strong>显示一个值<br>7、<strong>显示不同进制</strong>：使用<code>%d</code>显示十进制，<code>%o</code>显示八进制，<code>%x</code>显示十六进制。<strong>显示前缀</strong>使用<code>%#o</code>、<code>%#x</code>、<code>%#X</code></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dec=%d ; octal=%o ; hex=%x  \n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dec=%#d ; octal=%#o ; hex=%#X"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>其他整数类型</strong></p>
<blockquote>
<p>1、<code>short</code>类型：占用空间可能比<code>int</code>少，有符号类型<br>2、<code>long</code>类型：占用空间可能比<code>int</code>多，有符号类型<br>3、<code>long long</code>类型(<strong>C99 加入</strong>)：占用空间可能比<code>long</code>多，<strong>至少 64 位</strong>，有符号类型<br>4、<code>unsigned</code>类型：<strong>非负整型</strong>，<strong>16 位</strong>取值范围 0 ~ 2<sup>16</sup>-1，即<code>0 ~ 65535</code><br>5、<strong>C90 后</strong>，新增<code>unsigned short</code>、<code>unsigned long</code>；<strong>C99 后</strong>，新增<code>unsigned long long</code><br>6、在任何<strong>有符号类型前</strong>添加关键字<code>signed</code>，可<strong>强调</strong>使用有符号类型的<strong>意图</strong><br>7、空间“<strong>可能</strong>”多与少是因为 C<strong>只规定</strong>了<code>short</code>不能多于<code>int</code>，<code>long</code>不能少于<code>int</code><br>8、现在<strong>个人计算机</strong>常见设置是，<code>long long</code>占<strong>64 位</strong>，<code>long</code>占<strong>32 位</strong>，<code>int</code>占<strong>16 位</strong>或<strong>32 位</strong>，<code>short</code>占<strong>16 位</strong><br>9、打印时，使用<code>%u</code>打印<code>unsigned</code>类型，使用<code>%ld</code>打印<code>long</code>类型，使用<code>%lld</code>打印<code>long long</code>类型，使用<code>%hd</code>打印<code>short</code>类型</p>
</blockquote>
</li>
<li><p><strong>浮点数类型</strong></p>
<blockquote>
<p>1、<strong>浮点类型</strong>能表示<strong>包括小数</strong>在内更大范围的数，浮点数的表示类似<strong>科学计数法</strong>。在计算机中，科学计数法中的 10 的<strong>指数</strong>，跟写在字母<code>e</code>后面，如 1.02 * 10<sup>3</sup>记作<code>1.02e3</code><br>2、<strong>单精度浮点数</strong><code>float</code>，C 语言规定其至少能表示<strong>6 位有效数字</strong>，且取值范围至少是 10<sup>-37</sup> ~ 10<sup>37</sup>。通常，系统储存一个浮点数要<strong>占用 32 位</strong>，<strong>其中 8 位</strong>用于表示<strong>指数的值和符号</strong>，<strong>剩下 24 位</strong>用于表示<strong>非指数部分及其符号</strong><br>3、<strong>双精度浮点数</strong><code>double</code>，其与<code>float</code>类型的<strong>最小取值范围相同</strong>，但必须至少能表示<strong>10 位有效数字</strong>，一般来说，<code>double</code><strong>占用 64 位</strong>而非 32 位。一些系统将多出来的 32 位<strong>全用来</strong>表示<strong>非指数部分</strong>，不仅增加<strong>有效数字位数</strong>(<strong>即精度</strong>)，还减少了<strong>舍入误差</strong>；另一些系统把<strong>其中一些位</strong>分配给<strong>指数部分</strong>，以容纳<strong>更大的指数</strong>，增加<strong>可表示数的范围</strong>。无论哪种类型，<code>double</code>类型的值<strong>至少有 13 位有效数字</strong><br>4、<code>long double</code>，可以满足比<code>double</code>更高的精度要求，不过，C 只保证<code>long double</code>类型至少与<code>double</code>类型的<strong>精度相同</strong><br>5、浮点数后面加上<code>f</code><strong>或</strong><code>F</code><strong>后缀</strong>可<strong>覆盖默认设置</strong>，编译器会将<strong>浮点型常量</strong>看做<code>float</code>类型，如<strong>2.3f</strong>，<strong>9.11E9F</strong>；使用<code>l</code><strong>或</strong><code>L</code><strong>后缀</strong>使数字成为<code>long double</code>类型；没有后缀的浮点型常量是<code>double</code>类型<br>6、<strong>打印浮点值</strong>时，使用<code>%f</code>打印<code>float</code>类型，用<code>%e</code>打印<strong>指数计数法</strong>的浮点值，如果系统支持十六进制的浮点数，使用<code>%a</code>打印<strong>十六进制</strong>的浮点值，打印<code>double</code>或<code>long double</code>要使用<code>%Lf</code>、<code>%Le</code>和<code>%La</code>的转换说明</p>
</blockquote>
</li>
<li><p><code>char</code><strong>字符类型</strong></p>
<blockquote>
<p>1、<code>char</code>类型用来<strong>储存字符</strong>，如<strong>字母</strong>或<strong>标点符号</strong><br>2、从技术层面来看，<code>char</code>是<strong>整数类型</strong>，因为<code>char</code>类型<strong>实际储存</strong>的是<strong>整数</strong>而不是字符。计算机使用<strong>数字编码</strong>来<strong>处理字符</strong>，即用特定<strong>整数</strong>代表特定<strong>字符</strong><br>3、C 常用编码为<strong>ASCII</strong>编码，其中如<strong>整数 65</strong>代表<strong>大写字母 A</strong>，<strong>整数 97</strong>代表<strong>小写字母 a</strong>，<strong>整数 48</strong>代表<strong>数字 0</strong><br>4、标准<strong>ASCII 码</strong>范围为<strong>0~127</strong>，只需 7 位二进制数即可表示。通常，<code>char</code>被定义为<strong>8 位的存储单元</strong><br>5、C 语言把<strong>1 字节</strong>定义为<code>char</code>类型占用的<strong>位</strong>(<strong>bit</strong>)<strong>数</strong><br>6、<code>char</code>赋值时，需要传入<strong>char 字符类型</strong>的数据，即<strong>单引号</strong><code>&#39;&#39;</code>包裹的字符，如<code>char set = &#39;A&#39;</code>。此外也可使用<strong>ASCII 码</strong>进行赋值，如<code>char set = 65</code><br>7、有一些<strong>代表行为</strong>的<strong>非打印字符</strong>，如换行、退格、回车、蜂鸣等，这些字符<strong>打印不出来</strong>。如需要表示这些字符，可以使用<strong>ASCII 码</strong>，比如蜂鸣：<code>char beep = 7</code>。此外也可以使用<strong>转义字符</strong>，如<code>char beep = &#39;\a&#39;</code><br>8、使用<code>%c</code><strong>打印</strong><code>char</code>类型字符，如果使用<code>%d</code><strong>打印</strong>，则会打印<strong>字符对应 ACSII 码的整数</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">转义序列</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\a</td>
<td>警报(ANSI C)</td>
</tr>
<tr>
<td align="center">\b</td>
<td>退格</td>
</tr>
<tr>
<td align="center">\f</td>
<td>换页</td>
</tr>
<tr>
<td align="center">\n</td>
<td>换行</td>
</tr>
<tr>
<td align="center">\r</td>
<td>回车</td>
</tr>
<tr>
<td align="center">\t</td>
<td>水平制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td align="center">\\</td>
<td>反斜杠()</td>
</tr>
<tr>
<td align="center">\‘</td>
<td>单引号(‘)</td>
</tr>
<tr>
<td align="center">\0oo</td>
<td>八进制值(<code>oo</code>必须是有效的八进制数，即每个<code>o</code>可表示<code>0~7</code>中的一个数)</td>
</tr>
<tr>
<td align="center">\xhh</td>
<td>十六进制值(<code>hh</code>必须是有效的十六进制数，即每个<code>h</code>可表示<code>0~f</code>中的一个数)</td>
</tr>
</tbody></table>
</li>
<li><p><code>_Bool</code><strong>布尔类型</strong></p>
<blockquote>
<p>1、<strong>C99</strong>标准新增了<code>_Bool</code>类型，用于表示<strong>布尔值</strong>，即逻辑值<strong>true</strong>和<strong>false</strong><br>2、因为 C 语言用<strong>值 1</strong>表示<strong>true</strong>，<strong>值 0</strong>表示<strong>false</strong>，所以<code>_Bool</code>类型实质上也是一种<strong>整数类型</strong><br>3、原则上它仅占用<strong>1 位存储空间</strong>，因为对与<strong>0 和 1</strong>而言，一位的存储空间足够了</p>
</blockquote>
</li>
<li><p><strong>可移植类型：</strong><code>stdint.h</code><strong>和</strong><code>inttypes.h</code></p>
<blockquote>
<p>1、<strong>C99</strong>新增两个<strong>头文件</strong><code>stdint.h</code>和<code>inttypes.h</code>，以确保 C 语言<strong>各类型</strong>在<strong>各系统</strong>中<strong>功能正常</strong><br>2、C 语言为<strong>现有类型</strong>创建了<strong>更多类型名</strong>，这些新类型名<strong>被定义在</strong><code>stdint.h</code>中<br>3、如在<strong>精确宽度整数类型中</strong>，<code>int32_t</code><strong>表示 32 位的有符号整数类型</strong>。在使用<strong>32 位系统</strong>时，头文件会把<code>int32_t</code>当做<code>int</code>的<strong>别名</strong>；而在<code>int</code>为<strong>16 位</strong>，<code>long</code>为<strong>32 位</strong>的系统中，系统会把<code>int32_t</code>当做<code>long</code>的别名。然后，使用<code>int32_t</code>类型<strong>编写程序并包含</strong><code>stdint.h</code><strong>头文件</strong>时，<strong>编译器</strong>会把<code>int</code>或<code>long</code><strong>替换</strong>成与<strong>当前系统匹配</strong>的类型<br>4、如果系统<strong>不支持精确宽度整数类型</strong>，可以使用<strong>最小宽度类型</strong>，例如<code>int_least8_t</code>是<strong>可容纳 8 位有符号整数值</strong>的类型中<strong>宽度最小</strong>的类型的一个<strong>别名</strong><br>5、如果更关心<strong>速度</strong>而非空间，则可使用<strong>最快最小宽度类型</strong>，如<code>int_fast8_t</code>被定义为<strong>系统中</strong>对<strong>8 位有符号值</strong>而言<strong>运算最快的整数类型</strong><br>6、如果需要<strong>最大整数类型</strong>，最大的有符号整数类型<code>intmax_t</code><strong>可储存任何有效的有符号整数值</strong>。类似的，<code>uintmax_t</code>表示最大的无符号整数类型，这种类型可能比<code>long long</code>和<code>unsigned long long</code><strong>更大</strong><br>7、C 标准针对这种<strong>输入和输出</strong>，提供了一些<strong>字符串宏</strong>来显示可移植类型，例如<code>inttypes.h</code>中定义了<code>PRId32</code><strong>字符串宏</strong>，代表打印<strong>32 位有符号值</strong>的<strong>合适转换说明</strong>(<strong>如 d 或 l</strong>)</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;inttypes.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token class-name">int32_t</span> me32<span class="token punctuation">;</span>
    me32 <span class="token operator">=</span> <span class="token number">45933945</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"me32 = %"</span> PRId32 <span class="token string">"\n"</span><span class="token punctuation">,</span> me32<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>复数和虚数</strong></p>
<blockquote>
<p>1、许多<strong>科学</strong>和<strong>工程计算</strong>都要用到<strong>复数和虚数</strong>，<strong>C99</strong>支持复数和虚数，但是<strong>有所保留</strong><br>2、<strong>复数类型</strong>：有<code>float_Complex</code>、<code>double_Complex</code>和<code>long double_Complex</code>。例如<code>float_Complex</code>变量应包含<strong>两个</strong><code>float</code><strong>类型的值</strong>，分别表示复数的<strong>实部和虚部</strong><br>3、<strong>虚数类型</strong>：有<code>float_Imaginary</code>、<code>double_Imaginary</code>和<code>long double_Imaginary</code><br>4、如果包含<code>complex.h</code>头文件，便可用<code>complex</code>代替<code>_Complex</code>，用<code>imaginary</code>代替<code>_Imaginary</code>，还可以用 1 代替-1 的平方根</p>
</blockquote>
</li>
<li><p><strong>其他类型</strong></p>
<blockquote>
<p>1、C 语言中<strong>没有字符串类型</strong>，却也能很好的处理字符串，详见后续<br>2、C 语言还有一些<strong>基本类型衍生</strong>的其他类型，如数组、指针、结构、联合，详见后续<br>3、本章程序案例简单使用到了<strong>指针</strong>，如<code>scanf()</code>函数用到的<code>&amp;</code>前缀，便创建了一个指针，告诉<code>scanf()</code>把数据放在何处</p>
</blockquote>
</li>
</ul>
<h4 id="获取类型大小"><a href="#获取类型大小" class="headerlink" title="获取类型大小"></a><strong>获取类型大小</strong></h4><ul>
<li><p>可以使用<code>sizeof()</code>获取以<strong>字节</strong>为单位的<strong>类型大小</strong>，<strong>C99</strong>和<strong>C11</strong>提供<code>%zd</code>匹配<code>sizeof()</code>返回值，其余不支持的编译器可用<code>%u</code>或<code>%lu</code>代替</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Type int has a size of %zd bytes.\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Type char has a size of %zd bytes.\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Type float has a size of %zd bytes.\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<hr>
<h3 id="字符串和格式化输入输出"><a href="#字符串和格式化输入输出" class="headerlink" title="字符串和格式化输入输出"></a><strong>字符串和格式化输入输出</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：字符串简介；char 类型数组与 null 字符；<code>strlen()</code>函数；常量与 C 预处理器；明示常量；<code>printf()</code>函数；参数传递；<code>scanf()</code>函数；<code>scanf</code>多个输入与返回值</p>
</blockquote>
</div>

<h4 id="引入示例"><a href="#引入示例" class="headerlink" title="引入示例"></a><strong>引入示例</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DENSITY</span> <span class="token expression"><span class="token number">62.4</span> </span><span class="token comment">// 定义人体密度</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">float</span> weight<span class="token punctuation">,</span> volume<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">,</span> letters<span class="token punctuation">;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hi! What's your first name?\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s,whats's your weight in pounds?\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    letters <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    volume <span class="token operator">=</span> weight <span class="token operator">/</span> DENSITY<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"well, %s, your volume is %2.2f cubic feet\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> volume<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Also, your first name has %d letters,\n"</span><span class="token punctuation">,</span> letters<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"and we have %d bytes to store it.\n"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>新元素简单分析</strong></p>
<ul>
<li>用<strong>数组</strong>储存<strong>字符串</strong>。在该程序中，用户<strong>输入的名</strong>被储存在<strong>数组</strong>中，该数组占用内存中<strong>40 个连续的字节</strong>，每个字节储存一个字符值</li>
<li>使用<code>%s</code><strong>转换说明</strong>来<strong>处理字符串</strong>的输入和输出。注意，在<code>scanf</code>中，<code>name</code><strong>没有</strong><code>&amp;</code><strong>前缀</strong>，而<code>weight</code>有(稍后解释，<code>&amp;weight</code>和<code>name</code>都是<strong>地址</strong>)</li>
<li>用 C<strong>预处理器</strong>把<strong>字符常量</strong><code>DENSITY</code>定义为 62.4</li>
<li>用 C 函数<code>strlen()</code>获取字符串的长度</li>
</ul>
</li>
</ul>
<h4 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a><strong>字符串简介</strong></h4><blockquote>
<p>1、<strong>字符串</strong>是<strong>一个或多个字符</strong>的<strong>序列</strong>，如<code>&quot;I came from America&quot;</code><br>2、<strong>双引号</strong><code>&quot;</code>不是字符串的一部分，仅是<strong>告知编译器</strong>它<strong>括起来的是字符串</strong>，就如<strong>单引号</strong><code>&#39;</code>用于标识单个字符一样</p>
</blockquote>
<h4 id="char-类型数组与-null-字符"><a href="#char-类型数组与-null-字符" class="headerlink" title="char 类型数组与 null 字符"></a><strong>char 类型数组与 null 字符</strong></h4><blockquote>
<p>1、C 语言<strong>没有</strong>专门用于<strong>存储字符串</strong>的变量类型，字符都被储存在<code>char</code><strong>类型数组</strong>中。<strong>数组</strong>由<strong>连续的存储单元</strong>组成，字符串的<strong>字符</strong>被储存在<strong>相邻的存储单元</strong>中，每个单元储存一个字符<br>2、数组<strong>末尾位置</strong>有一个<strong>空字符</strong>(<strong>\0</strong>)，C 语言用<strong>空字符</strong>(<strong>null</strong>)标记<strong>字符串结束</strong>。这意味着<strong>数组容量</strong>必须<strong>比存储字符数多 1</strong><br>3、<strong>数组</strong>是<strong>同类型数据元素</strong>的<strong>有序序列</strong>，<strong>方括号</strong><code>[]</code>表示这是一个数组<br>4、使用<code>%s</code>来转换<strong>打印</strong>一个<strong>字符串</strong><br>5、<strong>字符串</strong>与<strong>字符</strong><code>char</code>不是同一种类型，因为<strong>字符串</strong>最后有<strong>空字符标识</strong>，而<code>char</code><strong>只存储该字符</strong><br>6、使用<code>strlen()</code>函数可以得到<strong>字符串的字符长度</strong>，且<code>strlen()</code>并<strong>不会计入空字符</strong></p>
</blockquote>
<h4 id="常量与-C-预处理器"><a href="#常量与-C-预处理器" class="headerlink" title="常量与 C 预处理器"></a><strong>常量与 C 预处理器</strong></h4><ul>
<li><p><strong>为什么要使用常量</strong></p>
<blockquote>
<p>1、使用常量名比数字<strong>表达的信息更多</strong>，如<code>area = PI * d</code>与<code>area = 3.14 * d</code>相比<strong>更加直观</strong><br>2、对于程序中<strong>多次使用同一个常量时</strong>，如果常量的值需要<strong>修改</strong>，<strong>只需要修改常量值</strong>即可</p>
</blockquote>
</li>
<li><p><strong>如何创建符号常量</strong></p>
<ul>
<li>可以<strong>定义变量</strong>，将<strong>其值</strong>定义为<strong>所需的值</strong>，但这样程序可能会<strong>无意间改变它的值</strong></li>
<li>使用<strong>C 预处理器</strong>定义，格式为<code>#define 常量名 值</code>，<strong>编译程序时</strong>，所有的<strong>常量名</strong>都会<strong>被替换</strong>为它们的值<ul>
<li>定义常量时，<strong>习惯上</strong>建议<strong>全用大写</strong>，以此<strong>告知他人</strong>这是一个常量，提高程序可读性；此外也有<strong>小众习惯</strong>使用<code>c_变量名</code>或<code>k_变量名</code>表示常量</li>
<li><strong>注意</strong>：<code>define</code>常量名后的内容用于替换符号常量，不要将<code>#define NUM 20</code>写成<code>#define NUM = 20</code>，这样定义的<strong>WORD</strong>值为<code>=20</code>而非<code>20</code></li>
</ul>
</li>
<li><strong>C90</strong>标准新增限定词<code>const</code>，表示<strong>只读</strong>，也可用此<strong>作为</strong>常量使用(其只表明<strong>只读变量</strong>)，如<code>const float PI=3.14</code></li>
</ul>
</li>
<li><p><strong>明示常量</strong></p>
<ul>
<li><p>C 头文件<code>limits.h</code>与<code>float.h</code>分别提供与<strong>整数与浮点数</strong>类型<strong>大小限制</strong>相关的说明，如<code>limits.h</code>中有类似以下代码：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INT_MAX</span> <span class="token expression"><span class="token operator">+</span><span class="token number">32767</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INT_MIN</span> <span class="token expression"><span class="token operator">-</span><span class="token number">32768</span></span></span></code></pre></li>
<li><p>这些<strong>明示常量</strong>代表<code>int</code>类型可表示的<strong>最大值和最小值</strong>，<strong>该头文件</strong>会为这些明示常量提供<strong>不同的值</strong>，如果系统使用<strong>32 位的 int</strong>且程序包含<code>limits.h</code>头文件，则可以使用<code>printf()</code>与<code>%d</code>转换输出<strong>该常量 32 位 int 的值</strong></p>
</li>
<li><p>如果系统使用<strong>4 字节的 int</strong>，<strong>该头文件</strong>将提供<strong>符合 4 字节的对应值</strong></p>
</li>
<li><p>下为<code>limits.h</code>中的一些明示常量：</p>
<table>
<thead>
<tr>
<th align="center">明示常量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR_BIT</td>
<td>char 类型的位数</td>
</tr>
<tr>
<td align="center">CHAR_MAX</td>
<td>char 类型的最大值</td>
</tr>
<tr>
<td align="center">CHAR_MIN</td>
<td>char 类型的最小值</td>
</tr>
<tr>
<td align="center">SCHAR_MAX</td>
<td>signed char 类型最大值</td>
</tr>
<tr>
<td align="center">SCHAR_MIN</td>
<td>signed char 类型最小值</td>
</tr>
<tr>
<td align="center">UCHAR_MAX</td>
<td>unsigned char 类型的最大值</td>
</tr>
<tr>
<td align="center">SHRT_MAX</td>
<td>short 类型的最大值</td>
</tr>
<tr>
<td align="center">USHRT_MAX</td>
<td>unsigned short 类型的最大值</td>
</tr>
<tr>
<td align="center">INT_MAX</td>
<td>int 类型的最大值</td>
</tr>
<tr>
<td align="center">UINT_MAX</td>
<td>unsigned int 类型的最大值</td>
</tr>
<tr>
<td align="center">LONG_MAX</td>
<td>long 类型的最大值</td>
</tr>
<tr>
<td align="center">ULONG_MAX</td>
<td>unsigned long 类型的最大值</td>
</tr>
<tr>
<td align="center">LLONG_MAX</td>
<td>long long 类型的最大值</td>
</tr>
<tr>
<td align="center">ULLONG_MAX</td>
<td>unsigned long long 类型的最大值</td>
</tr>
</tbody></table>
</li>
<li><p>相似的，<code>float.h</code>头文件下也有一些明示常量：</p>
<table>
<thead>
<tr>
<th align="center">明示常量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FLT_MANT_DIG</td>
<td>float 类型的尾数位数</td>
</tr>
<tr>
<td align="center">FLT_DIG</td>
<td>float 类型的最小有效数字位数(十进制)</td>
</tr>
<tr>
<td align="center">FLT_MIN_10_EXP</td>
<td>带全部有效数字的 float 类型的最小负指数(以 10 为底)</td>
</tr>
<tr>
<td align="center">FLT_MAX_10_EXP</td>
<td>float 类型的最大正指数(以 10 为底)</td>
</tr>
<tr>
<td align="center">FLT_MIN</td>
<td>保留全部精度的 float 类型最小正数</td>
</tr>
<tr>
<td align="center">FLT_MAX</td>
<td>float 类型的最大正数</td>
</tr>
<tr>
<td align="center">FLT_EPSILON</td>
<td>1.00 和比 1.00 大的最小 float 类型值之间的差值</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf()函数"></a><strong>printf()函数</strong></h4><ul>
<li><p>请求<code>printf()</code>打印数据的<strong>指令</strong>要与待打印<strong>数据类型</strong>相匹配。例如，<strong>打印整数</strong>使用<code>%d</code>，<strong>打印字符</strong>使用<code>%c</code>。这些符号称为<strong>转换说明</strong>，它们指定如何把数据转换成<strong>可显示的形式</strong>。</p>
</li>
<li><p><strong>ANSI C</strong>标准为<code>printf()</code>提供的<strong>转换说明</strong></p>
<table>
<thead>
<tr>
<th align="center">转换说明</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%a</td>
<td>浮点数、十六进制数和 p 计数法</td>
</tr>
<tr>
<td align="center">%A</td>
<td>浮点数、十六进制数和 p 计数法</td>
</tr>
<tr>
<td align="center">%c</td>
<td>单个字符</td>
</tr>
<tr>
<td align="center">%d</td>
<td>有符号十进制整数</td>
</tr>
<tr>
<td align="center">%e</td>
<td>浮点数，e 计数法</td>
</tr>
<tr>
<td align="center">%E</td>
<td>浮点数，e 计数法</td>
</tr>
<tr>
<td align="center">%f</td>
<td>浮点数，十进制计数法</td>
</tr>
<tr>
<td align="center">%g</td>
<td>根据值的不同，自动选择%f 或%e。%e 格式用于指数小于-4 或者大于等于精度时</td>
</tr>
<tr>
<td align="center">%G</td>
<td>根据值的不同，自动选择%f 或%E。%E 格式用于指数小于-4 或者大于等于精度时</td>
</tr>
<tr>
<td align="center">%i</td>
<td>有符号十进制整数(与%d 相同)</td>
</tr>
<tr>
<td align="center">%o</td>
<td>无符号八进制整数</td>
</tr>
<tr>
<td align="center">%p</td>
<td>指针</td>
</tr>
<tr>
<td align="center">%s</td>
<td>字符串</td>
</tr>
<tr>
<td align="center">%u</td>
<td>无符号十进制整数</td>
</tr>
<tr>
<td align="center">%x</td>
<td>无符号十六进制整数，使用十六进制数 0f</td>
</tr>
<tr>
<td align="center">%X</td>
<td>无符号十六进制整数，使用十六进制数 0F</td>
</tr>
<tr>
<td align="center">%%</td>
<td>打印一个百分号</td>
</tr>
</tbody></table>
</li>
<li><p><code>prinft()</code>的转换说明<strong>修饰符</strong>，在<code>%</code>与<strong>转换字符</strong>之间插入<strong>修饰符</strong>可修饰基本转换说明</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标记</td>
<td>本表格下一张表格描述了 5 种标记(-、+、空格、#、0)，可以不使用标记或使用多个标记，如<code>%-10d</code></td>
</tr>
<tr>
<td align="center">数字</td>
<td>最小字段宽度，如果该字段不能容纳待打印内容则会使用更宽的字段，如<code>%4d</code></td>
</tr>
<tr>
<td align="center">.数字</td>
<td>精度。对于<code>%e</code>和<code>%f</code>转换，表示小数点右边数字位数 ； 对于<code>%g</code>转换，表示有效数字的最大位数 ； 对于<code>%s</code>转换，表示待打印字符最大数量 ； 对于整型转换，表示待打印数字的最小位数。如有必要，使用前导 0 达到这个位数，只使用<code>.</code>表示其后跟随一个 0，所以<code>%.f</code>与<code>%.0f</code>相同。如<code>%5.2f</code>表示打印一个字段宽度为 5，小数点后有 2 位数字的浮点数</td>
</tr>
<tr>
<td align="center">h</td>
<td>和整型转换说明一起使用，表示 short int 或 unsigned short int 类型的值，如<code>%hu</code>、<code>%hx</code>、<code>%6.4hd</code></td>
</tr>
<tr>
<td align="center">hh</td>
<td>和整型转换说明一起使用，表示 signed char 或 unsigned char 类型的值，如<code>%hhu</code>、<code>%hhx</code>、<code>%6.4hhd</code></td>
</tr>
<tr>
<td align="center">j</td>
<td>和整型转换说明一起使用，表示 intmax_t 或 uintmax_t 的值，这些类型定义在<code>stdint.h</code>中</td>
</tr>
<tr>
<td align="center">l</td>
<td>和整型转换说明一起使用，表示 long int 或 unsigned long int 类型的值</td>
</tr>
<tr>
<td align="center">ll</td>
<td>和整型转换说明一起使用，表示 long long int 或 unsigned long long int 类型的值</td>
</tr>
<tr>
<td align="center">L</td>
<td>和浮点转换说明一起使用，表示 long double 的值</td>
</tr>
<tr>
<td align="center">t</td>
<td>和整型转换说明一起使用，表示 ptrdiff_t 类型的值，ptrdiff_t 是两个指针差值的类型(C99)</td>
</tr>
<tr>
<td align="center">z</td>
<td>和整型转换说明一起使用，表示 size_t 类型的值，size_t 是 sizeof 返回的类型(C99)</td>
</tr>
</tbody></table>
<blockquote>
<p>注：<code>%u</code>标记<strong>不能把数字和符号分开</strong>，会报错!!</p>
</blockquote>
</li>
<li><p><code>printf()</code>中的<strong>标记</strong></p>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td>待打印项左对齐，即从字段左侧开始打印该项，如<code>%-20s</code></td>
</tr>
<tr>
<td align="center">+</td>
<td>有符号值若为正，则在值前面显示加号(正号)，若为负则显示减号(负号)，如<code>%+6.2f</code></td>
</tr>
<tr>
<td align="center">空格</td>
<td>有符号值若为正，则在值前面显示前导空格(不显示任何符号)，若为负则显示减号(负号)覆盖前导空格，如<code>% 6.2f</code></td>
</tr>
<tr>
<td align="center">#</td>
<td>把结果转换成另一种形式。如果是<code>%o</code>格式，则从 0 开始 ； 如果是<code>%x</code>格式，则从 0x 开始 ； 如果是<strong>浮点</strong>格式，<code>#</code>则保证了即使后面没有任何数字也打印一个小数点 ； 如果是<code>%g</code>格式，<code>#</code>防止结果后面的 0 被删除</td>
</tr>
<tr>
<td align="center">0</td>
<td>对于数值格式，使用前导 0 代替空格填充字段宽度 ； 对于整数格式，如果出现-标记或指定精度，则忽略该标记</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h4><ul>
<li><p><strong>参数传递机制</strong>因实现而异，下面以<strong>本机系统</strong>中的<strong>本程序</strong>分析参数传递。该调用告诉计算机把<strong>变量 n1、n2、n3、n4</strong>的值传递给程序，是一种<strong>常见的传参方式</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">float</span> n1 <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> n2 <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> n3 <span class="token operator">=</span> <span class="token number">2000000000</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> n4 <span class="token operator">=</span> <span class="token number">1234567890</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld  %ld  %ld  %ld"</span><span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n3<span class="token punctuation">,</span> n4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、程序把<strong>传入的值</strong>放入被称为<strong>栈</strong>的<strong>内存区域</strong>，计算机根据<strong>变量类型</strong>(<strong>不是转换说明</strong>)把值放入<strong>栈</strong>中。<br>2、因此，<strong>n1</strong>被储存在<strong>栈</strong>中，<strong>占 8 字节</strong>(<strong>float 被转换成 double 类型</strong>)。同样，<strong>n2</strong>在<strong>栈</strong>中也占<strong>8 字节</strong>，而<strong>n3、n4</strong>分别占<strong>4 字节</strong><br>3、然后，控制转到<code>printf()</code>，其根据<strong>转换说明</strong>从<strong>栈</strong>中读取值。<code>%ld</code>转换说明表明<strong>应读取 4 字节</strong>，所以<code>printf()</code>读取<strong>前 4 字节</strong>作为<strong>第 1 个值</strong>。这是<strong>n1 前半部分</strong>，将被解释成<strong>long 类型整数</strong>，根据下一个转换说明，<code>printf()</code><strong>再读取 4 字节</strong>，这是<strong>n1 后半部分</strong>，将被解释为<strong>第 2 个 long 类型整数</strong><br>4、类似的，继续读取<strong>第 3、4 个</strong><code>%ld</code>，读取为<strong>n2 的前、后半部分</strong>，并解释成<strong>两个 long 类型整数</strong><br>5、因此，对于<strong>n3、n4</strong>虽然用对了转换说明，但还是<strong>读错了字节</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BC%A0%E5%8F%82%E8%AF%B4%E6%98%8E.png" loading="lazy"></p>
</li>
</ul>
<h4 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a><strong>scanf()函数</strong></h4><ul>
<li><p><code>scanf()</code>是最通用的<strong>输入函数</strong>，因为它可以读取<strong>不同格式的数据</strong>，其将输入的<strong>字符串</strong>转换成<strong>整数</strong>、<strong>浮点数</strong>、<strong>字符</strong>或<strong>字符串</strong></p>
</li>
<li><p><code>scanf()</code>使用<strong>指向变量的指针</strong>，而<code>printf()</code>使用<strong>变量、常量、表达式</strong></p>
</li>
<li><p><code>scanf()</code>的<strong>多个输入</strong></p>
<blockquote>
<p>1、可以通过<code>scanf(&quot;%d%d&quot;,&amp;n,&amp;m)</code>的格式<strong>输入多个数据</strong><br>2、<code>scanf()</code>函数允许把<strong>普通字符</strong>放在<strong>格式字符串</strong>中，<strong>除空格外</strong>的字符必须与输入字符串<strong>严格匹配</strong><br>3、如<code>scanf(&quot;%d,%d&quot;,&amp;n,&amp;m)</code>，用户必须输入<strong>两个整数</strong>，并以<strong>逗号分隔</strong><br>4、除了<code>%c</code>，其他转换说明都会<strong>自动跳过待输入值前面的所有空白</strong></p>
</blockquote>
</li>
<li><p><code>scanf()</code>的<strong>返回值</strong></p>
<blockquote>
<p><code>scanf()</code>函数返回<strong>成功读取的项数</strong><br>如果<strong>没有成功读取</strong>任何项，且需要读取<strong>一个数字</strong>而用户输入一个<strong>数值字符串</strong>，其便返回<strong>0</strong><br>当<code>scanf()</code>检测到“<strong>文件结尾</strong>”时，会返回<strong>EOF</strong>。这是<code>stdio.h</code>中定义的特殊值，通常会用<code>#define</code>将其定义为-1</p>
</blockquote>
</li>
<li><p><strong>ANSI C</strong>标准为<code>scanf()</code>准备的<strong>转换说明</strong>和转换说明<strong>修饰符</strong></p>
<ul>
<li><code>scanf</code>的<strong>转换说明</strong>与<strong>修饰符</strong>与<code>printf</code>的基本一致，但过程上从<strong>转换输出</strong>变成了<strong>解释输入</strong>，具体使用方法参考<code>printf</code>的表格</li>
</ul>
</li>
</ul>
<hr>
<h3 id="运算符、表达式和语句"><a href="#运算符、表达式和语句" class="headerlink" title="运算符、表达式和语句"></a><strong>运算符、表达式和语句</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：<code>while</code>循环简述；运算符；赋值术语；<code>sizeof</code>运算符和<code>size_t</code>类型；表达式、语句和块；语句术语；类型转换；强制类型转换；带参数的函数；形参实参</p>
</blockquote>
</div>

<h4 id="while-循环简述"><a href="#while-循环简述" class="headerlink" title="while 循环简述"></a><strong>while 循环简述</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ADJUST</span> <span class="token expression"><span class="token number">6.37</span></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">double</span> SCALE <span class="token operator">=</span> <span class="token number">0.333</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> shoe<span class="token punctuation">,</span> foot<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Shoe size (men's)   foot length\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shoe <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>shoe <span class="token operator">&lt;</span> <span class="token number">10.5</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        foot <span class="token operator">=</span> SCALE <span class="token operator">*</span> shoe <span class="token operator">+</span> ADJUST<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%10.1f %15.2f inches\n"</span><span class="token punctuation">,</span> shoe<span class="token punctuation">,</span> foot<span class="token punctuation">)</span><span class="token punctuation">;</span>
        shoe <span class="token operator">=</span> shoe <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"If the shoe fits , wear it.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>while 循环</strong></p>
<blockquote>
<p>1、当<strong>条件语句</strong>为<strong>真</strong>时，执行<strong>循环体</strong>。<strong>圆括号</strong>内为<strong>关系表达式</strong>，<strong>花括号</strong>内为<strong>循环体</strong><br>2、该程序中，程序判断<code>shoe &lt; 18.5</code><strong>是否为真</strong>，执行<strong>循环体</strong>内的代码，到达<strong>花括号</strong>时<strong>再次判断表达式</strong>，为<strong>真</strong>则<strong>继续执行</strong>，当<strong>条件语句</strong>为<strong>假</strong>时，<strong>结束循环</strong></p>
</blockquote>
</li>
</ul>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h4><ul>
<li><p><strong>赋值运算符: &#x3D;</strong></p>
<blockquote>
<p>1、C 语言中，<strong>等号</strong><code>=</code>意为<strong>赋值</strong>而非<strong>相等</strong>。<strong>赋值运算符</strong>将<strong>右侧的值赋给左侧</strong><br>2、当<strong>赋值运算符</strong>连用时，如<code>a=b=c=10</code>，仍按照<strong>从右向左</strong>方式<strong>链式赋值</strong>，即<code>c=10</code>，<code>b=c</code>，<code>a=b</code></p>
</blockquote>
<ul>
<li><p><strong>几个术语：数据对象、左值、右值、项</strong></p>
<blockquote>
<p><strong>数据对象</strong>：赋值表达式语句的目的是把<strong>值</strong>储存到<strong>内存位置</strong>上，用于储存<strong>值</strong>的<strong>数据存储区域</strong>统称为<strong>数据对象</strong><br><strong>左值</strong>：是 C 语言的术语，用于标识<strong>特定数据对象</strong>的<strong>名称</strong>或<strong>表达式</strong>。因此，<strong>对象</strong>指的是<strong>实际的数据储存</strong>，而<strong>左值</strong>是用于<strong>标识</strong>或<strong>定位</strong>储存<strong>位置</strong>的<strong>标签</strong><br><strong>右值</strong>：指的是<strong>赋值</strong>给<strong>可修改左值</strong>的<strong>量</strong>，且<strong>本身不是左值</strong><br><strong>项</strong>：学习名称时，被称为<strong>项</strong>的就是<strong>运算对象</strong>(如，赋值运算符左侧的项)。<strong>运算对象</strong>是<strong>运算符</strong>操作的对象</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>基本算术运算符</strong></p>
<blockquote>
<p>1、<strong>加法运算符</strong><code>+</code>、<strong>减法运算符</strong><code>-</code>、<strong>乘法运算符</strong><code>*</code>、<strong>除法运算符</strong><code>/</code><br>2、<strong>加和减</strong>都被称为<strong>二元运算符</strong><br>3、C 语言中的<strong>除法</strong>，若变量类型为<strong>整数</strong>，则除法的<strong>商</strong>的<strong>小数部分</strong>会<strong>被舍弃</strong></p>
</blockquote>
</li>
<li><p><strong>符号运算符: +和-</strong></p>
<blockquote>
<p>1、<code>+</code><strong>和</strong><code>-</code>还可以做<strong>符号运算符</strong>，用作<strong>正负号</strong><br>2、用作<strong>正负号</strong>时，为<strong>一元运算符</strong></p>
</blockquote>
</li>
<li><p><strong>取模(余)运算符</strong></p>
<blockquote>
<p>1、用于<strong>整数运算</strong>，得到相除的<strong>余数</strong>，如<code>9 % 2 = 1</code><br>2、<strong>负数求模</strong>，<strong>C99</strong>后，若<strong>第一个运算对象</strong>为<strong>负数</strong>，那么取模的结果为<strong>负数</strong>，反之亦然。如<code>11 % -5 = 1</code>，<code>-11 % 5 = -1</code>，<code>-11 % -5 = -1</code></p>
</blockquote>
</li>
<li><p><strong>递增&#x2F;减运算符: ++和--</strong></p>
<blockquote>
<p>1、下文以<code>++</code>为例<br>2、两种形式：<code>++</code>出现在<strong>变量前</strong>，为<strong>前缀模式</strong>；<code>++</code>出现在<strong>变量后</strong>，为<strong>后缀模式</strong><br>3、该<strong>运算符作用</strong>为变量<strong>自加一</strong>，如<code>a++</code>意为<code>a = a + 1</code><br>4、当<strong>单独使用</strong>递增运算符时，使用哪种形式都没关系<br>5、当使用<strong>较为复杂</strong>时，<strong>则会不同</strong>。如<code>q = 2*++a;</code>，意为<strong>a 递增 1，后 2*a，再将结果赋给 q</strong>；而<code>q = 2*a++;</code>，意为<strong>2*a，后将结果赋给 q，再 a 递增 1</strong><br>6、由于<strong>前后缀模式</strong>的以上特性会对代码<strong>产生不同的影响</strong>，因此最好<strong>单独使用</strong>(如需复合使用时，可以先单独自增再使用)</p>
</blockquote>
</li>
<li><p><strong>sizeof 运算符和 size_t 类型</strong></p>
<blockquote>
<p>1、第 3 章已介绍，<code>sizeof</code>运算符用于以<strong>字节</strong>为单位返回<strong>运算对象的大小</strong><br>2、C 语言规定，<code>sizeof</code>返回<code>size_t</code>类型数值，这是一个<strong>无符号整数类型</strong>，其为<strong>语言定义</strong>的<strong>标准类型</strong><br>3、<strong>C99</strong>后使用<code>%zd</code>用于转换显示<code>size_t</code>类型，如不支持可以使用<code>%u</code>或<code>%lu</code>代替</p>
</blockquote>
</li>
</ul>
<h4 id="表达式、语句和块"><a href="#表达式、语句和块" class="headerlink" title="表达式、语句和块"></a><strong>表达式、语句和块</strong></h4><ul>
<li><p><strong>表达式</strong></p>
<blockquote>
<p>1、<strong>表达式</strong>由<strong>运算符</strong>和<strong>运算对象</strong>组成。<strong>最简单的表达式</strong>是<strong>单个运算对象</strong>，以此为基础可以建立<strong>复杂的表达式</strong><br>2、<strong>运算对象</strong>可以是<strong>常量</strong>、<strong>变量</strong>或<strong>二者的组合</strong><br>3、每个表达式<strong>都有一个值</strong>，如<code>q=5*2</code>作为一个整体的<strong>值为 10</strong>；表达式<code>q&gt;3</code>的值为<strong>布尔值</strong>，为<strong>true</strong>或<strong>false</strong>，即值为 1 或 0</p>
</blockquote>
</li>
<li><p><strong>语句</strong></p>
<blockquote>
<p>1、<strong>语句</strong>是 C 程序的<strong>基本构建块</strong>，<strong>一条语句</strong>相当于<strong>一条完整的计算机指令</strong>，C 中大部分语句都以<strong>分号</strong><code>;</code><strong>结尾</strong><br>2、最简单的语句为<strong>空语句</strong>，只有一个分号构成；C 把<strong>末尾加上一个分号</strong>的<strong>表达式</strong>也<strong>看做语句</strong>，因此<code>8;</code>，<code>3+4;</code>这些语句也没问题，只是在程序中<strong>什么都不做</strong></p>
</blockquote>
<ul>
<li><p><strong>副作用、序列点、完整表达式</strong></p>
<blockquote>
<p>1、<strong>副作用</strong>：副作用是对<strong>数据对象</strong>或<strong>文件</strong>的<strong>修改</strong>。例如语句<code>states=50;</code>，其<strong>副作用</strong>为<strong>修改</strong>变量 states 的值为 50。这似乎是<strong>主要目的</strong>，而在<strong>C 语言的角度</strong>看，<strong>主要目的</strong>是<strong>对表达式求值</strong>，如<strong>表达式</strong><code>4+6</code>求值得<code>10</code>，给出<strong>表达式</strong><code>states=50</code>求值得<code>50</code><br>2、<strong>序列点</strong>：是<strong>程序执行</strong>的点，在该点上，<strong>所有的副作用</strong>都在<strong>进入下一步之前</strong>发生。<strong>语句</strong>中的<strong>分号</strong>标记了一个序列点，另外，任何<strong>完整表达式</strong>的结束也是一个序列点<br>3、<strong>完整表达式</strong>：指这个表达式<strong>不是</strong>另一个<strong>更大表达式</strong>的<strong>子表达式</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>复合语句(块)</strong></p>
<blockquote>
<p><strong>复合语句</strong>：是用<strong>花括号</strong>括起来的<strong>一条或多条语句</strong>，<strong>复合语句</strong>也称为<strong>块</strong></p>
</blockquote>
</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a><strong>类型转换</strong></h4><ul>
<li><p>通常，在<strong>语句</strong>和<strong>表达式</strong>中，应使用<strong>类型相同</strong>的变量和常量。但是，如果使用<strong>混合类型</strong>，C 会采用一套规则进行<strong>自动类型转换</strong>，虽然这很便利，但有一定危险性，尤其是在无意间混合使用类型的情况下</p>
</li>
<li><p><strong>基本的类型转换规则</strong></p>
<blockquote>
<p>1、当类型转换出现在<strong>表达式</strong>时，无论是<code>unsigned</code>还是<code>signed</code>的<code>char</code>和<code>short</code>都会被自动转换成<code>int</code>，如有必要会被自动转换成<code>unsigned int</code>(如果<code>short</code>和<code>int</code><strong>大小相同</strong>，<code>unsigned short</code>就比<code>int</code>大，此时<code>unsigned short</code>会被转换成<code>unsigned int</code>)。由于都是<strong>较小类型</strong>转换为<strong>较大类型</strong>，所以这些转换被称为<strong>升级</strong><br>2、涉及<strong>两种类型</strong>的<strong>运算</strong>，两个值会被<strong>分别转换</strong>成两种类型的<strong>更高级别</strong><br>3、类型的<strong>级别从高至低</strong>依次是：<code>long double</code>、<code>double</code>、<code>float</code>、<code>unsigned long long</code>、<code>long long</code>、<code>unsigned long</code>、<code>long</code>、<code>unsigned int</code> 、<code>int</code>。<strong>例外</strong>的情况是，当<code>long</code>和<code>int</code><strong>大小相同时</strong>，<code>unsigned int</code>级别比<code>long</code>的级别高。之所以<code>short</code>和<code>char</code>没有列出，是因为它们已经<strong>被升级</strong>成了<code>int</code>或<code>unsigned int</code><br>4、在<strong>赋值表达式语句</strong>中，计算的<strong>最终结果</strong>会被转换成<strong>被赋值变量</strong>的类型，因此该过程可能导致类型<strong>升级或降级</strong><br>5、当作为<strong>函数参数传递</strong>时，<code>char</code>和<code>short</code>被转换成<code>int</code>，<code>float</code>被转换成<code>double</code>。第九章将介绍，函数原型会覆盖自动升级</p>
</blockquote>
</li>
<li><p><strong>强制类型转换</strong></p>
<ul>
<li>通常，应该避免<strong>自动类型转换</strong>，尤其是<strong>类型降级</strong>，但如果能小心使用，类型转换也很方便</li>
<li>当需要进行<strong>精确的类型转换</strong>，或者在程序中<strong>表明类型转换的意图</strong>，此时要用到<strong>强制类型转换</strong></li>
<li><strong>强制类型转换</strong>:在某个量<strong>前面</strong>放置用<strong>圆括号</strong><code>()</code>括起来的<strong>类型名</strong>，该<strong>类型名</strong>即是希望转换成的<strong>目标类型</strong>。<strong>圆括号</strong>和它括起来的<strong>类型名</strong>构成了<strong>强制类型转换运算符</strong>，其通用形式为<code>(type)</code>，例子为<code>score = (int)1.6 + (int)1.7</code></li>
</ul>
</li>
</ul>
<h4 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a><strong>带参数的函数</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">void</span> <span class="token function">pound</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>           <span class="token comment">// 定义函数</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> times <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token char">'!'</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">6.0</span><span class="token punctuation">;</span>
    <span class="token function">pound</span><span class="token punctuation">(</span>times<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pound</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pound</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>参数-形参、实参</strong></p>
<ul>
<li>首先，看<strong>函数头</strong><code>void pound(int n)</code>，如果函数<strong>不接受任何参数</strong>，那么<strong>圆括号中</strong>应写上<code>void</code>。由于该函数接受一个<code>int</code>类型的<strong>参数</strong>，所以其中包含一个<code>int</code>类型的<strong>变量 n</strong>的声明。参数名应遵循 C 语言的<strong>命名规则</strong></li>
<li>声明参数就创建了被称为<strong>形式参数</strong>的<strong>变量</strong>(简称<strong>形参</strong>)，该例中，形式参数是 int 类型的<strong>变量 n</strong>；像<code>pound(10)</code>这样的<strong>函数调用</strong>会把 <strong>10</strong> 赋给 <strong>n</strong> ，我们称函数调用<strong>传递的值</strong>为<strong>实际参数</strong>(简称<strong>实参</strong>)</li>
<li>函数调用<code>pound(10)</code>把<strong>实参 10</strong>传递给<strong>函数</strong>，函数将 <strong>10</strong> 赋给<strong>形参</strong></li>
<li><strong>变量名</strong>是函数<strong>私有的</strong>，即在<strong>函数中定义</strong>的变量名<strong>不会</strong>和<strong>别处的相同名称</strong>发生冲突</li>
</ul>
</li>
<li><p><strong>函数调用</strong></p>
<ul>
<li>现在，来学习<strong>函数调用</strong>，如第一次调用<code>pound(times)</code>，<strong>times</strong>的值<strong>5</strong>被赋给<strong>n</strong>，因此函数打印了<strong>5 个井号和一个换行符</strong></li>
<li>第二次调用<code>pound(ch)</code>，此时<strong>ch</strong>是<code>char</code>类型变量，被初始化为<code>!</code>，其<strong>ASCII 码</strong>为<strong>33</strong>。由于函数形参类型为<code>int</code>，与<code>char</code>不匹配，所以程序开头的<strong>函数原型</strong>发挥了作用；<strong>原型</strong>即<strong>函数声明</strong>，描述函数<strong>返回值</strong>和<strong>参数</strong>，<code>pound</code>原型说明了两点：<blockquote>
<p>1、函数<strong>没有返回值</strong>(<strong>函数名</strong>前关键字为<code>void</code>)<br>2、函数有一个<code>int</code>类型的<strong>形参</strong></p>
</blockquote>
</li>
<li>函数原型告诉编译器，函数<strong>接受一个</strong><code>int</code>类型的<strong>参数</strong>，当编译器执行到<code>pound(n)</code>时，参数<strong>ch</strong>被自动转换成<code>int</code>类型，于是从<strong>1 字节的 33</strong>变成了<strong>4 字节的 33</strong>。于此类型，第三次调用<code>pound(f)</code>也使得<code>float</code>类型<strong>转换成合适的</strong><code>int</code><strong>类型</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="C-控制语句-循环"><a href="#C-控制语句-循环" class="headerlink" title="C 控制语句:循环"></a><strong>C 控制语句:循环</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：再探<code>while</code>循环；<code>while</code>循环语句；迭代；关系运算符与关系表达式；真(true)与假(false)；<code>bool</code>布尔变量；<code>for</code>循环；<code>for</code>的几种使用示例；复合赋值运算符；出口条件循环<code>do-while</code>；循环嵌套；数组简介；函数返回值的使用</p>
</blockquote>
</div>

<h4 id="再探-while-循环"><a href="#再探-while-循环" class="headerlink" title="再探 while 循环"></a><strong>再探 while 循环</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> num<span class="token punctuation">;</span>
    <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> status<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Please enter an integer to be summed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(q to quit):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    status <span class="token operator">=</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        sum <span class="token operator">=</span> sum <span class="token operator">+</span> num<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Please enter next integer (q to quit):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        status <span class="token operator">=</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Those integer sum to %ld.\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>新元素分析</strong></p>
<ul>
<li><strong>sum</strong>初始值为<code>0L</code>，为<code>long</code>类型的<code>0</code>，而非<code>int</code>类型的<code>0</code></li>
<li><code>==</code>为<strong>相等运算符</strong>，用于判断<strong>前后值是否相等</strong>，不要与<code>=</code><strong>赋值运算符</strong>混淆</li>
<li><code>scanf()</code>函数的<strong>返回值</strong>，返回<strong>成功读取项的数量</strong>，因此此处读取<strong>1 个整数</strong>，则<strong>成功后</strong>返回<strong>1</strong></li>
</ul>
</li>
</ul>
<h4 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a><strong>while 循环语句</strong></h4><ul>
<li><p><strong>while 循环语句格式</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>关系表达式<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    循环体<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>迭代</strong>:在循环的<strong>关系表达式</strong>为<strong>假(0)<strong>之前，循环的</strong>判断和执行</strong>一直<strong>重复进行</strong>，<strong>每一次循环</strong>都被称为一次<strong>迭代</strong></p>
</li>
<li><p><strong>循环条件</strong></p>
<ul>
<li>在<strong>构建循环</strong>时，必须让<strong>测试表达式</strong>的值<strong>有变化</strong>，表达式最终要为<strong>假</strong>(<strong>0</strong>)，否则循环就不会停止</li>
<li>可以使用<code>while(1)</code>来构建简单的<strong>死循环</strong>，之后会将到如何<strong>破除循环</strong></li>
<li>注意<strong>循环终止</strong>的时间，只有<strong>大括号内的语句</strong>会<strong>循环执行</strong>，注意哪些语句需要循环执行，哪些不需要</li>
</ul>
</li>
</ul>
<h4 id="关系运算符与关系表达式"><a href="#关系运算符与关系表达式" class="headerlink" title="关系运算符与关系表达式"></a><strong>关系运算符与关系表达式</strong></h4><ul>
<li><p><strong>关系运算符</strong></p>
<blockquote>
<p><code>==</code>：<strong>相等运算符</strong>，用于判断<strong>前后值是否相等</strong>，不要与<code>=</code><strong>赋值运算符</strong>混淆<br><code>!=</code>：<strong>不等运算符</strong>，用于判断<strong>前后值是否不相等</strong><br><code>&lt;</code>：<strong>小于运算符</strong>，用于判断<strong>前值是否小于后值</strong><br><code>&gt;</code>：<strong>大于运算符</strong>，用于判断<strong>前值是否大于后值</strong><br><code>&lt;=</code>：<strong>小于等于运算符</strong>，用于判断<strong>前值是否小于等于后值</strong><br><code>&gt;=</code>：<strong>大于等于运算符</strong>，用于判断<strong>前值是否大于等于后值</strong></p>
</blockquote>
</li>
<li><p><strong>真(true)与假(false)</strong></p>
<blockquote>
<p>1、<strong>关系表达式</strong>会产生<strong>真(true)<strong>和</strong>假(false)<strong>的值，</strong>真(true)<strong>值通过打印会得到为</strong>1</strong>，<strong>假(false)<strong>值通过打印会得到为</strong>0</strong><br>2、因此<code>while</code>循环<strong>判断</strong>的实际为<strong>表达式的真假值</strong><br>3、而在 C 语言中，一般所有<strong>非 0 的值</strong>都可以被识别为<strong>真(true)<strong>，只有</strong>0</strong>被识别为<strong>假(false)</strong></p>
</blockquote>
</li>
<li><p><strong>_Bool 布尔变量</strong></p>
<blockquote>
<p>1、<strong>C99</strong>新增了<code>_Bool</code><strong>布尔</strong>类型变量，其只能储存<strong>真(true)<strong>和</strong>假(false)<strong>，所有其他非零数值都会被转换为</strong>真(true)</strong><br>2、<code>stdbool.h</code>头文件让<code>bool</code>成为了<code>_Bool</code>的别名，还把<strong>true</strong>和<strong>false</strong>分别定义为<strong>1</strong>和<strong>0</strong>的<strong>符号常量</strong><br>3、且使用该头文件的代码可以与<code>C++</code><strong>兼容</strong>，因为<code>C++</code>把<code>bool</code>、<code>true</code>、<code>false</code>定义为<strong>关键字</strong></p>
</blockquote>
</li>
</ul>
<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><strong>for 循环</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> count <span class="token operator">&lt;=</span> NUMBER<span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Be my Valentine\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>for 循环格式</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>初始化<span class="token punctuation">;</span>测试条件<span class="token punctuation">;</span>执行更新<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    循环体
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、<code>for</code>后面的括号中有<strong>三个表达式</strong>，分别用<strong>两个分号</strong><code>;</code>隔开<br>2、<strong>第 1 个</strong>表达式是<strong>初始化</strong>，只会在<code>for</code><strong>循环开始时</strong>执行<strong>一次</strong><br>3、<strong>第 2 个</strong>表达式是<strong>测试条件</strong>，<strong>测试条件</strong>为<strong>真(true)<strong>时</strong>执行</strong>循环体<strong>，</strong>测试条件<strong>为</strong>假(false)<strong>时</strong>结束<strong>循环</strong><br>4、<strong>第 3 个</strong>表达式是<strong>执行更新</strong>，<strong>每次循环结束时求值</strong></p>
</blockquote>
</li>
<li><p><strong>for 的灵活性</strong></p>
<ul>
<li><p><code>for</code>循环十分灵活，可以利用<strong>三个表达式</strong>完成<strong>几乎所有</strong>需要的<strong>条件判断</strong>，使用<code>for</code>循环能更轻松清楚地完成<strong>遍历</strong></p>
</li>
<li><p><strong>逗号运算符</strong><code>,</code>使得<strong>循环头</strong>可以包含<strong>更多表达式</strong>，如<code>for(i=0,a=10; i&lt;a; i=i+2,a++)</code></p>
</li>
<li><p><code>for</code>循环的其他几种妙用</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//输出20内平方表</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数字        平方\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-11d %-11d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//输出ASCII码表</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"字符        ASCII码\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> i <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token char">'z'</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-11c %-11d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//输出20内的、平方小于350的偶数</span>
    <span class="token comment">//注: &amp;&amp;为“与”，表示两者皆满足；i+=2同i=i+2</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">20</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;</span> <span class="token number">350</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a><strong>复合赋值运算符</strong></h4><ul>
<li><p><strong>复合赋值运算符</strong>：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></p>
</li>
<li><p><strong>符号赋值运算符</strong>：<code>+=</code>表示<strong>加法赋值</strong>，如<code>a+=2</code>意义等同于<code>a=a+2</code>，其余以此类推</p>
</li>
</ul>
<h4 id="出口条件循环-do-while"><a href="#出口条件循环-do-while" class="headerlink" title="出口条件循环 do-while"></a><strong>出口条件循环 do-while</strong></h4><ul>
<li><p>是<code>while</code>循环的一种<strong>变种</strong>，<code>while</code>为<strong>入口处判断</strong>，<code>do-while</code>为<strong>出口处判断</strong></p>
</li>
<li><p>特点为<strong>第一次执行</strong>，无论如何<code>do-while</code>的<strong>循环体至少执行一次</strong>，出口处再<strong>判断是否下次循环</strong>。如下程序即使<strong>count 初始值大于 22</strong>，也会执行一次<strong>do 内循环体</strong></p>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Be my Valentine\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a><strong>循环嵌套</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//输出乘法表</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d*%d=%-2d  "</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token operator">*</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>循环嵌套</strong></p>
<blockquote>
<p>1、<strong>循环嵌套</strong>指在<strong>循环内</strong>包含<strong>另一个循环</strong>，执行顺序为<strong>外层循环</strong>过程中执行多次<strong>内层循环</strong>，两个循环的<strong>大括号</strong>分别<strong>标识自己的循环体部分</strong><br>2、如上述示例程序<strong>乘法表</strong>，通过最内层<code>printf</code>能得知，使用<strong>j</strong>表示乘法表<strong>第一个数字</strong>，使用<strong>i</strong>表示<strong>第二个数字</strong>，使用<strong>i*j</strong>表示<strong>乘法的积</strong><br>3、通过<code>j&lt;=i</code>的<strong>循环条件</strong>防止出现<code>2*3</code>后再次出现<code>3*2</code><strong>重复</strong><br>4、建议自己运行一次程序，感受循环的顺序，也可以改变几个数值，看看程序的变化</p>
</blockquote>
</li>
</ul>
<h4 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a><strong>数组简介</strong></h4><ul>
<li><p>在许多程序中，数组很重要。<strong>数组</strong>可以作为一种<strong>储存多个相关元素</strong>的<strong>便利方式</strong>，将在第十章详细介绍</p>
</li>
<li><p><strong>数组</strong></p>
<blockquote>
<p>1、数组是<strong>按顺序存储</strong>的一系列<strong>类型相同</strong>的值，如 10 个<code>char</code>类型数值或 10 个<code>int</code>类型数值<br>2、整个数组有一个<strong>数组名</strong>，通过<strong>整数下标</strong>访问数组中<strong>单独的项</strong>或<strong>元素</strong></p>
</blockquote>
</li>
<li><p><strong>数组声明与使用</strong></p>
<blockquote>
<p><strong>数组声明</strong>：示例<code>int a[15]</code>，表示声明一个<strong>内涵 15 个元素</strong>的整数数组<br><strong>数组使用</strong>：通过<strong>下标</strong>访问<strong>指定元素</strong>。数组的<strong>第一个元素</strong>为<code>a[0]</code>，<strong>第二个元素</strong>为<code>a[1]</code>，以此类推。实际上<strong>数组元素</strong>的使用与<strong>同类型变量</strong>相同<br><strong>陷阱</strong>：考虑到 C 执行速度，C 编译器<strong>不会检查</strong>数组<strong>下标是否正常</strong>，注意数组元素<strong>不要超出定义的范围</strong><br><strong>下标</strong>：用于<strong>标识数组元素的数字</strong>叫做<strong>下标</strong>、<strong>索引</strong>或<strong>偏移量</strong>。下标<strong>必须是整数</strong>且要<strong>从 0 开始计数</strong></p>
</blockquote>
</li>
<li><p><strong>for 循环中使用数组</strong></p>
<ul>
<li><p><code>for</code><strong>循环</strong>的<strong>数组使用</strong>，可以通过利用<strong>循环变量</strong>的变化来<strong>切换数组的元素</strong>，示例如下：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//循环输入</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//循环输出</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-5d  "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="函数返回值的使用"><a href="#函数返回值的使用" class="headerlink" title="函数返回值的使用"></a><strong>函数返回值的使用</strong></h4><ul>
<li><p>对于<strong>有返回值的函数</strong>，函数最后的<code>return</code><strong>语句</strong>表示函数的<strong>返回值</strong>，即执行完函数后，函数<strong>返回的值</strong></p>
</li>
<li><p><strong>编写</strong>一个有返回值的函数，需要注意以下几点：</p>
<blockquote>
<p>1、定义函数时，<strong>确定函数的返回类型</strong><br>2、使用<code>return</code>表明待返回的值</p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// double 函数名 表明函数返回一个double类型的值</span>
<span class="token keyword">double</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">double</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> pow <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> p<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        pow <span class="token operator">*=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 返回pow的值</span>
    <span class="token keyword">return</span> pow<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// a^b</span>
    <span class="token keyword">double</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入底数:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入指数:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用函数</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"乘方结果:%lf"</span><span class="token punctuation">,</span> <span class="token function">power</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<hr>
<h3 id="C-控制语句-分支和跳转"><a href="#C-控制语句-分支和跳转" class="headerlink" title="C 控制语句:分支和跳转"></a><strong>C 控制语句:分支和跳转</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：<code>if</code>语句；<code>if-else</code> 语句与 <code>else-if</code> 语句；<code>if</code> 与 <code>else</code> 的配对和嵌套 <code>if</code>；<code>getchar()</code>与<code>putchar()</code>函数；<code>ctype.h</code>系列的字符函数；逻辑运算符；备选拼写：<code>iso646.h</code>头文件；条件(三目)运算符；循环辅助：<code>continue</code>和<code>break</code>；<code>switch</code> 语句；<code>goto</code> 语句</p>
</blockquote>
</div>

<h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><strong>if 语句</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sure,A>B!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Over!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>if 语句</strong></p>
<blockquote>
<p>1、<code>if</code><strong>语句</strong>被称为<strong>分支语句</strong>或<strong>选择语句</strong>，因为它相当于一个<strong>交叉点</strong>，程序要在两条分支中<strong>选择一条</strong>执行<br>2、程序如果对<strong>分支表达式</strong>求值为<strong>真</strong>，则执行<strong>执行语句</strong>，否则<strong>跳过</strong>执行语句<br>3、<code>if</code><strong>语句</strong>的通用形式如下</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>分支表达式<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    执行语句<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="if-else-语句与-else-if-语句"><a href="#if-else-语句与-else-if-语句" class="headerlink" title="if-else 语句与 else-if 语句"></a><strong>if-else 语句与 else-if 语句</strong></h4><ul>
<li><p><strong>if-else 语句</strong></p>
<blockquote>
<p>1、简单的<code>if</code><strong>语句</strong>可以让程序选择<strong>执行一条语句或跳过</strong>，而<code>if-else</code><strong>语句</strong>可以在<strong>两条语句之间做选择</strong><br>2、程序如果对<strong>分支表达式</strong>求值为<strong>真</strong>，则执行<strong>执行语句 1</strong>，否则执行<strong>执行语句 2</strong><br>3、<code>if-else</code><strong>语句</strong>的通用形式如下</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>分支表达式<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    执行语句<span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">else</span><span class="token punctuation">&#123;</span>
    执行语句<span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>else-if 语句</strong></p>
<blockquote>
<p>1、<code>else-if</code><strong>语句</strong>为<strong>多重选择</strong>语句，可以在<strong>多个分支之间做选择</strong><br>2、程序会根据表达式是否为真<strong>逐步判断</strong>，特别注意，如果<strong>第一个表达式为真</strong>，则<strong>不会继续向下执行</strong><br>3、<code>else-if</code><strong>语句</strong>的通用形式如下</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>分支表达式<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    执行语句<span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>分支表达式<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    执行语句<span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">else</span><span class="token punctuation">&#123;</span>
    执行语句<span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="if-与-else-的配对和嵌套-if"><a href="#if-与-else-的配对和嵌套-if" class="headerlink" title="if 与 else 的配对和嵌套 if"></a><strong>if 与 else 的配对和嵌套 if</strong></h4><ul>
<li><p>当一个程序有<strong>多个</strong><code>if</code>和<code>else</code>，<strong>如果没有花括号</strong>，<code>else</code>将与<strong>离它最近</strong>的<code>if</code>配对，除非最近的 if 被花括号括起来</p>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/if%E9%85%8D%E5%AF%B9.png" loading="lazy"></p>
</li>
<li><p>有关<code>if</code>的嵌套，与<code>for</code>的嵌套基本雷同，只需要注意<strong>不同嵌套的花括号包括的范围</strong>即可</p>
</li>
</ul>
<h4 id="getchar-与-putchar-函数"><a href="#getchar-与-putchar-函数" class="headerlink" title="getchar()与 putchar()函数"></a><strong>getchar()与 putchar()函数</strong></h4><ul>
<li><p><strong>getchar()与 putchar()的使用</strong></p>
<blockquote>
<p>1、<code>getchar()</code><strong>函数</strong>用于从<strong>标准输入流</strong>中<strong>读取一个字符</strong>，并将其存储在变量中<br>2、如把字符<strong>储存进</strong>变量<strong>ch</strong>，则写为<code>ch = getchar()</code>，其等效于<code>scanf(&quot;%c&quot;, &amp;ch)</code><br>3、<code>putchar()</code><strong>函数</strong>用于<strong>打印它的参数</strong><br>4、如打印<strong>ch</strong>的值，则写为<code>putchar(ch)</code>，其等效于<code>printf(&quot;%c&quot;,ch)</code><br>5、由于这些函数<strong>只处理字符</strong>，所以比<code>scanf</code>与<code>printf</code><strong>更快更轻量</strong>，而且<strong>不需要转换说明</strong></p>
</blockquote>
</li>
<li><p><strong>探索如何工作的程序示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 读取第一个字符</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 当不为换行符时循环，即一行字符未结束时</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token comment">// 留下空格不变</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">putchar</span><span class="token punctuation">(</span>ch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//其他字符改变+1</span>
        <span class="token punctuation">&#125;</span>
        ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取下一个字符</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印换行符</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<ul>
<li><p>该程序<strong>可以进行优化</strong>，将<strong>如下形式的循环</strong>替换为<strong>后者</strong></p>
<pre class="language-c" data-language="c"><code class="language-c">ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>这样的写法体现了<strong>C 特有的编程风格</strong>——<strong>把两个行为合并成一个表达式</strong></p>
</li>
<li><p>程序中的<code>putchar(ch+1);</code>语句，再次演示了<strong>字符</strong>实际上是<strong>作为整数储存</strong>的</p>
</li>
</ul>
</li>
</ul>
<h4 id="ctype-h-系列的字符函数"><a href="#ctype-h-系列的字符函数" class="headerlink" title="ctype.h 系列的字符函数"></a><strong>ctype.h 系列的字符函数</strong></h4><ul>
<li><p>C 有一系列专门用于<strong>处理字符</strong>的<strong>函数</strong>，<code>ctype.h</code><strong>头文件</strong>包含了这些<strong>函数</strong>的原型。这些函数<strong>接受一个字符作为参数</strong>，如果该字符<strong>属于某特殊的类别</strong>，则返回<strong>true</strong>，否则返回<strong>false</strong></p>
</li>
<li><p><code>ctype.h</code>的<strong>字符测试函数</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th>如果是下列参数，返回值为 true</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isalnum()</td>
<td>字母或数字</td>
</tr>
<tr>
<td align="center">isalpha()</td>
<td>字母</td>
</tr>
<tr>
<td align="center">isblank()</td>
<td>标准的空白字符(空格、换行、水平制表符)或其他本地指定为空白的字符</td>
</tr>
<tr>
<td align="center">iscntrl()</td>
<td>控制字符，如<code>Ctrl+B</code></td>
</tr>
<tr>
<td align="center">isdigit()</td>
<td>数字</td>
</tr>
<tr>
<td align="center">isxdigit()</td>
<td>十六进制数字符</td>
</tr>
<tr>
<td align="center">isgraph()</td>
<td>除空格以外的任意可打印字符</td>
</tr>
<tr>
<td align="center">islower()</td>
<td>小写字母</td>
</tr>
<tr>
<td align="center">isupper()</td>
<td>大写字母</td>
</tr>
<tr>
<td align="center">isprint()</td>
<td>可打印字符</td>
</tr>
<tr>
<td align="center">ispunct()</td>
<td>标点符号(除空格和字母数字以外的任何可打印字符)</td>
</tr>
<tr>
<td align="center">isspace()</td>
<td>空白符(空格、换行、换页、回车、垂直或水平制表符、其他本地定义的空白符)</td>
</tr>
</tbody></table>
</li>
<li><p><code>ctype.h</code>的<strong>字符映射函数</strong></p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tolower()</td>
<td>如果参数是大写字符，则函数返回小写，否则返回原始参数</td>
</tr>
<tr>
<td align="center">toupper()</td>
<td>如果参数是小写字符，则函数返回大写，否则返回原始参数</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h4><ul>
<li><p>C 语言的<code>if</code>和<code>while</code>语句通常需要使用<strong>关系表达式</strong>作为测试条件。有时需要<strong>多个关系表达式组合</strong>，来判断<strong>多个条件的逻辑关系</strong>，<strong>逻辑运算符</strong>便可满足这一需求</p>
</li>
<li><p><strong>3 种逻辑运算符</strong></p>
<blockquote>
<p>1、<code>&amp;&amp;</code><strong>逻辑与</strong>：如果连接的两个表达式<strong>都为 true</strong>，则<strong>返回 true</strong><br>2、<code>||</code><strong>逻辑或</strong>：如果连接的两个表达式<strong>至少有一个为 true</strong>，则<strong>返回 true</strong><br>3、<code>!</code><strong>逻辑非</strong>：如果表达式为 <strong>true</strong>，则<strong>返回 false</strong>；如果表达式为 <strong>false</strong>，则<strong>返回 true</strong></p>
</blockquote>
</li>
<li><p><strong>逻辑运算符优先级</strong></p>
<blockquote>
<p>1、<code>!</code>优先级<strong>最高</strong>、<code>&amp;&amp;</code>优先级<strong>次之</strong>、<code>||</code>优先级<strong>最低</strong><br>2、<code>!</code>的优先级<strong>仅次于圆括号</strong>，比乘法运算符还高。<code>&amp;&amp;</code>、<code>||</code>的优先级都<strong>比关系运算符低</strong>，<strong>比赋值运算符高</strong><br>3、因此，表达式<code>a&gt;b &amp;&amp; b&gt;c || b&gt;d</code>相当于<code>((a&gt;b) &amp;&amp; (b&gt;c)) || (b&gt;d)</code></p>
</blockquote>
</li>
<li><p><strong>备选拼写：iso646.h 头文件</strong></p>
<ul>
<li>由于 C 使用<strong>标准美式键盘</strong>开发，部分键盘并<strong>没有美式键盘的符号</strong>。使用<code>iso646.h</code><strong>头文件</strong>，可以使用<code>and</code>、<code>or</code>、<code>not</code>分别代替<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li>
</ul>
</li>
</ul>
<h4 id="条件-三目-运算符"><a href="#条件-三目-运算符" class="headerlink" title="条件(三目)运算符"></a><strong>条件(三目)运算符</strong></h4><ul>
<li><p>C 提供<strong>条件(三目)运算符</strong>作为表达<code>if-else</code>的一种便捷方式，常用于为一个变量<strong>判断赋值或输出的值</strong>时使用</p>
</li>
<li><p><strong>三目运算符的使用</strong></p>
<ul>
<li><strong>基本语法</strong>：<code>测试条件 ? 结果true执行表达式 : 结果false执行表达式</code></li>
<li>例如<code>a = (num&lt;0) ? -y : y;</code>等效于如下语句：<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    a <span class="token operator">=</span> <span class="token operator">-</span>y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    a <span class="token operator">=</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
<li><strong>三目运算符</strong>也可以<strong>嵌套使用</strong>，使用<strong>小括号表明不同层级部分</strong></li>
</ul>
</li>
</ul>
<h4 id="循环辅助：continue-和-break"><a href="#循环辅助：continue-和-break" class="headerlink" title="循环辅助：continue 和 break"></a><strong>循环辅助：continue 和 break</strong></h4><ul>
<li><p><strong>语句功能</strong></p>
<blockquote>
<p><code>continue</code><strong>语句</strong>：在<strong>循环过程</strong>中，如果执行到<code>continue</code>语句，则会从<code>continue</code>执行处<strong>跳过本层本次循环</strong>的剩余内容，<strong>继续执行下一次循环</strong><br><code>break</code><strong>语句</strong>：在<strong>循环过程</strong>中，如果执行到<code>break</code>语句，则会从<code>break</code>执行处<strong>终止本层循环</strong>且<strong>跳过未执行内容</strong>，<strong>不再进行下一次本层循环</strong></p>
</blockquote>
</li>
<li><p><strong>语句优势</strong></p>
<blockquote>
<p>1、可以<strong>更加灵活</strong>的控制循环的执行<br>2、能够<strong>减少不必要的</strong><code>if-else</code><strong>层级缩进</strong>，提高代码的<strong>可读性</strong><br>3、使代码语句<strong>结构更清晰紧凑</strong></p>
</blockquote>
</li>
</ul>
<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a><strong>switch 语句</strong></h4><ul>
<li><p>使用<strong>条件运算符</strong>和<code>if-else</code>语句很容易编写<strong>二选一</strong>的程序，然而有时程序需要从<strong>多个选项中选择</strong>，尽管可以使用<code>else if</code>实现，但大多情况下<code>switch</code><strong>更加方便</strong></p>
</li>
<li><p><strong>基本语法</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">switch</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> 表达式的可能值<span class="token number">1</span><span class="token operator">:</span>
        语句<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> 表达式的可能值<span class="token number">2</span><span class="token operator">:</span>
        语句<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        语句<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>注意事项</strong></p>
<blockquote>
<p>1、<code>break</code>语句使程序离开<code>switch</code>语句，<strong>直接执行</strong><code>switch</code>后的<strong>下一条语句</strong>，如果<strong>没有</strong><code>break</code>，则会<strong>按顺序</strong>将<strong>条件成立处</strong>向后<strong>所有</strong><code>case</code>内语句执行完毕，直到<code>default</code>语句后退出<br>2、C 语言的<code>case</code>一般都<strong>指定一个值</strong>，<strong>不能使用一个范围</strong><br>3、关于<code>switch</code>不使用<code>break</code>会<strong>向后执行</strong>的特性，可以在特定的地方设定<code>break</code>，来利用这个特性，如下设计统计字母出现次数的程序</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>                              <span class="token comment">// 输入字母</span>
    <span class="token keyword">int</span> a_ct<span class="token punctuation">,</span> b_ct<span class="token punctuation">,</span> c_ct<span class="token punctuation">,</span> d_ct<span class="token punctuation">,</span> e_ct<span class="token punctuation">;</span>     <span class="token comment">// 统计abcde的次数</span>
    a_ct <span class="token operator">=</span> b_ct <span class="token operator">=</span> c_ct <span class="token operator">=</span> d_ct <span class="token operator">=</span> e_ct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 初始化为0</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"enter some text;enter # to quit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'#'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> <span class="token char">'a'</span><span class="token operator">:</span> <span class="token comment">// 检测a时执行，并会向下执行'A'的语句</span>
        <span class="token keyword">case</span> <span class="token char">'A'</span><span class="token operator">:</span> <span class="token comment">// 不论大写小写a，都会执行语句计入统计</span>
            a_ct<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// break终止继续执行</span>
        <span class="token comment">// 以此类推，此处省略bcde的case</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A   B   C   D   E\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-4d%-4d%-4d%-4d%-4d"</span><span class="token punctuation">,</span> a_ct<span class="token punctuation">,</span> b_ct<span class="token punctuation">,</span> c_ct<span class="token punctuation">,</span> d_ct<span class="token punctuation">,</span> e_ct<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>swith 与 if-else</strong></p>
<blockquote>
<p>1、通常而言，<code>switch</code>能干的<code>if-else</code><strong>都能实现</strong>，但<code>switch</code>的运行<strong>速度更快</strong><br>2、当需要判断<strong>一个范围</strong>或<strong>浮点变量或表达式</strong>时，<code>switch</code><strong>无法实现</strong><br>3、<code>switch</code>通常只是<code>if-else</code>的<strong>优化</strong>，对比之下，仍是<code>if-else</code><strong>泛用性更强</strong></p>
</blockquote>
</li>
</ul>
<h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a><strong>goto 语句</strong></h4><ul>
<li><p>早期版本的<strong>BASIC</strong>和<strong>FORTRAN</strong>所依赖的<code>goto</code>语句，在 C 中<strong>仍然可用</strong>，但<strong>非常不建议</strong>使用，即使没有<code>goto</code>语句 C 语言也仍能运行良好，且<strong>逻辑更加清晰</strong></p>
</li>
<li><p><strong>基本语法</strong></p>
<pre class="language-c" data-language="c"><code class="language-c">语句标签<span class="token punctuation">(</span>如<span class="token operator">:</span>part1<span class="token punctuation">)</span><span class="token operator">:</span>语句

<span class="token keyword">goto</span> 语句标签<span class="token punctuation">;</span></code></pre></li>
</ul>
<hr>
<h3 id="字符输入输出与输入验证"><a href="#字符输入输出与输入验证" class="headerlink" title="字符输入输出与输入验证"></a><strong>字符输入输出与输入验证</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：单字符 I&#x2F;O:<code>getchar</code>与<code>putchar</code>；缓冲区；完全缓冲 I&#x2F;O 与行缓冲 I&#x2F;O；结束键盘输入(C 处理文件的方式)；文件；流；检测文件结尾；C 语言的<code>EOF</code>；重定向和文件；UNIX、Linux 和 DOS 重定向(流的输送)、重定向注意事项；创建更友好的用户界面；处理缓冲输入的换行符；处理混合数值字符输入的错误；输入验证</p>
</blockquote>
</div>

<h4 id="单字符-I-x2F-O-getchar-与-putchar"><a href="#单字符-I-x2F-O-getchar-与-putchar" class="headerlink" title="单字符 I&#x2F;O:getchar 与 putchar"></a><strong>单字符 I&#x2F;O:getchar 与 putchar</strong></h4><ul>
<li><p>在第七章中提到过，<code>getchar()</code>和<code>putchar()</code>每次<strong>只处理一个字符</strong>。可能这种方法过于笨拙，但这种方法<strong>很适合计算机</strong>。而且，这是绝大多数<strong>文本处理程序</strong>所用的<strong>核心方法</strong></p>
</li>
<li><p>详细用法请参照<strong>前一章</strong></p>
</li>
<li><p>为何输入的字符能直接<strong>显示在屏幕</strong>上？如果用一个<strong>特殊字符</strong>(如<code>#</code>)来<strong>结束输入</strong>，就无法<strong>在文本中使用</strong>这个字符。是否有<strong>更好的办法</strong>结束输入？首先要了解<strong>C 程序如何处理键盘输入</strong>，尤其是<strong>缓冲</strong>和<strong>标准输入文件</strong>的概念</p>
</li>
</ul>
<h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a><strong>缓冲区</strong></h4><ul>
<li><p><strong>缓冲输入与缓冲区</strong></p>
<blockquote>
<p><strong>缓冲输入</strong>：对于<strong>程序输入</strong>，大部分系统在用户按下<code>Enter</code>之前<strong>不会重复打印</strong>刚输入的字符，即在<strong>重复输入字符</strong>时，不会在终端出现<code>H(输入)H(输入后处理输出的字符)e(第二格输入的字符)elllloo</code>这样的情况。这种<strong>输入形式</strong>称为<strong>缓冲输入</strong><br><strong>缓冲区</strong>：用户<strong>输入的字符</strong>会先被<strong>收集并储存</strong>在一个被称为<strong>缓冲区</strong>的<strong>临时储存区</strong>，按下<code>Enter</code>时，程序才可使用用户输入的字符</p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E7%BC%93%E5%86%B2%E5%8C%BA.png" loading="lazy"></p>
</li>
<li><p><strong>为什么要有缓冲区</strong></p>
<blockquote>
<p>1、把<strong>若干字符</strong>作为<strong>一个块</strong>传输比<strong>逐个发送</strong>这些字符<strong>节约时间</strong><br>2、如果用户<strong>打错字符</strong>，可以<strong>直接通过键盘修正</strong>，当最后按下<code>Enter</code>时，传输的是<strong>正确的输入</strong><br>3、虽然缓冲输入<strong>好处很多</strong>，但某些<strong>交互式程序</strong>也需要<strong>无缓冲输入</strong>，比如在<strong>游戏中</strong>，希望<strong>按下一个按键</strong>就<strong>立刻执行</strong>相应的指令。因此缓冲输入和无缓冲输入<strong>都有用武之地</strong></p>
</blockquote>
</li>
<li><p><strong>完全缓冲 I&#x2F;O 与行缓冲 I&#x2F;O</strong></p>
<blockquote>
<p><strong>完全缓冲输入</strong>：指当<strong>缓冲区被填满</strong>时才<strong>刷新缓冲区</strong>(内容被发送至目的地)，通常出现在<strong>文件输入</strong>中。<strong>缓冲区大小</strong>取决于<strong>系统</strong>，常见<strong>512 字节</strong>和<strong>4096 字节</strong><br><strong>行缓冲输入</strong>：指在<strong>出现换行</strong>时<strong>刷新缓冲区</strong>。<strong>键盘输入</strong>通常是<strong>行缓冲输入</strong>，所以在按下<code>Enter</code>时才<strong>刷新缓冲区</strong></p>
</blockquote>
</li>
<li><p><strong>使用缓冲输入还是无缓冲输入</strong></p>
<blockquote>
<p>1、<strong>ANSI C</strong>和<strong>后续的 C 标准</strong>都规定<strong>输入是缓冲的</strong>，不过最初 K&amp;R 把这个<strong>决定权</strong>交给了<strong>编译器的编写者</strong><br>2、<strong>ANSI C</strong>决定把<strong>缓冲输入</strong>作为<strong>标准输入</strong>的原因是：一些计算机<strong>不允许无缓冲输入</strong><br>3、<strong>ANSI C</strong>没有提供<strong>调用无缓冲输入</strong>的<strong>标准方式</strong>，这意味着能否进行无缓冲输入<strong>取决于计算机系统</strong></p>
</blockquote>
</li>
</ul>
<h4 id="结束键盘输入-C-处理文件的方式"><a href="#结束键盘输入-C-处理文件的方式" class="headerlink" title="结束键盘输入(C 处理文件的方式)"></a><strong>结束键盘输入(C 处理文件的方式)</strong></h4><ul>
<li><p><strong>文件、流和键盘输入</strong></p>
<ul>
<li><p><strong>文件</strong></p>
<blockquote>
<p>1、<strong>文件</strong>是<strong>储存器</strong>中<strong>储存信息的区域</strong>。通常，文件都<strong>保存</strong>在某种<strong>永久储存器</strong>中(如硬盘、U 盘、DVD 等)。<br>2、毫无疑问，文件对于计算机系统<strong>相当重要</strong>。例如你编写的<strong>C 程序</strong>就保存在<strong>文件</strong>中，用来<strong>编译 C 程序</strong>的<strong>程序</strong>也保存在<strong>文件</strong>中<br>3、某些程序需要<strong>访问指定的文件</strong>。当<strong>编译</strong>储存在名为<code>echo.c</code><strong>文件</strong>中的<strong>程序</strong>时，编译器<strong>打开</strong><code>echo.c</code>文件并<strong>读取</strong>其中的内容，当编译器<strong>处理完后</strong>，会<strong>关闭</strong>该文件<br>4、其他程序，例如<strong>文字处理器</strong>，不仅要<strong>打开</strong>、<strong>读取</strong>、<strong>关闭</strong>文件，还要把数据<strong>写入</strong>文件</p>
</blockquote>
</li>
<li><p><strong>C 语言与文件</strong></p>
<blockquote>
<p>1、C 是一门强大、灵活的语言，有许多用于<strong>打开</strong>、<strong>读取</strong>、<strong>写入</strong>、<strong>关闭</strong>文件的<strong>库函数</strong><br>2、从<strong>较低层面</strong>上，C 可以使用<strong>主机操作系统</strong>的<strong>基本文件工具</strong>直接处理文件，这些直接<strong>调用操作系统</strong>的<strong>函数</strong>被称为<strong>底层 I&#x2F;O</strong>。但计算机系统<strong>各不相同</strong>，所以<strong>不可能</strong>为普通的<strong>底层 I&#x2F;O</strong>函数创建<strong>标准库</strong><br>3、从<strong>较高层面</strong>上，C 还可以通过<strong>标准 I&#x2F;O 包</strong>来处理文件。这涉及<strong>创建</strong>用于处理文件的<strong>标准模型</strong>和一套<strong>标准 I&#x2F;O 函数</strong>。这一层面上，具体的<strong>C 实现</strong>负责<strong>处理不同系统的差异</strong>，以便用户使用<strong>统一</strong>的界面</p>
</blockquote>
</li>
<li><p><strong>流(stream)</strong></p>
<blockquote>
<p>1、从<strong>概念上</strong>看，C 程序<strong>处理</strong>的是<strong>流</strong>，而<strong>不是直接处理文件</strong><br>2、<strong>流</strong>是一个<strong>实际输入或输出</strong>映射的<strong>理想化数据流</strong>。这意味着<strong>不同属性</strong>和<strong>不同种类</strong>的输入，由<strong>属性更统一</strong>的<strong>流</strong>来表示<br>3、于是，<strong>打开文件的过程</strong>就是把<strong>流</strong>与<strong>文件</strong>关联，而且<strong>读写</strong>都通过<strong>流</strong>来完成</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>文件结尾</strong></p>
<ul>
<li><p><strong>操作系统检测文件结尾</strong></p>
<blockquote>
<p>1、计算机<strong>操作系统</strong>要以某种方式<strong>判断文件的开始和结束</strong>，其中<strong>一种方法</strong>是，在<strong>文件末尾</strong>放一个<strong>特殊的字符</strong>标记文件结尾<br>2、<strong>CP&#x2F;M</strong>，<strong>IBM-DOS</strong>，<strong>MS-DOS</strong>的文本文件曾经都<strong>用过这种方法</strong>。如今这些操作系统可以使用<strong>内嵌的</strong><code>Ctrl+Z</code>字符来标记文件结尾<br>3、这<strong>曾经是</strong>操作系统使用的<strong>唯一标记</strong>，不过现在有一些<strong>其他选择</strong>，如<strong>记录文件的大小</strong>。所以现代的文本文件<strong>不一定有</strong>嵌入的<code>Ctrl+Z</code>，但如果有，<strong>操作系统</strong>会<strong>将其视为</strong>一个<strong>文件结尾的标记</strong>，如后附图<br>4、操作系统使用的<strong>另一种方法</strong>是<strong>储存文件大小的信息</strong>。如果文件有<strong>3000 字节</strong>，那么<strong>读到 3000 字节</strong>时便<strong>达到文件的末尾</strong><br>5、<strong>MS-DOS</strong>及其相关系统使用这种方法<strong>处理二进制文件</strong>，因为用这种方法可以在文件中<strong>储存所有的字符</strong>。新版的<strong>DOS</strong>也使用这种方式<strong>处理文本文件</strong>。<strong>UNIX</strong>使用这种方式<strong>处理所有的文件</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E7%BB%93%E5%B0%BE%E6%A0%87%E8%AE%B0.png" loading="lazy"></p>
</li>
<li><p><strong>C 语言检测文件结尾</strong></p>
<blockquote>
<p>1、在 C 语言中，用<code>getchar()</code>读取文件<strong>检测到文件结尾</strong>时，会返回<strong>特殊值</strong><code>EOF</code>(End Of Line 缩写)。<code>scanf()</code>检测到文件结尾时也返回<code>EOF</code><br>2、通常，<code>EOF</code>被定义在<code>stdio.h</code><strong>文件中</strong>：<code>#define EOF (-1)</code></p>
</blockquote>
</li>
<li><p><strong>关于 EOF</strong></p>
<blockquote>
<p>1、为什么是<strong>选用-1</strong>？因为<code>getchar()</code>函数的<strong>返回值</strong>介于<strong>0~127</strong>，这些值对应<strong>标准字符集</strong>。但是如果系统能识别<strong>拓展字符集</strong>，则<strong>返回值</strong>可能在<strong>0~255</strong>。但无论哪种情况，-1<strong>都不对应任何字符</strong>，所以选用-1 标记文章结尾<br>2、某些系统也许把<code>EOF</code><strong>定义为-1 以外的值</strong>，但是<strong>定义的值</strong>一定与<strong>输入字符</strong>所产生的<strong>返回值</strong>会<strong>不同</strong>。如果包含<code>stdio.h</code>文件，并使用<code>EOF</code>符号，就<strong>不必担心</strong>值不同的问题。这里关键要理解<code>EOF</code><strong>是一个值</strong>，标志着<strong>检测到文件结尾</strong>，<strong>并不是</strong>在文件中<strong>找得到的符号</strong><br>3、如何在<strong>程序中使用</strong>？把<code>getchar()</code>的<strong>返回值</strong>和<code>EOF</code>比较，如果<strong>不同</strong>则<strong>没有到达文件结尾</strong>，即如下：<code>while((ch = getchar()) != EOF)</code></p>
</blockquote>
</li>
<li><p><strong>键盘模拟文件结尾条件</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> ch<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、不用定义<code>EOF</code>，因为<code>stdio.h</code>已经<strong>定义过了</strong><br>2、不用担心<code>EOF</code>的<strong>实际值</strong>，因为<code>EOF</code>在<code>stdio.h</code>中用<code>#define</code>预处理指令定义，<strong>可直接使用</strong><br>3、变量<strong>ch</strong>的类型从<code>char</code>变成了<code>int</code>，因为<code>char</code>的变量只能表示<strong>0~255</strong>的<strong>无符号</strong>整数，但<code>EOF</code>的<strong>值是-1</strong>。还好<code>getchar()</code>函数<strong>实际返回值类型</strong>是<code>int</code>，所以它可以读取<code>EOF</code>字符。如果实现使用<strong>有符号</strong>的<code>char</code>类型，也可以把<strong>ch</strong>声明为<code>char</code>，但最好还是用<strong>更通用</strong>的形式<br>4、由于<code>getchar()</code><strong>返回类型</strong>是<code>int</code>，如果把<code>getchar()</code>的<strong>返回值</strong>赋给<code>char</code>变量，一些编译器可能会<strong>警告甚至丢失数据</strong><br>5、<strong>ch</strong>是<strong>整数</strong>不会影响<code>putchar()</code>，该函数仍然会<strong>打印等价字符</strong><br>6、使用该程序进行<strong>键盘输入</strong>，要设法输入<code>EOF</code>字符，不能只输入<strong>字符 EOF</strong>，也不能只输入<strong>数值-1</strong>(会被当做一个连字符和一个数字 1)。正确的方法是<strong>找出当前系统的要求</strong>，如大多数<strong>UNIX</strong>和<strong>Linux</strong>系统中在<strong>一行开始</strong>使用<code>Ctrl+Z</code>会<strong>传输文件结尾信号</strong>，而<strong>Windows</strong>系统中在<strong>一行开始</strong>使用<code>Ctrl+Z</code>会<strong>传输文件结尾信号</strong>，所以在程序中需要<strong>设立不同的提示语</strong>提醒用户</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a><strong>重定向和文件</strong></h4><ul>
<li><p>默认情况下，C 程序使用<strong>标准 I&#x2F;O</strong>包查找<strong>标准输入</strong>作为<strong>输入源</strong>，这就是前面介绍过的<strong>stdin 流</strong>，它是把数据<strong>读入计算机</strong>的常用方式</p>
</li>
<li><p><strong>程序使用文件的两种方式</strong></p>
<blockquote>
<p>1、显式使用<strong>特定的函数</strong>打开、关闭、读取、写入文件，将在第 13 章介绍<br>2、设计能与键盘和屏幕互动的程序，通过不同的渠道<strong>重定向</strong>输入至文件和从文件输出，下面主要介绍此类<strong>重定向</strong></p>
</blockquote>
</li>
<li><p><strong>UNIX、Linux 和 DOS 重定向</strong></p>
<ul>
<li><p>UNIX(运行命令行模式)、Linux(ditto)和 Windows 命令行(注意使用<strong>cmd</strong>而不是<strong>终端</strong>)提示都能<strong>重定向输入输出</strong>。<strong>重定向输入</strong>让程序<strong>使用文件</strong>而不是键盘输入，<strong>重定向输出</strong>让程序<strong>输出至文件</strong>而不是屏幕</p>
</li>
<li><p><strong>重定向输入</strong></p>
<blockquote>
<p>1、假设已经编译了<strong>echo.c</strong>程序，并生成了一个名为<strong>echo</strong>的<strong>可执行文件</strong>(Windows 中为<strong>echo.exe</strong>，<strong>注意后续命令注意使用带有文件后缀的名字</strong>)。想要<strong>运行</strong>该程序，在<strong>命令行</strong>的<strong>对应目录</strong>中输入可执行文件名：<code>./echo</code>，<strong>Windows</strong>下输入<code>echo.exe</code>，即可执行可运行文件<br>2、现在，假设要用该程序处理<strong>名为 passage</strong>的<strong>文本文件</strong>(.txt)，文件中储存的是<strong>可识别的字符</strong>。此处由于操作对象是<strong>字符</strong>，所以使用文本文件。使用此命令代替上面的命令：<code>./echo &lt; passage</code>，<strong>Windows</strong>下输入<code>echo.exe &lt; passage.txt</code><br>3、<code>&lt;</code>符号是 UNIX 和 DOS&#x2F;Windows 的<strong>重定向运算符</strong>。该运算符使<strong>passage 文件</strong>与<strong>stdin 流</strong>相关联，把文件中的内容<strong>导入 echo 可执行程序</strong></p>
</blockquote>
</li>
<li><p><strong>重定向输出</strong></p>
<blockquote>
<p>1、类似的，假设要用<strong>echo 可执行程序</strong>把<strong>程序输出</strong>的内容<strong>发送到名为 passage 的新文件</strong>，便可以使用<code>./echo &gt; passage</code>，<strong>Windows</strong> 下输入<code>echo.exe &gt; passage.txt</code><br>2、<code>&gt;</code>符号是第二个<strong>重定向运算符</strong>，创建了一个名为<strong>passage 的新文件</strong>，然后把 echo 的<strong>输出写入该文件</strong>。通常会<strong>擦除该文件的内容</strong>，然后<strong>替换新的内容</strong>，在下一行开始处按下<code>Ctrl+D</code>(UNIX)或<code>Ctrl+Z</code>(DOS)即可<strong>结束该程序</strong></p>
</blockquote>
</li>
<li><p><strong>组合重定向</strong></p>
<blockquote>
<p>1、现在假设你希望制作一份<strong>mywords 文件</strong>的<strong>副本</strong>，并<strong>命名为 savewords</strong>，输入<code>./echo &lt; mywords &gt; savewords</code>，Windows 下输入<code>echo.exe &lt; mywords.txt &gt; savewords.txt</code><br>2、下面的命令<strong>也起作用</strong>，因为<strong>命令</strong>与<strong>重定向运算符的顺序无关</strong>，如：<code>./echo &gt; savewords &lt; mywords</code><br>3、在一条命令中，输入文件名和输出文件名<strong>不能相同</strong>，如：<code>./echo &lt; mywords &gt; mywords &lt;==错误</code>，原因是<code>&gt; mywords</code>在输入之前已导致<strong>原 mywords 长度被截断为 0</strong></p>
</blockquote>
</li>
<li><p><strong>其他重定向注意事项</strong></p>
<blockquote>
<p>1、重定向运算符连接<strong>一个可执行程序</strong>和<strong>一个数据文件</strong>，<strong>不能直接连接两个可执行文件或连接两个数据文件</strong><br>2、使用重定向运算符<strong>不能读取多个文件的输入</strong>，也<strong>不能把输出定向至多个文件</strong><br>3、文件名和运算符之间<strong>空格不是必须的</strong>，且<strong>有些系统不能使用空格</strong><br>4、UNIX、Linux 或 Windows&#x2F;DOS 还有<code>&gt;&gt;</code>运算符，该运算符可以<strong>把数据添加到现有文件的末尾</strong>且<strong>不覆盖原内容</strong>，而<code>|</code>运算符能<strong>把一个文件的输出连接到另一个文件的输入</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="创建更友好的用户界面"><a href="#创建更友好的用户界面" class="headerlink" title="创建更友好的用户界面"></a><strong>创建更友好的用户界面</strong></h4><ul>
<li><p><strong>使用缓冲输入</strong></p>
<ul>
<li><p><strong>示例程序(待优化程序)</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> guess <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"在1-100想一个数，输入y或n表示当前显示的数是否是你想的数\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数字是1吗\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'y'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"那么，是%d吗\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>guess<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"好的，这便是你想的数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>该示例程序有<strong>以下问题</strong>，对于用户的体验有影响</p>
<blockquote>
<p>1、<strong>缓冲输入</strong>要求用户按下<code>Enter</code>发送，这一动作也<strong>传递了换行符</strong>，程序必须<strong>妥善处理</strong>这个<strong>换行符</strong><br>2、<strong>用户的输入</strong>可能并不会按照<strong>人为约定</strong>只输入<strong>y 或 n</strong>，仍有<strong>其他输入</strong>的可能，也需要<strong>对应进行处理</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>处理缓冲输入的换行符</strong></p>
<ul>
<li><p>该程序每次<strong>输入 n 时</strong>，程序便打印了<strong>两条消息</strong>。这是由于程序<strong>读取 n</strong>作为用户<strong>否定了数字 1</strong>，另外<strong>读取了一个换行符</strong>作为用户<strong>否定了数字 2</strong>。此外<strong>输入 no</strong>，会打印三条语句，程序<strong>将 n 和 o 分别当做了一次响应</strong>，外加<strong>换行符的一次响应</strong></p>
</li>
<li><p><strong>优化 1</strong>：跳过剩余输入</p>
<blockquote>
<p>1、使用<code>while</code>循环，<strong>循环丢弃</strong>输入行最后<strong>剩余的内容</strong>，包括换行符<br>2、这种方法还能把<strong>no</strong>、<strong>no way</strong>都视为简单的<strong>n</strong>(因为只使用第一个字符，其余字符被丢弃)</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'y'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"那么，是%d吗\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>guess<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">//跳过剩余输入行</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>优化 2</strong>：使用变量储存响应以进行判断</p>
<blockquote>
<p>1、上述<strong>方法 1</strong>虽然解决了换行符的问题，但程序仍会将<strong>f</strong>视为<strong>n</strong><br>2、可以添加一个<strong>char</strong>类型变量<strong>储存响应</strong>，再用<code>if</code>判断<strong>筛选其他响应</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> response<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>response <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'y'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>response <span class="token operator">==</span> <span class="token char">'n'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"那么，是%d吗\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>guess<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"未知输入\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">//跳过剩余输入行</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>混合数值和字符输入</strong></p>
<ul>
<li><p><strong>示例程序(待优化程序)</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">char</span> cr<span class="token punctuation">,</span> <span class="token keyword">int</span> lines<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 该函数用于输出</span>
    <span class="token keyword">int</span> row<span class="token punctuation">,</span> col<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>row <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> row <span class="token operator">&lt;=</span> lines<span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>col <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> col <span class="token operator">&lt;=</span> width<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">putchar</span><span class="token punctuation">(</span>cr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> ch<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入要打印的字符、行数、每行个数\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rows<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cols<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">display</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入另一组数据继续，输入换行退出\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Bye!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>该示例程序有<strong>以下问题</strong>，对于用户的体验有影响</p>
<blockquote>
<p>1、<code>getchar()</code>与<code>scanf()</code>各自使用都能完成各自的任务，但尽可能<strong>不要将它们混用</strong>。<code>getchar()</code>读取每个字符，<strong>包括空格换行制表符</strong>，<code>scanf()</code>会<strong>跳过空格换行制表符</strong>，上述程序便因此出错<br>2、当程序<strong>输出完第一组</strong>数据，就<strong>直接退出</strong>了，无法输入第二组数据<br>3、在<strong>第一次输入</strong>的最后一个数字后的<strong>换行符</strong>，<code>scanf()</code>将其<strong>留在了输入队列里</strong>，而<code>getchar()</code>不会跳过换行符。所以进入<strong>下一次迭代</strong>时，<code>getchar()</code>便<strong>读取了该换行符</strong>，将其赋给<strong>ch</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>处理混合数值字符输入的错误</strong></p>
<ul>
<li><p><strong>优化</strong>：跳过<strong>一轮输入结束</strong>与<strong>下一轮输出开始</strong>之间所有的<strong>换行符和空格</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*修改主函数的while循环*/</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rows<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cols<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">display</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入另一组数据继续，输入换行退出\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a><strong>输入验证</strong></h4><ul>
<li><p>在<strong>实际应用</strong>中，用户不一定会按照<strong>程序的指令</strong>行事，<strong>用户的输入</strong>和<strong>程序期望</strong>的输入<strong>不匹配</strong>时常发生。因此需要<strong>输入验证</strong>，<strong>预料</strong>一些可能的<strong>输入错误</strong>，并提前编写<strong>处理错误</strong>的程序</p>
</li>
<li><p>假设编写了一个<strong>处理非负整数</strong>的循环，提前推演<strong>可能出现的错误</strong>，便可以按如下方式处理：</p>
<ul>
<li><p>防止出现<strong>负数</strong>，使用<strong>关系表达式</strong>排除此种情况：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> n<span class="token punctuation">;</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取第一个值</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// 判断是否为非负数</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 处理n(此处省略处理语句)</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 继续获取下一个值</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>防止输入<strong>错误类型</strong>的值，判断<code>scanf()</code><strong>返回值</strong>排除，并结合上处错误改进：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> n<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> n<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 处理n(此处省略处理语句)</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>对于上处程序，当用户输入<strong>错误的值</strong>，会直接<strong>结束程序</strong>。此外还可以<strong>提示用户</strong>再次<strong>输入正确的值</strong>，但这种情况下，需要<strong>处理有问题的输入</strong>。因为<code>scanf()</code>的<strong>错误输入</strong>仍会<strong>留在输入队列</strong>，可以使用<code>getchar()</code>函数<strong>逐字读取输入</strong>，还可以将其<strong>结合在一个函数内</strong>，按如下改进：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">get_long</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> input<span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%ld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>input<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理错误的输入</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入有误，请重新输入\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> input<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：复习函数；函数概述；函数创建与使用；函数参数与返回值；ANSI C 函数原型；旧式声明问题及解决；递归；递归演示；递归的基本原理；尾递归；递归和倒序计算；递归的优缺点；编译多源代码文件的程序;使用(自建)头文件；查找地址：&amp;运算符；更改主调函数中的变量；指针简介；指针基本概念；间接运算符：*；声明指针；使用指针在函数间通信</p>
</blockquote>
</div>

<h4 id="复习函数"><a href="#复习函数" class="headerlink" title="复习函数"></a><strong>复习函数</strong></h4><ul>
<li><p><strong>函数概述</strong></p>
<ul>
<li><p><strong>函数</strong>：完成<strong>特定任务</strong>的<strong>独立程序代码单元</strong>。<strong>语法规则</strong>定义了函数的<strong>结构</strong>和<strong>使用方式</strong></p>
</li>
<li><p><strong>功能</strong></p>
<blockquote>
<p>1、<strong>执行某些动作</strong>：如<code>printf()</code>把数据<strong>打印</strong>到屏幕<br>2、<strong>找出一个值供程序使用</strong>：如<code>strlen()</code>把<strong>指定字符串</strong>的<strong>长度</strong>返回给程序</p>
</blockquote>
</li>
<li><p><strong>优点</strong></p>
<blockquote>
<p>1、可以省去编写<strong>重复代码</strong>的苦差<br>2、让程序更加<strong>模块化</strong><br>3、提高代码的<strong>可读性</strong><br>4、方便后期<strong>修改</strong>、<strong>完善</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>函数创建与使用</strong></p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*定义并使用starbar函数打印40个星号*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">starbar</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数原型</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 主函数</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">starbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用函数</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">starbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">starbar</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>  <span class="token comment">// 定义函数</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">40</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>函数基础</strong></p>
<ul>
<li><p>基本术语</p>
<blockquote>
<p>1、<strong>函数原型</strong>：告诉<strong>编译器</strong>函数<code>starbar()</code>的<strong>相关信息</strong>。其指明了函数的<strong>返回值类型</strong>和函数接收的<strong>参数类型</strong>，这些<strong>信息</strong>称为函数的<strong>签名</strong><br>2、<strong>函数调用</strong>：表明在此<strong>执行函数</strong><br>3、<strong>函数定义</strong>：指定<strong>函数</strong>具体要<strong>做什么工作</strong><br>4、<strong>补充</strong>：<strong>函数原型</strong>与<strong>函数定义</strong>可以在<strong>同一步</strong>完成，即函数原型<code>void starbar(void)</code>后可以<strong>直接跟花括号</strong>进行<strong>定义</strong>。此外<strong>函数原型</strong>可以置于<code>main()</code><strong>主函数</strong>内<strong>声明变量处</strong></p>
</blockquote>
</li>
<li><p>函数类型</p>
<blockquote>
<p>1、<strong>函数</strong>和<strong>变量</strong>一样有<strong>多种类型</strong>，任何程序在<strong>使用函数前</strong>都要<strong>声明函数类型</strong><br>2、<code>void starbar(void);</code>中第一个<strong>void</strong>表明函数<strong>返回类型</strong>是<strong>void</strong>，即<strong>没有返回值</strong>；<strong>starbar</strong>为<strong>函数名</strong>；第二个<strong>void</strong>表明函数<strong>没有参数</strong>；<strong>分号</strong>表明<strong>仅在声明函数</strong>，<strong>不是在定义函数</strong><br>3、因此，<strong>函数名前</strong>的<strong>类型</strong>仅表明函数<strong>返回值类型</strong>，而<strong>不是参数类型</strong></p>
</blockquote>
</li>
<li><p>函数的跨文件调用</p>
<blockquote>
<p>1、程序把<code>starbar()</code>和<code>main()</code>放在<strong>一个文件</strong>中，也可以将它们<strong>分别</strong>放在<strong>两个文件</strong>下<br>2、把函数都<strong>放在一个文件</strong>中的<strong>单文件形式</strong>比较<strong>容易编译</strong>，而<strong>使用多个文件</strong>方便在<strong>不同程序</strong>中使用<strong>同一个函数</strong><br>3、如果把<strong>函数</strong>放在<strong>单独的文件</strong>中，要把<code>#define</code>和<code>include</code>指令也放入该文件，稍后会讨论如何<strong>跨文件调用函数</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>函数参数与返回值</strong></p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">plus_multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">,</span> <span class="token keyword">int</span> num3<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> result<span class="token punctuation">;</span>
    result <span class="token operator">=</span> <span class="token punctuation">(</span>num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span> <span class="token operator">*</span> num3<span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"计算(a+b)*c的结果，请分别输入a,b,c的值：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">plus_multiply</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>形参与实参</strong></p>
<blockquote>
<p>1、<strong>形式参数</strong>：<strong>函数定义</strong>的<strong>函数头</strong>中声明的<strong>变量</strong>，称为<strong>形参</strong><br>2、<strong>实际参数</strong>：出现在<strong>函数调用</strong>的<strong>圆括号</strong>内的<strong>表达式</strong>，称为<strong>实参</strong></p>
</blockquote>
</li>
<li><p><strong>函数参数的定义与使用</strong></p>
<blockquote>
<p>1、在<strong>函数原型</strong>的<strong>圆括号</strong>里，写入需要<strong>传入的参数</strong>的<strong>类型</strong>，以及<strong>参数名</strong>，即<strong>定义形参</strong>。语法为<code>void def (类型 形参1, 类型 形参2, ...)</code>，实例如<code>void def (int a, float b)</code><br>2、<strong>使用形参</strong>，需要先<strong>传入实参</strong>。在调用函数时，<strong>按顺序</strong>传入<strong>指定类型</strong>的值(即传入实参)</p>
</blockquote>
</li>
<li><p><strong>返回值</strong></p>
<blockquote>
<p>1、如果说<strong>参数</strong>是方便<strong>值</strong>从<strong>主调函数</strong>前往<strong>被调函数</strong>，那<strong>返回值</strong>便是方便<strong>值</strong>从<strong>被调函数</strong>前往<strong>主调函数</strong>。函数中为<code>return</code>语句后的值<br>2、返回值的<strong>类型</strong>即为<strong>函数原型</strong>中定义的<strong>函数类型</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="ANSI-C-函数原型"><a href="#ANSI-C-函数原型" class="headerlink" title="ANSI C 函数原型"></a><strong>ANSI C 函数原型</strong></h4><ul>
<li><p><strong>旧式声明</strong></p>
<blockquote>
<p>1、在<strong>ANSI C</strong>标准<strong>之前</strong>，声明函数的方案<strong>有缺陷</strong>，因为只需要声明<strong>函数类型</strong>，不用声明<strong>任何参数</strong><br>2、如<code>int imin()</code>这个<strong>函数声明</strong>，只需要告知编译器<code>init()</code><strong>返回 int 类型的值</strong><br>3、然而，以上<strong>函数声明</strong>并未给出<code>imin()</code>函数的<strong>参数个数和类型</strong>。因此，如果<strong>调用</strong><code>imin()</code>时使用的参数<strong>个数不对</strong>或<strong>类型不匹配</strong>，编译器根本<strong>不会察觉</strong></p>
</blockquote>
</li>
<li><p><strong>问题所在</strong></p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">imax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 旧式声明</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d和%d的最大值是%d\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token function">imax</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d和%d的最大值是%d\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token function">imax</span><span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">imax</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">></span> m <span class="token operator">?</span> n <span class="token operator">:</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">3和5的最大值是1606416656
3和5的最大值是3886</code></pre>
</li>
<li><p><strong>问题分析</strong></p>
<blockquote>
<p>1、由于不同系统的<strong>内部机制不同</strong>，所以出现问题的<strong>具体情况也不同</strong>，下面介绍<strong>PC</strong>和<strong>VAX</strong>的情况<br>2、<strong>主调函数</strong>把它的<strong>参数</strong>储存在被称为<strong>栈</strong>的<strong>临时储存区</strong>，<strong>被调函数</strong>从<strong>栈</strong>中<strong>读取</strong>这些参数，而这两个过程<strong>并未互相协调</strong><br>3、<strong>主调函数</strong>根据函数调用中的<strong>实际参数</strong>决定<strong>传递的类型</strong>，<strong>被调函数</strong>根据它的<strong>形式参数</strong>来<strong>读取</strong>值。因此，函数调用<code>imax(3)</code>把<strong>一个整数</strong>放在<strong>栈</strong>中，当函数<strong>开始执行时</strong>，它从<strong>栈</strong>中<strong>读取两个整数</strong>，而<strong>实际</strong>只存放了<strong>一个</strong>待读取的整数，所以读取的<strong>第二个值</strong>是当时<strong>恰好在栈中</strong>的<strong>其他值</strong><br>4、<strong>第二次</strong>使用<code>imax()</code>函数时，它传递的是<strong>float</strong>类型的值。这次把两个<strong>double</strong>类型的值放在<strong>栈</strong>中(当 float 作为参数传递会被升级成 double)。<strong>两个 double</strong>的值就是<strong>两个 64 位</strong>的值，所以弓<strong>128 位</strong>的数据被存放在<strong>栈</strong>中。当<code>imax()</code>读取<strong>两个 int</strong>值时，即<strong>读取前 64 位</strong>，于是<strong>出现错误</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>解决方案</strong></p>
<ul>
<li><p>针对<strong>参数不匹配</strong>的问题，<strong>ANSI C</strong>标准要求在<strong>声明函数</strong>时还要声明<strong>变量的类型</strong>，即使用<strong>函数原型</strong>来声明函数的返回类型、参数数量、参数类型</p>
</li>
<li><p>未标明<code>imax()</code>函数有两个<strong>int</strong>类型的<strong>参数</strong>，可以使用<strong>下面两种函数原型</strong>来声明</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">imax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">imax</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>第一种</strong>形式使用以<strong>逗号分隔</strong>的类型列表，<strong>第二种</strong>形式在类型后面<strong>添加了变量名</strong>。注意，这里的<strong>变量名</strong>是<strong>假名</strong>，<strong>不必</strong>与函数定义的<strong>形式参数</strong>名<strong>一致</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h4><ul>
<li><p><strong>递归</strong>：C 函数允许<strong>调用它自己</strong>，这种调用称为<strong>递归</strong>。递归有时难以捉摸，有时却很方便实用</p>
</li>
<li><p><strong>递归演示</strong></p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">up_and_down</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Level %d: n location %p\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// #1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">up_and_down</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Level %d: n location %p\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// #2</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">up_and_down</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用递归函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">Level 1: n location 000000000061FE00
Level 2: n location 000000000061FDD0
Level 3: n location 000000000061FDA0
Level 4: n location 000000000061FD70
Level 4: n location 000000000061FD70
Level 3: n location 000000000061FDA0
Level 2: n location 000000000061FDD0
Level 1: n location 000000000061FE00</code></pre>
</li>
<li><p><strong>程序分析</strong></p>
<blockquote>
<p>1、<code>main()</code>函数<strong>调用</strong><code>up_and_down()</code>，称为<strong>第 1 级递归</strong>，然后<code>up_and_down()</code><strong>调用自己</strong>，这次调用称为<strong>第 2 级递归</strong>，第 2 级<strong>再次调用</strong>，称为<strong>第 3 级递归</strong>，以此类推<br>2、<code>%p</code>、<code>&amp;</code>用于显示变量的<strong>内存地址</strong>，稍后解释<br>3、首先，<code>main()</code>函数调用带<strong>参数 1</strong>的<code>up_and_down()</code>函数，此时<strong>n&#x3D;1</strong>，<strong>语句#1</strong>打印<strong>Level 1</strong>，由于<strong>n&lt;4</strong>，执行调用<strong>实际参数</strong>为<strong>n+1</strong>(即 2)的<code>up_and_down()</code>(第 2 级)<br>4、<strong>第 2 级</strong>中<strong>n&#x3D;2</strong>，所以<strong>语句#1</strong>打印<strong>Level 2</strong>，以此类推继续<strong>递归调用</strong><br>5、当执行到<strong>第 4 级</strong>时<strong>n&#x3D;4</strong>，<code>if</code>语句<strong>n&lt;4</strong>为<strong>false</strong>，所以跳过执行<strong>不再调用</strong>自己，<strong>第 4 级</strong>继续执行<strong>语句#2</strong>，打印<strong>Level 4</strong><br>6、此时<strong>第 4 级</strong>调用结束，控制返回它的<strong>主调函数</strong>(<strong>即第 3 级</strong>)，<strong>第 3 级</strong>继续执行<strong>语句#2</strong>，打印<strong>Level 3</strong>，以此类推，直到<strong>第 1 级</strong>返回<code>main()</code>函数<br>7、注意，每级递归的<strong>变量 n</strong>都属于每级递归<strong>私有</strong>，这点从<strong>程序输出的地址</strong>可以得出</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>递归的基本原理</strong></p>
<blockquote>
<p>1、<strong>每级递归调用</strong>都有<strong>自己的变量</strong>。也就是说，<strong>第 1 级的 n</strong>和<strong>第 2 级的 n</strong>是<strong>完全不同</strong>的<br>2、<strong>每次函数调用</strong>都会<strong>返回一次</strong>。当函数执行完毕，<strong>控制权</strong>将返回到<strong>上一级递归</strong>，程序必须<strong>按顺序逐级返回递归</strong><br>3、递归函数中位于<strong>递归调用之前</strong>的语句，均按<strong>被调函数的顺序</strong>执行。例如上例按序<strong>Level 1</strong>、<strong>Level 2</strong>、<strong>Level 3</strong>、<strong>Level 4</strong><br>4、递归函数中位于<strong>递归调用之后</strong>的语句，均按<strong>被调函数相反的顺序</strong>执行。例如上例按序<strong>Level 4</strong>、<strong>Level 3</strong>、<strong>Level 2</strong>、<strong>Level 1</strong><br>5、虽然<strong>每级递归</strong>都有<strong>自己的变量</strong>，但是并<strong>没有拷贝函数的代码</strong>。程序<strong>按顺序执行</strong>函数中的代码，<strong>递归调用</strong>相当于又<strong>从头开始按序执行</strong>函数的代码。除了为每次递归调用<strong>创建变量</strong>外，<strong>递归调用</strong>非常类似一个<strong>循环语句</strong><br>6、递归函数<strong>必须包含</strong>能让递归<strong>调用停止</strong>的语句。通常都使用<code>if</code><strong>语句</strong>或其他等价的<strong>测试条件</strong>在<strong>函数形参</strong>等于<strong>某特定值</strong>时终止递归。因此，<strong>每次递归</strong>调用的<strong>形参</strong>都要使用<strong>不同的值</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%80%92%E5%BD%92.png" loading="lazy"></p>
</li>
<li><p><strong>尾递归</strong></p>
<ul>
<li><p><strong>尾递归</strong>：把<strong>递归调用</strong>置于<strong>函数末尾</strong>。是<strong>最简单的</strong>递归形式，因为它<strong>相当于循环</strong></p>
</li>
<li><p><strong>阶乘计算示例</strong>(5 的阶乘：1*2*3*4*5；0 的阶乘&#x3D;1)</p>
</li>
</ul>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment">// 直接使用for循环的函数</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> ans<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span> n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">// 此处顺带初始化ans为1</span>
    <span class="token punctuation">&#123;</span>
        ans <span class="token operator">*=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">long</span> <span class="token function">rfact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment">// 使用递归的函数</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> ans<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        ans <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token function">rfact</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
    <span class="token keyword">do</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入一个0~12之间的整数：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> num <span class="token operator">></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"循环得到的结果：%ld\n"</span><span class="token punctuation">,</span> <span class="token function">fact</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"递归得到的结果：%ld\n"</span><span class="token punctuation">,</span> <span class="token function">rfact</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>递归和倒序计算</strong></p>
<ul>
<li><p><strong>递归</strong>在<strong>处理倒序</strong>时非常方便，<strong>比循环更便捷</strong></p>
</li>
<li><p><strong>示例程序：打印整数二进制</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 递归函数</span>
<span class="token keyword">void</span> <span class="token function">to_binary</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    r <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token function">to_binary</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token char">'0'</span> <span class="token operator">:</span> <span class="token char">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> number<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入整数：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lu"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">to_binary</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>递归的优缺点</strong></p>
<blockquote>
<p>1、递归既有优点也有缺点<br>2、<strong>优点</strong>是递归对于<strong>某些编程问题</strong>提供了<strong>最简单的解决方案</strong><br>3、<strong>缺点</strong>是一些<strong>递归算法</strong>会<strong>快速消耗</strong>计算机的<strong>内存资源</strong>，此外<strong>不便于阅读和维护</strong></p>
</blockquote>
</li>
</ul>
<h4 id="编译多源代码文件的程序"><a href="#编译多源代码文件的程序" class="headerlink" title="编译多源代码文件的程序"></a><strong>编译多源代码文件的程序</strong></h4><ul>
<li><p>使用<strong>多个函数</strong>最简单的方法是把它们都放在<strong>同一个文件</strong>中，然后像编译<strong>只有一个函数的文件</strong>那样编译该文件即可。其他方法<strong>因操作系统而异</strong>，下面举例说明</p>
</li>
<li><p><strong>UNIX</strong></p>
<blockquote>
<p>1、假定<strong>UNIX 系统</strong>中安装了<strong>UNIX C 编译器 cc</strong>，假设<strong>file1.c</strong>和<strong>file2.c</strong>是两个内涵 C 函数的文件<br>2、使用<code>cc file1.c file2.c</code>可以将<strong>两个文件</strong>编译成<strong>一个</strong>名为<strong>a.out</strong>的可执行文件，并<strong>生成</strong>两个名为<strong>file1.o</strong>和<strong>file2.o</strong>的目标文件<br>3、如果后来改动了<strong>file1.c</strong>而没有改动<strong>file2.c</strong>，可以使用<code>cc file1.c file2.o</code>来编译(如果<strong>file2.o</strong>文件还存在)</p>
</blockquote>
</li>
<li><p><strong>Linux</strong></p>
<blockquote>
<p>1、假定<strong>Linux 系统</strong>中安装了<strong>GNU C 编译器 GCC</strong>，假设<strong>file1.c</strong>和<strong>file2.c</strong>是两个内涵 C 函数的文件<br>2、使用<code>gcc file1.c file2.c</code>可以将<strong>两个文件</strong>编译成<strong>一个</strong>名为<strong>a.out</strong>的可执行文件，并<strong>生成</strong>两个名为<strong>file1.o</strong>和<strong>file2.o</strong>的目标文件<br>3、如果后来改动了<strong>file1.c</strong>而没有改动<strong>file2.c</strong>，可以使用<code>gcc file1.c file2.o</code>来编译(如果<strong>file2.o</strong>文件还存在)</p>
</blockquote>
</li>
<li><p><strong>DOS 命令行编译器</strong></p>
<blockquote>
<p>1、绝大多数<strong>DOS 命令行编译器</strong>的工作原理和<strong>UNIX 的 cc 命令类似</strong>，只不过使用<strong>不同名称</strong>而已<br>2、一个<strong>区别</strong>是，对象文件的<strong>拓展名</strong>是<code>.obj</code>而不是<code>.o</code></p>
</blockquote>
</li>
<li><p><strong>Windows 和 Mac 的 IDE 编译器</strong></p>
<blockquote>
<p>1、<strong>Windows</strong>和<strong>Mac</strong>使用的<strong>集成开发环境 IDE</strong>的编译器是<strong>面向项目</strong>的，这种 IDE 的编译器要<strong>创建项目</strong>来<strong>运行单文件程序</strong><br>2、对于<strong>多文件</strong>程序，需要使用相应的<strong>菜单命令</strong>，把源代码加入一个项目中。要确保<strong>所有源代码文件</strong>都在<strong>项目列表</strong>中列出</p>
</blockquote>
</li>
<li><p><strong>使用头文件</strong></p>
<blockquote>
<p>1、如果把<code>main()</code>放在<strong>第一个文件中</strong>，<strong>函数定义</strong>放在<strong>第二个文件中</strong>，那么<strong>第一个文件</strong>仍然要使用<strong>函数原型</strong><br>2、而把<strong>函数原型</strong>放在<strong>头文件</strong>中，就<strong>不用</strong>每次使用函数文件都<strong>写出函数的原型</strong><br>3、此外，我们常常使用<strong>C 预处理器</strong>(<code>#define</code>)定义<strong>符号常量</strong>，也可以将其<strong>写入头文件</strong>，使用时只需要<strong>包含</strong>(<code>#include</code>)<strong>该头文件</strong>即可。这样更有利于<strong>维护修改</strong>，也利于对<strong>常量的管理</strong><br>4、因此，将<strong>函数原型</strong>和<strong>字符常量</strong>放在<strong>头文件</strong>，是一个十分良好的<strong>编程习惯</strong><br>5、<code>#include &quot;xxx.h&quot;</code>命令可以引入<strong>自定义的头文件</strong>，使用<strong>双引号</strong><code>&quot;&quot;</code>，且引号内如果是<strong>同目录</strong>可以<strong>直接写文件名</strong>，不同目录也可以使用<strong>相对路径</strong>和<strong>绝对路径</strong></p>
</blockquote>
<ul>
<li><p><strong>如下案例</strong>，编写一个模拟酒店收费管理的程序，注意<strong>标注的文件名</strong>来区分文件，请使用<strong>多源代码文件</strong>编译方法<strong>编译文件</strong>(程序运行仍会从<code>usehotel.c</code>的<code>main()</code><strong>主函数</strong>开始)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* hotel.h */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">QUIT</span> <span class="token expression"><span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOTEL1</span> <span class="token expression"><span class="token number">180.00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOTEL2</span> <span class="token expression"><span class="token number">225.00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOTEL3</span> <span class="token expression"><span class="token number">225.00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOTEL4</span> <span class="token expression"><span class="token number">355.00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DISCOUNT</span> <span class="token expression"><span class="token number">0.95</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STARS</span> <span class="token string">"**************************************************"</span></span>

<span class="token comment">// 显示选择列表</span>
<span class="token keyword">int</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回预定天数</span>
<span class="token keyword">int</span> <span class="token function">getnights</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 计算费用并显示结果</span>
<span class="token keyword">void</span> <span class="token function">showprice</span><span class="token punctuation">(</span><span class="token keyword">double</span> rate<span class="token punctuation">,</span> <span class="token keyword">int</span> nights<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* hotel.c */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hotel.h"</span></span>
<span class="token keyword">int</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> code<span class="token punctuation">,</span> status<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%s\n"</span><span class="token punctuation">,</span> STARS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"enter the number to desired hotel:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1) XXX Hotel1            2) XXX Hotel2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3) XXX Hotel3            4) XXX Hotel4\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"5) Quit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> STARS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>status <span class="token operator">=</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>code <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> code <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%*s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理非整数输入</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter an integer from 1 to 5:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> code<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">getnights</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> nights<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"How many nights are you needed?\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>nights<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%*s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理非整数输入</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter an integer, such as 2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> nights<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">showprice</span><span class="token punctuation">(</span><span class="token keyword">double</span> rate<span class="token punctuation">,</span> <span class="token keyword">int</span> nights<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">double</span> total <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> factor <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">&lt;=</span> nights<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">,</span> factor <span class="token operator">*=</span> DISCOUNT<span class="token punctuation">)</span>
        total <span class="token operator">+=</span> rate <span class="token operator">*</span> factor<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The total cost will be &amp;%0.2f.\n"</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* usehotel.c */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hotel.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> nights<span class="token punctuation">;</span>
    <span class="token keyword">double</span> hotel_rate<span class="token punctuation">;</span>
    <span class="token keyword">int</span> code<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>code <span class="token operator">=</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> QUIT<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>code<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
                hotel_rate <span class="token operator">=</span> HOTEL1<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
                hotel_rate <span class="token operator">=</span> HOTEL2<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
                hotel_rate <span class="token operator">=</span> HOTEL3<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>
                hotel_rate <span class="token operator">=</span> HOTEL4<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Oops!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        nights <span class="token operator">=</span> <span class="token function">getnights</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">showprice</span><span class="token punctuation">(</span>hotel_rate<span class="token punctuation">,</span>nights<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thank you and goodbye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>此外，<strong>函数</strong>也可以<strong>直接定义</strong>在头文件内，因此上述程序写为<strong>单源代码文件</strong>的方式可以<strong>精简如下</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* hotel.h */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> <span class="token comment">// 注意引入头文件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">QUIT</span> <span class="token expression"><span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOTEL1</span> <span class="token expression"><span class="token number">180.00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOTEL2</span> <span class="token expression"><span class="token number">225.00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOTEL3</span> <span class="token expression"><span class="token number">225.00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOTEL4</span> <span class="token expression"><span class="token number">355.00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DISCOUNT</span> <span class="token expression"><span class="token number">0.95</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STARS</span> <span class="token string">"**************************************************"</span></span>

<span class="token comment">// 显示选择列表</span>
<span class="token keyword">int</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> code<span class="token punctuation">,</span> status<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%s\n"</span><span class="token punctuation">,</span> STARS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"enter the number to desired hotel:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1) XXX Hotel1            2) XXX Hotel2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3) XXX Hotel3            4) XXX Hotel4\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"5) Quit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> STARS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>status <span class="token operator">=</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>code <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> code <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%*s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理非整数输入</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter an integer from 1 to 5:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> code<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 返回预定天数</span>
<span class="token keyword">int</span> <span class="token function">getnights</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> nights<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"How many nights are you needed?\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>nights<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%*s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理非整数输入</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter an integer, such as 2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> nights<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 计算费用并显示结果</span>
<span class="token keyword">void</span> <span class="token function">showprice</span><span class="token punctuation">(</span><span class="token keyword">double</span> rate<span class="token punctuation">,</span> <span class="token keyword">int</span> nights<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">double</span> total <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> factor <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">&lt;=</span> nights<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">,</span> factor <span class="token operator">*=</span> DISCOUNT<span class="token punctuation">)</span>
        total <span class="token operator">+=</span> rate <span class="token operator">*</span> factor<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The total cost will be &amp;%0.2f.\n"</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* usehotel.c */</span>
同上例文件，写法不变
此外由于hotel<span class="token punctuation">.</span>h中引入了stdio<span class="token punctuation">.</span>h，而本文件又调用了hotel<span class="token punctuation">.</span>h，所以可以不再调用stdio<span class="token punctuation">.</span>h，即删除本文件的#include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="查找地址：-amp-运算符"><a href="#查找地址：-amp-运算符" class="headerlink" title="查找地址：&amp;运算符"></a><strong>查找地址：&amp;运算符</strong></h4><ul>
<li><p><strong>指针</strong>是 C 语言中<strong>最重要的</strong>(有时也是<strong>最复杂的</strong>)概念之一，用于<strong>存储变量的地址</strong>。前面使用的<code>scanf()</code>函数中就<strong>使用地址作为参数</strong></p>
</li>
<li><p>如果<strong>主调函数</strong>不使用<code>return</code><strong>返回</strong>的值，则必须通过<strong>地址</strong>才能<strong>修改</strong>主调函数中的值</p>
</li>
<li><p><strong>一元</strong><code>&amp;</code><strong>运算符</strong>的用法</p>
<ul>
<li><p><strong>一元</strong><code>&amp;</code><strong>运算符</strong>给出变量的<strong>储存地址</strong>，如果<code>pooh</code>是变量名，那么<code>&amp;pooh</code>是变量的地址。可以把地址看做是<strong>变量在内存中的位置</strong></p>
</li>
<li><p><strong>PC 地址</strong>通常使用<strong>十六进制</strong>表示，<code>%p</code>是输出地址的<strong>转换说明</strong></p>
</li>
<li><p><strong>示例程序</strong>：查看不同函数中同名变量分别储存在什么位置</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">mikado</span><span class="token punctuation">(</span><span class="token keyword">int</span> bah<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> pooh <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In mikado(), pooh= %d and &amp;pooh= %p\n"</span><span class="token punctuation">,</span> pooh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pooh<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In mikado(), bah= %d and &amp;bah= %p\n"</span><span class="token punctuation">,</span> bah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bah<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> pooh <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> bah <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In main(), pooh= %d and &amp;pooh= %p\n"</span><span class="token punctuation">,</span> pooh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pooh<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In main(), bah= %d and &amp;bah= %p\n"</span><span class="token punctuation">,</span> bah<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bah<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mikado</span><span class="token punctuation">(</span>pooh<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">In main(), pooh&#x3D; 2 and &amp;pooh&#x3D; 000000000061FE1C
In main(), bah&#x3D; 5 and &amp;bah&#x3D; 000000000061FE18
In mikado(), pooh&#x3D; 10 and &amp;pooh&#x3D; 000000000061FDDC
In mikado(), bah&#x3D; 2 and &amp;bah&#x3D; 000000000061FDF0</code></pre>
</li>
<li><p><strong>输出解析</strong></p>
<blockquote>
<p>1、两个<strong>pooh</strong>地址不同，两个<strong>bah</strong>的地址也不同，因此证实<strong>计算机</strong>把它们看做<strong>4 个独立的变量</strong><br>2、函数调用<code>mikado(pooh)</code>把<strong>实参 pooh&#x3D;2</strong>传递给了<strong>形参 bah</strong>。注意这种传递<strong>只传递了值</strong>，涉及的<strong>两个变量并未改变</strong><br>3、注意<strong>第 2 点</strong>并非在<strong>所有语言</strong>都成立。如<strong>FORTRAN</strong>中，<strong>子例程</strong>会影响<strong>主调例程</strong>的<strong>原始变量</strong>。子例程<strong>变量名</strong>可能与原始变量<strong>不同</strong>，但它们的<strong>地址相同</strong>。但在 C 中不是这样，每个<strong>C 函数</strong>都有<strong>自己的变量</strong>，这样可以防止<strong>原始变量</strong>被<strong>被调函数</strong>的副作用<strong>意外修改</strong>，但也带来了<strong>一些麻烦</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="更改主调函数中的变量"><a href="#更改主调函数中的变量" class="headerlink" title="更改主调函数中的变量"></a><strong>更改主调函数中的变量</strong></h4><ul>
<li><p>有时需要在<strong>一个函数</strong>中改变<strong>其他函数的变量</strong>，则需要<strong>使用指针</strong></p>
</li>
<li><p><strong>程序示例</strong>(<strong>错误的方式</strong>使用<strong>函数</strong>交换两个变量的<strong>值</strong>)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
    temp <span class="token operator">=</span> u<span class="token punctuation">;</span>
    u <span class="token operator">=</span> v<span class="token punctuation">;</span>
    v <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"u:%d    v:%d\n"</span><span class="token punctuation">,</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before: %d %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">change</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"after: %d %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>问题解析</strong></p>
<blockquote>
<p>1、但显然该程序<code>main()</code>中<strong>x</strong>和<strong>y</strong>的值<strong>并未交换</strong>，而交换函数<code>change()</code>内的<strong>u</strong>和<strong>v</strong>的值是<strong>交换</strong>的。问题出现在把<strong>结果传回</strong><code>main()</code>时。<br>2、<code>change()</code>的变量并不是<code>main()</code>的变量，因此交换的<strong>值</strong>并不会<strong>影响</strong><code>main()</code>中的<strong>值</strong>。<br>3、能否使用<code>return</code><strong>将值传回</strong><code>main()</code>？当然可以，但<code>return</code>只能把<strong>被调函数</strong>中的<strong>一个值</strong>传回，但现在<strong>要传回两个值</strong>，因此需要<strong>使用指针</strong></p>
</blockquote>
</li>
</ul>
<h4 id="指针简介"><a href="#指针简介" class="headerlink" title="指针简介"></a><strong>指针简介</strong></h4><ul>
<li><p><strong>基本概念</strong></p>
<ul>
<li><p><strong>指针</strong>：一个<strong>值</strong>为<strong>内存地址</strong>的<strong>变量</strong>(或数据对象)。正如<strong>char</strong>类型变量<strong>值是字符</strong>，<strong>int</strong>类型变量<strong>值是整数</strong>，<strong>指针</strong>变量的<strong>值是地址</strong></p>
</li>
<li><p>假设一个<strong>指针变量名</strong>是<strong>ptr</strong>，则可以编写<code>ptr = &amp;pooh</code>这条语句</p>
<blockquote>
<p>1、对于这条语句，我们说<strong>ptr 指向 pooh</strong><br>2、<strong>指针 ptr</strong>和<strong>地址 &amp;pooh</strong>的<strong>区别</strong>是，<strong>指针 ptr</strong>是<strong>变量</strong>，<strong>地址 &amp;pooh</strong>是<strong>常量</strong>。或者说，<strong>指针 ptr</strong>是<strong>可修改</strong>的<strong>左值</strong>，<strong>地址 &amp;pooh</strong>是<strong>右值</strong><br>3、我们当然还可以<strong>把 ptr 指向别处</strong>，如<code>ptr = &amp;bah</code>，现在<strong>ptr 指向 bah</strong>，<strong>值</strong>为<strong>bah 的地址</strong></p>
</blockquote>
</li>
<li><p>要创建<strong>指针变量</strong>，要先<strong>声明</strong>指针变量的<strong>类型</strong>。假设想把<strong>ptr</strong>声明为<strong>储存 int 类型变量地址</strong>的指针，就要使用下面介绍的<strong>新运算符</strong></p>
</li>
</ul>
</li>
<li><p><strong>间接运算符：</strong><code>*</code></p>
<blockquote>
<p>1、假设已知<code>ptr = &amp;bah;</code>，即<strong>ptr 指向 bah</strong><br>2、使用<strong>间接运算符</strong><code>*</code>，可以找出<strong>储存在 bah 中</strong>的<strong>值</strong>，语句为：<code>val = *ptr;</code>，意为<strong>找出 ptr 指向的值</strong><br>3、该运算符有时也称为<strong>解引用运算符</strong>。但注意不要将其与<strong>二元乘法运算符</strong>混淆，虽然符号相同，但<strong>语法功能不同</strong><br>4、将语句<code>ptr = &amp;bah</code>和<code>val = *ptr</code><strong>放在一起</strong>，其<strong>功能作用</strong>相当于此<strong>赋值语句</strong>：<code>val = bah;</code><br>5、由此可见，使用<strong>地址</strong>和<strong>间接运算符</strong>可以<strong>间接完成</strong>上面赋值语句的功能，这也是其名称的由来</p>
</blockquote>
</li>
<li><p><strong>声明指针</strong></p>
<ul>
<li><p><strong>声明指针变量示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span> pi<span class="token punctuation">;</span>               <span class="token comment">// 指向int类型变量的指针</span>
<span class="token keyword">char</span> <span class="token operator">*</span> pc<span class="token punctuation">;</span>              <span class="token comment">// 指向char类型变量的指针</span>
<span class="token keyword">float</span> <span class="token operator">*</span> pf<span class="token punctuation">,</span> <span class="token operator">*</span> pg<span class="token punctuation">;</span>       <span class="token comment">// 指向float类型变量的指针</span></code></pre>
</li>
<li><p><strong>声明解析</strong></p>
<blockquote>
<p>1、<strong>类型说明符</strong>表明了指针<strong>所指向对象</strong>的<strong>类型</strong>，<strong>星号</strong>表明<strong>声明的变量</strong>是一个<strong>指针</strong><br>2、<code>*</code>和<strong>指针名</strong>之间的<strong>空格可有可无</strong>，通常在<strong>声明时使用</strong>空格，在<strong>解引用时省略</strong>空格<br>3、<strong>pc 指向的值</strong>(即*pc)是<code>char</code>类型，而<strong>pc 本身的类型</strong>描述为”<strong>指向 char 类型的指针</strong>“<br>4、在大部分系统内部，该<strong>地址</strong>由一个<strong>无符号整数</strong>表示。但<strong>不要</strong>把<strong>指针</strong>认为是<strong>整数类型</strong>，为此，<strong>ANSI C</strong>专门为指针提供了<code>%p</code>的<strong>格式转换说明</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%A3%B0%E6%98%8E%E6%8C%87%E9%92%88.png" loading="lazy"></p>
</li>
</ul>
</li>
<li><p><strong>使用指针在函数间通信</strong></p>
<ul>
<li><p>在上节<strong>改变主调函数中的变量</strong>中的程序，通过<strong>函数</strong>调换两个变量的值不能成功，在此可以<strong>通过指针实现</strong></p>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>u<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
    temp <span class="token operator">=</span> <span class="token operator">*</span>u<span class="token punctuation">;</span>
    <span class="token operator">*</span>u <span class="token operator">=</span> <span class="token operator">*</span>v<span class="token punctuation">;</span>
    <span class="token operator">*</span>v <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before: %d %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"after: %d %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>程序解析</strong></p>
<blockquote>
<p>1、该函数传递的不是<strong>x 和 y</strong>的<strong>值</strong>，而是他们的<strong>地址</strong>。这意味着出现在<code>change()</code><strong>原型和定义</strong>中的<strong>形参 u 和 v</strong>将<strong>地址</strong>作为它们的<strong>值</strong>。因此应把他们声明为<strong>指针</strong>。由于<strong>x 和 y</strong>是<strong>整数</strong>，所以<strong>u 和 v</strong>是<strong>指向整数的指针</strong><br>2、在<strong>函数体</strong>中声明了一个交换值时必需的<strong>临时变量 temp</strong>，通过<code>temp = *u;</code>把<strong>x 的值</strong>存储在<strong>temp</strong>中<br>3、注意，<strong>u 的值</strong>是<code>&amp;x</code>，这意味着可以用<code>*u</code>表示<strong>x 的值</strong>，这正是我们需要的。不要写成<code>temp = u;</code>，该语句意为把<strong>x 的地址</strong>赋给<strong>temp</strong>(u 的值就是 x 的地址)，而<strong>不是 x 的值</strong><br>4、于是，通过这种形式进行交换，就可以做到<strong>修改主调函数的值</strong>的需求了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a><strong>数组与指针</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：数组；数组复习；初始化数组；只读数组；指定初始化器；指定初始化器的特性；数组元素赋值；数组边界；多维数组；二维数组；二维数组的声明；其他多维数组；指针和数组；指针处理数组；函数、数组与指针(声明数组形参)；使用指针形参；指针操作；不要解引用未初始化的指针；保护数组中的数据；对形参使用<code>const</code>；其他<code>const</code>内容；指针和多维数组；通过指针表示二维数组的值；数组指针与指针、多维数组深入；指向多维数组的指针；指针的兼容性；<code>C const</code>和<code>C++ const</code>；函数和多维数组指针；变长数组(VLA)；复合字面量</p>
</blockquote>
</div>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h4><ul>
<li><p><strong>数组复习</strong></p>
<ul>
<li><p><strong>声明示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">float</span> candy<span class="token punctuation">[</span><span class="token number">365</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 内含365个float类型元素的数组</span>
    <span class="token keyword">char</span> code<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// 内含12个char类型元素的数组</span>
    <span class="token keyword">int</span> states<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 内含50个int类型元素的数组</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>数组使用规则</strong></p>
<blockquote>
<p>1、前面介绍过，<strong>数组</strong>由<strong>数据类型相同</strong>的<strong>一系列元素</strong>组成。需要使用<strong>数组</strong>时，通过<strong>声明数组</strong>告诉<strong>编译器</strong>数组内含有<strong>多少元素</strong>和<strong>元素类型</strong>。<strong>编译器</strong>根据这些<strong>信息</strong>正确的<strong>创建数组</strong><br>2、<strong>普通变量</strong>可以使用的<strong>类型</strong>，<strong>数组元素都可以用</strong><br>3、<strong>方括号</strong><code>[]</code>表示<strong>candy</strong>、<strong>code</strong>、<strong>states</strong>都是<strong>数组</strong>，方括号中的<strong>数字</strong>表示数组中的<strong>元素个数</strong><br>4、要<strong>访问</strong>数组中的<strong>元素</strong>，通过使用数组<strong>下标数</strong>(也称为<strong>索引</strong>)<strong>表示</strong>数组中的各个<strong>元素</strong>。数组<strong>元素编号</strong>从<strong>0</strong>开始，所以<code>candy[0]</code>表示<strong>candy</strong>的<strong>第 1 个元素</strong>，<code>candy[364]</code>表示<strong>第 365 个元素</strong>，即<strong>最后一个元素</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>初始化数组</strong></p>
<ul>
<li><p><strong>数组</strong>通常被用来储存程序<strong>需要的数据</strong>。例如，一个内涵<strong>12 个整数元素</strong>的数组可以<strong>储存 12 个月的天数</strong>。这种情况下，在程序<strong>一开始</strong>就<strong>初始化数组</strong>比较好</p>
</li>
<li><p><strong>初始化数组的方法</strong></p>
<ul>
<li><p>只<strong>存储单个值</strong>的<strong>变量</strong>有时也称为<strong>标量变量</strong>，我们已经<strong>很熟悉</strong>如何<strong>初始化</strong>这种变量(代码中<strong>PI</strong>已被定义为<strong>宏</strong>)：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fix <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> flax <span class="token operator">=</span> PI <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>而 C 使用<strong>新的语法</strong>来<strong>初始化数组</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> power<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>       <span class="token comment">// ANSI C开始支持这种初始化</span></code></pre>
</li>
<li><p><strong>语法解析</strong></p>
<blockquote>
<p>1、如上所示，用以<strong>逗号分隔</strong>的<strong>值列表</strong>(用<strong>花括号</strong>括起来)来<strong>初始化数组</strong>，<strong>各值之间</strong>用<strong>逗号分隔</strong>(逗号和值之间可以使用空格)<br>2、根据上面的<strong>初始化</strong>，把<strong>1</strong>赋给数组<strong>首元素 power[0]<strong>，</strong>2</strong>赋给<strong>power[1]<strong>，</strong>按序</strong>以此类推(注意 64 赋给的末元素是 power[7])<br>3、不支持<strong>ANSI C</strong>的编译器会把这种<strong>初始化</strong>识别为错误，在<strong>数组声明前</strong>加上关键字<code>static</code>即可解决(12 章将讨论此关键字)</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>使用 const 声明数组</strong></p>
<blockquote>
<p>1、有时需要把<strong>数组</strong>设置为<strong>只读</strong>，这样<strong>只能</strong>从数组中<strong>检索值</strong>，不能把<strong>新值写入</strong><br>2、要<strong>创建只读数组</strong>，应该用<code>const</code>声明和初始化数组，即<code>const int days[12] = &#123;..., ..., ...&#125;</code><br>3、这样修改后，程序在<strong>运行过程中</strong>就<strong>不能修改数组的内容</strong>。一旦声明为<code>const</code>，便<strong>不能</strong>再给它<strong>赋值</strong></p>
</blockquote>
</li>
<li><p><strong>自动适配数组大小</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> days<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>days<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>days<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Month %2d has %d days.\n"</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> days<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>注意事项</strong></p>
<blockquote>
<p>1、 使用数组前<strong>必须先初始化</strong>。与普通变量类似，在使用<strong>数组元素</strong>前<strong>必须</strong>先给它们<strong>赋初值</strong>，否则<strong>编译器</strong>使用的值是<strong>内存相应位置上的现有值</strong>(即都是<strong>垃圾值</strong>，会干扰程序运行)。只要<strong>初始化</strong>至少<strong>1 个元素</strong>的值，其余<strong>未初始化</strong>的值也会被<strong>初始化为 0</strong><br>2、如果<strong>初始化数组</strong>时<strong>省略</strong>方括号中的<strong>数字</strong>，<strong>编译器</strong>会根据<strong>初始化列表</strong>中的<strong>项数</strong>来确定<strong>数组大小</strong>(如上”自动适配数组大小”)<br>3、使用<code>sizeof()</code>计算<strong>数组大小</strong>(<strong>字节</strong>)时，<code>sizeof(days)</code>是<strong>整个数组</strong>的大小，<code>sizeof(days[0])</code>是数组中<strong>一个元素</strong>的大小</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>指定初始化器</strong></p>
<ul>
<li><p><strong>C99</strong>新增加了一个<strong>新特性</strong>：<strong>指定初始化器</strong>。利用该特性可以<strong>初始化指定的数组元素</strong>。例如只初始化<strong>最后一个元素</strong></p>
<blockquote>
<p>1、传统 C 初始化：<code>int arr[6] = &#123;0, 0, 0, 0, 0, 212&#125;;</code><br>2、<strong>C99</strong>规定，可以在<strong>初始化列表</strong>中使用带<strong>方括号</strong>的<strong>下标</strong>指明<strong>待初始化的元素</strong>：<code>int arr[6] = &#123; [5] = 212 &#125;;</code></p>
</blockquote>
</li>
<li><p><strong>复杂示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"index:%-3d    value:%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">index:0      value:31
index:1      value:29
index:2      value:0
index:3      value:0
index:4      value:31
index:5      value:30
index:6      value:31
index:7      value:0
index:8      value:0
index:9      value:0
index:10     value:0
index:11     value:0</code></pre>
</li>
<li><p><strong>特性解析</strong></p>
<blockquote>
<p>1、以上输出揭示了<strong>指定初始化器</strong>的<strong>两个重要特性</strong><br>2、如果<strong>指定初始化器</strong>后面有<strong>更多值</strong>，如该例<code>[4] = 31, 30, 31</code>，那么<strong>后面的值</strong>将被用于<strong>初始化指定元素后面的元素</strong>(即 arr[5]和 arr[6]被初始化为 30 和 31)<br>3、如果<strong>再次初始化</strong>指定元素，那么<strong>最后的初始化</strong>将会<strong>取代之前的初始化</strong>(如 arr[1]先被初始化为 28，后被指定初始化<code>[1] = 29</code>初始化为 29)<br>4、如果未指定元素大小，如<code>int arr[] = &#123;1, [6]=4, 9, 10&#125;;</code>，编译器将会把<strong>数组大小</strong>设置为<strong>足够装得下初始化</strong>的值(即该例下标应为 0~8，共 9 个元素)</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>数组元素赋值</strong></p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    arr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>示例解析</strong></p>
<blockquote>
<p>1、声明<strong>数组</strong>后，可以借助<strong>数组下标</strong>给数组元素<strong>赋值</strong>，如已定义<code>int arr[20];</code>则可使用<code>arr[6] = 10;</code>来赋值对应元素<br>2、注意<strong>多个元素</strong>赋值应通过<strong>循环遍历依次赋值</strong>。C<strong>不允许</strong>把<strong>数组</strong>作为一个单元<strong>赋给另一个数组</strong>，<strong>初始化外</strong>也<strong>不允许</strong>使用<strong>花括号列表</strong>赋值</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>数组边界</strong></p>
<blockquote>
<p>1、在<strong>使用数组</strong>时，要防止数组<strong>下标越界</strong>，必须确保<strong>下标</strong>是<strong>有效的值</strong><br>2、假设有<code>int doofi[20];</code>的<strong>声明</strong>，则使用时数组<strong>下标</strong>应在<strong>0~19 的范围内</strong><br>3、编译器<strong>不会检查</strong>这种错误，但是一些编译器会<strong>发出警告</strong>，然后<strong>继续编译</strong>程序<br>4、在 C 标准中，使用<strong>越界下标</strong>的结果是<strong>未定义</strong>的。这意味着程序可能<strong>看上去可以运行</strong>，但是运行<strong>结果很奇怪</strong>，或<strong>异常终止</strong><br>5、C 语言为什么会允许这种事发生？这要归功于<strong>C 信任程序员</strong>的原则。编译器没必要<strong>捕获所有</strong>的<strong>下标错误</strong>，这会<strong>降低运行速度</strong>；C 相信程序员能<strong>编写正确的代码</strong>，<strong>不检查边界</strong>，这样程序<strong>运行速度更快</strong></p>
</blockquote>
</li>
</ul>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a><strong>多维数组</strong></h4><ul>
<li><p><strong>概念引入与分析</strong></p>
<blockquote>
<p>1、假如需要记录<strong>5 年内每个月</strong>的降水量，应该如何更方便的储存数据？<br>2、第一种方案，创建<strong>60 个变量</strong>，分别储存每个月的数据。但显然<strong>十分麻烦</strong><br>3、第二种方案，使用<strong>内涵 60 个元素的数组</strong>，<strong>每个元素</strong>恰好表示<strong>每月的数据</strong>。这种更加可行，但<strong>无法分辨年份</strong><br>4、第三种方案，创建<strong>5 个分别内涵 12 个元素的数组</strong>，以此分辨年份。但这种方案也<strong>很麻烦</strong>，且<strong>不能满足更多年份</strong>的需求<br>5、第四种方案，使用<strong>二维数组</strong>，下面介绍此种方案</p>
</blockquote>
</li>
<li><p><strong>二维数组</strong></p>
<ul>
<li>结合上例，可以将<strong>二维数组</strong>理解为<strong>数组的数组</strong>。<strong>主数组</strong>有<strong>5 个元素</strong>(表示 5 年)，这 5 个元素<strong>每个元素</strong>都是<strong>内涵 12 个元素的数组</strong>(表示每年 12 个月)</li>
</ul>
</li>
<li><p><strong>二维数组的声明</strong></p>
<blockquote>
<p>1、使用<code>float rain[5][12]</code><strong>声明</strong>符合本需求的<strong>二维数组</strong><br>2、分开来看，<code>rain[5]</code>表示数组<strong>rain 有 5 个元素</strong>，至于<strong>每个元素</strong>的情况，要看<strong>声明的其余部分</strong><br>3、<code>float</code>和<code>[12]</code>说明<strong>每个元素的类型</strong>是<strong>float[12]<strong>。即</strong>rain 的每个元素</strong>本身都是一个<strong>内含 12 个 float 类型值</strong>的<strong>数组</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.png" loading="lazy"></p>
</li>
<li><p><strong>示例程序(十分重要，请理解代码，教程夹杂在代码中)</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MONTHS</span> <span class="token expression"><span class="token number">12</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">YEARS</span> <span class="token expression"><span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LINE</span> <span class="token string">"========================================================="</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 声明二维数组并初始化(这样初始化换行为了方便查看，也可以按规定格式写在一行)</span>
    <span class="token keyword">float</span> rain<span class="token punctuation">[</span>YEARS<span class="token punctuation">]</span><span class="token punctuation">[</span>MONTHS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span><span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">2.4</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">,</span> <span class="token number">6.6</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span><span class="token number">8.5</span><span class="token punctuation">,</span> <span class="token number">8.2</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">,</span> <span class="token number">2.4</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">5.2</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token number">1.4</span><span class="token punctuation">,</span> <span class="token number">7.3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span><span class="token number">9.1</span><span class="token punctuation">,</span> <span class="token number">8.5</span><span class="token punctuation">,</span> <span class="token number">6.7</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">2.1</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token number">6.1</span><span class="token punctuation">,</span> <span class="token number">8.4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span><span class="token number">7.2</span><span class="token punctuation">,</span> <span class="token number">9.9</span><span class="token punctuation">,</span> <span class="token number">8.4</span><span class="token punctuation">,</span> <span class="token number">3.3</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token number">1.7</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token number">6.2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span><span class="token number">7.6</span><span class="token punctuation">,</span> <span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token number">3.8</span><span class="token punctuation">,</span> <span class="token number">2.8</span><span class="token punctuation">,</span> <span class="token number">3.8</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">2.6</span><span class="token punctuation">,</span> <span class="token number">5.2</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> year<span class="token punctuation">,</span> month<span class="token punctuation">;</span>
    <span class="token keyword">float</span> subtot<span class="token punctuation">,</span> total<span class="token punctuation">;</span>

    <span class="token comment">/* 输出年总降水与年均降水 */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> LINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"年份               降水量(英尺)\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// year遍历年份，total计算所有年份(5年)总降水量</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>year <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> year <span class="token operator">&lt;</span> YEARS<span class="token punctuation">;</span> year<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// month遍历月份，subtot计算每年总降水量</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>month <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> subtot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> month <span class="token operator">&lt;</span> MONTHS<span class="token punctuation">;</span> month<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            subtot <span class="token operator">+=</span> rain<span class="token punctuation">[</span>year<span class="token punctuation">]</span><span class="token punctuation">[</span>month<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4d %20.1f\n"</span><span class="token punctuation">,</span> <span class="token number">2018</span> <span class="token operator">+</span> year<span class="token punctuation">,</span> subtot<span class="token punctuation">)</span><span class="token punctuation">;</span>
        total <span class="token operator">+=</span> subtot<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"年均降水：%.1f\n"</span><span class="token punctuation">,</span> total <span class="token operator">/</span> YEARS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> LINE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 输出降水详情 */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>year <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> year <span class="token operator">&lt;</span> YEARS<span class="token punctuation">;</span> year<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token number">2018</span> <span class="token operator">+</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>month <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> month <span class="token operator">&lt;</span> MONTHS<span class="token punctuation">;</span> month<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.1f "</span><span class="token punctuation">,</span> rain<span class="token punctuation">[</span>year<span class="token punctuation">]</span><span class="token punctuation">[</span>month<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> LINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
年份               降水量(英尺)
2018                 32.4
2019                 37.9
2020                 49.8
2021                 44.0
2022                 32.9
年均降水：39.4
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
2018 4.3 4.3 4.3 3.0 2.0 1.2 0.2 0.2 0.4 2.4 3.5 6.6
2019 8.5 8.2 1.2 1.6 2.4 0.0 5.2 0.9 0.3 0.9 1.4 7.3
2020 9.1 8.5 6.7 4.3 2.1 0.8 0.2 0.2 1.1 2.3 6.1 8.4
2021 7.2 9.9 8.4 3.3 1.2 0.8 0.4 0.0 0.6 1.7 4.3 6.2
2022 7.6 5.6 3.8 2.8 3.8 0.2 0.0 0.0 0.0 1.3 2.6 5.2
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</code></pre>
</li>
<li><p><strong>其他多维数组</strong></p>
<ul>
<li>前面讨论的<strong>二维数组</strong>相关内容都<strong>适用</strong>于<strong>三维数组</strong>或<strong>更多维的数组</strong>。例如可以通过<code>int box[10][20][30];</code><strong>声明一个三维数组</strong></li>
<li>同样面对<strong>更多维的数组</strong>，需要<strong>更多的循环嵌套</strong>来<strong>遍历</strong>，理解好<strong>每层循环</strong>所<strong>控制的元素</strong>，才能够<strong>准确地操控数组</strong></li>
<li>实际使用中，更多维的数组<strong>出现概率不高</strong>，通常只需要<strong>二维数组</strong>就能完成<strong>大多数需求</strong></li>
</ul>
</li>
</ul>
<h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a><strong>指针和数组</strong></h4><ul>
<li><p>第 9 章介绍过指针，指针提供一种<strong>以符号形式使用地址</strong>的方法。因为计算机的<strong>硬件指令</strong>非常<strong>依赖地址</strong>，指针在某种程度上把程序员想要<strong>传达的指令</strong>以<strong>更接近机器</strong>的方式表达，因此<strong>使用指针</strong>的程序<strong>很有效率</strong>。</p>
</li>
<li><p><strong>指针处理数组</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>指针</strong>能有效地<strong>处理数组</strong>，<strong>数组表示法</strong>其实是在<strong>变相地使用指针</strong><br>2、举个简单的例子，<strong>数组名</strong>是数组的<strong>首元素地址</strong>，即<code>arr == &amp;arr[0]</code>成立<br>3、两者都是<strong>常量</strong>，运行过程中<strong>不会改变</strong>。但是可以将它们<strong>赋值</strong>给<strong>指针变量</strong>，然后可以<strong>修改指针变量的值</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">4</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">short</span> dates<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">short</span> <span class="token operator">*</span>pti<span class="token punctuation">;</span>
    <span class="token keyword">double</span> bills<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> <span class="token operator">*</span>ptf<span class="token punctuation">;</span>
    pti <span class="token operator">=</span> dates<span class="token punctuation">;</span> <span class="token comment">// 把数组地址赋给指针，数组名是数组首元素地址</span>
    ptf <span class="token operator">=</span> bills<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%23s %15s\n"</span><span class="token punctuation">,</span> <span class="token string">"short"</span><span class="token punctuation">,</span> <span class="token string">"double"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> SIZE<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pointers + %d: %10p %10p\n"</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> pti <span class="token operator">+</span> index<span class="token punctuation">,</span> ptf <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">                  short          double
pointers + 0: 000000000061FE00 000000000061FDE0
pointers + 1: 000000000061FE02 000000000061FDE8
pointers + 2: 000000000061FE04 000000000061FDF0
pointers + 3: 000000000061FE06 000000000061FDF8</code></pre>
</li>
<li><p><strong>程序解析</strong></p>
<blockquote>
<p>1、第 2 行起打印<strong>两个数组的地址</strong>，下一行打印的是<strong>指针+1 后的地址</strong>。地址为<strong>十六进制</strong>，因此<strong>DF</strong>比<strong>DE</strong>大<br>2、系统中，地址<strong>按字节编址</strong>。<strong>short</strong>占<strong>2 字节</strong>，<strong>double</strong>占<strong>8 字节</strong>。在 C 中，<strong>地址+1</strong>指的是增加一个<strong>存储单元</strong>。对<strong>数组</strong>而言，这意味着<strong>地址+1 后</strong>是<strong>下一个元素的地址</strong>，而不是<strong>下一个字节的地址</strong><br>3、这便是为何必须<strong>声明指针所指向的对象类型</strong>的原因之一。只知道<strong>地址</strong>不够，还需要知道<strong>储存对象</strong>需要<strong>多少字节</strong>，否则指针<strong>无法正确取回</strong>地址上的<strong>值</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88.png" loading="lazy"></p>
</li>
<li><p><strong>特性总结补充</strong></p>
<blockquote>
<p>1、<strong>指针的值</strong>是<strong>它所指向对象的地址</strong>。地址的表示方式依赖于计算机内部的硬件，大部分都是<strong>按字节编址</strong>，即内存中<strong>每个字节</strong>都<strong>按顺序编号</strong>。一个<strong>较大对象</strong>(如 double 的 8 字节)的地址通常是<strong>第一个字节的地址</strong><br>2、在指针前面使用<code>*</code><strong>运算符</strong>可以得到该指针<strong>所指向对象的值</strong><br>3、<strong>指针+1</strong>，指针的值<strong>递增</strong>它<strong>所指向类型的大小</strong>(字节为单位)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="函数、数组与指针-声明数组形参"><a href="#函数、数组与指针-声明数组形参" class="headerlink" title="函数、数组与指针(声明数组形参)"></a><strong>函数、数组与指针(声明数组形参)</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、假设要编写一个<strong>处理数组的函数</strong>，该函数<strong>返回数组中所有元素之和</strong><br>2、此时注意，由于<strong>数组名</strong>是数组<strong>首元素地址</strong>，所以<strong>实参</strong>是一个<strong>存储对应类型值的地址</strong>而不是<strong>数值</strong>，因此<strong>传参时</strong>应把它赋给一个<strong>指针形式参数</strong>，即<strong>形参</strong>应为<strong>指向对应类型的指针</strong><br>3、此时<strong>函数</strong>获得了该数组<strong>首元素的地址</strong>，且知道需要找出的<strong>值的数据类型</strong>，但并未获得<strong>数组元素个数</strong>，有两种方法：一种方式可以在函数中需要时直接<strong>人为写入数组元素个数</strong>(比如<code>for</code>遍历时的条件直接写入元素个数)来告知此信息，但这样<strong>不利于维护</strong>；另一种方式是<strong>创建形参</strong>，将<strong>元素个数</strong>也<strong>传入函数</strong>中</p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">10</span></span></span>

<span class="token comment">// 此处也可写为：</span>
<span class="token comment">// int def(int * ar, int n)</span>
<span class="token keyword">int</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        sum <span class="token operator">+=</span> ar<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ar的大小是 %zd bytes\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">39</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> answer<span class="token punctuation">;</span>
    answer <span class="token operator">=</span> <span class="token function">def</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数值相加为 %d\n"</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"arr的大小是 %zd bytes\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">ar的大小是 8 bytes
数值相加为 190
arr的大小是 40 bytes</code></pre>
</li>
<li><p><strong>程序解析</strong></p>
<blockquote>
<p>1、函数<strong>第 1 个形参</strong>告诉函数<strong>数组地址</strong>与<strong>数据类型</strong>，<strong>第 2 个形参</strong>告诉函数数组的<strong>元素个数</strong><br>2、只有在<strong>函数原型</strong>或<strong>函数定义头</strong>时，才可以用<code>int ar[]</code>代替<code>int * ar</code>(某些编译器可能对于前者会报警报 warning)。在这种情况下，<code>int * ar</code>与<code>int ar[]</code>都表示<strong>ar</strong>是一个<strong>指向 int 的指针</strong>，但是<code>int ar[]</code>只能用于<strong>声明形参</strong>。<code>int ar[]</code>提醒读者，不仅是一个<strong>int 类型值</strong>，还是一个<strong>int 类型数组的元素</strong><br>3、<strong>arr</strong>大小是<strong>40 字节</strong>，因为其<strong>内含 10 个 int 类型值</strong>。<strong>ar</strong>只有<strong>8 字节</strong>，因为其是指向<strong>arr</strong>数组首元素的<strong>指针</strong>，<strong>我们的系统</strong>使用<strong>8 字节存储地址</strong>(其他系统可能不同)，所以<strong>指针变量大小</strong>是<strong>8 字节</strong></p>
</blockquote>
</li>
<li><p><strong>声明数组形参</strong></p>
<ul>
<li><p>因为<strong>数组名</strong>是该数组<strong>首元素的地址</strong>，作为<strong>实参</strong>的<strong>数组名</strong>要求<strong>形参</strong>是一个<strong>与之相配的指针</strong>。只有这种情况下，C 才会把<code>int ar[]</code>和<code>int * ar</code>解释成一样</p>
</li>
<li><p>注意上方<strong>示例程序</strong>的<strong>函数原型</strong>与<strong>函数定义</strong>写在一起，因此对于下方的解释，应按照<strong>函数定义</strong>标准，而非<strong>函数原型</strong>标准</p>
</li>
<li><p>由于<strong>函数原型</strong>可以<strong>省略参数名</strong>，所以<strong>下面 4 种原型等价</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> ar<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>函数定义</strong>中<strong>不能省略参数名</strong>，因此只有<strong>下面 2 种的定义等价</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> ar<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 省略函数内代码</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 省略函数内代码</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="使用指针形参"><a href="#使用指针形参" class="headerlink" title="使用指针形参"></a><strong>使用指针形参</strong></h4><ul>
<li><p>函数要<strong>处理数组</strong>必须知道何时<strong>开始</strong>、何时<strong>结束</strong>。上节已展示一种方式<strong>标识函数开始与元素个数</strong>，而这并非唯一途径。第二种方式是<strong>传递两个指针</strong>，一个表明<strong>数组开始处</strong>，一个表明<strong>数组结束处</strong></p>
</li>
<li><p><strong>程序示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">10</span></span></span>

<span class="token keyword">int</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        sum <span class="token operator">+=</span> <span class="token operator">*</span>start<span class="token punctuation">;</span>
        start<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">39</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> answer<span class="token punctuation">;</span>
    answer <span class="token operator">=</span> <span class="token function">def</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr <span class="token operator">+</span> SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数值相加为 %d"</span><span class="token punctuation">,</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>程序解析</strong></p>
<blockquote>
<p>1、指针<strong>start</strong>开始指向<strong>arr</strong>数组的首元素地址，所以赋值表达式<code>sum += *start</code>把<strong>首元素的值</strong>加给<strong>sum</strong>(前面讲过<code>*指针变量</code>表示获取对应地址的<strong>值</strong>)<br>2、表达式<code>start++</code><strong>递增</strong>指针变量<strong>start</strong>，使其指向数组<strong>下一个元素</strong>(前面讲过<strong>指针递增 1</strong>相当于<strong>递增对应类型的大小</strong>，此处即为<strong>递增 int 类型的大小</strong>)<br>3、程序的<code>while</code>循环，使用<strong>第二个指针 end</strong>来设定范围，告知函数<strong>数组的大小</strong><br>4、<code>while</code>循环的条件使用了<strong>小于</strong>，即循环处理的<strong>最后一个元素</strong>是<strong>end</strong>所指向位置的<strong>前一个元素</strong>。这是由于<strong>end</strong>(<code>arr + SIZE</code>)指向的位置实际是<strong>数组最后一个元素</strong>(arr[9])的<strong>后面</strong>(并不存在的 arr[10])，本机测试时<code>arr[9]</code>地址尾缀<strong>fe14</strong>，<strong>end</strong>尾缀<strong>fe18</strong>。C 保证在给数组<strong>分配空间</strong>时，<strong>指向</strong>数组<strong>后面第一个位置</strong>的指针仍是<strong>有效的指针</strong><br>5、因此结合<strong>第 4 条</strong>，如果按照<strong>常规逻辑</strong>，<strong>end</strong>应被传入<code>arr + SIZE -1</code>以正确<strong>指向最后的元素</strong><code>arr[9]</code>。只是这种写法既不简洁也不好记，于是使用了上面的写法</p>
</blockquote>
</li>
</ul>
<h4 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a><strong>指针操作</strong></h4><ul>
<li><p>可以对指针进行哪些操作？C 提供一些基本的<strong>指针操作</strong>，下面的程序演示一些不同的操作</p>
</li>
<li><p><strong>程序示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> urn<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">,</span> <span class="token operator">*</span>ptr3<span class="token punctuation">;</span>

    ptr1 <span class="token operator">=</span> urn<span class="token punctuation">;</span>     <span class="token comment">// 把一个地址赋给指针</span>
    ptr2 <span class="token operator">=</span> <span class="token operator">&amp;</span>urn<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 把第一个地址赋给指针</span>

    <span class="token comment">// 1.解引用指针，以及获得指针的地址</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1. ptr1 = %p, *ptr1 = %d, &amp;ptr1 = %p\n"</span><span class="token punctuation">,</span> ptr1<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2.指针加法</span>
    ptr3 <span class="token operator">=</span> ptr1 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2. ptr1+4 = %p, *(ptr1+4) = %d\n"</span><span class="token punctuation">,</span> ptr1 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr1 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3.指针递增</span>
    ptr1<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3. ptr1 = %p, *ptr1 = %d, &amp;ptr1 = %p\n"</span><span class="token punctuation">,</span> ptr1<span class="token punctuation">,</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 4.指针递减</span>
    ptr2<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"4. ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\n"</span><span class="token punctuation">,</span> ptr2<span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">--</span>ptr1<span class="token punctuation">;</span> <span class="token comment">// 恢复初始值</span>
    <span class="token operator">++</span>ptr2<span class="token punctuation">;</span> <span class="token comment">// 恢复初始值</span>

    <span class="token comment">// 5.指针减另一个指针</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"5. ptr2 = %p, ptr1 = %p, ptr2-ptr1 = %td\n"</span><span class="token punctuation">,</span> ptr2<span class="token punctuation">,</span> ptr1<span class="token punctuation">,</span> ptr2 <span class="token operator">-</span> ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 6.指针减一个整数</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"6 .ptr3 = %p, ptr3-2 = %p\n"</span><span class="token punctuation">,</span> ptr3<span class="token punctuation">,</span> ptr3 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">1. ptr1 &#x3D; 000000000061FE00, *ptr1 &#x3D; 100, &amp;ptr1 &#x3D; 000000000061FDF8
2. ptr1+4 &#x3D; 000000000061FE10, *(ptr1+4) &#x3D; 500
3. ptr1 &#x3D; 000000000061FE04, *ptr1 &#x3D; 200, &amp;ptr1 &#x3D; 000000000061FDF8
4. ptr2 &#x3D; 000000000061FE04, *ptr2 &#x3D; 200, &amp;ptr2 &#x3D; 000000000061FDF0
5. ptr2 &#x3D; 000000000061FE08, ptr1 &#x3D; 000000000061FE00, ptr2-ptr1 &#x3D; 2
6. ptr3 &#x3D; 000000000061FE10, ptr3-2 &#x3D; 000000000061FE08</code></pre>
</li>
<li><p><strong>指针变量的基本操作</strong></p>
<ul>
<li><p><strong>赋值</strong></p>
<blockquote>
<p>1、可以把<strong>地址</strong>赋给<strong>指针</strong>。例如，用<strong>数组名</strong>、<strong>带地址运算符的变量名</strong>(&amp;a)、<strong>另一个指针</strong>等进行赋值<br>2、该例中，urn 数组的<strong>首地址</strong>赋给<strong>ptr1</strong>，其地址编号尾号<strong>FE00</strong>，变量<strong>ptr2</strong>获得数组 urn 的<strong>第 3 个元素的地址</strong>，即<code>urn[2]</code>的地址</p>
</blockquote>
</li>
<li><p><strong>解引用</strong></p>
<blockquote>
<p>1、<code>*</code><strong>运算符</strong>给出指针<strong>指向地址</strong>上<strong>储存的值</strong><br>2、因此，<strong>*ptr</strong>的初值是<strong>100</strong>，该值储存在编号尾号<strong>FE00</strong>的<strong>地址</strong>上</p>
</blockquote>
</li>
<li><p><strong>取址</strong></p>
<blockquote>
<p>1、和所有变量一样，<strong>指针变量</strong>也有自己的<strong>地址</strong>和<strong>值</strong>。对指针而言，<code>&amp;</code><strong>运算符</strong>给出<strong>指针本身</strong>的<strong>地址</strong><br>2、该例中，<strong>ptr1</strong>储存在内存编号尾号<strong>FDF8</strong>的地址上，其<strong>值</strong>为编号尾号<strong>FE00</strong>的地址(即 urn 的地址)<br>3、因此，<code>&amp;ptr1</code>是指向<strong>ptr1</strong>的指针，<strong>ptr1</strong>是指向<code>urn[0]</code>的指针</p>
</blockquote>
</li>
<li><p><strong>指针和整数相加</strong></p>
<blockquote>
<p>1、可以使用<code>+</code><strong>运算符</strong>把<strong>指针和整数相加</strong>，或者<strong>整数和指针相加</strong><br>2、无论哪种情况，<strong>整数</strong>都会和指针<strong>所指向类型的大小</strong>(字节为单位)<strong>相乘</strong>，再与初始地址相加<br>3、因此<code>ptr1 + 4</code>与<code>&amp;urn[4]</code>等价。如果结果<strong>超出数组范围</strong>，计算结果是<strong>未定义的</strong>，除非<strong>超出数组末尾第一个位置</strong>(前面讲过，C 保证该指针有效)</p>
</blockquote>
</li>
<li><p><strong>指针减去一个整数</strong></p>
<blockquote>
<p>1、可以使用<code>-</code><strong>运算符</strong>从一个<strong>指针</strong>减去一个<strong>整数</strong>。<strong>指针</strong>必须是<strong>第 1 个运算对象</strong>，<strong>整数</strong>是<strong>第 2 个运算对象</strong><br>2、其<strong>运算规则</strong>与<strong>指针+整数</strong>相同</p>
</blockquote>
</li>
<li><p><strong>递增指针</strong></p>
<blockquote>
<p>1、<strong>递增</strong>指向<strong>数组的元素</strong>的<strong>指针</strong>可以让该指针<strong>移动</strong>到数组<strong>下一元素</strong><br>2、因此，<code>ptr1++</code>相当于<strong>把 ptr1 的值+4</strong>(因为本系统 int 为 4 字节)，<strong>ptr1</strong>指向<code>urn[1]</code><br>3、注意程序中还输出了<strong>ptr1 的地址</strong>，其并<strong>未发生变化</strong>。，因为指针变量也是变量，变量<strong>不会</strong>因为<strong>值发生变化</strong>就<strong>移动位置</strong></p>
</blockquote>
</li>
<li><p><strong>递减指针</strong></p>
<blockquote>
<p>1、当然，除了递增指针，还可以<strong>递减指针</strong><br>2、其<strong>使用方法</strong>与<strong>递增指针</strong>相同</p>
</blockquote>
</li>
<li><p><strong>指针求差</strong></p>
<blockquote>
<p>1、可以计算<strong>两个指针</strong>的<strong>差值</strong>。通常，求差的两个指针分别指向<strong>同一个数组的不同元素</strong>，通过计算求出<strong>两元素之间的距离</strong>。<strong>差值的单位</strong>与<strong>数组类型单位</strong>相同<br>2、该例中，<code>ptr2 - ptr1 = 2</code>意为这两个指针所指向的<strong>两个元素</strong>相隔<strong>2 个 int</strong>，而<strong>不是 2 字节</strong><br>3、只要两个指针都指向<strong>相同的数组</strong>，C 都能保证<strong>运算有效</strong>。如果指向<strong>不同数组</strong>，求差运算可能会<strong>得出一个值</strong>，或者导致<strong>运行时错误</strong></p>
</blockquote>
</li>
<li><p><strong>比较</strong></p>
<blockquote>
<p>1、使用<strong>关系运算符</strong>可以<strong>比较两个指针的值</strong>，前提是它们<strong>指向相同类型的对象</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>不要解引用未初始化的指针</strong></p>
<ul>
<li><p><strong>注意事项</strong>：千万<strong>不要</strong>解引用<strong>未初始化</strong>的指针，如下：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">;</span>    <span class="token comment">// 未初始化的指针</span>
<span class="token operator">*</span>pt <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">// 严重的错误</span></code></pre>
</li>
<li><p><strong>原因说明</strong></p>
<blockquote>
<p>1、为何不行？<strong>第 2 行</strong>的意思是<strong>把 5 存储在 pt 指向的位置</strong>。但<strong>pt 未初始化</strong>，其<strong>值</strong>是一个<strong>随机值</strong>，所以不知道 5 将<strong>存储在何处</strong><br>2、这可能不会出什么错，也可能会<strong>擦写数据或代码</strong>，或者<strong>导致程序崩溃</strong><br>3、<strong>创建</strong>一个<strong>指针</strong>时，系统只分配了<strong>储存指针本身</strong>的内存，并未分配<strong>存储数据</strong>的内存。因此<strong>使用指针</strong>前，必须先用<strong>已分配</strong>的地址<strong>初始化</strong>它</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="保护数组中的数据"><a href="#保护数组中的数据" class="headerlink" title="保护数组中的数据"></a><strong>保护数组中的数据</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、编写一个<strong>处理基本类型</strong>的<strong>函数</strong>时，需要选择是传递<strong>值</strong>还是<strong>指针</strong>。通常都是传递<strong>数值</strong>，只有程序需要在函数内<strong>改变该值</strong>时，才会传递<strong>指针</strong><br>2、对于<strong>数组</strong>别无选择，<strong>必须</strong>传递<strong>指针</strong>。因为这样<strong>效率更高</strong>，如果<strong>按值传递</strong>，则必须分配足够空间将值<strong>拷贝</strong>到<strong>新数组</strong>中<br>3、C 通常<strong>按值传递</strong>数据，这样可以保证<strong>数据</strong>的<strong>完整性</strong>，使用的是原始数据的<strong>副本</strong>而非原始数据<strong>本身</strong>，这样便可以<strong>保护原数据</strong>。但对于数组，我们需要一种方式来保护数组中的数据</p>
</blockquote>
</li>
<li><p><strong>对形参使用 const</strong></p>
<blockquote>
<p>1、如果函数的意图不是<strong>修改</strong>数组中的<strong>数据内容</strong>，那么<strong>函数原型</strong>和<strong>函数定义</strong>可以使用<strong>只读</strong>——<code>const</code><strong>关键字</strong><br>2、<code>const</code>告诉编译器，函数<strong>不能修改</strong>指针<strong>指向的数组</strong>的内容。如若使用<code>arr[i]++</code>这样的表达式会<strong>生成错误信息</strong><br>3、函数声明例如<code>void def(const int ar[])</code>，这样便可以<strong>保护数组的数据</strong></p>
</blockquote>
</li>
<li><p><strong>其他 const 内容</strong></p>
<ul>
<li><p><strong>其他 const 的使用</strong></p>
<blockquote>
<p>1、之前我们使用<code>const</code><strong>创建</strong>过<strong>变量</strong>。虽然使用<code>#define</code>也能<strong>创建符号常量</strong>，但<code>const</code>更为灵活，可以创建<code>const</code>数组、<code>const</code>指针和指向<code>const</code>的指针。<br>2、下面举例(<strong>默认已声明</strong><code>int arr[5];</code>)<br>3、如指向<code>const</code>的<strong>指针</strong>：<code>const int *ptr = arr;</code>，将<strong>不允许通过 ptr 修改</strong>指向数据的值。但注意<strong>arr</strong>并未被声明为<code>const</code>，所以仍可<strong>通过 arr 修改</strong>元素的值：<code>arr[0] = 10;</code>。此外也可以<strong>让 ptr 指向别处</strong>：<code>ptr++; // 指向arr[1]</code><br>4、此外可以声明并初始化一个<strong>不能指向别处</strong>的<code>const</code><strong>指针</strong>，特别注意<code>const</code><strong>的位置</strong>：<code>int * const ptr = arr;</code>。<strong>可以</strong>用这种指针<strong>修改指向的值</strong>，但<strong>不能更改</strong>它<strong>指向的地址</strong><br>5、如果创建指针时<strong>使用两次</strong><code>const</code>，这样便既<strong>不能修改指向地址的数据</strong>也<strong>不能修改指向的地址</strong>：<code>const int * const ptr = arr;</code></p>
</blockquote>
</li>
<li><p><strong>其他 const 的规则</strong></p>
<blockquote>
<p>1、把<code>const</code>或<strong>非</strong><code>const</code>数据的<strong>地址</strong>初始化为<strong>指向</strong><code>const</code><strong>的指针</strong>是<strong>合法的</strong>，但<code>const</code>数据的<strong>地址</strong>只能赋给<strong>指向</strong><code>const</code><strong>的指针</strong>，赋值给<strong>普通指针</strong>是<strong>非法的</strong><br>2、这个规则非常合理，否则通过<strong>普通指针</strong>就能<strong>修改</strong><code>const</code>数组的<strong>数据</strong><br>3、因此，对函数的<strong>形参</strong>使用<code>const</code>不仅能<strong>保护数据</strong>，还能让函数<strong>处理</strong><code>const</code><strong>数组</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> locked<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>ptr1<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ptr2<span class="token punctuation">;</span>

ptr1 <span class="token operator">=</span> arr<span class="token punctuation">;</span>       <span class="token comment">// 有效(指向非const数据的地址)</span>
ptr1 <span class="token operator">=</span> locked<span class="token punctuation">;</span>    <span class="token comment">// 有效(只是不能通过ptr1改变指向的值，但可以更改ptr1指向的对象。指向const数据的地址)</span>
ptr1 <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 有效(指向非const数据的地址)</span>
ptr2 <span class="token operator">=</span> arr<span class="token punctuation">;</span>       <span class="token comment">// 有效(普通指针指向普通地址)</span>
ptr2 <span class="token operator">=</span> locked<span class="token punctuation">;</span>    <span class="token comment">// 无效(普通指针不能指向const数据的地址，只能通过指向const的指针指向此数据)</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a><strong>指针和多维数组</strong></h4><ul>
<li><p><strong>引入</strong></p>
<ul>
<li>假设有<code>int arr[4][2];</code>的声明。<strong>数组名 arr</strong>是该数组的<strong>首元素地址</strong>。在本例中，<strong>arr</strong>的<strong>首元素</strong>是一个<strong>内含两个 int 值</strong>的<strong>数组</strong>(由 arr 声明时第二维为<code>[2]</code>表明)，所以<strong>arr</strong>是<strong>这个数组</strong>(即内含两个 int 值的数组)的<strong>地址</strong></li>
</ul>
</li>
<li><p><strong>从指针属性进一步分析(可结合下方辅助理解示例来理解)</strong></p>
<blockquote>
<p>1、因为<strong>arr</strong>是<strong>首元素地址</strong>(即第一维首元素<code>arr[0]</code>的地址)，所以在地址上<code>arr = &amp;arr[0]</code>，其值<strong>相同</strong>。而<code>arr[0]</code>本身是一个<strong>内含两个整数</strong>的<strong>数组</strong>，所以<code>arr[0]</code>的值和它的<strong>首元素</strong>(一个整数)<strong>地址</strong>(即<code>&amp;arr[0][0]</code>)<strong>相同</strong>，即在地址上<code>arr[0] = &amp;arr[0][0]</code>(此处可以像第一维一样，假设将二维数组的<code>arr[0]</code>看做一维的<strong>arr</strong>，将二维数组的<code>arr[0]</code>的元素<code>arr[0][0]</code>和<code>arr[0][1]</code>分别看做一维的<code>arr[0]</code>和<code>arr[1]</code>，方便理解)<br>2、简而言之，<strong>arr</strong>是一个<strong>占用两个 int 大小对象</strong>的<strong>地址</strong>(因为其一个元素(<code>arr[0]</code>)内含两个 int 值)，而<code>arr[0]</code>是一个<strong>占用一个 int 大小对象</strong>的<strong>地址</strong>。但由于内含两个整数的<strong>数组</strong>(<code>arr[0]</code>)和这个<strong>整数</strong>(<code>arr[0][0]</code>)<strong>起始于同一个地址</strong>，所以<strong>arr</strong>和<code>arr[0]</code><strong>地址相同</strong>。综上，在地址上<code>arr = arr[0] = &amp;arr[0] = &amp;arr[0][0]</code>，因为都<strong>指向整个二维数组的起始地址</strong>(即最根本的第一个数值的位置<code>arr[0][0]</code>)<br>3、<strong>给指针或地址+1</strong>,其值会增加<strong>对应类型大小</strong>的数值。在这方面，<strong>arr</strong>和<code>arr[0]</code>不同，因为如上所言<strong>arr</strong>指向的对象<strong>占两个 int 大小</strong>，而<code>arr[0]</code>指向对象<strong>占一个 int 大小</strong>。因此<code>arr + 1</code>和<code>arr[0] + 1</code>的值不同<br>4、<strong>解引用</strong>(使用<code>*</code>符)指针或通过<strong>数组下标</strong><code>[]</code>，可以<strong>得到</strong>引用对象的<strong>值</strong>。因为<code>arr[0]</code>作为<strong>数组名</strong>是<strong>数组首元素</strong>(即<code>arr[0][0]</code>)的<strong>地址</strong>，所以<strong>解引用</strong><code>*(arr[0])</code><strong>得到</strong>的是存储在<code>arr[0][0]</code>上的<strong>值</strong>。与此类似，<strong>arr</strong>作为<strong>数组名</strong>代表<strong>首元素</strong>(即<code>arr[0]</code>)的<strong>地址</strong>，但<code>arr[0]</code>本身还是一个<strong>地址</strong>，其地址是<code>&amp;arr[0][0]</code>，所以<strong>解引用</strong><code>*arr</code>就是<code>&amp;arr[0][0]</code>(注意这里<strong>解引用后</strong><code>*arr</code>的值就是<strong>地址</strong>，而<strong>不是数值</strong>)，此时<strong>再次解引用</strong><code>**arr</code>就相当于<code>*&amp;arr[0][0]</code>，即<strong>取得</strong><code>arr[0][0]</code>指向的<strong>值</strong><br>5、简而言之，<strong>arr</strong>作为数组名(首元素地址)，是<strong>地址的地址</strong>，必须<strong>解引用两次</strong>才能<strong>获得原始值</strong>。此处<strong>地址的地址</strong>或者<strong>指针的指针</strong>就是<strong>双重间接</strong>的例子</p>
</blockquote>
</li>
<li><p><strong>针对上述 1、2 条的辅助理解示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 数组名为首元素地址，起始首元素为arr[0]，即指向&amp;arr[0]</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 与上者相等</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 数组名为首元素地址，起始首元素为arr[0][0]，即指向&amp;arr[0][0]</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 与上者相等</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从第二维递增一个下标，证明arr[0]是一个占用一个 int 大小对象的地址</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从第一维递增一个下标，证明arr是一个占用两个 int 大小对象的地址</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">000000000061FE00
000000000061FE00
000000000061FE00
000000000061FE00
000000000061FE04
000000000061FE08</code></pre>
</li>
<li><p><strong>针对上述 3、4、5 条的辅助理解示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> arr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 增加对应元素类型的大小(两个int类型大小)</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 增加对应元素类型的大小(一个int类型大小)</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"=================\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接通过数组下标获取值</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 解引用arr[0]</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 解引用一次arr，其值仍为地址，即arr[0][0]的地址</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 解引用两次，获得指向的值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">000000000061FE00
000000000061FE08
000000000061FE00
000000000061FE04
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
2
2
000000000061FE00
2</code></pre>
</li>
<li><p><strong>通过指针表示二维数组的值</strong></p>
<ul>
<li><p>前面我们了解过，对于<code>int arr[4][2]</code>该例：<code>arr + 1</code>，其值+8(两个 int)，而<code>arr[0] + 1</code>，其值+4(一个 int)</p>
</li>
<li><p>但要注意，与<code>arr[2][1]</code><strong>数值等价</strong>的指针表示法是<code>*(*(arr+2) + 1)</code>，理解如下</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>相对上一步的含义</th>
</tr>
</thead>
<tbody><tr>
<td>arr</td>
<td>二维数组首元素地址，(每个元素都是内含两个 int 的一维数组)，即第一维首元素<code>arr[0]</code>的地址</td>
</tr>
<tr>
<td>arr +2</td>
<td>二维数组第 3 个元素的地址，即第一维从第一个元素<code>arr[0]</code>变为第三个元素<code>arr[2]</code>，值为其地址</td>
</tr>
<tr>
<td>*(arr+2)</td>
<td>二维数组第 3 个元素的首元素地址，即第二维首元素<code>arr[2][0]</code>的地址</td>
</tr>
<tr>
<td>*(arr+2) + 1</td>
<td>二维数组第 3 个元素的第 2 个元素的地址，即第二维从第一个元素<code>arr[2][0]</code>变为第二个元素<code>arr[2][1]</code>，值为其地址</td>
</tr>
<tr>
<td>*(*(arr+2) + 1)</td>
<td>解引用该地址，取得<code>arr[2][1]</code>的值</td>
</tr>
</tbody></table>
</li>
<li><p>图片演示<strong>指针表示法</strong></p>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E6%8C%87%E9%92%88%E8%A1%A8%E7%A4%BA%E6%B3%95.png" loading="lazy"></p>
</li>
<li><p>以上分析并<strong>不是为了</strong>说明用<strong>指针表示法</strong>来<strong>代替</strong>常用的<strong>数组表示法</strong>(即下标直接引用)，而是表述程序恰巧使用一个<strong>指向二维数组的指针</strong>，而且要通过该指针<strong>获取值</strong>，最好用简单的<strong>数组表示法</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="数组指针与指针、多维数组深入"><a href="#数组指针与指针、多维数组深入" class="headerlink" title="数组指针与指针、多维数组深入"></a><strong>数组指针与指针、多维数组深入</strong></h4><ul>
<li><p><strong>指向多维数组的指针</strong></p>
<ul>
<li><p>如何声明一个<strong>指针变量 pz</strong>指向一个<strong>二维数组</strong>(如<code>int arr[4][2]</code>的第一层的<strong>arr</strong>或<code>arr[1]</code>)？</p>
</li>
<li><p><strong>声明方法</strong></p>
<blockquote>
<p>1、对于声明指向<strong>arr</strong>和<code>arr[1]</code>这样的数组，只声明为<strong>指向 int 类型</strong>还<strong>不够</strong>，因为这种指针指向<strong>一个 int 类型的值</strong>，但需要指向的<strong>元素</strong>为<strong>内含两个 int 类型的值的数组</strong><br>2、因此应按照<code>int (*pz)[2]</code><strong>这种格式</strong>声明，这种声明的<strong>pz</strong>便指向一个<strong>内含两个 int 类型的值的数组</strong>，将其声明为<strong>指向数组的指针</strong>。为什么使用<strong>圆括号</strong><code>()</code>，因为<code>[]</code>的优先级高于<code>*</code>，考虑下条声明<br>3、对于<code>int *pax[2]</code>这条声明。按照优先级<strong>pax</strong>先与<code>[2]</code>结合成为一个<strong>内含两个元素的数组</strong>，然后<code>*</code>表示<strong>pax 数组</strong>内含<strong>两个指针</strong>。因此这条代码声明了<strong>两个指向 int 的指针</strong><br>4、补充解释，<code>int (*pz)[2]</code>的<strong>pz</strong>是一个<strong>储存一个地址</strong>的指针，其储存的地址指向<strong>内含两个 int 类型的值的数组</strong>；而<code>int *pax[2]</code>的<strong>pax</strong>是一个<strong>储存两个地址</strong>的<strong>指针数组</strong>，其储存的地址指向<strong>一个 int 类型的值</strong></p>
</blockquote>
</li>
<li><p><strong>辅助理解示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>pz<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    pz <span class="token operator">=</span> arr<span class="token punctuation">;</span> <span class="token comment">// 指向&amp;arr[0]，其为内含两个int类型值的数组</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pz <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// +1直接增加了两个int类型值的大小</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 证明了pz+1 相当于从arr[0]指向了arr[1]</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pz<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 因为pz指向arr[0]，所以相当于&amp;arr[0][0] (具体还需结合下方“数组指针的[]使用来理解”)</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pz<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 相当于从arr[0][0] +1后指向arr[0][1]，所以增加了一个int类型值的大小</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 证明了pz[0]+1 指向 arr[0][1]</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 使用 * 解运算pz，相当于解运算arr[0]，即 *arr[0]，arr[0]指向其首元素地址，于是便得到 &amp;arr[0][0]</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pz <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 相当于arr[0][0] +1后指向arr[0][1]，增加一个int类型值大小</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"=================\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pz<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// pz[0]即指向 &amp;arr[0][0]，解运算得到arr[0][0]的值</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>pz<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 第一次解运算 *pz得到指向arr[0][0]的地址 &amp;arr[0][0]，解运算得到值</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> pz<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 关于数组指针加[]的事宜，下方将详细讨论</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>pz <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按前节方法解释，相当于得到arr[3][1]的值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">000000000061FDF0
000000000061FDF0
000000000061FDF8
000000000061FDF8
000000000061FDF0
000000000061FDF4
000000000061FDF4
000000000061FDF0
000000000061FDF4
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
2
2
3
3</code></pre>
</li>
<li><p><strong>数组指针的[]使用</strong></p>
<blockquote>
<p>1、如前所述，虽然<strong>pz 是一个指针</strong>，不是数组名，但仍可以使用<code>pz[2][1]</code>这种写法<br>2、可以用<strong>数组表示法</strong>或<strong>指针表示法</strong>表示<strong>一个数组元素</strong>，既可以使用<strong>数组名</strong>，也可以使用<strong>指针名</strong><br>3、三者的<strong>等价关系如下陈述</strong>。需要注意数组名<code>[m][n]</code>调用到的数值与<code>arr[m][n]</code>的值是对应的，<strong>pz 调用时</strong>，如果 pz<strong>不指向数组首元素地址</strong>，则<strong>对应的值</strong>是<code>arr[指向元素 + m][指向元素 + n]</code></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c">arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>arr<span class="token operator">+</span>m<span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span>
pz<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>pz<span class="token operator">+</span>m<span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span></code></pre></li>
</ul>
</li>
<li><p><strong>指针的兼容性</strong></p>
<ul>
<li><p><strong>指针</strong>之间的<strong>赋值</strong>比<strong>数值类型</strong>之间的<strong>赋值</strong>要<strong>严格</strong>。例如，不用类型转换就可以把<strong>int 类型值</strong>赋给<strong>double 类型变量</strong>，但<strong>两个类型的指针</strong>就<strong>不能这样做</strong>，如下两例：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> x<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pl <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token comment">/*-------------------------------*/</span>
x <span class="token operator">=</span> n<span class="token punctuation">;</span>      <span class="token comment">// 数值类型，隐式类型转换</span>
pd <span class="token operator">=</span> pl<span class="token punctuation">;</span>    <span class="token comment">// 指针，编译时错误</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p2<span class="token punctuation">;</span>             <span class="token comment">// 一个指向指针的指针</span>
<span class="token comment">/*--------------------------------*/</span>
pt <span class="token operator">=</span> <span class="token operator">&amp;</span>arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 都是指向int的指针</span>
pt <span class="token operator">=</span> arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 数组名是首元素地址，都是指向int的指针</span>
pt <span class="token operator">=</span> arr1<span class="token punctuation">;</span>            <span class="token comment">// 无效，首元素地址指向&amp;arr[0]，是一个指向三个int类型值的数组</span>
pa <span class="token operator">=</span> arr1<span class="token punctuation">;</span>            <span class="token comment">// 相当于&amp;arr[0]，都是指向内含三个int类型元素数组的指针</span>
pa <span class="token operator">=</span> arr2<span class="token punctuation">;</span>            <span class="token comment">// 无效，arr2为指向两个int类型值的数组</span>
pa <span class="token operator">=</span> <span class="token operator">&amp;</span>pt<span class="token punctuation">;</span>             <span class="token comment">// 都是指向int *的指针，&amp;pt为指向指针pt的地址</span>
<span class="token operator">*</span>p2 <span class="token operator">=</span> arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 都是指向int的指针，p2此处进行了一次解运算，指向int类型而非指向指针</span>
p2 <span class="token operator">=</span> arr2<span class="token punctuation">;</span>            <span class="token comment">// 无效，p2为指向指针的指针</span></code></pre>
</li>
<li><p><strong>多重解引用</strong>注意事项：</p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>y<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>pp2<span class="token punctuation">;</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>        <span class="token comment">// 不安全，把const指针赋给非const指针</span>
p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token comment">// 有效，把非const指针赋给const指针</span>
pp2 <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span>      <span class="token comment">// 不安全，嵌套指针类型赋值</span></code></pre>
</li>
<li><p><strong>示例解析</strong></p>
<blockquote>
<p>1、前面提到过，把<code>const</code><strong>指针</strong>赋给<strong>非</strong><code>const</code><strong>指针</strong>是<strong>不安全</strong>的，因为这样可以<strong>使用新的指针改变</strong><code>const</code><strong>指针指向的数据</strong>。<strong>编译器</strong>在编译时，可能会给出警告，执行这样的代码是<strong>未定义的</strong><br>2、但把<strong>非</strong><code>const</code><strong>指针</strong>赋给<code>const</code><strong>指针</strong>没问题，前提是<strong>只进行一级解引用</strong>。但当进行<strong>两级解引用</strong>时，这样的赋值<strong>也不安全</strong>，如下描述</p>
</blockquote>
</li>
<li><p><strong>非 const 赋值 const 时的两级解引用</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>pp2<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">;</span>
pp2 <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span>        <span class="token comment">// 允许，但是这会导致const限定符失效(根据第一行代码，不能通过**pp2修改它所指向的内容)</span>
<span class="token operator">*</span>pp2 <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span>        <span class="token comment">// 有效，两者都声明为const，但是这将导致p1指向n(*pp2已被修改)</span>
<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token comment">// 有效，但是这将改变n的值(但是根据第三行代码，不能修改n的值)</span></code></pre>
</li>
<li><p><strong>示例解析</strong></p>
<blockquote>
<p>1、发生了什么？如前所示，标准<strong>规定了</strong>通过<strong>非</strong><code>const</code><strong>指针</strong>更改<code>const</code><strong>数据</strong>是<strong>未定义的</strong><br>2、例如使用<strong>gcc</strong>编译包含以上代码的程序，导致<strong>n</strong>最终值为<strong>13</strong>(未更改)。但是在<strong>相同系统下</strong>使用<strong>clang</strong>来编译，<strong>n</strong>最终的值是<strong>10</strong>(已更改)。两个编译器都给出<strong>指针类型不兼容</strong>的<strong>警告</strong><br>3、当然您可以忽略这些警告，但最好<strong>不要相信程序运行的结果</strong>，因为这些结果都是<strong>未定义的</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>C const 和 C++ const</strong></p>
<blockquote>
<p>1、C 和 C++中<code>const</code><strong>用法很相似</strong>，但并不完全相同<br>2、区别之一是，C++允许<strong>声明数组大小</strong>时<strong>使用</strong><code>const</code><strong>整数</strong>，而 C<strong>不允许</strong><br>3、区别之二是，C++的<strong>指针赋值检查更严格</strong>。C++<strong>不允许</strong>把<code>const</code><strong>指针</strong>赋给<strong>非</strong><code>const</code><strong>指针</strong>，而 C 允许。如下例，但如果<strong>通过 p1 更改 y</strong>，其行为是未定义的</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>y<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>    <span class="token comment">// C++不允许这样做，C可能只发出警告</span></code></pre>
</li>
<li><p><strong>函数和多维数组指针</strong></p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ROWS</span> <span class="token expression"><span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COLS</span> <span class="token expression"><span class="token number">4</span></span></span>

<span class="token keyword">void</span> <span class="token function">sum_rows</span><span class="token punctuation">(</span><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> tot<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> COLS<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span>
            tot <span class="token operator">+=</span> ar<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"row %d: sum = %d\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> tot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">sum_cols</span><span class="token punctuation">(</span><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> tot<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> COLS<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>
            tot <span class="token operator">+=</span> ar<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"col %d: sum = %d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> tot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">sum2d</span><span class="token punctuation">(</span><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> COLS<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span>
            tot <span class="token operator">+=</span> ar<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> tot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> junk<span class="token punctuation">[</span>ROWS<span class="token punctuation">]</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">sum_rows</span><span class="token punctuation">(</span>junk<span class="token punctuation">,</span> ROWS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sum_cols</span><span class="token punctuation">(</span>junk<span class="token punctuation">,</span> ROWS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sum of all elements = %d\n"</span><span class="token punctuation">,</span> <span class="token function">sum2d</span><span class="token punctuation">(</span>junk<span class="token punctuation">,</span> ROWS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">row 0: sum &#x3D; 20
row 1: sum &#x3D; 24
row 2: sum &#x3D; 36
col 0: sum &#x3D; 17
col 1: sum &#x3D; 19
col 2: sum &#x3D; 21
col 3: sum &#x3D; 23
Sum of all elements &#x3D; 80</code></pre>
</li>
<li><p><strong>程序解析</strong></p>
<blockquote>
<p>1、在<strong>函数声明</strong>中<code>int ar[][COLS]</code>，第 1 个<strong>方括号</strong><code>[]</code>是空的，空的方括号<strong>表明 ar 是一个指针</strong>。所以该语句等效于<code>int (*ar)[COLS]</code>，如前面<strong>数组指针</strong>提到的，后面的<code>COLS</code>用于告知指针指向的<strong>元素</strong>(子数组)内含多少个<strong>对应数据类型</strong>的<strong>大小</strong><br>2、该程序把<strong>数组名 junk</strong>(即首元素地址，即<strong>子数组</strong>)和<strong>符号常量 ROWS</strong>作为参数<strong>传递给函数</strong>。由于<code>int ar[][COLS]</code>的声明，每个函数都把<strong>ar</strong>视为<strong>内含数组元素</strong>的<strong>数组</strong><br>3、注意，<strong>ar</strong>和<code>main</code>中的<strong>junk</strong>都使用<strong>数组表示法</strong>。因为 ar 和 junk<strong>类型相同</strong>，都是指向<strong>内含 4 个 int 值的数组的指针</strong><br>4、一般而言，声明一个<strong>指向 N 维数组</strong>的指针时，<strong>只能省略最左边</strong>的方括号中的值，因为其只用于<strong>表明这是一个指针</strong>，其他方括号则用于描述<strong>指针指向</strong>的<strong>数据对象的类型</strong>(内含多少个对应什么数据类型的大小)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="变长数组-VLA"><a href="#变长数组-VLA" class="headerlink" title="变长数组(VLA)"></a><strong>变长数组(VLA)</strong></h4><ul>
<li><p><strong>引入</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*如上节的函数示例*/</span>
<span class="token keyword">int</span> <span class="token function">sum2d</span><span class="token punctuation">(</span><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> COLS<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span>
            tot <span class="token operator">+=</span> ar<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> tot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、为什么<strong>使用函数</strong>操作<strong>二维数组</strong>时，只将<strong>行数</strong>(<strong>ROWS</strong>)作为函数的<strong>形参</strong>，而<strong>列数</strong>(<strong>COLS</strong>)<strong>内置</strong>在函数体内？<br>2、我们可以使用<code>sum2d()</code>函数对<code>int arr1[5][4]</code>、<code>int arr2[100][4]</code>、<code>int arr3[2][4]</code>等数组<strong>求各元素之和</strong>，是因为这些数组的<strong>列数固定为 4</strong>，<strong>行数</strong>被<strong>传递</strong>给<strong>形参 rows</strong>，<strong>rows</strong>是一个<strong>变量</strong>。但如果要对<code>int arr4[6][5]</code>计算，则<strong>不能使用这个函数</strong>，必须新建一个<strong>COLS 为 5</strong>的函数，因为<strong>C 规定</strong>，数组的维数<strong>必须是常量</strong>，<strong>不能用变量代替</strong><br>3、要创建一个能<strong>处理任意大小</strong>二维数组的函数，比较繁琐(必须把数组<strong>作为一位数组传递</strong>，然后让<strong>函数计算每行的开始处</strong>)。鉴于此，<strong>C99</strong>新增了<strong>变长数组</strong>，允许使用<strong>变量</strong>表示<strong>数组的维度</strong></p>
</blockquote>
</li>
<li><p><strong>变长数组</strong></p>
<ul>
<li><p><strong>声明示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> quarters <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> regions <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> arr<span class="token punctuation">[</span>regions<span class="token punctuation">]</span><span class="token punctuation">[</span>quarters<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 一个变长数组</span></code></pre>
</li>
<li><p><strong>变长数组的特性</strong></p>
<blockquote>
<p>1、<strong>变长数组</strong>有一些<strong>限制</strong>：变长数组<strong>必须</strong>是<strong>自动储存类别</strong>，这意味着无论在<strong>函数中声明</strong>还是作为<strong>函数形参声明</strong>都<strong>不能使用</strong><code>static</code>或<code>extern</code><strong>储存类别说明符</strong>(第 12 章介绍)。而且<strong>不能在声明中初始化</strong>它们<br>2、变长数组<strong>不能改变大小</strong>：<strong>变长数组</strong>的“<strong>变</strong>”不是指可以<strong>修改</strong>已创建数组的<strong>大小</strong>。<strong>一旦创建</strong>了变长数组，<strong>其大小保持不变</strong>。这里的“<strong>变</strong>”指的是在<strong>创建数组时</strong>，可以<strong>使用变量指定数组的维度</strong><br>3、由于<strong>变长数组</strong>是 C 语言的<strong>新特性</strong>，目前<strong>完全支持</strong>这一特性的<strong>编译器</strong>不多</p>
</blockquote>
</li>
<li><p><strong>示例程序(程序要求编译器支持变长数组)</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ROWS</span> <span class="token expression"><span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COLS</span> <span class="token expression"><span class="token number">4</span></span></span>

<span class="token comment">// 带变长数组形参的函数</span>
<span class="token keyword">int</span> <span class="token function">sum2d</span><span class="token punctuation">(</span><span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">,</span> <span class="token keyword">int</span> ar<span class="token punctuation">[</span>rows<span class="token punctuation">]</span><span class="token punctuation">[</span>cols<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span>
            tot <span class="token operator">+=</span> ar<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> tot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> cs <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> junk<span class="token punctuation">[</span>ROWS<span class="token punctuation">]</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                <span class="token comment">// 3*4数组</span>
    <span class="token keyword">int</span> morejunk<span class="token punctuation">[</span>ROWS <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>COLS <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 2*6数组</span>
    <span class="token keyword">int</span> varr<span class="token punctuation">[</span>rs<span class="token punctuation">]</span><span class="token punctuation">[</span>cs<span class="token punctuation">]</span><span class="token punctuation">;</span>                                                                   <span class="token comment">// 3*10变长数组</span>
    <span class="token comment">// 为变长数组赋值</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cs<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            varr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> j <span class="token operator">+</span> i<span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3*4 array: sum = %d\n"</span><span class="token punctuation">,</span> <span class="token function">sum2d</span><span class="token punctuation">(</span>ROWS<span class="token punctuation">,</span> COLS<span class="token punctuation">,</span> junk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2*6 array: sum = %d\n"</span><span class="token punctuation">,</span> <span class="token function">sum2d</span><span class="token punctuation">(</span>ROWS <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> COLS <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> morejunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3*10 VLA: sum = %d\n"</span><span class="token punctuation">,</span> <span class="token function">sum2d</span><span class="token punctuation">(</span>rs<span class="token punctuation">,</span> cs<span class="token punctuation">,</span> varr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">3*4 array: sum &#x3D; 80
2*6 array: sum &#x3D; 315
3*10 VLA: sum &#x3D; 165</code></pre>
</li>
<li><p><strong>示例解析</strong></p>
<blockquote>
<p>1、声明一个带<strong>二维变长数组参数</strong>的函数，需要注意<strong>前两个形参</strong><code>rows</code>和<code>cols</code>用作<strong>第三个形参</strong>二维数组<code>ar[rows][cols]</code>的<strong>两个维度</strong>。<strong>参数数组 ar</strong>的声明需要<strong>使用前两个参数</strong>，因此<strong>必须先声明</strong>前两个参数，使用<code>int sum2d(int ar[rows][cols], int rows, int cols)</code>这种<strong>无效的顺序</strong>声明函数原型是<strong>错误的</strong><br>2、前面提到过 C 标准规定，可以省略<strong>函数原型</strong>中的<strong>形参名</strong>，但这种情况下必须用<strong>星号</strong><code>*</code><strong>代替省略的维度</strong>：<code>int sum2d(int, int, int ar[*][*])</code>。(注意是<strong>函数原型</strong>不是<strong>函数定义</strong>，如果是<strong>函数定义</strong>仍必须<strong>完整写出</strong>类型、变量名等信息)<br>3、需要注意的是，在<strong>函数定义</strong>时的形参列表中<strong>声明的变长数组</strong>，<strong>并非实际创建数组</strong>。和传统的语法类似，<strong>变长数组名</strong>实际上<strong>是一个指针</strong>。这说明函数实际上还是在<strong>原始数组</strong>中处理数组，因此<strong>可以更改传入的数据</strong><br>4、变长数组还允许<strong>动态内存分配</strong>，这说明可以在<strong>程序运行时指定数组的大小</strong>。<strong>普通数组</strong>都是<strong>静态内存分配</strong>，即在<strong>编译时确定数组大小</strong>(12 章将详细讨论)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a><strong>复合字面量</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、假设给带<strong>int 类型形参</strong>的函数<strong>传递</strong>一个值，应传递<strong>int 类型的变量</strong>，但也可以传递<strong>int 类型的常量</strong>，比如<strong>5</strong><br>2、C99 之前，对于<strong>带数组形参的函数</strong>，可以传递数组，但没有等价的<strong>数组常量</strong>，于是 C99 新增了<strong>复合字面量</strong><br>3、<strong>字面量</strong>是除<strong>符号常量</strong>以外的<strong>常量</strong>。如：<strong>5</strong>是<strong>int</strong>的字面量；<strong>81.3</strong>是<strong>double</strong>的字面量；<strong>Y</strong>是<strong>char</strong>的字面量；<strong>hello</strong>是字符串字面量<br>4、于是，C99 认为如果有<strong>代表数组</strong>和<strong>结构内容</strong>的<strong>复合字面量</strong>，会更方便</p>
</blockquote>
</li>
<li><p><strong>复合字面量</strong></p>
<blockquote>
<p>1、对于数组，<strong>复合字面量</strong>类似数组<strong>初始化列表</strong>(实际可以看做<strong>常量数组</strong>，类似我们给普通变量赋值时写的<strong>5</strong>、<strong>81.3</strong>这样的<strong>字面量常量</strong>)，前面是用<strong>括号</strong><code>()</code>括起来的<strong>类型名</strong>。如<code>(int [2])&#123;10,20&#125;;</code>，括号内的<code>int [2]</code>便是复合字面量的<strong>类型名</strong><br>2、初始化<strong>有数组名的数组</strong>时可以<strong>省略数组大小</strong>，<strong>复合字面量</strong>也可以<strong>省略大小</strong>，<strong>编译器</strong>会<strong>自动计算</strong>数组当前<strong>元素个数</strong>：<code>(int [])&#123;50,20,90&#125;</code><br>3、因为<strong>复合字面量</strong>是<strong>匿名</strong>的，所以<strong>不能先创建再使用</strong>，必须在<strong>创建的同时使用</strong>它。使用<strong>指针记录地址</strong>就是一种用法，即如果有<code>int *pt;</code>，则可以通过<code>pt = (int [2])&#123;10,20&#125;;</code>让<strong>pt</strong>指针<strong>记录地址</strong>，后通过<strong>pt</strong>使用这个<strong>常量数组</strong>(匿名只是无法通过名称调用，但仍储存在固定的内存地址上，因此可以使用指针调用)。<strong>复合字面量</strong>的<strong>类型名</strong>也代表<strong>首元素地址</strong>，因此和数组规则相同，<code>*pt</code>是<strong>10</strong>，<code>pt[1]</code>是<strong>20</strong><br>4、还可以把<strong>复合字面量</strong>作为<strong>实参</strong>传给带有<strong>匹配形参</strong>的<strong>函数</strong>。这也是复合字面量的<strong>典型用法</strong>，其好处是把信息<strong>传入函数</strong>前<strong>不必先创建数组</strong><br>5、注意，<strong>复合字面量</strong>是提供<strong>只临时需要</strong>的值的<strong>一种手段</strong>。<strong>复合字面量</strong>具有<strong>块作用域</strong>(12 章详细介绍)，一旦<strong>离开</strong>定义复合字面量的<strong>块</strong>，程序无法保证该字面量<strong>是否存在</strong>。也就是说，复合字面量定义在<strong>最内层的花括号内</strong></p>
</blockquote>
</li>
<li><p><strong>综合应用示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COLS</span> <span class="token expression"><span class="token number">4</span></span></span>

<span class="token comment">// 计算一维数组各元素的和</span>
<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        total <span class="token operator">+=</span> ar<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> total<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 计算二维数组各元素的和</span>
<span class="token keyword">int</span> <span class="token function">sum2d</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> COLS<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span>
            tot <span class="token operator">+=</span> ar<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> tot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> total1<span class="token punctuation">,</span> total2<span class="token punctuation">,</span> total3<span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>pt1<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>pt2<span class="token punctuation">)</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用指针记录匿名的复合字面量的地址，以后续调用</span>
    pt1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    pt2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>COLS<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    total1 <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>pt1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    total2 <span class="token operator">=</span> <span class="token function">sum2d</span><span class="token punctuation">(</span>pt2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将复合字面量作为实参传入函数形参</span>
    total3 <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"total1 = %d\n"</span><span class="token punctuation">,</span> total1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"total2 = %d\n"</span><span class="token punctuation">,</span> total2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"total3 = %d\n"</span><span class="token punctuation">,</span> total3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<hr>
<h3 id="字符串和字符串函数"><a href="#字符串和字符串函数" class="headerlink" title="字符串和字符串函数"></a><strong>字符串和字符串函数</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：表示字符串和字符串 I&#x2F;O；在程序中定义字符串；数组表示法与指针表示法；字符串数组；字符串输入；分配空间；<code>gets()</code>函数；<code>fgets()</code>函数；<code>gets_s()</code>函数；<code>scanf()</code>函数；字符串输出；<code>puts()</code>函数；<code>fputs()</code>函数；<code>printf()</code>函数；自定义输入&#x2F;输出函数；字符串函数；<code>strlen()</code>函数；<code>strcat()</code>函数；<code>strncat()</code>函数；<code>strcmp()</code>函数；<code>strncmp()</code>函数；<code>strcpy()</code>函数；<code>strncpy()</code>函数；其他字符串函数；<code>ctype.h</code>字符函数和字符串；字符串示例：字符串排序；排序指针而非字符串；选择排序算法；命令行参数；字符串转换为数字；<code>atoi()</code>与其类别函数；<code>strtol()</code>与其类别函数</p>
</blockquote>
</div>

<h4 id="表示字符串和字符串-I-x2F-O"><a href="#表示字符串和字符串-I-x2F-O" class="headerlink" title="表示字符串和字符串 I&#x2F;O"></a><strong>表示字符串和字符串 I&#x2F;O</strong></h4><ul>
<li><p>第四章介绍过，<strong>字符串</strong>是以<strong>空字符</strong>(<code>\0</code>)结尾的<strong>char 类型数组</strong>。因此，可以把上一章学到的<strong>数组和指针</strong>的知识应用于<strong>字符串</strong></p>
</li>
<li><p><strong>在程序中定义字符串</strong></p>
<ul>
<li><p><strong>字符串字面量</strong>(<strong>字符串常量</strong>)</p>
<blockquote>
<p>1、用<strong>双引号</strong><code>&quot;&quot;</code>括起来的内容称为<strong>字符串字面量</strong>，也叫做<strong>字符串常量</strong>。双引号中的<strong>字符</strong>和编译器<strong>自动加入末尾</strong>的<code>\0</code>字符，都作为字符串<strong>储存在内存中</strong><br>2、从<strong>ANSI C</strong>起如果<strong>字符串字面量</strong>之间<strong>没有间隔</strong>，或者用<strong>空白字符分隔</strong>，C 会将其视为<strong>串联起来的</strong>字符串字面量。如<code>char word[50] = &quot;hello,&quot;&quot; how are&quot; &quot; you?&quot;</code>等价于<code>char word[50] = &quot;hello, how are you?&quot;</code>。如果要在<strong>字符串内部</strong>使用<strong>双引号</strong>，则必须通过<strong>反斜杠</strong><code>\</code>进行<strong>转义</strong>。如<code>printf(&quot;\&quot;Hello\&quot;, Jimmy said&quot;);</code><br>3、<strong>字符串常量</strong>属于<strong>静态存储类别</strong>，这说明如果在<strong>函数中使用</strong>字符串，该字符串<strong>只会被储存一次</strong>，并在<strong>整个程序的生命周期内存在</strong>，即使函数<strong>被调用多次</strong><br>4、用<strong>双引号括起来的内容</strong>被视为指向<strong>该字符串存储位置</strong>的<strong>指针</strong>(该字符串<strong>首字符地址</strong>)，这类似于把<strong>数组名</strong>作为指向<strong>该数组位置</strong>的<strong>指针</strong><br>5、因此，如果使用<code>printf()</code>打印<code>&quot;hello&quot;</code>，使用<code>%s</code>将打印<strong>整个字符串</strong>，使用<code>%p</code>将打印该字符串<strong>首字符地址</strong>。既然整个字符串表示<strong>首字符地址</strong>，那么使用<code>%c</code>输出解引用的<code>*&quot;hello&quot;</code>，结果便是<strong>首字符 h</strong>而<strong>不是整个字符串</strong></p>
</blockquote>
</li>
<li><p><strong>字符串数组和初始化</strong></p>
<blockquote>
<p>1、<strong>定义字符串数组</strong>时，必须让编译器知道<strong>需要多少空间</strong><br>2、<strong>声明示例</strong>：<code>const char word[10] = &quot;hello&quot;</code>，其中<code>const</code>表明不会更改这个字符串(可省略)。这种形式初始化比<strong>标准的数组初始化</strong>简单的多：<code>const char word[10] = &#123;&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;</code>，注意最后的<strong>空字符</strong>，如果没有这个空字符，这就<strong>不是</strong>一个<strong>字符串</strong>，而是一个<strong>字符数组</strong><br>3、在<strong>指定数组大小</strong>时，要确保数组的<strong>元素个数</strong>要<strong>至少</strong>比字符串长度<strong>多 1</strong>(为了容纳空字符)。所有<strong>未被使用的元素</strong>都会被自动<strong>初始化为 0</strong>(这里的 0 是 char 形式的空字符，不是数字字符 0)<br>4、通常，让<strong>编译器</strong>确定<strong>数组大小</strong>很方便。对于<strong>字符串</strong>(字符数组)也一样，省略数组<strong>初始化声明</strong>中的<strong>大小</strong>，编译器会<strong>自动计算</strong>数组的大小<br>5、<strong>字符数组名</strong>和其他<strong>数组名</strong>一样，是该数组<strong>首元素的地址</strong></p>
</blockquote>
</li>
<li><p><strong>数组表示法与指针表示法</strong></p>
<ul>
<li><p>前面介绍的声明为<strong>数组表示法</strong>，如<code>const char arr[] = &quot;hello&quot;;</code>(<code>const</code>可省略)，此外还可以用<strong>指针表示法</strong>创建字符串，如<code>const char * pt = &quot;hello&quot;;</code>(<code>const</code>不可省略)</p>
</li>
<li><p><strong>pt</strong>和<strong>arr</strong>都是该字符串的<strong>地址</strong>，且<strong>字符串本身</strong>决定预留的<strong>存储空间</strong>，尽管如此，这两种形式<strong>并不完全相同</strong></p>
</li>
<li><p><strong>数组表示法</strong></p>
<blockquote>
<p>1、<strong>数组形式</strong>(<code>arr[]</code>)在计算机的<strong>内存中</strong>分配为一个<strong>内含 6 个元素</strong>的数组(预留出空字符)，每个元素被<strong>初始化</strong>为字符串字面量<strong>对应的字符</strong><br>2、通常<strong>字符串</strong>都作为<strong>可执行文件</strong>的一部分存储在<strong>数据段</strong>中，当把程序<strong>载入内存</strong>时，也载入了<strong>字符串</strong>。字符串存储在<strong>静态存储区</strong>中，但是程序在<strong>开始运行时</strong>才会为数组<strong>分配内存</strong>，此时才<strong>将字符串拷贝到数组</strong>中。这时字符串有<strong>两个副本</strong>，一个是<strong>静态内存</strong>中的<strong>字符串字面量</strong>，另一个是<strong>arr 数组</strong>中的<strong>字符串</strong><br>3、随后，编译器将<strong>数组名 arr</strong>识别为数组的<strong>首元素地址</strong>的别名。在<strong>数组形式</strong>中，<strong>arr</strong>是<strong>地址常量</strong>，<strong>不能更改 arr</strong>，否则更改意味着<strong>改变了</strong>数组的<strong>存储位置</strong>。所以<strong>可以进行</strong>类似<code>arr+1</code>这样的操作，标识数组的<strong>下一个元素</strong>，但<strong>不能进行</strong>类似<code>++arr</code>这样的操作，<strong>递增运算符</strong>只可以用于<strong>可修改的左值</strong>，<strong>不能用于常量</strong></p>
</blockquote>
</li>
<li><p><strong>指针表示法</strong></p>
<blockquote>
<p>1、<strong>指针形式</strong>(<code>*pt</code>)也使得<strong>编译器</strong>为<strong>字符串</strong>在<strong>静态存储区</strong>预留 6 个元素的空间。另外<strong>一旦开始执行</strong>程序，他会为<strong>指针变量 pt</strong>留出一个储存位置，并把<strong>字符串的地址</strong>存储在<strong>指针变量</strong>中<br>2、该指针变量<strong>最初指向</strong>该<strong>字符串首字母</strong>，但是它的值<strong>可以改变</strong>。因此可以使用<strong>递增运算符</strong>，如<code>++pt;</code>将指向<strong>第二个字符</strong>(即 e)<br>3、<strong>字符串字面量</strong>被视为<code>const</code><strong>数据</strong>，由于<strong>pt 指向这个数据</strong>，所以应该把<strong>pt</strong>声明为<strong>指向</strong><code>const</code><strong>数据</strong>的<strong>指针</strong>。这意味着<strong>不能用 pt 改变</strong>它所<strong>指向的数据</strong>，但<strong>可以改变 pt 的值</strong>(即指向的地址)<br>4、如果把一个字符串<strong>拷贝</strong>给一个<strong>数组</strong>(即使用数组表示法)，则可以<strong>随意改变数据</strong>，除非把数组<strong>声明</strong>为<code>const</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>字符串数组</strong></p>
<ul>
<li><p>创建一个<strong>字符串数组</strong>通常很方便，可以通过<strong>数组下标</strong>访问多个<strong>不同的</strong>字符串</p>
</li>
<li><p><strong>字符串数组-数组表示法</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> words<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"Hello, my name is Lisa."</span><span class="token punctuation">,</span>
    <span class="token string">"I'm 16 years old."</span><span class="token punctuation">,</span>
    <span class="token string">"How about you?"</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>字符串数组-指针表示法</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token operator">*</span>words<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"Hello, my name is Lisa."</span><span class="token punctuation">,</span>
    <span class="token string">"I'm 16 years old."</span><span class="token punctuation">,</span>
    <span class="token string">"How about you?"</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a><strong>字符串输入</strong></h4><ul>
<li><p>想把一个<strong>字符串</strong>读入程序，首先必须<strong>预留</strong>储存该字符串的<strong>空间</strong>，然后用<strong>输入函数</strong>获取该<strong>字符串</strong></p>
</li>
<li><p><strong>分配空间</strong></p>
<ul>
<li><p>第一件事便是<strong>分配空间</strong>，以<strong>储存</strong>后续读入的<strong>字符串</strong>。这意味着要为字符串<strong>分配足够的空间</strong>，<strong>不要指望</strong>计算机在读取时<strong>顺便计算</strong>它的长度，再分配空间(计算机不会这样做)</p>
</li>
<li><p><strong>错误示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、虽然<strong>可能通过编译</strong>(大概率会报<strong>警报</strong>)，但在读取<strong>name</strong>时，<strong>name</strong>很可能会<strong>擦写</strong>程序中的<strong>数据或代码</strong>，导致程序<strong>异常终止</strong><br>2、因为<code>scanf()</code>要把信息<strong>拷贝</strong>到参数的<strong>指定地址</strong>，而<strong>name</strong>是个<strong>未初始化的指针</strong>，所以可能指向<strong>任何地方</strong></p>
</blockquote>
</li>
<li><p><strong>正确分配空间</strong></p>
<blockquote>
<p>1、<strong>最简单</strong>的方法是，在<strong>声明时显式指明数组的大小</strong>：<code>char name[81];</code><br>2、还有一种方法是使用<strong>C 库函数</strong>来<strong>分配内存</strong>，第 12 章介绍</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>gets()函数</strong></p>
<ul>
<li><p><code>gets()</code><strong>的使用</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> word<span class="token punctuation">[</span><span class="token number">81</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">gets</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">puts</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、在<strong>读取字符</strong>时，<code>scanf()</code>配合<code>%s</code>只能读取<strong>一个单词</strong>(遇到空格就停止)，但程序经常要读取<strong>一整行输入</strong><br>2、<code>gets()</code>函数就用于<strong>读取整行输入</strong>，直至<strong>遇到换行符</strong>。然后<strong>丢弃换行符</strong>，<strong>储存其他字符</strong>，并在这些字符<strong>末尾添加一个空字符</strong>使其成为一个<strong>字符串</strong><br>3、<code>gets()</code>常常与<code>puts()</code>函数<strong>配对使用</strong>，该函数用于<strong>显示字符串</strong>，并在末尾<strong>添加换行符</strong></p>
</blockquote>
</li>
<li><p><code>gets()</code><strong>的危险性</strong></p>
<blockquote>
<p>1、某些<strong>编译器</strong>对于使用<code>gets()</code>的程序<strong>报出警告</strong>，但并非全部编译器都会这样做。其他编译器可能在<strong>编译过程中</strong>给出警告，但不会引起你的注意<br>2、问题出现在<code>gets()</code>的<strong>唯一参数</strong>是<strong>字符串名</strong>(word)，它<strong>无法检查</strong>数组<strong>是否装得下</strong>输入行<br>3、如果输入的<strong>字符串过长</strong>，会导致<strong>缓冲区溢出</strong>，即多余的字符<strong>超出了</strong>指定的<strong>目标空间</strong>。如果这些<strong>多余字符</strong>只是占用了<strong>尚未使用的内存</strong>，就<strong>不会立刻出现问题</strong>；如果它们<strong>擦写</strong>掉了程序中的其他数据，会导致<strong>程序异常终止</strong>，或者还有<strong>其他情况</strong><br>4、如果出现上述情况，会报出<code>Segmentation fault</code>(<strong>分段错误</strong>)，这条消息说明<strong>该程序试图访问未分配的内存</strong>。该函数的<strong>不安全行为</strong>造成了<strong>安全隐患</strong>，过去有些人通过<strong>系统编程</strong>，利用<code>gets()</code>插入和运行一些破坏系统安全的代码</p>
</blockquote>
</li>
<li><p><code>gets()</code><strong>被遗弃</strong></p>
<blockquote>
<p>1、由于<code>gets()</code>的<strong>不安全性</strong>，不久<strong>C 社区</strong>许多人都建议编程时<strong>摒弃</strong><code>gets()</code>。制定<strong>C99</strong>标准的委员会将这些建议<strong>放入了标准</strong>，承认<code>gets()</code>的<strong>大量问题</strong>并建议不要再使用它<br>2、尽管如此，在标准中<strong>保留</strong><code>gets()</code>也合情合理，因为<strong>现有程序</strong>中含有<strong>大量使用该函数</strong>的代码。而且只要使用得当，其的确是一个<strong>很方便</strong>的函数<br>3、好景不长，<strong>C11</strong>采取了更强硬的手段，直接从标准中<strong>废除了</strong><code>gets()</code>函数。既然标准已经发布，那么<strong>编译器</strong>就必须<strong>调整支持</strong>。然而<strong>实际使用</strong>中，编译器为了<strong>兼容以前的代码</strong>，大部分仍<strong>继续支持</strong><code>gets()</code>函数，但部分编译器已<strong>按标准废除</strong><code>gets()</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>fgets()函数</strong></p>
<ul>
<li><p><code>fgets()</code>函数可以作为<code>gets()</code>的替代品，其通过<strong>第二个参数</strong>限制<strong>读入的字符数</strong>来解决<strong>溢出问题</strong>。但该函数<strong>设计用于处理文件输入</strong>，一般情况可能不那么好用</p>
</li>
<li><p><code>fgets()</code><strong>和</strong><code>gets()</code><strong>的区别</strong></p>
<blockquote>
<p>1、<code>fgets()</code>函数的<strong>第二个参数</strong>指定了读入字符的<strong>最大数量</strong>。如果<strong>该参数值</strong>为<strong>n</strong>，那么<code>fgets()</code>将读取<strong>n-1</strong>个字符，或者读到遇到的<strong>第一个换行符</strong><br>2、如果<code>fgets()</code>读到一个<strong>换行符</strong>，会把它<strong>保存在字符串</strong>中。而<code>gets()</code>函数会<strong>舍弃换行符</strong><br>3、<code>fgets()</code>的<strong>第三个参数</strong>指明<strong>要读入的文件</strong>。如果读入从<strong>键盘输入</strong>的数据，则以<code>stdin</code>(标准输入)<strong>作为参数</strong>，该<strong>标识符</strong>定义在<code>stdio.h</code>中</p>
</blockquote>
</li>
<li><p><code>fgets()</code><strong>的使用</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> word<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">fgets</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fputs</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、假设<strong>输入 17 个字符</strong>，该程序输出仅会<strong>输出前 13 个字符</strong>(<code>fgets</code>只读入<strong>第二个参数-1</strong>个字符)<br>2、假设<strong>输入 6 个字符</strong>，<code>fgets()</code>函数会将末尾的<strong>换行符</strong>也<strong>储存起来</strong>，如果使用<code>puts()</code>函数打印则会<strong>附带一个换行符</strong>，如果使用<code>fputs()</code>则不会<br>3、<code>fgets()</code>由于<strong>储存换行符</strong>的特性常常与<code>fputs()</code><strong>配对使用</strong>。<code>fputs()</code><strong>第二个参数</strong>指明它要<strong>写入的文件</strong>，如果要<strong>显示在屏幕上</strong>，则应使用<code>stdout</code>(标准输出)<strong>作为参数</strong><br>4、<code>fgets()</code>函数返回<strong>指向 char</strong>的<strong>指针</strong>。如果一切顺利，该函数<strong>返回地址</strong>与传入的<strong>第一个参数</strong>相同。但是，如果函数<strong>读到文件结尾</strong>，它将返回一个<strong>空指针</strong>(null pointer)，该指针<strong>保证不会指向有效数据</strong>,在代码中可以<strong>用数字 0 代替</strong>，不过 C 语言中用宏<code>NULL</code>代替<strong>更常见</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> word<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入字符串(单独换行结束):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// fgets输入，返回值不等于空指针(文件结尾)且判断第一个字符不为换行符</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Done."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">by the way, the gets() function
by the way, the gets() function
hello, world
hello, world
how about you?
how about you?

Done.</code></pre>
</li>
<li><p><strong>示例解析</strong></p>
<blockquote>
<p>1、虽然<strong>word</strong>的长度被设置为<strong>10</strong>(即实际读入 9 个字符)，但处理<strong>更长的字符串</strong>时貌似并<strong>没有问题</strong>，原理如下<br>2、之前提到过，程序的输入使用了<strong>缓冲区</strong>，所以输入<strong>更长的字符串</strong>被<strong>储存在缓冲区</strong>内<strong>等待处理</strong>。第一轮<code>while</code>迭代按<code>fgets()</code>函数要求<strong>只读入 9 个字符</strong>(即<code>by the wa</code>，储存为<code>by the wa\0</code>)，然后<strong>处理</strong>(即输出)该字符串，<code>fputs()</code>打印且<strong>不换行</strong><br>3、随后进入<strong>第二轮迭代</strong>，从<strong>缓冲区</strong>中读取<strong>剩余未读取的字符</strong><code>y, the ge</code>并存储，再次<strong>输出</strong>，由于<code>fputs()</code>的输出<strong>未换行</strong>，所以与上次输入<strong>拼接在了一起</strong>。以此类推</p>
</blockquote>
</li>
<li><p><strong>特殊处理</strong>(需要对应操作时可参考处理思路)</p>
<ul>
<li><p><strong>处理换行符</strong>(查找换行符，将其替换为空字符)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>word<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>   <span class="token comment">// 假设 \n 在 word 中，while循环检测跳过非换行符的部分</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
word<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>           <span class="token comment">// 将换行符替换为空字符</span></code></pre>
</li>
<li><p><strong>处理留在缓冲区中的多余字符</strong>(丢弃多余字符)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 读取但不存储输入，包括\n</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>gets_s()函数</strong></p>
<ul>
<li><p><strong>C11</strong>新增的<code>gets_s()</code>函数和<code>fgets()</code>类似，用一个参数<strong>限制读入的字符数</strong>，其语法为<code>gets_s(字符串名, 字符数)</code>，但由于是<strong>可选标准</strong>，所以<strong>某些编译器可能不支持</strong></p>
</li>
<li><p><code>gets_s</code><strong>与</strong><code>fgets()</code><strong>的区别</strong></p>
<blockquote>
<p>1、<code>gets_s</code>只从<code>stdin</code><strong>标准输入</strong>中读取数据，所以<strong>不需要第三个参数</strong><br>2、如果<code>gets_s</code>读到<strong>换行符</strong>，会<strong>舍弃换行符</strong>而不是储存它<br>3、如果<code>gets_s</code>读到<strong>最大字符数</strong>都<strong>没有读到</strong>换行符，将会执行以下几步。首先把<strong>目标数组</strong>的<strong>首字符</strong>设置为<strong>空字符</strong>，<strong>读取并丢弃随后的输入</strong>直至<strong>换行符</strong>或<strong>文件结尾</strong>，然后<strong>返回空指针</strong>。接着调用依赖实现的<strong>处理函数</strong>(或你选择的其他函数)，可能会<strong>终止或退出</strong>程序<br>4、第二个特性说明，只要<strong>不超过最大值</strong>，这两个函数<strong>几乎完全一样</strong>；第三个特性说明，要使用<code>gets_s</code>函数还需<strong>进一步学习</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>scanf()函数</strong></p>
<ul>
<li><p><code>scanf()</code><strong>与</strong><code>gets()</code>、<code>fgets()</code><strong>的区别</strong></p>
<blockquote>
<p>1、<strong>最主要的区别</strong>在于它们如何<strong>确定字符串的末尾</strong>。<code>scanf()</code>更像<strong>获取单词</strong>函数，而非<strong>获取字符串</strong>函数<br>2、如果<strong>预留的储存区</strong>装得下输入行，<code>gets()</code>和<code>fgets()</code>会读取<strong>第一个换行符</strong>前<strong>所有的字符</strong><br>3、<code>scnaf()</code>有<strong>两种方式</strong>确定<strong>输入结束</strong>，无论哪种方式，都从<strong>第一个非空白字符</strong>作为<strong>字符串开始</strong>。如果使用<code>%s</code><strong>转换说明</strong>，则以<strong>下一个空白字符</strong>作为<strong>字符串结束</strong>；如果指定了<strong>字段宽度</strong>，如<code>%10s</code>，那么将<strong>读取 10 个字符</strong>或<strong>读到第一个空白符停止</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a><strong>字符串输出</strong></h4><ul>
<li><p><strong>puts()函数</strong></p>
<ul>
<li><p><code>puts()</code><strong>的使用</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> word<span class="token punctuation">[</span><span class="token number">81</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
<span class="token function">puts</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、<code>puts()</code>函数很容易使用，只需要把<strong>字符串地址</strong>传递给它即可。<code>puts()</code><strong>只能</strong>用来<strong>打印字符串</strong><br>2、<code>puts()</code>在显示字符串时会<strong>自动</strong>在其末尾<strong>添加一个换行符</strong><br>3、<code>puts()</code>如何知道<strong>在哪停止</strong>？其在检测到<strong>空字符</strong>(<code>\0</code>)时就<strong>停止输出</strong>，所以必须确保<strong>有空字符</strong>。<strong>典型错误</strong>为打印<strong>字符数组</strong><code>char word[81] = &#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;</code>，字符数组是<strong>没有空字符</strong>的</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>fputs()函数</strong></p>
<ul>
<li><p><code>fputs()</code><strong>与</strong><code>puts()</code><strong>的区别</strong></p>
<blockquote>
<p>1、<code>fputs()</code>与<code>puts()</code>就如同<code>fgets()</code>与<code>gets()</code>相似，<strong>前者</strong>是<strong>后者</strong>的<strong>针对文件</strong>定制的版本<br>2、<code>fputs()</code>函数的<strong>第二个参数</strong>指明<strong>要写入数据的文件</strong>，如果打印在屏幕上，可以用<code>stdout</code>(标准输出)<strong>作为参数</strong><br>3、与<code>puts()</code>不同，<code>fputs()</code><strong>不会</strong>在<strong>末尾添加换行符</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>printf()函数</strong></p>
<ul>
<li><p>和<code>puts()</code>等函数一样，<code>printf()</code>也把<strong>字符串地址</strong>作为参数。<code>printf()</code>输出<strong>字符串</strong>虽然用起来<strong>不如</strong><code>puts()</code><strong>方便</strong>，但其更加<strong>全能</strong>和<strong>可控</strong></p>
</li>
<li><p><code>printf()</code><strong>不会</strong>在每个字符串<strong>末尾添加换行符</strong>，所以必须<strong>人为指定</strong>(使用<code>\n</code>)在哪里使用换行符</p>
</li>
</ul>
</li>
</ul>
<h4 id="自定义输入-x2F-输出函数"><a href="#自定义输入-x2F-输出函数" class="headerlink" title="自定义输入&#x2F;输出函数"></a><strong>自定义输入&#x2F;输出函数</strong></h4><ul>
<li><p>不一定非要使用 C 库的<strong>标准函数</strong>，当然我们也可以自己通过<code>getchar()</code>和<code>putchar()</code>这两个<strong>功能更简单的函数</strong>写一个我们<strong>自己需求的函数</strong></p>
</li>
<li><p><strong>打印字符串，不添加\n</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token comment">// 因为不需要改变字符串值，所以使用const保护数据</span>
<span class="token keyword">void</span> <span class="token function">put1</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
        <span class="token comment">// str++指的是指针指向地址递增，而不是指向的数值递增</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>一个能统计打印字符个数的 puts()函数</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">put2</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 当str指向空字符时，*str值为0，即false，循环结束</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// puts额外添加的换行符，单独输出</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>优化的 fgets()函数，读取整行输入并用空字符代替换行符(即不存储换行符)，或读取一部分输入舍弃其余部分(即越界部分不存储)</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token comment">// 函数的返回值是字符串(char *s_gets)</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span> <span class="token comment">// 创建指针(同时也是存储字符串的变量)</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>                    <span class="token comment">// 即，ret_val != NULL，判断是否读到文件结尾</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token comment">// 忽略跳过正常字符</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 出现换行符替换为空字符，即不存储换行符</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>                          <span class="token comment">// 否则就是读到了空字符</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 丢弃该输入行的其余字符</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a><strong>字符串函数</strong></h4><ul>
<li><p>C 库提供了多个<strong>处理字符串</strong>的<strong>函数</strong>，<strong>ANSI C</strong>把这些函数原型放在<code>string.h</code><strong>头文件</strong>中(即<strong>使用需要调用</strong><code>string.h</code><strong>头文件</strong>)</p>
</li>
<li><p><strong>strlen()函数</strong></p>
<ul>
<li><p><code>strlen()</code>函数用于<strong>统计字符串有效字符的个数</strong>(不含空字符)</p>
</li>
<li><p><strong>使用</strong><code>strlen()</code><strong>截断字符串</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span>           <span class="token comment">// 特别注意需要头文件</span></span>

<span class="token keyword">void</span> <span class="token function">fit</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">></span> size<span class="token punctuation">)</span>   <span class="token comment">// 判断字符串是否比截断位置长</span>
        str<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>     <span class="token comment">// 将第size+1位置的字符替换成空字符</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、由于<code>puts()</code>函数检测到<strong>空字符停止输出</strong>的特性，所以将第<strong>size+1</strong>位置替换为<strong>空字符</strong>，便可实现在此处<strong>停止输出</strong><br>2、若<strong>size</strong>传入<strong>40</strong>，则意味着输出<strong>显示 40 个字符</strong>，因为<code>str[size]</code>的<strong>size</strong>作为<strong>下标</strong>，实际修改的是<strong>第 41 位</strong>的值<br>3、可以使用<code>puts(arr + (size+1))</code>(arr 代指主函数中原字符串名)<strong>输出剩余字符</strong>，但<strong>被替换</strong>为空字符的<strong>字符</strong>已被修改<strong>无法输出</strong>。<code>arr + (size+1)</code>实际就是<strong>被替换字符</strong>的<strong>下一个字符</strong>的<strong>地址</strong>，即<strong>跳过</strong>被修改的<code>\0</code>位置<strong>向后输出</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>strcat()函数</strong></p>
<blockquote>
<p>1、<code>strcat()</code>函数用于<strong>拼接字符串</strong><br>2、<code>strcat()</code>接收<strong>两个字符串</strong>作为<strong>参数</strong>。将<strong>第二个字符串</strong>的<strong>备份</strong>，<strong>拼接</strong>在<strong>第一个字符串末尾</strong>，并把拼接后的<strong>新字符串</strong>作为<strong>第一个字符串</strong>，<strong>第二个字符串不变</strong><br>3、<code>strcat()</code><strong>返回第一个参数</strong>，即<strong>拼接后的第一个字符串的地址</strong><br>4、注意，该函数无法检测<strong>拼接第二个字符串后</strong>，<strong>第一个字符串是否越界</strong>，需要小心使用</p>
</blockquote>
</li>
<li><p><strong>strncat()函数</strong></p>
<blockquote>
<p>1、<code>strncat()</code>函数也用于<strong>拼接字符串</strong>，其为<code>strcat()</code>的<strong>更优选</strong>，可以<strong>预防越界</strong><br>2、相比<code>strcat()</code>，<code>strncat()</code>多了<strong>第三个参数</strong>用于<strong>指定最大添加字符数</strong>。其在<strong>拼接时</strong>，<strong>拼接到指定大小</strong>或<strong>遇到空字符</strong>时<strong>停止</strong></p>
</blockquote>
</li>
<li><p><strong>strcmp()函数</strong></p>
<ul>
<li><p><code>strcmp</code><strong>介绍</strong></p>
<blockquote>
<p>1、<code>strcmp()</code>函数用于<strong>检测字符串的内容是否相等</strong><br>2、一般程序中，<strong>直接比对</strong>两个字符串名，比对的是他们的<strong>地址是否相同</strong>，而非<strong>值是否相同</strong>，<code>strcmp()</code>便用于检测<strong>值是否相同</strong>。比如作为<strong>循环条件判断</strong>时<code>arr != &quot;Quit&quot;</code>就是<strong>典型错误</strong>，因为<strong>比对地址</strong>永远会得到<strong>false</strong><br>3、<code>strcmp()</code>比较的是<strong>字符串</strong>，而不是<strong>整个数组</strong>。例如一个<strong>数组</strong>占用<strong>40 字节</strong>，但其仅储存<strong>5 个字符+1 个空字符</strong>共计<strong>6 字节</strong>。此时<code>strcmp()</code>函数只会比较该数组<strong>第一个空字符前面</strong>的部分。所以可以用<code>strcmp()</code>比较存储在<strong>不同大小数组</strong>中的<strong>字符串</strong></p>
</blockquote>
</li>
<li><p><code>strcmp()</code><strong>返回值</strong></p>
<blockquote>
<p>1、当<strong>两个字符串</strong>比对<strong>完全相同</strong>，则<strong>返回 0</strong>，<strong>不同</strong>则<strong>返回非零值</strong><br>2、<code>strcmp()</code>按照顺序<strong>依次比对字符</strong>，如果比对字符(ASCII 码值)<strong>前者比后者大</strong>(C 和 A)，则<strong>返回 1</strong>；如果<strong>后者比前者大</strong>(A 和 C)，则<strong>返回 -1</strong><br>3、<strong>有些系统</strong>对于上面的结果可能为<strong>2 与 -2</strong>，这些系统的<strong>返回值</strong>为两者的<strong>ASCII 码值</strong>的<strong>差</strong>。但无论如何，<strong>正负</strong>的<strong>规律不变</strong><br>4、注意<strong>ASCII 码</strong>中<strong>大写字母</strong>与<strong>小写字母</strong>比对，<strong>相差 32</strong>，即<strong>小写 &#x3D; 大写 + 32</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>strncmp()函数</strong></p>
<blockquote>
<p>1、<code>strncmp()</code>函数也用于<strong>检测字符串的内容是否相等</strong><br>2、<code>strncmp()</code>相比<code>strcmp()</code>多了<strong>第三个参数</strong>，用于<strong>限定最大对比到第多少位</strong><br>3、<code>strncmp()</code>可以<strong>限制只比对多少位</strong>，例如需要查找<strong>以 astro 开头</strong>的单词，<code>strncmp(arr, &quot;astro&quot;, 5)</code>则表示<strong>只比对前五位</strong>是不是<strong>astro</strong>。而<code>strcmp()</code>会<strong>一直比对</strong>，直至发现不同，这一过程可能会<strong>持续到字符串末尾</strong>，且比对<strong>全部字符</strong></p>
</blockquote>
</li>
<li><p><strong>strcpy()函数</strong></p>
<blockquote>
<p>1、<code>strcpy()</code>函数用于<strong>拷贝字符串</strong><br>2、前面提到过，如果<strong>pts1</strong>和<strong>pts2</strong>都是<strong>指向字符串的指针</strong>，那么<code>pts2 = pts1</code>这个语句<strong>拷贝</strong>的是<strong>字符串的地址</strong>而不是<strong>字符串本身</strong><br>3、<code>strcpy()</code>函数接受<strong>两个参数</strong><code>strcpy(str1, str2)</code>，其将<strong>后者</strong>(地址)指向的字符串<strong>拷贝</strong>至<strong>前者</strong>(地址)。<strong>拷贝出来的</strong>字符串(前者)被称为<strong>目标字符串</strong>，<strong>最初的</strong>字符串(后者)被称为<strong>源字符串</strong>。实际过程中，<code>strcpy()</code>函数先创建<strong>源字符串</strong>内容的<strong>副本</strong>，再让<strong>目标字符串</strong>指向该<strong>副本</strong>。如果其<strong>第一个参数</strong>是<strong>数组</strong>，<strong>不必指向</strong>数组的<strong>开始</strong>。须注意拷贝至的<strong>目标字符串</strong>需要保证有<strong>足够空间</strong>容纳<strong>源字符串</strong>副本<br>4、<code>strcpy()</code>的<strong>返回类型</strong>是<strong>指向 char 的指针</strong>，其<strong>返回值</strong>是<strong>第一个参数的值</strong>，即一个<strong>字符地址</strong></p>
</blockquote>
</li>
<li><p><strong>strncpy()函数</strong></p>
<blockquote>
<p>1、<code>strncpy()</code>函数也用于<strong>拷贝字符串</strong><br>2、<code>strncpy()</code>相比<code>strcpy()</code>多了<strong>第三个参数</strong>，用于<strong>指定可拷贝的最大字符数</strong></p>
</blockquote>
</li>
<li><p><strong>sprintf()函数</strong></p>
<blockquote>
<p>1、<code>sprintf()</code>函数声明在<code>stdio.h</code>头文件中，其用于<strong>将数据写入字符串</strong><br>2、<code>sprintf()</code>可以把<strong>多个元素</strong>组合成<strong>一个字符串</strong>，其接受的<strong>第一个参数</strong>是<strong>目标字符串</strong>的<strong>地址</strong>，其余参数和<code>printf()</code><strong>相同</strong>，即<strong>格式字符串</strong>和<strong>待写入项的列表</strong><br>3、示例：<code>sprintf(str, &quot;%s, %6.2f %s&quot;, &quot;there are&quot;, prize, &quot;yuan.&quot;);</code></p>
</blockquote>
</li>
<li><p><strong>其他字符串函数</strong></p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char *strchr(const char *str, char c)</td>
<td>如果 str 字符串包含 c 字符，返回指向 str 中<strong>首次</strong>出现 c 字符位置的指针，如果未找到 c 字符，返回空指针(末尾的空字符也在查找范围内)</td>
</tr>
<tr>
<td align="center">char *strrchr(const char *str, char c)</td>
<td>如果 str 字符串包含 c 字符，返回指向 str 中<strong>最后一次</strong>出现 c 字符位置的指针，如果未找到 c 字符，返回空指针(末尾的空字符也在查找范围内)</td>
</tr>
<tr>
<td align="center">char *strpbrk(const char *s1, const char *s2)</td>
<td>如果 s1 字符串中包含 s2 字符串中的任意字符，返回指向 s1 字符串首位置的指针，否则返回空指针</td>
</tr>
<tr>
<td align="center">char *strstr(const char *s1, const char *s2)</td>
<td>该函数返回指向 s1 字符串中 s2 字符串出现的首位置，如果没有找到，返回空指针</td>
</tr>
</tbody></table>
</li>
<li><p><strong>ctype.h 字符函数和字符串</strong></p>
<ul>
<li><p><strong>第 7 章</strong>中介绍了<code>ctype.h</code>系列<strong>与字符相关</strong>的<strong>函数</strong>，这些函数虽然<strong>不能处理整个字符串</strong>，但可以通过<strong>自定义编写</strong>，<strong>处理</strong>字符串中的<strong>字符</strong></p>
</li>
<li><p>例如可以自己编写<code>for</code>循环<strong>遍历</strong>字符串中的<strong>字符</strong>，然后对<strong>这些字符</strong>使用<code>ctype.h</code>中的<strong>函数</strong>来<strong>实现一些功能</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="字符串示例：字符串排序"><a href="#字符串示例：字符串排序" class="headerlink" title="字符串示例：字符串排序"></a><strong>字符串示例：字符串排序</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">81</span> </span><span class="token comment">// 限制字符串长度</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIM</span> <span class="token expression"><span class="token number">20</span>  </span><span class="token comment">//可读入最多行数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HALT</span> <span class="token string">""</span> <span class="token comment">//空字符串停止输入</span></span>

<span class="token comment">// 字符串-指针-排序函数</span>
<span class="token keyword">void</span> <span class="token function">stsrt</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strings<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">,</span> seek<span class="token punctuation">;</span>
    <span class="token comment">// 选择排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> top <span class="token operator">&lt;</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> top<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>seek <span class="token operator">=</span> top <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> seek <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> seek<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>strings<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">,</span> strings<span class="token punctuation">[</span>seek<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token comment">// 交换指针</span>
                temp <span class="token operator">=</span> strings<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
                strings<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> strings<span class="token punctuation">[</span>seek<span class="token punctuation">]</span><span class="token punctuation">;</span>
                strings<span class="token punctuation">[</span>seek<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 前面“自定义函数”中提到过的自定义 s_gets()函数</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span> <span class="token comment">// 创建指针(同时也是存储字符串的变量)</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>                    <span class="token comment">// 即，ret_val != NULL，判断是否读到文件结尾</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token comment">// 忽略跳过正常字符</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 出现换行符替换为空字符，即不存储换行符</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>                          <span class="token comment">// 否则就是读到了空字符</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 丢弃该输入行的其余字符</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> input<span class="token punctuation">[</span>LIM<span class="token punctuation">]</span><span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 储存输入的数组</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ptstr<span class="token punctuation">[</span>LIM<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 内含指针变量的数组</span>
    <span class="token keyword">int</span> ct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">// 输入计数</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>                 <span class="token comment">//输出计数</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"最多输入%d行，我将会对它们排序，在一行开始处回车以停止输入\n"</span><span class="token punctuation">,</span> LIM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输入行数在范围内 &amp;&amp; 输入数据正常 &amp;&amp; 第一个字符不是空字符</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>ct <span class="token operator">&lt;</span> LIM <span class="token operator">&amp;&amp;</span> <span class="token function">s_gets</span><span class="token punctuation">(</span>input<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">,</span> SIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> input<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        ptstr<span class="token punctuation">[</span>ct<span class="token punctuation">]</span> <span class="token operator">=</span> input<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//设置指针指向字符串</span>
        ct<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 函数排序</span>
    <span class="token function">stsrt</span><span class="token punctuation">(</span>ptstr<span class="token punctuation">,</span> ct<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> ct<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">puts</span><span class="token punctuation">(</span>ptstr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">最多输入20行，我将会对它们排序，在一行开始处回车以停止输入
O that I was where I would be,
Then would I be where I an not;
But there I an I must be,
And where I would be I can not.

排序后：
And where I would be I can not.
But there I an I must be,
O that I was where I would be,
Then would I be where I an not;</code></pre>
</li>
<li><p><strong>排序指针而非字符串</strong></p>
<blockquote>
<p>1、该程序的<strong>巧妙之处</strong>，在于<strong>排序</strong>的是<strong>指向字符串的指针</strong>，而<strong>不是字符串本身</strong><br>2、最初，<code>ptrst[0]</code><strong>指针</strong>被设置为<code>input[0]</code>，<code>ptrst[1]</code><strong>指针</strong>被设置为<code>input[1]</code>，以此类推，这意味着<strong>指针</strong><code>ptrst[i]</code><strong>指向数组</strong><code>input[i]</code>的<strong>首字符</strong>。每个<code>input[i]</code>都是<strong>内含 81 个元素的数组</strong>，每个<code>ptrst[i]</code>都是一个<strong>单独的指针变量</strong><br>3、排序过程中，将<code>ptrst</code><strong>重新排列</strong>，并<strong>未改变</strong><code>input</code>。例如<strong>按字母顺序</strong><code>input[1]</code>应在<code>input[0]</code>前面，程序便<strong>交换它们的指针</strong>(即<code>ptrst[0]</code>指向<code>input[1]</code>的开始，而<code>ptrst[1]</code>指向<code>input[0]</code>的开始)。这样做比<code>strcpy()</code>函数<strong>交换字符串内容</strong>要<strong>简易快速</strong>的多，且还保留了<code>input</code>的<strong>原始顺序</strong></p>
</blockquote>
</li>
<li><p><strong>选择排序算法</strong></p>
<blockquote>
<p>1、上例中<strong>排序函数</strong>使用的<strong>排序算法</strong>为<strong>选择排序</strong>，具体通过<strong>两层循环</strong>处理以下操作(简称内层循环变量为 j，外层循环变量为 i)<br>2、<strong>内层循环</strong>负责<strong>依次</strong>把<strong>每个未排序的元素</strong>(第 j 个元素)与<strong>所排序位置元素</strong>(第 i 个元素)比较。如果<strong>第 j 个元素</strong>在<strong>第 i 个元素</strong>前面，则<strong>交换两者</strong><br>3、<strong>内层循环结束</strong>时，<strong>第 i 个元素</strong>便是这一轮排序中的<strong>最值</strong>，然后<strong>外层循环</strong>将 i 加 1(比对下一位置)，继续<strong>重复这一过程</strong></p>
</blockquote>
</li>
</ul>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a><strong>命令行参数</strong></h4><ul>
<li><p><strong>命令行简介</strong></p>
<blockquote>
<p>1、在<strong>图形界面</strong>普及之前都是用<strong>命令行界面</strong>，<strong>UNIX</strong>和<strong>DOS</strong>就是例子。<strong>命令行</strong>是在<strong>命令行环境</strong>中，用户为运行程序<strong>输入命令的行</strong><br>2、假设一个文件中有一个名为<strong>fuss</strong>的<strong>程序</strong>，在<strong>UNIX</strong>环境中<strong>运行该程序</strong>的<strong>命令行</strong>是<code>$ fuss</code>，或者<strong>Windows</strong>命令提示模式下是<code>C&gt; fuss</code>($ 和 C&gt; 都是命令行自带的的行首标识)<br>3、<strong>命令行参数</strong>是同一行的<strong>附加项</strong>，比如<code>$ fuss -r Ginger</code>，一个<strong>C 程序</strong>可以<strong>读取并使用</strong>这些<strong>附加项</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*test.c*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The command line has %d arguments:\n"</span><span class="token punctuation">,</span> argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: %s\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">,</span> argv<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>编译后使用终端 cmd<strong>运行命令行</strong>及<strong>输出结果</strong></p>
<pre class="language-none"><code class="language-none">C&gt; test.exe resistance is futile
The command line has 3 arguments:
1: resistance
2: is
3: futile</code></pre>
</li>
<li><p><strong>程序解析</strong></p>
<blockquote>
<p>1、C 编译器<strong>允许</strong><code>main()</code><strong>没有参数</strong>或者<strong>有两个参数</strong>(一些实现会允许更多参数，属于对标准的扩展)<br>2、<code>main()</code>有<strong>两个参数</strong>时，<strong>第一个参数</strong>表示命令行中<strong>字符串数量</strong>。过去，这个<strong>int 类型</strong>的<strong>参数</strong>称为<strong>argc</strong>(参数计数 argument count)<br>3、系统用<strong>空格</strong>表示一个<strong>字符串的结束</strong>和<strong>下一个字符串的开始</strong>。因此<code>test.exe resistance is futile</code>中<strong>一共 4 个字符串</strong>，其中<strong>后 3 个</strong>供<code>test.exe</code>使用<br>4、该程序把<strong>命令行字符串</strong>储存在<strong>内存</strong>中，并把每个字符串的<strong>地址</strong>存储在<strong>指针数组</strong>中，而<strong>该数组的地址</strong>则被存储在<code>main()</code>的<strong>第二个参数</strong>中。按照惯例，这个<strong>指向指针</strong>的<strong>指针</strong>称为<strong>argv</strong>(参数值 argument value)<br>5、如果系统允许，就把<strong>程序本身的名称</strong>赋给<code>argv[0]</code>，把随后的<strong>第一个字符串</strong>赋给<code>argv[1]</code>，以此类推。在我们的例子中，<code>argv[0]</code>指向<strong>test.exe</strong>，<code>argv[1]</code>指向<strong>resistance</strong>，<code>argv[2]</code>指向<strong>is</strong>，<code>argv[3]</code>指向<strong>futile</strong><br>6、<code>main()</code>中的<strong>形式参数</strong>与其他<strong>带形参的函数</strong>相同，许多程序员用<strong>不同的形式</strong>声明<strong>argv</strong>。如<code>int main(int argc, char **argv)</code>，其中<code>**argv</code>与<code>*argv[]</code><strong>等价</strong>，<strong>argv</strong>也是一个<strong>指向指针的指针</strong></p>
</blockquote>
</li>
</ul>
<h4 id="字符串转换为数字"><a href="#字符串转换为数字" class="headerlink" title="字符串转换为数字"></a><strong>字符串转换为数字</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>数字</strong>(如 213)既能以<strong>字符串形式</strong>(‘2’,’1’,’3’,’\0’)<strong>存储</strong>，也能以<strong>数值形式</strong>(int 类型值 213)<strong>存储</strong><br>2、C 进行<strong>数值运算</strong>要求用<strong>数值形式</strong>，但在屏幕上<strong>显示数字</strong>要求用<strong>字符串形式</strong>，因为屏幕显示的是<strong>字符</strong>。<code>printf()</code>和<code>sprintf()</code>函数通过<strong>转换说明</strong>将数字从<strong>数值形式</strong>转换成<strong>字符串形式</strong>，而<code>scanf()</code>可以把输入的<strong>字符串</strong>转换成<strong>数值形式</strong><br>3、假设你编写的程序需要使用<strong>数值命令形参</strong>，但是<strong>命令形参数</strong>被读取为<strong>字符串</strong>。因此要使用<strong>数值</strong>必须先把<strong>字符串转换成数字</strong>。C 的<code>stdlib.h</code>中有一些函数专门用于处理这类问题</p>
</blockquote>
</li>
<li><p><strong>atoi()示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> times<span class="token punctuation">;</span>
    <span class="token comment">// 使用atoi()函数转换为数值比对</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> <span class="token punctuation">(</span>times <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage:%s, positive-number\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 提示语句</span>
    <span class="token keyword">else</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> times<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Hello, good looking!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>atoi()与其类别函数</strong></p>
<blockquote>
<p>1、<code>atoi()</code>函数用于将<strong>字符串</strong>转换为<strong>int 数值形式</strong><br>2、<code>atoi()</code>函数能处理<strong>字符串开头</strong>的<strong>数字部分</strong>，例如<code>123</code>、<code>123hello</code>都会被<strong>转换</strong>成<strong>123</strong>。但如果<strong>开头不是整数</strong>，如<code>hello123</code>、<code>hello</code>这种字符串，在我们的<strong>C 实现</strong>中会<strong>返回 0</strong>，但<strong>C 标准</strong>规定这种行为是<strong>未定义</strong>的<br>3、因此，使用有<strong>错误检测功能</strong>的<code>strtol()</code>函数(马上介绍)会<strong>更安全</strong><br>4、除了<code>stoi()</code>外，<code>stdlib.h</code>还包含了其他一些<strong>类似函数</strong>的原型，如下表</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">atoi()</td>
<td>将字符串转换成 int 类型数值形式</td>
</tr>
<tr>
<td align="center">atof()</td>
<td>将字符串转换成 float 类型数值形式</td>
</tr>
<tr>
<td align="center">atol()</td>
<td>将字符串转换成 long 类型数值形式</td>
</tr>
</tbody></table>
</li>
<li><p><strong>strtol()示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">// 前面自定义函数提到的自定义s_gets()函数</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span> <span class="token comment">// 创建指针(同时也是存储字符串的变量)</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>                    <span class="token comment">// 即，ret_val != NULL，判断是否读到文件结尾</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token comment">// 忽略跳过正常字符</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 出现换行符替换为空字符，即不存储换行符</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>                          <span class="token comment">// 否则就是读到了空字符</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 丢弃该输入行的其余字符</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>end<span class="token punctuation">;</span>
    <span class="token keyword">long</span> value<span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    value <span class="token operator">=</span> <span class="token function">strtol</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token operator">&amp;</span>end<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 十进制</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"10进制：%ld，终止于%s (%d)\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> end<span class="token punctuation">,</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    value <span class="token operator">=</span> <span class="token function">strtol</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token operator">&amp;</span>end<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 十六进制</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"16进制：%ld，终止于%s (%d)\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> end<span class="token punctuation">,</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">10
10进制：10，终止于 (0)
16进制：16，终止于 (0)</code></pre>

<pre class="language-none"><code class="language-none">10atom
10进制：10，终止于atom (97)
16进制：266，终止于tom (116)</code></pre>
</li>
<li><p><strong>strtol()与其类别函数</strong></p>
<blockquote>
<p>1、<code>atrtol()</code>函数用于将<strong>字符串</strong>转换为<strong>long 数值形式</strong><br>2、<code>strtol()</code>的<strong>第一个参数</strong>接受一个<strong>指向待转换字符串</strong>的<strong>指针</strong>；<strong>第二个参数</strong>接受一个<strong>指针的地址</strong>，该指针被<strong>设置</strong>为标识<strong>输入数字结束字符</strong>的<strong>地址</strong>；<strong>第三个参数</strong>接受一个<strong>整数</strong>，表示以<strong>什么进制</strong>读入数字<br>3、<strong>示例中</strong>，如果<strong>end</strong>指针<strong>指向一个字符</strong>，那么<strong>解引用</strong><code>*end</code>就是一个字符。<strong>第一次转换</strong>读到<strong>空字符</strong>结束(‘1’,’0’,’\0’)，此时<strong>end</strong>指向<strong>空字符</strong>，打印<strong>end</strong>会显示一个<strong>空字符</strong>，后面的<code>%d</code>输出的<code>*end</code>显示的是<strong>空字符</strong>的<strong>ASCII 码</strong>(即 0)<br>4、<strong>第二次转换</strong>，以<strong>十进制</strong>读入字符串，<strong>end</strong>的值是<strong>字符’a’<strong>的</strong>地址</strong>，所以打印<strong>end</strong>显示<strong>字符串”atom”<strong>；以</strong>十六进制</strong>读入，函数将<strong>atom</strong>的<strong>字符 a</strong>识别为合法的<strong>十六进制数</strong>，所以将十六进制数<strong>10a</strong>转换为<strong>266</strong><br>5、该函数<strong>最多可以支持</strong>转换<strong>三十六进制</strong>，即<strong>a~z</strong>都可以<strong>用作数字</strong><br>6、除了<code>strtol()</code>外，<code>stdlib.h</code>还包含了其他一些<strong>类似函数</strong>的原型，如下表</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">strtol()</td>
<td>将字符串转换成 long 类型数值形式</td>
</tr>
<tr>
<td align="center">strtoul()</td>
<td>将字符串转换成 unsigned long 类型数值形式</td>
</tr>
<tr>
<td align="center">strtod()</td>
<td>将字符串转换成 double 类型数值形式(只以十进制转换，只需要两个参数)</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="储存类别、链接和内存管理"><a href="#储存类别、链接和内存管理" class="headerlink" title="储存类别、链接和内存管理"></a><strong>储存类别、链接和内存管理</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：储存类别(引入)；标识符、表达式与左值；作用域、链接与存储期；作用域；翻译单元和文件；链接；储存期；使块作用域变量具有静态存储期；C 的存储类别；自动变量；内层块与外层块变量同名隐藏；编译器对 C99 和 C11 的支持；寄存器变量；块作用域的静态变量；外部链接的静态变量；内部链接的静态变量；存储类别补充；多文件；储存类别说明符；储存类别和函数；存储类别的选择；随机数函数和静态变量;随机数实现原理；自动重置种子；分配内存：<code>malloc()</code>和<code>free()</code>；<code>calloc()</code>函数；ANSI C 类型限定符；<code>volatile</code>类型限定符；<code>restrict</code>类型限定符；<code>_Atomic</code>类型限定符</p>
</blockquote>
</div>

<h4 id="储存类别-引入"><a href="#储存类别-引入" class="headerlink" title="储存类别(引入)"></a><strong>储存类别(引入)</strong></h4><ul>
<li><p>C 提供了多种<strong>不同的模型</strong>或<strong>存储类别</strong>在<strong>内存</strong>中存储<strong>数据</strong>。要理解这些<strong>存储类别</strong>，需要先复习一些<strong>概念和术语</strong></p>
</li>
<li><p><strong>概念术语复习</strong></p>
<blockquote>
<p>1、截至目前，所有的<strong>示例程序</strong>的<strong>数据</strong>都存储在<strong>内存</strong>中<br>2、从<strong>硬件层面</strong>来看，被存储的每个<strong>值</strong>都占用一定的<strong>物理内存</strong>，C 把这样的<strong>一块内存</strong>称为<strong>对象</strong>。对象可以存储<strong>一个或多个值</strong>。一个对象可能并<strong>未存储实际的值</strong>，但当它<strong>存储适当的值</strong>时一定具有<strong>相应的大小</strong>(<strong>面向对象编程</strong>中对象指的是<strong>类对象</strong>，其定义包括<strong>数据</strong>和允许对数据进行的<strong>操作</strong>，但 C <strong>不是面向对象</strong>编程语言)<br>3、从<strong>软件层面</strong>来看，<strong>程序</strong>需要一种方法来<strong>访问对象</strong>。可以通过<strong>声明变量</strong>来完成，如<code>int entity = 3;</code>，该声明<strong>创建</strong>了一个名为<strong>entity</strong>的<strong>标识符</strong>。<strong>标识符</strong>是一个<strong>名称</strong>，这种情况下，<strong>标识符</strong>可以用来<strong>指定</strong>特定<strong>对象的内容</strong>，其遵循变量的<strong>命名规则</strong>，该例中，<strong>标识符 entity</strong>即是<strong>软件</strong>(即 C 程序)指定<strong>硬件内存</strong>中的对象的方式</p>
</blockquote>
</li>
<li><p><strong>标识符、表达式与左值</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> entity <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pt <span class="token operator">=</span> <span class="token operator">&amp;</span>entity<span class="token punctuation">;</span>
<span class="token keyword">int</span> ranks<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、<strong>变量名</strong>不是<strong>指定对象</strong>的唯一途径<br>2、<strong>pt</strong>是一个<strong>标识符</strong>，它<strong>指定</strong>了一个<strong>储存地址</strong>的<strong>对象</strong>。但是，表达式<code>*pt</code><strong>不是标识符</strong>，因为它<strong>不是一个名称</strong>，但它确实<strong>指定</strong>了一个<strong>对象</strong>，这种情况下，它与<strong>entity</strong>指定的<strong>对象相同</strong><br>3、一般而言，那些<strong>指定对象</strong>的<strong>表达式</strong>被称为<strong>左值</strong>。所以<strong>entity</strong>既是<strong>标识符</strong>也是<strong>左值</strong>，<code>*pt</code>既是<strong>表达式</strong>也是<strong>左值</strong><br>4、按照这个思路，<code>ranks + 2 * entity</code>既<strong>不是标识符</strong>(不是名称)也<strong>不是左值</strong>(不指定内存位置上的内容)。但是表达式<code>*(ranks + 2 * entity)</code>是一个<strong>左值</strong>，因为它<strong>指定了特定内存位置的值</strong>，即<strong>ranks</strong>的<strong>第七个元素</strong><br>5、所有这些示例中，如果可以<strong>使用左值改变对象中的值</strong>，该<strong>左值</strong>就是一个<strong>可修改的左值</strong><br>6、例如<code>const char *pc = &quot;Behold&quot;;</code>这条声明，创建了一个<strong>标识符为 pc</strong>的<strong>对象</strong>，存储<strong>字符串的地址</strong>。由于可以设置<strong>pc</strong>重新<strong>指向</strong>其他字符串，所以<strong>标识符 pc</strong>是一个<strong>可修改的左值</strong>(该<code>const</code>只保证字符串<strong>内容不被修改</strong>)。由于<code>*pc</code><strong>指向</strong>存储’B’字符的<strong>数据对象</strong>，所以<code>*pc</code>是一个<strong>左值</strong>，但<strong>不是可修改的左值</strong>；与此类似，因为<strong>字符串字面量</strong>本身<strong>指定</strong>了存储字符串的<strong>对象</strong>，所以它也是一个<strong>左值</strong>，但也<strong>不是可修改的左值</strong></p>
</blockquote>
</li>
<li><p><strong>新概念引入</strong></p>
<blockquote>
<p>1、可以用<strong>存储期</strong>描述<strong>对象</strong>，所谓<strong>存储期</strong>是指<strong>对象</strong>在<strong>内存</strong>中<strong>保留了多长时间</strong><br>2、<strong>标识符</strong>用于<strong>访问对象</strong>，可以用<strong>作用域</strong>和<strong>链接</strong>描述标识符，标识符的<strong>作用域</strong>和<strong>链接</strong>表明了<strong>程序哪些部分可以使用它</strong><br>3、不同的<strong>存储类别</strong>具有不同的<strong>存储期</strong>、<strong>作用域</strong>和<strong>链接</strong><br>4、<strong>标识符</strong>可以在源代码的<strong>多文件</strong>中<strong>共享</strong>、可用于<strong>特定文件</strong>的<strong>任意函数</strong>中、可仅限于<strong>特定函数</strong>中使用，甚至只在<strong>函数中某部分</strong>使用<br>5、<strong>对象</strong>可存在于程序的<strong>执行期</strong>，也可仅存在于它<strong>所在函数的执行期</strong>。对于<strong>并发编程</strong>，<strong>对象</strong>可以在<strong>特定线程的执行期</strong>存在</p>
</blockquote>
</li>
</ul>
<h4 id="作用域、链接与存储期"><a href="#作用域、链接与存储期" class="headerlink" title="作用域、链接与存储期"></a><strong>作用域、链接与存储期</strong></h4><ul>
<li><p><strong>作用域</strong></p>
<ul>
<li><p><strong>作用域</strong>描述程序中<strong>可访问标识符</strong>的<strong>区域</strong>。一个 C 变量的<strong>作用域</strong>可以是<strong>块作用域</strong>、<strong>函数作用域</strong>、<strong>函数原型作用域</strong>或<strong>文件作用域</strong></p>
</li>
<li><p><strong>块作用域</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">blocky</span><span class="token punctuation">(</span><span class="token keyword">double</span> cleo<span class="token punctuation">)</span>      <span class="token comment">// cleo的作用域开始</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> partrick <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>      <span class="token comment">// partrick的作用域开始</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// i的作用域开始</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">double</span> q <span class="token operator">=</span> cleo <span class="token operator">*</span> i<span class="token punctuation">;</span>    <span class="token comment">// q的作用域开始</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        partrick <span class="token operator">*=</span> q<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>                           <span class="token comment">// i,q的作用域结束</span>
    <span class="token keyword">return</span> patrick<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>                               <span class="token comment">// cleo,partrick的作用域结束</span></code></pre>

<blockquote>
<p>1、到目前为止，<strong>示例程序</strong>中使用的<strong>变量</strong>几乎都具有<strong>块作用域</strong><br>2、<strong>块</strong>是用一对<strong>花括号括起来</strong>的<strong>代码区域</strong>。例如<strong>整个函数体</strong>是一个<strong>块</strong>，函数中的任意<strong>复合语句</strong>也是一个<strong>块</strong><br>3、定义在<strong>块</strong>中的<strong>变量</strong>具有<strong>块作用域</strong>，<strong>块作用域变量</strong>的<strong>可见范围</strong>是从<strong>定义处</strong>到包含该定义的<strong>块的末尾</strong>。另外，虽然函数<strong>形参声明</strong>在函数的<strong>左花括号之前</strong>，但它们也<strong>具有块作用域</strong>，属于<strong>函数体</strong>这个<strong>块</strong>，同理对于一些<strong>复合语句</strong>也是这样(如<code>for()</code>循环)</p>
</blockquote>
</li>
<li><p><strong>函数作用域</strong></p>
<blockquote>
<p>1、<strong>函数作用域</strong>仅用于<code>goto</code><strong>语句</strong>的<strong>标签</strong>。这意味着即使<strong>一个标签首次出现</strong>在函数的<strong>内层块</strong>中，它的<strong>作用域</strong>也延伸至<strong>整个函数</strong><br>2、如果在<strong>两个块</strong>中<strong>使用相同的标签</strong>会很混乱，<strong>标签</strong>的<strong>函数作用域</strong>防止了这样的事情发生</p>
</blockquote>
</li>
<li><p><strong>函数原型作用域</strong></p>
<blockquote>
<p>1、<strong>函数原型作用域</strong>用于<strong>函数原型</strong>中的<strong>形参名</strong>：<code>int def(int mouse, double large);</code>，<strong>函数原型作用域</strong>的<strong>范围</strong>是从形参<strong>定义处</strong>到函数原型<strong>声明结束</strong><br>2、这意味着，<strong>编译器</strong>在处理<strong>函数原型</strong>中的<strong>形参</strong>时，<strong>只关注它的类型</strong>，而<strong>形参名</strong>(如果有的话，因为可以省略)通常<strong>无关紧要</strong>。而且即使函数原型<strong>有形参名</strong>，也<strong>不必</strong>与<strong>函数定义</strong>中的形参名<strong>相匹配</strong><br>3、只有在<strong>变长数组</strong>中，<strong>形参名才有用</strong>：<code>void def(int n, int m, arr[n][m])</code>，<strong>方括号</strong>中<strong>必须使用</strong>在<strong>函数原型</strong>中<strong>已声明的名称</strong></p>
</blockquote>
</li>
<li><p><strong>文件作用域</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> units <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 具有文件作用域</span>

<span class="token keyword">void</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、变量定义在<strong>函数</strong>的<strong>外面</strong>，具有<strong>文件作用域</strong>。具有<strong>文件作用域</strong>的<strong>变量</strong>，从<strong>定义处</strong>到该定义<strong>所在文件末尾</strong>均<strong>可见</strong><br>2、如示例<strong>units</strong>变量，具有<strong>文件作用域</strong>，<code>def()</code>和<code>main()</code><strong>都可以使用它</strong>(更准确的说，<strong>units</strong>具有<strong>外部链接文件作用域</strong>，稍后讲解)<br>3、由于这样的<strong>变量可用于多个函数</strong>，所以<strong>文件作用域变量</strong>也被称为<strong>全局变量</strong></p>
</blockquote>
</li>
<li><p><strong>翻译单元和文件</strong></p>
<blockquote>
<p>1、你认为的<strong>多个文件</strong>在<strong>编译器</strong>中可能<strong>以一个文件出现</strong>。例如，通常在<strong>源代码</strong>(.c 拓展名)中<strong>包含一个或多个头文件</strong>(.h 拓展名)，<strong>头文件</strong>会依次<strong>包含其他头文件</strong>，所以会包含<strong>多个</strong>单独的<strong>物理文件</strong><br>2、但是，<strong>C 预处理</strong>实际上是用包含的<strong>头文件内容</strong>替换<code>#include</code><strong>指令</strong>。所以<strong>编译器</strong>把<strong>源代码文件</strong>和<strong>所有头文件</strong>都看成是<strong>一个</strong>包含信息的<strong>单独文件</strong>，这个文件被称为<strong>翻译单元</strong><br>3、描述一个具有<strong>文件作用域</strong>的<strong>变量</strong>时，它的<strong>实际可见范围</strong>是<strong>整个翻译单元</strong>。如果程序由<strong>多个源代码文件</strong>组成，那么该程序也将由<strong>多个翻译单元</strong>组成，<strong>每个翻译单元</strong>对应<strong>一个源代码文件</strong>和<strong>它所包含的文件</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>链接</strong></p>
<ul>
<li><p><strong>基本概念</strong></p>
<blockquote>
<p>1、C 变量有 3 种<strong>链接属性</strong>：<strong>外部链接</strong>、<strong>内部链接</strong>或<strong>无链接</strong><br>2、具有<strong>块作用域</strong>、<strong>函数作用域</strong>或<strong>函数原型作用域</strong>的<strong>变量</strong>都是<strong>无链接变量</strong>。这意味着这些变量<strong>属于定义它们的块、函数或函数原型私有</strong><br>3、具有<strong>文件作用域</strong>的<strong>变量</strong>可以是<strong>外部链接</strong>或<strong>内部链接</strong>。<strong>外部链接变量</strong>可以在<strong>多文件程序</strong>中使用，<strong>内部链接变量</strong>只能在<strong>一个翻译单元</strong>中使用</p>
</blockquote>
</li>
<li><p><strong>非正式用语的简称</strong></p>
<blockquote>
<p>1、C 标准用<strong>内部链接的文件作用域</strong>描述<strong>仅限于一个翻译单元</strong>的作用域，用<strong>外部链接的文件作用域</strong>描述<strong>可延伸至其他翻译单元</strong>的作用域，这些是<strong>正式用语</strong><br>2、对于程序员而言这些用语太长了。因此一些程序员把<strong>内部链接的文件作用域</strong>简称为<strong>文件作用域</strong>，把<strong>外部链接的文件作用域</strong>简称为<strong>全局作用域</strong>或<strong>程序作用域</strong></p>
</blockquote>
</li>
<li><p>如何知道<strong>文件作用域变量</strong>是<strong>内部链接</strong>还是<strong>外部链接</strong>？可以看<strong>外部定义</strong>是否使用了<strong>储存类别说明符</strong><code>static</code>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> giants <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>             <span class="token comment">// 文件作用域，外部链接</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> dodgers <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>     <span class="token comment">// 文件作用域，内部链接</span>
<span class="token comment">/*该文件和同一程序的其他文件，都可以使用giants，但dodgers属文件私有*/</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>存储期</strong></p>
<ul>
<li><p><strong>作用域</strong>和<strong>链接</strong>描述了<strong>标识符</strong>的<strong>可见性</strong>，<strong>存储期</strong>描述了通过这些<strong>标识符</strong>访问的<strong>对象</strong>的<strong>生存期</strong>。C 对象有 4 种<strong>存储期</strong>：<strong>静态存储期</strong>、<strong>线程存储期</strong>、<strong>自动存储期</strong>、<strong>动态分配存储期</strong></p>
</li>
<li><p><strong>静态存储期</strong></p>
<blockquote>
<p>1、如果<strong>对象</strong>具有<strong>静态存储期</strong>，那么它在<strong>程序执行期间一直存在</strong>。<strong>文件作用域变量</strong>具有<strong>静态存储期</strong><br>2、注意，对于<strong>文件作用域变量</strong>，<strong>关键字</strong><code>static</code>表明其<strong>链接</strong>属性，而非<strong>存储期</strong>。所有的<strong>文件作用域变量</strong>都具有<strong>静态存储期</strong></p>
</blockquote>
</li>
<li><p><strong>线程存储期</strong></p>
<blockquote>
<p>1、<strong>线程存储期</strong>用于<strong>并发程序</strong>设计，<strong>程序执行</strong>可被分为<strong>多个线程</strong>。具有<strong>线程存储期</strong>的<strong>对象</strong>，从<strong>被声明</strong>到<strong>线程结束</strong>都<strong>一直存在</strong><br>2、以<strong>关键字</strong><code>_Thread_local</code>声明一个<strong>对象</strong>时，每个<strong>线程</strong>都获得该<strong>变量</strong>的<strong>私有备份</strong></p>
</blockquote>
</li>
<li><p><strong>自动存储期</strong></p>
<blockquote>
<p>1、<strong>块作用域</strong>通常都具有<strong>自动存储期</strong>。当程序<strong>进入</strong>定义这些变量的<strong>块</strong>时，为这些变量<strong>分配内存</strong>，<strong>退出</strong>这个<strong>块</strong>时，<strong>释放</strong>刚才分配的<strong>内存</strong><br>2、这种做法相当于把<strong>自动变量</strong>占用的<strong>内存</strong>视为一个<strong>可重复使用</strong>的<strong>工作区</strong>或<strong>暂存区</strong>。例如<strong>一个函数调用结束</strong>时，其<strong>变量</strong>占用的<strong>内存</strong>可用于<strong>存储下一个被调函数的变量</strong><br>3、<strong>变长数组</strong>稍有不同，它们的<strong>存储期</strong>从<strong>声明处</strong>到<strong>块的末尾</strong>，而不是从<strong>块的开始</strong>到<strong>末尾</strong><br>4、我们到<strong>目前为止</strong>使用的<strong>局部变量</strong>都是<strong>自动类别</strong>。然而，<strong>块作用域变量</strong>也能具有<strong>静态存储期</strong>，为此需要<strong>把变量声明在块中</strong>并在声明前加上<strong>关键字</strong><code>static</code></p>
</blockquote>
</li>
<li><p><strong>使块作用域变量具有静态存储期</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">more</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> index<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> ct<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、该程序中，变量<strong>ct</strong>由于<strong>声明在块中</strong>且使用<code>static</code><strong>关键字</strong>，因此<strong>ct 存储在静态内存中</strong>，从<strong>程序被载入</strong>到<strong>程序结束</strong>期间都<strong>一直存在</strong><br>2、注意，它的<strong>作用域</strong>定义在<code>more()</code>函数<strong>块</strong>中，只有在<strong>执行该函数</strong>时，程序才能使用<strong>ct</strong>访问它所<strong>指向的对象</strong><br>3、但是，<strong>该函数</strong>可以给<strong>其他函数</strong>提供该<strong>存储区</strong>的<strong>地址</strong>，以便<strong>间接访问</strong>该<strong>对象</strong>，例如通过<strong>指针形参</strong>或<strong>返回值</strong></p>
</blockquote>
</li>
<li><p><strong>动态分配存储期</strong>在本章后面介绍。C 使用<strong>作用域</strong>、<strong>链接</strong>和<strong>存储期</strong>为变量定义了<strong>多种存储方案</strong>。由于教程不涉及<strong>并发程序</strong>设计，所以不再赘述这方面的内容</p>
</li>
</ul>
</li>
</ul>
<h4 id="C-的存储类别"><a href="#C-的存储类别" class="headerlink" title="C 的存储类别"></a><strong>C 的存储类别</strong></h4><ul>
<li><p>C 有 5 种<strong>存储类别</strong>：<strong>自动</strong>、<strong>寄存器</strong>、<strong>静态块作用域</strong>、<strong>静态外部链接</strong>、<strong>静态内部链接</strong>。如下表：</p>
<table>
<thead>
<tr>
<th align="center">存储类别</th>
<th align="center">存储期</th>
<th align="center">作用域</th>
<th align="center">链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自动</td>
<td align="center">自动</td>
<td align="center">块</td>
<td align="center">无</td>
<td>块内</td>
</tr>
<tr>
<td align="center">寄存器</td>
<td align="center">自动</td>
<td align="center">块</td>
<td align="center">无</td>
<td>块内，使用关键字<code>register</code></td>
</tr>
<tr>
<td align="center">静态块作用域(静态无链接)</td>
<td align="center">静态</td>
<td align="center">块</td>
<td align="center">无</td>
<td>块内，使用关键字<code>static</code></td>
</tr>
<tr>
<td align="center">静态外部链接</td>
<td align="center">静态</td>
<td align="center">文件</td>
<td align="center">外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td align="center">静态内部链接</td>
<td align="center">静态</td>
<td align="center">文件</td>
<td align="center">内部</td>
<td>所有函数外，使用关键字<code>static</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>自动变量</strong></p>
<ul>
<li><p>属于<strong>自动存储类别</strong>的<strong>变量</strong>具有<strong>自动存储期</strong>、<strong>块作用域</strong>且<strong>无链接</strong>，其拥有这<strong>三者</strong>的所有<strong>特点</strong>。<strong>默认情况</strong>下，声明在<strong>块</strong>或<strong>函数头</strong>中的<strong>任何变量</strong>都属于<strong>自动存储类别</strong></p>
</li>
<li><p><code>auto</code><strong>关键字</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> <span class="token keyword">int</span> plox<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、为了<strong>更清楚表达</strong>你的<strong>意图</strong>，可以显式使用<strong>关键字</strong><code>auto</code><br>2、<strong>关键字</strong><code>auto</code>是<strong>存储类别说明符</strong>。但要注意<code>auto</code>在<strong>C++<strong>中用法</strong>完全不同</strong></p>
</blockquote>
</li>
<li><p><strong>内层块与外层块变量同名隐藏</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">// 原始的 x=30</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"outer block:%p %d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 定义一个单独的块</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">77</span><span class="token punctuation">;</span> <span class="token comment">// 新的 x，隐藏了原始的 x</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"inner block:%p %d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 离开块后，仍使用原始的 x</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"outer block:%p %d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">33</span><span class="token punctuation">)</span> <span class="token comment">// 原始的 x</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 新的 x，隐藏了原始的 x</span>
        x<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"while loop :%p %d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"outer block:%p %d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">outer block:000000000061FE1C 30
inner block:000000000061FE18 77
outer block:000000000061FE1C 30
while loop :000000000061FE14 101
while loop :000000000061FE14 101
while loop :000000000061FE14 101
outer block:000000000061FE1C 34</code></pre>

<blockquote>
<p>1、如果<strong>内层块</strong>与<strong>外层块</strong>变量<strong>同名</strong>，<strong>内层块</strong>将会<strong>隐藏外层块的定义</strong>，但当<strong>离开内层块</strong>后，<strong>外层块变量</strong>的<strong>作用域</strong>又回到了<strong>原来的作用域</strong><br>2、程序中，较难理解的是<code>while()</code>循环部分。<code>while()</code>循环的<strong>条件</strong>内使用的<strong>x</strong>是<strong>原始的 x</strong>，其每次<strong>先参与</strong><code>while</code>的<strong>判断</strong>，再<strong>自增 1</strong>(因此参与判断的 x 的值分别为 30、31、32、33，当 x&#x3D;33 时循环中断，但由于<code>x++</code>所以 x 仍然自增 1)。<code>while()</code>循环的<strong>内部</strong>，<strong>每次</strong>执行循环都会创建一个<strong>新的 x&#x3D;100</strong>(此时进入块内，与原始的 x 已无关系，原始 x 已被隐藏)，由于<strong>块作用域</strong>每次循环结束就<strong>销毁新建的 x</strong>，因此实际创建了<strong>三个 x</strong>，又由于<strong>自动存储期</strong>每次<strong>创建的 x</strong>会<strong>复用</strong>前面<strong>销毁的 x 的地址</strong>，所以<strong>三次输出</strong>都是<strong>101</strong>且<strong>地址相同</strong><br>3、我们的<strong>编译器</strong>在<strong>创建</strong><code>while()</code>循环体中的<strong>x</strong>时，并<strong>未复用</strong>前一个<strong>块</strong>(即程序中单独的那对花括号)<strong>销毁的 x 的地址</strong>，有的编译器会这样做(则<code>while</code>的<strong>x</strong>复用前面<code>FE18</code>的地址)</p>
</blockquote>
</li>
<li><p><strong>没有花括号的块</strong></p>
<blockquote>
<p>1、前面提到一个<strong>C99</strong>特性：作为<strong>循环</strong>或<code>if</code><strong>语句</strong>的一部分，即使<strong>不使用花括号</strong>，<strong>也是一个块</strong><br>2、更完整的说，<strong>整个循环</strong>是它<strong>所在块</strong>的<strong>子块</strong>，<strong>循环体</strong>是整个<strong>循环块</strong>的<strong>子块</strong>。相似的，<code>if</code><strong>语句</strong>是一个<strong>块</strong>，其相关联的<strong>子语句</strong>是<code>if</code><strong>语句</strong>的<strong>子块</strong></p>
</blockquote>
</li>
<li><p><strong>编译器对 C99 和 C11 的支持</strong></p>
<blockquote>
<p>1、有些<strong>编译器</strong>并<strong>不支持 C99&#x2F;C11</strong>的这些<strong>作用域规则</strong>(如 Microsoft Visual Stutio 2012)<br>2、有些<strong>编译器</strong>会提供<strong>激活这些规则</strong>的选项，如<strong>gcc</strong>默认<strong>支持</strong>了<strong>部分 C99 特性</strong>，但要用<code>-std=c99</code>选项激活<strong>其他特性</strong>，命令行输出<code>gcc -std=c99 文件名</code>激活<br>3、与此类似，<strong>gcc</strong>或<strong>clang</strong>都要使用<code>-std=c1x</code>或<code>-std=c11</code>选项，才支持<strong>C11 特性</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>寄存器变量</strong></p>
<blockquote>
<p>1、<strong>变量</strong>通常存储在<strong>内存</strong>中。但<strong>如果幸运的话</strong>，<strong>寄存器变量</strong>将被存储在<strong>CPU 的寄存器</strong>中，或者概括地说，存储在<strong>最快的可用内存</strong>中。与<strong>普通变量</strong>相比，<strong>访问</strong>和<strong>处理</strong>这些变量的<strong>速度更快</strong><br>2、由于<strong>寄存器变量</strong>存储在<strong>寄存器</strong>中，而非<strong>内存</strong>中，所以<strong>无法获取</strong>寄存器变量的<strong>地址</strong><br>3、绝大多数方面，<strong>寄存器变量</strong>和<strong>自动变量</strong>一样(块作用域、无链接、自动存储期)。使用<strong>存储类别说明符</strong><code>register</code>即可<strong>声明寄存器变量</strong>，如<code>register int quick;</code><br>4、前面之所以说“<strong>如果幸运的话</strong>”，是因为声明变量为<code>register</code>与<strong>直接命令</strong>相比更像是一种<strong>请求</strong>。<strong>编译器</strong>会根据实际<strong>寄存器</strong>或<strong>最快可用内存</strong>的<strong>数量</strong>衡量你的请求，或者<strong>直接忽略</strong>。如果<strong>忽略</strong>，<strong>寄存器变量</strong>就变成<strong>普通变量</strong>，但仍然<strong>不能</strong>对该变量使用<strong>地址运算符</strong></p>
</blockquote>
</li>
<li><p><strong>块作用域的静态变量</strong></p>
<ul>
<li><p><strong>静态变量</strong>中<strong>静态</strong>的意思是该<strong>变量</strong>在<strong>内存</strong>中<strong>原地不动</strong>，并<strong>不是值不变</strong>。具有<strong>文件作用域</strong>的变量<strong>自动具有</strong>且<strong>必须</strong>是<strong>静态存储期</strong></p>
</li>
<li><p>前面提到过，可以创建具有<strong>静态存储期</strong>、<strong>块作用域</strong>的<strong>局部变量</strong>。<strong>这些变量</strong>和<strong>自动变量</strong>具有<strong>相同</strong>的<strong>作用域</strong>，但是程序<strong>离开</strong>它们<strong>所在的函数</strong>后，这些变量<strong>不会消失</strong>。也就是说，这些变量具有<strong>块作用域</strong>、<strong>无链接</strong>、<strong>静态存储期</strong></p>
</li>
<li><p><code>static</code><strong>关键字</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">def</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> fade <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> stay <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 块作用域的静态变量，具有静态存储期</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fade = %d, stay = %d\n"</span><span class="token punctuation">,</span> fade<span class="token operator">++</span><span class="token punctuation">,</span> stay<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">def</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">1: fade &#x3D; 1, stay &#x3D; 1
2: fade &#x3D; 1, stay &#x3D; 2
3: fade &#x3D; 1, stay &#x3D; 3</code></pre>

<blockquote>
<p>1、在<strong>块</strong>中，以<strong>存储类别说明符</strong><code>static</code>以声明<strong>块作用域的静态变量</strong><br>2、从程序的运行结果可以看出，<strong>静态变量 stay</strong>保存了它<strong>递增 1</strong>后的值，但<strong>fade</strong>每次都是<strong>1</strong>。这表明了<strong>初始化的不同</strong>：每次调用<code>def()</code>都会<strong>初始化 fade</strong>，但<strong>stay</strong>只在编译时<strong>被初始化一次</strong><br>3、不能在<strong>函数形参</strong>中使用<code>static</code>，如<code>int wontwork(static int flu);</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>外部链接的静态变量</strong></p>
<ul>
<li><p><strong>外部链接的静态变量</strong>具有<strong>块作用域</strong>、<strong>外部链接</strong>、<strong>静态存储期</strong>。该类别有时称为<strong>外部存储类别</strong>，属于该类别的<strong>变量</strong>称为<strong>外部变量</strong></p>
</li>
<li><p><strong>外部存储类别的使用</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> Errupt<span class="token punctuation">;</span>       <span class="token comment">// 外部定义的变量</span>
<span class="token keyword">double</span> Up<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 外部定义的数组</span>
<span class="token keyword">extern</span> <span class="token keyword">char</span> Coal<span class="token punctuation">;</span> <span class="token comment">// 如果只是本文件的声明，extern可省略，如果Coal被定义在另一个源代码文件中，则必须需要extern声明</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">extern</span> <span class="token keyword">int</span> Errupt<span class="token punctuation">;</span>  <span class="token comment">// 可选的声明</span>
    <span class="token keyword">extern</span> <span class="token keyword">double</span> Up<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 可选的声明</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、把<strong>变量</strong>的<strong>定义性声明</strong>放在所有<strong>函数外</strong>便创建了<strong>外部变量</strong><br>2、为了指出<strong>该函数使用</strong>了<strong>外部变量</strong>，可以在<strong>函数内</strong>使用关键字<code>extern</code><strong>再次声明</strong>。如果一个<strong>源代码文件</strong>使用的<strong>外部变量</strong>被<strong>定义</strong>在<strong>另一个源代码文件</strong>中，则必须用<code>extern</code>关键字声明该变量<br>3、注意示例中，<code>main()</code>中声明<strong>Up 数组</strong>时不用指明<strong>数组大小</strong>，因为前面<strong>外部变量</strong>第一次声明已经提供了<strong>数组大小信息</strong>。此外<code>main()</code>中的这<strong>两条声明</strong>都<strong>可以省略</strong>，使用<code>extern</code><strong>再次声明</strong>只是为了<strong>说明告知</strong><code>main()</code>要使用这<strong>两个变量</strong><br>4、如果<code>main()</code>中的<strong>两条声明</strong>都去除<code>extern</code><strong>关键字</strong>(如<code>int Errupt;</code>)会怎样？这相当于在<code>main()</code>中<strong>创建了</strong>一个<strong>自动变量</strong>，它是一个<strong>独立</strong>的<strong>局部变量</strong>，<strong>与原来的外部变量 Errupt 不同</strong>。此时原先的<strong>外部变量仍然存在</strong>，只是在<strong>块</strong>内(即<code>main()</code>中)执行语句时，<strong>块作用域</strong>的变量(即<code>main()</code>中声明的 Errupt)会<strong>隐藏</strong>原先<strong>文件作用域</strong>(即外部变量 Errupt)的<strong>同名变量</strong>。因此如果不得已要使用<strong>与外部变量同名</strong>的<strong>局部变量</strong>，最好在<strong>局部变量声明</strong>时显式使用<code>auto</code><strong>存储类别说明符</strong>，以清楚告知他人你的这种意图</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>内部链接的静态变量</strong></p>
<ul>
<li><p><strong>内部链接的静态变量</strong>具有<strong>静态存储期</strong>、<strong>文件作用域</strong>、<strong>内部链接</strong></p>
</li>
<li><p><code>static</code><strong>关键字</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> svil <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 静态变量，内部链接</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、在<strong>所有函数外部</strong>(这点与外部变量相同)，用<strong>存储类别说明符</strong><code>static</code>定义的<strong>变量</strong>具有这种存储类别<br>2、<strong>普通的外部变量</strong>可用于<strong>同一程序</strong>中<strong>任意文件</strong>的<strong>任意函数</strong>，但是<strong>内部链接的静态变量</strong>只能用于<strong>同一个文件</strong>的<strong>任意函数</strong><br>3、同样可以使用<strong>储存类别说明符</strong><code>extern</code>，在<strong>函数中</strong>再次<strong>重复声明</strong>任何具有<strong>文件作用域</strong>的变量。这样的声明<strong>不会改变其链接属性</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="存储类别补充"><a href="#存储类别补充" class="headerlink" title="存储类别补充"></a><strong>存储类别补充</strong></h4><ul>
<li><p><strong>多文件</strong></p>
<ul>
<li><p>只有当<strong>程序</strong>由<strong>多个翻译单元</strong>组成时，才体现<strong>区别内部链接</strong>和<strong>外部链接</strong>的重要性</p>
</li>
<li><p><strong>C 的变量共享</strong></p>
<blockquote>
<p>1、复杂的 C 程序通常由<strong>多个</strong>单独的<strong>源代码文件</strong>组成。有时，这些文件可能要<strong>共享</strong>一个<strong>外部变量</strong>。C 通过在<strong>一个文件</strong>中进行<strong>定义式声明</strong>，然后在<strong>其他文件</strong>中进行<strong>引用式声明</strong>来实现共享<br>2、也就是说，除了一个<strong>定义式声明</strong>外，<strong>其他声明</strong>都要使用<code>extern</code><strong>关键字</strong>，而且，只有<strong>定义式声明</strong>才能<strong>初始化变量</strong><br>3、如果<strong>外部变量</strong>定义在<strong>一个文件</strong>里，<strong>其他文件</strong>在使用它前必须先用<code>extern</code><strong>声明它</strong>。也就是说，在文件中对<strong>外部变量</strong>进行<strong>定义式声明</strong>但是单方面<strong>允许其他文件使用</strong>，<strong>其他文件</strong>在用<code>extern</code>声明前<strong>不能直接使用</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>储存类别说明符</strong></p>
<ul>
<li><p>C 语言共有<strong>6 个关键字</strong>作为<strong>存储类别说明符</strong>，分别是<code>auto</code>、<code>register</code>、<code>static</code>、<code>extern</code>、<code>_Thread_local</code>、<code>typedef</code></p>
</li>
<li><p><strong>存储类别说明符</strong></p>
<blockquote>
<p>1、<code>typedef</code>与任何<strong>内存存储</strong>无关，把它归为此类有一些<strong>语法上的原因</strong>。尤其是，在绝大多数情况下，<strong>不能</strong>在<strong>声明</strong>中<strong>使用多个存储类别说明符</strong>，所以这意味着不能使用<strong>多个存储类别说明符</strong>作为<code>typedef</code>的一部分<br>2、<code>_Thread_local</code>是<strong>唯一例外</strong>，其可以和<code>static</code>或<code>extern</code><strong>一起使用</strong><br>3、<code>auto</code>表明<strong>变量</strong>是<strong>自动存储期</strong>，只能用于<strong>块作用域</strong>的<strong>变量声明</strong>中。由于<strong>块</strong>中的<strong>变量</strong>本就具有<strong>自动存储期</strong>，显式使用<code>auto</code>大多情况是为了<strong>明确表达</strong>要使用<strong>与外部变量同名</strong>的<strong>局部变量</strong>的意图<br>4、<code>register</code>也只用于<strong>块作用域</strong>的变量，它把变量归为<strong>寄存器存储类别</strong>，请求<strong>最快速度访问</strong>该变量，同时还<strong>保护变量地址不被获取</strong><br>5、<code>static</code>说明符创建的对象具有<strong>静态存储期</strong>。<strong>载入程序时创建对象</strong>，<strong>程序结束对象消失</strong><br>6、<code>extern</code>表明声明的变量<strong>定义在别处</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>储存类别和函数</strong></p>
<ul>
<li><p><strong>函数</strong>也有<strong>存储类别</strong>，可以是<strong>外部函数</strong>(默认)或<strong>静态函数</strong>。此外<strong>C99</strong>新增了第三种类别——<strong>内联函数</strong>，将在 16 章介绍</p>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">gamma</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 该函数默认为外部函数</span>
<span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">beta</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">double</span> <span class="token function">delta</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、<strong>外部函数</strong>可以被<strong>其他文件</strong>的函数<strong>访问</strong>，<strong>静态函数</strong>只能用于<strong>其定义所在的文件</strong><br>2、在<strong>同一个程序</strong>中，<strong>其他文件</strong>的函数<strong>可以调用</strong><code>gamma()</code>和<code>delta()</code>，但<strong>不能调用</strong><code>bate()</code>，因为以<code>static</code><strong>存储类别说明符</strong>创建的函数属于<strong>特定模块私有</strong><br>3、这样做<strong>避免了名称冲突</strong>的问题，由于<code>beta()</code><strong>受限于</strong>它所在的文件，所以<strong>其他文件</strong>中可以使用<strong>与之同名</strong>的函数<br>4、通常的做法是：使用<code>extern</code><strong>声明</strong>定义在<strong>其他文件</strong>中的函数。这么做是为了<strong>表明</strong>当前文件中的使用的<strong>函数被定义在别处</strong>。除非使用<code>static</code>关键字，否则一般函数声明都<strong>默认为</strong><code>extern</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>存储类别的选择</strong></p>
<ul>
<li><p>对于<strong>使用哪种存储类别</strong>的回答，大多数是<strong>自动存储类别</strong>，要知道<strong>默认类别</strong>就是<strong>自动存储类别</strong></p>
</li>
<li><p>你可能会认为<strong>外部存储类别</strong>很不错，把<strong>所有变量</strong>设置成<strong>外部变量</strong>，就不需要<strong>参数</strong>和<strong>指针</strong>在函数间<strong>传递信息</strong>了。然而，如果这样做，很可能<strong>A 函数</strong>会<strong>违背你的意图</strong>，私自修改<strong>B 函数</strong>要使用的变量。无数程序员的<strong>经验表明</strong>，随意使用<strong>外部存储类别</strong>的变量导致的<strong>后果</strong>会<strong>远远超过</strong>它带来的<strong>便利</strong></p>
</li>
<li><p><strong>保护性程序设计</strong>的黄金法则是：“<strong>按需知道</strong>”原则。尽量在<strong>函数内部</strong>解决<strong>该函数的任务</strong>，<strong>只共享</strong>那些<strong>需要共享的变量</strong>。因此，在<strong>使用某类别</strong>前，考虑一下<strong>是否有必要</strong>这样做</p>
</li>
</ul>
</li>
</ul>
<h4 id="随机数函数和静态变量"><a href="#随机数函数和静态变量" class="headerlink" title="随机数函数和静态变量"></a><strong>随机数函数和静态变量</strong></h4><ul>
<li><p>C 语言的<strong>随机数函数</strong>是一个使用<strong>内部链接</strong>的<strong>静态变量函数</strong>。<strong>ANSI C</strong>库提供了一个<code>rand()</code>函数<strong>生成随机数</strong></p>
</li>
<li><p>生成随机数有<strong>多种算法</strong>，ANSI C 允许 C 实现针对<strong>特定机器</strong>使用<strong>最佳算法</strong>。然而，ANSI C 标准还提供了一个<strong>可移植</strong>的<strong>标准算法</strong>，在<strong>不同系统</strong>生成<strong>相同的随机数</strong>。实际上，<code>rand()</code>是<strong>伪随机数</strong>生成器，意思是<strong>可预测</strong>生成数字的<strong>实际序列</strong>，但是，数字在其<strong>取值范围</strong>内<strong>均匀分布</strong></p>
</li>
<li><p><strong>实现原理分析</strong></p>
<ul>
<li><p><strong>随机函数</strong></p>
<ul>
<li><p>为了看清<strong>程序内部情况</strong>，我们使用<strong>可移植</strong>的<strong>ANSI 版本</strong>(标准版本)，而不是<strong>编译器内置</strong>的<code>rand()</code>函数(实际使用可以直接使用编译器内置版本，只是生成的<strong>公式可能不同</strong>)</p>
</li>
<li><p><strong>随机函数示例</strong>(多文件编译)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* rand0.c —— 随机数函数文件 */</span>

<span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 种子</span>

<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">rand0</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 生成伪随机数的公式</span>
    next <span class="token operator">=</span> next <span class="token operator">*</span> <span class="token number">1103515245</span> <span class="token operator">+</span> <span class="token number">12345</span><span class="token punctuation">;</span> <span class="token comment">// 更新种子的公式</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>next <span class="token operator">/</span> <span class="token number">65536</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">32768</span><span class="token punctuation">;</span>  <span class="token comment">// 返回随机数的公式，(unsigned int)为强制类型转换</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* r_drive0.c 主运行文件，与 rand0.c 函数文件一起编译 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">extern</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">rand0</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 声明跨文件调用外部函数</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">rand0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出随机数</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">16838
5758
10113
17515
31051</code></pre>
</li>
<li><p><strong>示例解析</strong></p>
<blockquote>
<p>1、<strong>可移植版本</strong>的<strong>方案</strong>开始于一个“<strong>种子</strong>”<strong>数字</strong>。该函数使用该种子<strong>生成新的数</strong>，这个<strong>新数</strong>又成为<strong>新的种子</strong>。然后<strong>新的种子</strong>可用于生成<strong>更新的种子</strong>，以此类推。因此<strong>这个种子</strong>需要是一个<strong>静态变量</strong>，<strong>保持时刻存在</strong>并记录种子<strong>以便函数访问</strong><br>2、如示例<code>rand0.c</code>函数文件中，<strong>seed</strong>就是<strong>种子</strong>，其在<strong>ANSI 方案</strong>中默认被<strong>初始化为 1</strong>。<strong>生成随机数</strong>的<strong>函数</strong>中，先<strong>利用公式</strong>和<strong>seed 自身数值</strong>来<strong>更新 seed 的值</strong>(即生成新种子)，然后<code>return</code><strong>利用公式</strong>返回一个<strong>按照公式生成</strong>的<strong>伪随机数</strong>，<code>return</code>中<code>%32768</code>说明返回的数一定在<strong>0~32767</strong>之间<br>3、<code>r_drive0.c</code>主运行文件和<code>rand0.c</code><strong>一起编译并运行</strong>。输出证明<strong>调用正常</strong>，结果确实生成了<strong>伪随机数</strong>。但如果<strong>多运行几次</strong>，会发现每次生成的<strong>伪随机数</strong>都是按照<strong>相同规律出现</strong>的(即生成的<strong>随机数队列</strong>是一样的，都是 16838、5758、10113…)。这是因为，每次<strong>程序开始运行时</strong>，随机数生成都<strong>开始于种子 1</strong><br>4、为了解决这一问题，我们需要想种办法让<strong>每次程序开始时</strong>的<strong>种子不同</strong>，即需要一种办法<strong>重置种子</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>重置种子</strong></p>
<ul>
<li><p>我们可以引入<strong>另一个函数</strong><code>srand1()</code><strong>重置种子</strong>来解决<strong>随机数队列相同</strong>的问题(<code>srand1()</code>相当于 C 库的<code>srand()</code>函数)</p>
</li>
<li><p>关键在于，要让<strong>随机数函数</strong>中的<strong>next 变量</strong>，成为<strong>只供</strong><code>rand0()</code>和<code>srand1()</code><strong>访问</strong>的<strong>内部链接静态变量</strong>(“按需知道”原则)</p>
</li>
<li><p><strong>重置种子示例</strong>(多文件编译)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* rand0.c 函数文件 */</span>

<span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 种子</span>

<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">rand0</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 生成伪随机数的公式</span>
    next <span class="token operator">=</span> next <span class="token operator">*</span> <span class="token number">1103515245</span> <span class="token operator">+</span> <span class="token number">12345</span><span class="token punctuation">;</span> <span class="token comment">// 更新种子的公式</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>next <span class="token operator">/</span> <span class="token number">65536</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">32768</span><span class="token punctuation">;</span>  <span class="token comment">// 返回随机数的公式，(unsigned int)为强制类型转换</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 添加 srand1() 函数</span>
<span class="token keyword">void</span> <span class="token function">srand1</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    next <span class="token operator">=</span> seed<span class="token punctuation">;</span>  <span class="token comment">// 重置种子</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* r_drive0.c 主运行文件，与 rand0.c 函数文件一起编译 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">extern</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">rand0</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 声明跨文件调用外部函数</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">rand1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 声明跨文件调用外部函数</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> seed<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入你想要的随机数的种子\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// while判断输入是否有效合法</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%u"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>seed<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">srand1</span><span class="token punctuation">(</span>seed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置种子</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">rand0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出随机数</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入您的下一个种子，或输入q退出\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>示例解析</strong></p>
<blockquote>
<p>1、由于<strong>next</strong>具有<strong>内部链接</strong>的<strong>文件作用域静态变量</strong>，意味着<code>rand0()</code>和<code>srand1()</code><strong>都能使用</strong>它，但<strong>其他文件</strong>的函数<strong>无法访问</strong>它。这符合了程序设计“<strong>按需知道</strong>”的原则<br>2、现在的示例程序中，由于<strong>每次运行</strong>执行了<code>srand1()</code><strong>重置种子</strong>，所以<strong>种子</strong>都是<strong>输入的数字</strong>，因此<strong>随机数函数</strong>的<strong>随机性更强</strong>了<br>3、但这样<strong>重置种子</strong>还是<strong>比较麻烦</strong>，有没有什么办法能<strong>自动重置种子</strong>，答案是有的</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>项目中使用随机数(自动重置种子)</strong></p>
<ul>
<li><p>在<strong>项目中</strong>使用随机数，不需要再编写<code>rand0.c</code><strong>函数文件</strong>了，前面只是为了<strong>方便看清内部的操作</strong>。项目中，可以直接使用<strong>编译器提供</strong>的版本：<code>rand()</code><strong>函数</strong>和<code>srand()</code><strong>函数</strong>，它们被<strong>集成在</strong><code>stdlib.h</code><strong>头文件</strong>中，与前面<code>rand0.c</code>中定义的函数<strong>使用方法相同</strong></p>
</li>
<li><p>此外，在项目中很多时候需要程序<strong>自动重置种子</strong>以<strong>生成随机数</strong>，思路如下</p>
<blockquote>
<p>1、如果<strong>C 实现</strong>允许访问一些<strong>可变的量</strong>(如，系统时钟)，可以用<strong>这些值</strong>来<strong>初始化种子</strong><br>2、例如<strong>ANSI C</strong>有一个<code>time()</code><strong>函数</strong>，<strong>集成在</strong><code>time.h</code><strong>头文件</strong>中，可以<strong>返回系统时间</strong>。该返回值是一个<strong>可运算类型</strong>，且<strong>随时间变化而变化</strong>，便很适合做<strong>自动重置种子</strong>的<strong>值</strong><br>3、<code>time()</code>的<strong>返回类型</strong>是<code>time_t</code>，这与<code>srand()</code>接受的<code>unsigned int</code><strong>类型不符</strong>，但我们可以使用<strong>强制类型转换</strong>(注意别忘了<code>time.h</code>头文件)：<code>srand( (unsigned int)time(0) );</code><br>4、一般而言，<code>time()</code>接受的<strong>参数</strong>是一个<code>time_t</code><strong>类型对象</strong>的<strong>地址</strong>，而<strong>时间值</strong>就存储在<strong>传入的地址</strong>上(将时间值存入传入的地址)。当然也可以传入<strong>空指针 0</strong>作为<strong>参数</strong>，这样只不过<strong>仅能通过返回值机制</strong>来<strong>提取值</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="分配内存：malloc-和-free"><a href="#分配内存：malloc-和-free" class="headerlink" title="分配内存：malloc()和 free()"></a><strong>分配内存：malloc()和 free()</strong></h4><ul>
<li><p>我们前面讨论的<strong>存储类别</strong>有一个<strong>共同之处</strong>：在<strong>确定</strong>用哪种<strong>存储类别</strong>后，根据已制定好的<strong>内存管理规则</strong>，自动选择<strong>作用域</strong>和<strong>存储期</strong>。然而，还有<strong>更灵活</strong>的选择，即用<strong>库函数</strong>来<strong>分配</strong>和<strong>管理内存</strong></p>
</li>
<li><p><code>malloc()</code><strong>函数</strong></p>
<ul>
<li><p>C 可以在<strong>程序运行时</strong>分配<strong>更多的内存</strong>，主要的工具是<code>malloc()</code>函数，其被包含在<code>stdlib.h</code>中</p>
</li>
<li><p><strong>函数使用</strong></p>
<blockquote>
<p>1、<code>malloc()</code>函数用于<strong>主动分配内存</strong>。其接受<strong>一个参数</strong>，表示所需的<strong>内存字节数</strong>，返回<strong>动态分配内存块</strong>的<strong>首字节地址</strong><br>2、<code>malloc()</code>函数会找到合适的<strong>空闲内存块</strong>，这样的内存是<strong>匿名</strong>的。也就是说，该函数可以<strong>分配内存</strong>，但<strong>不会为其赋名</strong><br>3、可以把返回的<strong>首字节地址</strong>赋值给一个<strong>指针变量</strong>，并使用指针<strong>访问</strong>这块内存</p>
</blockquote>
</li>
<li><p><strong>函数的返回类型</strong></p>
<blockquote>
<p>1、由于<strong>char</strong>表示<strong>1 字节</strong>，所以曾经<code>malloc()</code>的<strong>返回类型</strong>通常被定义为<strong>指向 char 的指针</strong><br>2、然而从<strong>ANSI C</strong>标准起，C 使用一个<strong>新的类型</strong>——<strong>指向 void 的指针</strong>。该类型<strong>相当于</strong>一个<strong>通用指针</strong>，将这种类型<strong>赋值</strong>给<strong>任意其他类型的指针</strong>，完全<strong>不用考虑类型匹配</strong>的问题<br>3、<code>malloc()</code>函数还可用于返回<strong>指向数组的指针</strong>、<strong>指向结构的指针</strong>等，所以通常<strong>该函数</strong>的<strong>返回值</strong>会被<strong>强制转换</strong>为<strong>对应匹配的类型</strong>。在<strong>ANSI C</strong>中，应该坚持使用<strong>强制类型转换</strong>以<strong>提高代码可读性</strong>(可选，因为第 2 条的说明)<br>4、如果<code>malloc()</code><strong>分配内存失败</strong>，将返回<strong>空指针</strong></p>
</blockquote>
</li>
<li><p><strong>使用</strong><code>malloc()</code><strong>创建数组</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> <span class="token comment">// 注意不要忘了头文件</span></span>

<span class="token keyword">double</span> <span class="token operator">*</span>ptd<span class="token punctuation">;</span>
ptd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、要使用<code>malloc()</code><strong>创建一个数组</strong>，除了要用<code>malloc()</code><strong>请求一块内存</strong>，还需要一个<strong>指针</strong>记录这块内存的<strong>位置</strong><br>2、示例中，<code>sizeof(double)</code>表示<strong>一个 double 类型</strong>所需的<strong>内存大小</strong>，<code>30 * sizeof(double)</code>表示<strong>需要 30 个 double 的大小</strong>(即可以看做 30 个元素)<br>3、<code>(double *)</code>为<strong>强制类型转换</strong>，仅用于<strong>提高代码可读性</strong>，因为<code>malloc()</code><strong>返回值</strong>是<strong>指向 void 的指针</strong>，可以<strong>不用考虑类型匹配</strong>问题<br>4、注意，<strong>指针 ptd</strong>被声明<strong>指向一个 double 类型</strong>，而<strong>不是指向内含 30 个 double 的块</strong>。回忆一下，<strong>数组名</strong>是该数组<strong>首元素地址</strong>，因此如果让<strong>ptd</strong>指向这个<strong>块的首元素</strong>，就能像<strong>使用数组名一样</strong>使用它。也就是说，可以使用表达式<code>ptd[0]</code>、<code>ptd[1]</code>分别访问该<strong>块</strong>的<strong>首元素</strong>和<strong>第二个元素</strong>，以此类推</p>
</blockquote>
</li>
<li><p><code>malloc()</code><strong>创建的数组的特点</strong></p>
<blockquote>
<p>1、<code>malloc()</code><strong>创建的数组</strong>和曾经学过的<strong>变长数组</strong>，都可以<strong>创建动态数组</strong><br>2、<strong>动态数组</strong>与<strong>普通数组</strong>的不同在于，前者可以在<strong>运行时</strong>再<strong>选择数组的大小</strong>和<strong>分配内存</strong>(详细介绍见<strong>变长数组</strong>)<br>3、此外<strong>C99</strong>前不允许<code>double item[n];</code>，因为<strong>n 不允许是变量</strong>，但可以<code>ptd = malloc(n * sizeof(double));</code>，因此<code>malloc()</code><strong>创建数组</strong>比<strong>变长数组</strong>要<strong>更灵活</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>free()</code><strong>函数</strong></p>
<ul>
<li><p>通常，<code>malloc()</code>要与<code>free()</code><strong>配套使用</strong>，<code>free()</code>可以<strong>释放</strong>之前<code>malloc()</code><strong>分配的内存</strong>，其也被包含在<code>stdlib.h</code>头文件中</p>
</li>
<li><p><strong>函数使用</strong></p>
<blockquote>
<p>1、<code>free()</code>函数用于<strong>释放</strong><code>malloc()</code><strong>分配的内存</strong>，其接受<strong>一个参数</strong>，即之前<code>malloc()</code><strong>返回的地址</strong><br>2、因此，<strong>动态分配内存</strong>的<strong>存储期</strong>就是从调用<code>malloc()</code><strong>分配内存开始</strong>，到调用<code>free()</code><strong>释放内存为止</strong>。试想<code>malloc()</code>和<code>free()</code>管理着一个<strong>内存池</strong>，每次调用<code>malloc()</code>便<strong>分配给程序使用</strong>，每次调用<code>free()</code>便<strong>将内存归还</strong>给<strong>内存池</strong>，以便<strong>重复使用</strong>这些内存<br>3、<code>free()</code>只能接受<code>malloc()</code><strong>分配的内存</strong>的<strong>地址</strong>，不能释放<strong>通过其他方式</strong>(如：声明)<strong>分配</strong>的<strong>内存</strong></p>
</blockquote>
</li>
<li><p><code>free()</code><strong>的重要性</strong></p>
<blockquote>
<p>1、<strong>静态内存的数量</strong>在编译时是<strong>固定</strong>的，在程序运行期间也<strong>不会改变</strong>。<strong>自动变量使用的内存数量</strong>在程序执行期间<strong>自动增加或减少</strong>。但是<strong>动态分配的内存</strong>则<strong>只会增加</strong>，除非用<code>free()</code>进行<strong>释放</strong><br>2、假设一个程序需要<strong>大量调用</strong><code>malloc()</code><strong>分配内存</strong>，但<strong>没有使用</strong><code>free()</code><strong>释放内存</strong>，就可能在运行时<strong>耗尽所有可分配的内存</strong>导致程序出错<br>3、这类为题称为<strong>内存泄漏</strong>，因此需要<strong>及时使用</strong><code>free()</code><strong>释放内存</strong>避免这类问题发生</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>calloc()</code><strong>函数</strong></p>
<ul>
<li><p>分配内存还可以使用<code>calloc()</code><strong>函数</strong>，其用法与<code>malloc()</code><strong>大致相同</strong></p>
</li>
<li><p><strong>函数使用</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">long</span> <span class="token operator">*</span>newmem<span class="token punctuation">;</span>
newmem <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、和<code>malloc()</code>类似，<code>calloc()</code>在<strong>ANSI C</strong>前<strong>返回指向 char 的指针</strong>，在<strong>ANSI C</strong>后<strong>返回指向 void 的指针</strong><br>2、<code>calloc()</code>接受<strong>两个参数</strong>(<strong>ANSI C</strong>规定是<code>size_t</code>类型)，<strong>第一个参数</strong>是所需的<strong>存储单元数量</strong>，<strong>第二个参数</strong>是<strong>存储单元大小</strong>(以字节为单位)<br>3、<code>calloc()</code>还有一个<strong>特性</strong>，它会把<strong>块</strong>中<strong>所有位</strong>都<strong>设置为 0</strong>。此外，<code>free()</code>也可以释放<code>calloc()</code>分配的内存</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="ANSI-C-类型限定符"><a href="#ANSI-C-类型限定符" class="headerlink" title="ANSI C 类型限定符"></a><strong>ANSI C 类型限定符</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、我们通常用<strong>类型</strong>和<strong>存储类别</strong>来描述一个变量。<strong>C90</strong>还<strong>新增</strong>了两个属性：<strong>恒常性</strong>和<strong>易变性</strong>，可以分别用<strong>关键字</strong><code>const</code>和<code>volatile</code>来声明，以这两个<strong>关键字</strong>创建的<strong>类型</strong>是<strong>限定类型</strong><br>2、<strong>C99</strong>标准<strong>新增</strong>了<strong>第三个限定符</strong>：<code>restrict</code>，用于提高编译器优化<br>3、<strong>C11</strong>标准<strong>新增</strong>了<strong>第四个限定符</strong>：<code>_Atomic</code>。<strong>C11</strong>提供了一个<strong>可选库</strong>，由<code>stdatomic.h</code>管理，以支持<strong>并发程序设计</strong>，而且<code>_Atomic</code>是<strong>可选支持项</strong><br>4、<strong>C99</strong>为<strong>类型限定符</strong>新增了一个<strong>属性</strong>：它们现在是<strong>幂等</strong>的。这个属性的意思是，可以在<strong>一条声明</strong>中<strong>多次使用</strong>同一个限定符，<strong>多余</strong>的限定符将被<strong>忽略</strong></p>
</blockquote>
</li>
<li><p><code>const</code><strong>类型限定符</strong>在之前<strong>第 4 章</strong>和<strong>第 10 章</strong>已经详细介绍过，在此略过</p>
</li>
<li><p><code>volatile</code><strong>类型限定符</strong></p>
<ul>
<li><p><strong>作用及用途</strong></p>
<blockquote>
<p>1、<code>volatile</code><strong>类型限定符</strong>告知计算机，<strong>代理</strong>(而不是该变量所在的程序)<strong>可以改变</strong>该变量的<strong>值</strong><br>2、通常，它被用于<strong>硬件地址</strong>以及<strong>其他程序</strong>或<strong>同时运行的线程</strong>中<strong>共享数据</strong>。例如，一个<strong>地址</strong>上可能存储着当前的<strong>时钟时间</strong>，无论程序做什么，<strong>地址</strong>上的<strong>值</strong>都<strong>随时间变化而改变</strong>。或者一个<strong>地址</strong>用于接受<strong>另一台计算机</strong>传入的<strong>信息</strong></p>
</blockquote>
</li>
<li><p><strong>使用语法</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* volatile语法与const一样 */</span>
<span class="token keyword">volatile</span> <span class="token keyword">int</span> loc1<span class="token punctuation">;</span>    <span class="token comment">// loc1是一个易变的位置</span>
<span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token operator">*</span> ploc<span class="token punctuation">;</span>  <span class="token comment">// ploc是一个指向易变位置的指针</span></code></pre>
</li>
<li><p><strong>为什么列入 ANSI 标准</strong></p>
<pre class="language-c" data-language="c"><code class="language-c">val1 <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token comment">/*
省略中间一些不使用x的代码
*/</span>
val2 <span class="token operator">=</span> x<span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、开始可能认为<code>volatile</code>是个<strong>可有可无</strong>的概念，为何<strong>ANSI</strong>要将其<strong>放入标准</strong>？是因为它<strong>涉及编译器的优化</strong><br>2、<strong>智能的</strong>(进行优化的)<strong>编译器</strong>会注意到以上代码<strong>使用了 2 次 x</strong>，但并<strong>未改变</strong>它的<strong>值</strong>，于是<strong>编译器</strong>把<strong>x 的值</strong>临时存储在<strong>寄存器</strong>中，然后再<strong>val2</strong>使用<strong>x</strong>时，才从<strong>寄存器中</strong>(而非原始内存位置上)<strong>读取 x 的值</strong>，以<strong>节约时间</strong>。这个过程被称为<strong>高速缓存</strong><br>3、通常<strong>高速缓存</strong>是个不错的优化方案，但如果一些<strong>其他代理</strong>在以上两条语句间<strong>改变了 x 的值</strong>，就<strong>不能这样优化</strong>了。如果没有<code>volatile</code><strong>关键字</strong>，<strong>编译器</strong>就<strong>不知道</strong>这种事情<strong>是否发生</strong>，因此为了<strong>安全起见</strong>，编译器<strong>不会进行高速缓存</strong>。这便是<strong>ANSI 前</strong>的情况<br>4、现在，如果声明中<strong>没有</strong><code>volatile</code><strong>关键字</strong>，编译器会<strong>假定变量的值使用过程中不变</strong>，然后再<strong>尝试优化代码</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>restrict</code><strong>类型限定符</strong></p>
<ul>
<li><p><strong>作用及用途</strong></p>
<blockquote>
<p>1、<code>restrict</code><strong>关键字</strong>允许编译器<strong>优化某部分代码</strong>以更好地<strong>支持运算</strong><br>2、它<strong>只能用于指针</strong>，表明<strong>该指针</strong>是<strong>访问数据对象</strong>的<strong>唯一且初始</strong>的方式</p>
</blockquote>
</li>
<li><p><strong>深入理解优化部分代码</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> ar<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>restrict restar <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>par <span class="token operator">=</span> ar<span class="token punctuation">;</span>
<span class="token comment">/*-----------------------------------------------------*/</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    par<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    restar<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    ar<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    par<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    restar<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、这里，指针<strong>restar</strong>是访问<code>malloc()</code><strong>所分配内存</strong>的<strong>唯一且初始</strong>的方式，因此可以用<code>restrict</code><strong>限定它</strong>；而指针<strong>par</strong>既不是<strong>访问 ar 数组中数据</strong>的<strong>初始方式</strong>，也不是<strong>唯一方式</strong>，所以不用将其设置为<code>restrict</code><br>2、由于之前<strong>声明了 restar</strong>为<code>restrict</code>，<strong>编译器</strong>可以把<code>for()</code>中涉及<strong>restar</strong>的<strong>两条语句</strong>简化替换为<code>restar[n] += 8;</code>(原本是先+5，后+3)。但是如果将<code>for()</code>中与<strong>par</strong>相关的<strong>两条语句</strong>简化替换为<code>par[n] += 8;</code>就<strong>不可以</strong>，因为<strong>par</strong>在<strong>两次访问相同数据</strong>之间，<strong>用 ar 改变过</strong>该数据的<strong>值</strong><br>3、在本例中，如果<strong>未使用</strong><code>restrict</code>，<strong>编译器</strong>就必须<strong>假设最坏的情况</strong>(即两次使用指针之间，其他标识符可能更改了数据)。如果<strong>使用了</strong><code>restrict</code>，<strong>编译器</strong>则可以选择捷径<strong>优化计算</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>_Atomic</code><strong>类型限定符</strong></p>
<ul>
<li><p><strong>简介概述</strong></p>
<blockquote>
<p>1、<strong>并发程序设计</strong>把<strong>程序执行</strong>分为<strong>可以同时执行</strong>的<strong>多个线程</strong>。这给程序设计带来了<strong>新的挑战</strong>，包括<strong>如何管理并访问相同数据的不同线程</strong><br>2、<strong>C11</strong>通过包含<strong>可选的头文件</strong><code>stdatomic.h</code>和<code>threads.h</code><strong>提供了</strong>一些<strong>可选的</strong>(不是必须实现的)<strong>管理方法</strong><br>3、值得注意的是，要通过各种<strong>宏函数</strong>来访问<strong>原子类型</strong>。当一个<strong>线程</strong>对一个<strong>原子类型的对象</strong>执行<strong>原子操作</strong>时，<strong>其他线程不能访问</strong>该对象，如下示例</p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdatomic.h></span></span>

<span class="token keyword">int</span> hogs<span class="token punctuation">;</span>                 <span class="token comment">// 普通声明</span>
hogs <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>                <span class="token comment">// 普通赋值</span>
<span class="token comment">/*---------------可以替换为---------------*/</span>
<span class="token keyword">_Atomic</span> <span class="token keyword">int</span> hogs<span class="token punctuation">;</span>         <span class="token comment">// hogs是一个原子类型的变量</span>
<span class="token function">atomic_store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hogs<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// stdatomic.h中的宏</span></code></pre>

<blockquote>
<p>1、这里，在<strong>hogs</strong>中存储的<strong>12</strong>是一个<strong>原子过程</strong>，<strong>其他线程不能访问 hogs</strong><br>2、编写这一代码的前提，是编译器要支持这一新特性</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="文件输入-x2F-输出"><a href="#文件输入-x2F-输出" class="headerlink" title="文件输入&#x2F;输出"></a><strong>文件输入&#x2F;输出</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：与文件进行通信；文本模式和二进制模式；I&#x2F;O 的级别；标准文件；标准 I&#x2F;O；<code>fopen()</code>函数；文件指针；<code>getc()</code>和<code>putc()</code>函数；<code>fclose()</code>函数；指向标准文件的指针；简单的文件压缩程序；文件 I&#x2F;O；<code>fprintf()</code>、<code>fscanf()</code>函数和<code>rewind()</code>函数；<code>fgets()</code>和<code>fputs()</code>函数；随机访问：<code>fseek()</code>和<code>stell()</code>；<code>fgetpos()</code>和<code>fsetpos()</code>函数；其他标准 I&#x2F;O 函数；<code>ungetc()</code>函数；<code>fflush()</code>函数；<code>setvbuf()</code>函数；二进制 I&#x2F;O：<code>fread()</code>和<code>fwrite()</code>；<code>feof()</code>和<code>ferror()</code>函数</p>
</blockquote>
</div>

<h4 id="与文件进行通信"><a href="#与文件进行通信" class="headerlink" title="与文件进行通信"></a><strong>与文件进行通信</strong></h4><ul>
<li><p>有时，需要<strong>程序</strong>从<strong>文件</strong>中<strong>读取信息</strong>或<strong>把信息写入文件</strong>。这种<strong>程序与文件交互</strong>的形式就是<strong>文件重定向</strong>(第 8 章介绍过)。这种方法很简单，但是<strong>有一定限制</strong>，尤其对于<strong>交互性程序</strong>。C 提供了更强大的<strong>文件通信方法</strong>，可以<strong>在程序中打开文件</strong>，然后使用特殊的<strong>I&#x2F;O 函数</strong>与文件交互。在研究这些方法之前，先简要介绍下<strong>文件的性质</strong></p>
</li>
<li><p><strong>文件是什么</strong></p>
<blockquote>
<p>1、<strong>文件</strong>通常是在<strong>磁盘或固态硬盘</strong>上的一段<strong>已命名的存储区</strong><br>2、对我们而言，<code>stdio.h</code>就是一个<strong>文件</strong>的<strong>名称</strong>，该文件中包含一些<strong>有用的信息</strong>。对于<strong>操作系统</strong>而言，文件<strong>更复杂</strong>一些<br>3、例如，<strong>大型文件</strong>会被<strong>分开存储</strong>，或者包含一些<strong>额外的数据</strong>，方便<strong>操作系统</strong>确定<strong>文件的种类</strong>。然而这些都是<strong>操作系统</strong>所关心的，程序员关心的是<strong>C 程序如何处理文件</strong><br>4、C 把<strong>文件</strong>看做是<strong>一系列连续的字节</strong>，<strong>每个字节</strong>都能被<strong>单独读取</strong>。这与<strong>UNIX</strong>环境中的<strong>文件结构</strong>相对应。由于<strong>其他环境</strong>中可能<strong>无法完全对应</strong>这个模型，C 提供<strong>两种文件模式</strong>：<strong>文本模式</strong>和<strong>二进制模式</strong></p>
</blockquote>
</li>
<li><p><strong>文本模式和二进制模式</strong></p>
<ul>
<li><p>首先，要区分<strong>文本内容</strong>与<strong>二进制内容</strong>、<strong>文本文件格式</strong>和<strong>二进制文件格式</strong>以及文件的<strong>文本模式</strong>和<strong>二进制模式</strong></p>
</li>
<li><p><strong>文本与二进制的文件格式和内容</strong></p>
<blockquote>
<p>1、<strong>所有文件</strong>的<strong>内容</strong>都以<strong>二进制形式</strong>(0 或 1)<strong>存储</strong><br>2、但是，如果<strong>文件</strong>最初使用<strong>二进制编码的字符</strong>(如 ASCII 或 Unicode)<strong>表示文本</strong>，该文件就是<strong>文本文件</strong>，其中包含<strong>文本内容</strong><br>3、如果文件中的<strong>二进制值</strong>表示<strong>机器语言代码</strong>、<strong>数值数据</strong>、<strong>图片</strong>或<strong>音乐编码</strong>等，该文件就是<strong>二进制文件</strong>，其中包含<strong>二进制内容</strong></p>
</blockquote>
</li>
<li><p><strong>文本与二进制模式</strong></p>
<blockquote>
<p>1、由于各个<strong>操作系统</strong>对<strong>文件</strong>的<strong>识别与管理方式</strong>不同，为了规范<strong>文本文件</strong>的处理，C 提供<strong>两种访问文件的途径</strong>：<strong>二进制模式</strong>和<strong>文本模式</strong><br>2、在<strong>二进制模式</strong>中，程序可以<strong>访问</strong>文件的<strong>每个字节</strong>。而在<strong>文本模式</strong>中，程序<strong>所见的内容</strong>和文件的<strong>实际内容不同</strong><br>3、程序以<strong>文本模式</strong>读取文件时，把<strong>本地环境</strong>表示的<strong>行末尾</strong>或<strong>文件结尾</strong>映射为<strong>C 模式</strong>。例如 C 的<strong>文本模式</strong>在<strong>MS-DOS</strong>平台，<strong>读取</strong>文件时，会把<code>\r\n</code>(MS-DOS 中表示的行末尾)转换成<code>\n</code>，<strong>写入</strong>文件时，恰好与此<strong>相反</strong><br>4、虽然 C 提供了<strong>二进制模式</strong>和<strong>文本模式</strong>，但这两种模式的<strong>实现可以相同</strong>。因为<strong>UNIX</strong>只使用一种文件格式，这两种模式对<strong>UNIX</strong>实现<strong>完全相同</strong>，对<strong>Linux</strong>也是如此</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>I&#x2F;O 的级别</strong></p>
<blockquote>
<p>1、除了选择文件的<strong>模式</strong>，大多数情况下，还可以选择<strong>I&#x2F;O</strong>的<strong>两个级别</strong>(即处理文件访问的两个级别)<br>2、<strong>底层 I&#x2F;O</strong>使用<strong>操作系统</strong>提供的<strong>基本 I&#x2F;O 服务</strong>，<strong>标准高级 I&#x2F;O</strong>使用<strong>C 库</strong>的<strong>标准包</strong>和<code>stdio.h</code><strong>头文件定义</strong><br>3、因为<strong>无法保证</strong>所有的<strong>操作系统</strong>都使用<strong>相同的底层 I&#x2F;O 模型</strong>，C 标准只支持<strong>标准 I&#x2F;O 包</strong><br>4、有些实现会提供<strong>底层库</strong>，但是 C 标准建立了<strong>可移植的 I&#x2F;O 模型</strong>，我们主要讨论这些<strong>I&#x2F;O</strong></p>
</blockquote>
</li>
<li><p><strong>标准文件</strong></p>
<blockquote>
<p>1、C 程序会自动打开<strong>3 个文件</strong>，它们被称为<strong>标准输入</strong>、<strong>标准输出</strong>、<strong>标准错误输出</strong><br>2、在<strong>默认情况</strong>下，<strong>标准输入</strong>是系统的<strong>普通输入设备</strong>，通常为<strong>键盘</strong>；<strong>标准输出</strong>和<strong>标准错误输出</strong>是系统的<strong>普通输出设备</strong>，通常为<strong>显示屏</strong><br>3、通常，<strong>标准输入</strong>为程序<strong>提供输入</strong>，它是<code>getchar()</code>和<code>scanf()</code>使用的文件；程序通常<strong>输出</strong>到<strong>标准输出</strong>，它是<code>putchar()</code>、<code>puts()</code>和<code>printf()</code>使用的文件<br>4、<strong>第 8 章</strong>提到的<strong>重定向</strong>，便是将<strong>其他文件</strong>视为<strong>标准输入</strong>和<strong>标准输出</strong>，但并不会重定向<strong>标准错误输出</strong>。这样很好，否则只能打开文件才能看到错误信息了</p>
</blockquote>
</li>
</ul>
<h4 id="标准-I-x2F-O"><a href="#标准-I-x2F-O" class="headerlink" title="标准 I&#x2F;O"></a><strong>标准 I&#x2F;O</strong></h4><ul>
<li><p><strong>标准 I&#x2F;O 的优点</strong></p>
<blockquote>
<p>1、与<strong>底层 I&#x2F;O</strong>相比，<strong>标准 I&#x2F;O 包</strong>除了<strong>可移植</strong>以外，还有<strong>两个好处</strong><br>2、第一，<strong>标准 I&#x2F;O</strong>有许多专门的<strong>函数</strong>简化了<strong>处理不同 I&#x2F;O</strong>的问题。例如<code>printf()</code>把<strong>不同形式</strong>的数据转换成与<strong>终端</strong>相适应的<strong>字符串输出</strong><br>3、第二，<strong>输入和输出</strong>都是<strong>缓冲</strong>的。也就是说，一次转移<strong>一大块信息</strong>而不是<strong>一字节信息</strong>(通常至少 512 字节)。例如程序<strong>读取文件</strong>时，<strong>一块数据</strong>被<strong>拷贝</strong>到<strong>缓存区</strong>，这种<strong>缓冲</strong>极大地提高了<strong>数据传输速率</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*注意本程序使用了命令行参数，需要使用命令行运行并传入参数*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> <span class="token comment">// 提供exit()的原型</span></span>

<span class="token comment">// 使用命令行参数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> ch<span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span> <span class="token comment">// 文件指针</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断命令行参数是否成功读取</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 如果读取有误输出提示语并退出</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s filename\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 判断文件是否成功打开</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Can't open %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 将文件内容打印到屏幕并记录文件的字符数</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getc</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">putc</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等效于putchar(ch)</span>
        ct<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭文件</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%d"</span><span class="token punctuation">,</span> ct<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>fopen()函数</strong></p>
<ul>
<li><p>程序可以使用<code>fopen()</code><strong>打开文件</strong>，其声明在<code>stdio.h</code><strong>头文件</strong>中</p>
</li>
<li><p><code>fopen()</code>的<strong>第一个参数</strong>是<strong>待打开的文件名称</strong>，更准确的说，是一个<strong>包含该文件名</strong>的<strong>字符串地址</strong>。<strong>第二个参数</strong>是<strong>一个字符串</strong>，用于指定<strong>打开文件的模式</strong></p>
</li>
<li><p><code>fopen()</code><strong>的模式字符串</strong></p>
<table>
<thead>
<tr>
<th align="center">模式字符串</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“r”</td>
<td>以读模式打开文件</td>
</tr>
<tr>
<td align="center">“w”</td>
<td>以写模式打开文件，将现有文件的长度截为 0，如果文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td align="center">“a”</td>
<td>以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td align="center">“r+”</td>
<td>以更新模式打开文件(即可以读写文件)</td>
</tr>
<tr>
<td align="center">“w+”</td>
<td>以更新模式打开文件(即可以读写文件)，将现有文件的长度截为 0，如果文件不存在，则创建一个新文件</td>
</tr>
<tr>
<td align="center">“a+”</td>
<td>以更新模式打开文件(即可以读写文件)，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件。可以读整个文件，但只能从末尾添加内容</td>
</tr>
<tr>
<td align="center">“rb”,”wb”,”ab”,”rb+”,”r+b”,”wb+”,”w+b”,”ab+”,”a+b”</td>
<td>与上一个模式类似，但是以二进制模式而不是文本模式打开文件</td>
</tr>
<tr>
<td align="center">“wx”,”wbx”,”w+x”,”wb+x”,”w+bx”</td>
<td>(C11)类似非 x 模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败</td>
</tr>
</tbody></table>
<blockquote>
<p>1、像<strong>UNIX</strong>和<strong>Linux</strong>这样<strong>只有一种文件类型</strong>的系统，<strong>带 b 字母</strong>的模式和<strong>不带 b 字母</strong>的模式<strong>相同</strong><br>2、<strong>C11</strong>新增了<strong>带 x 字母</strong>的<strong>写模式</strong>，与<strong>以前的写模式</strong>相比<strong>具有更多特性</strong>。第一，如果以<strong>传统的写模式</strong>打开一个现有文件，<code>fopen()</code>会把该文件长度<strong>截为 0</strong>，就会<strong>丢失该文件的内容</strong>；但使用<strong>带 x 的写模式</strong>，即使<code>fopen()</code>操作失败，也<strong>不会删除源文件内容</strong>。第二，如果<strong>环境允许</strong>，<strong>x 模式</strong>的<strong>独占特性</strong>使得其他程序或线程<strong>无法访问正在被打开的文件</strong></p>
</blockquote>
</li>
<li><p><code>fopen()</code><strong>与文件指针</strong></p>
<blockquote>
<p>1、程序成功<strong>打开文件</strong>后，<code>fopen()</code>将返回<strong>文件指针</strong>，<strong>其他 I&#x2F;O 函数</strong>可以使用这个指针<strong>指定该文件</strong><br>2、<strong>文件指针</strong>(该例中的 fp)的<strong>类型</strong>是<strong>指向 FILE 的指针</strong>，<code>FILE</code>是一个<strong>定义在</strong><code>stdio.h</code>中的<strong>派生类型</strong><br>3、<strong>文件指针</strong>并不指向<strong>实际的文件</strong>，它指向一个<strong>包含文件信息</strong>的<strong>数据对象</strong>，其中包含<strong>操作文件</strong>的<strong>I&#x2F;O 函数</strong>所用的<strong>缓冲区信息</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>getc()和 putc()函数</strong></p>
<ul>
<li><p><code>getc()</code>和<code>putc()</code>与<code>getchar()</code>和<code>putchar()</code><strong>作用类似</strong>，所不同的是，要告诉<code>getc()</code>和<code>putc()</code>函数<strong>使用哪一个文件</strong></p>
</li>
<li><p><code>getc</code>接受<strong>一个参数</strong>，即<strong>文件指针</strong>；<code>putc()</code>接受<strong>两个参数</strong>，第一个是<strong>待写入的字符</strong>，第二个是<strong>文件指针</strong></p>
</li>
<li><p><strong>使用方式</strong></p>
<blockquote>
<p>1、<code>ch = getchar();</code>的意思是从<strong>标准输入</strong>中<strong>获取一个字符</strong>，而<code>ch = getc(fp);</code>的意思是从<strong>fp 指定的文件</strong>中<strong>获取一个字符</strong>。与此类似，<code>putc(ch, fpout);</code>的意思是把<strong>字符 ch</strong>放入<strong>FILE 指针 fpout 指定的文件</strong>中<br>2、示例程序中，<code>putc(ch, stdout);</code>将<code>stdout</code>作为<strong>第二个参数</strong>。<code>stdout</code>作为与<strong>标准输出</strong>相关联的<strong>文件指针</strong>，定义在<code>stdio.h</code>中，所以<code>putc(ch, stdout);</code>与<code>putchar(ch);</code><strong>作用相同</strong><br>3、如果<code>getc()</code>在<strong>读取一个字符</strong>时发现是<strong>文件结尾</strong>，将返回特殊值<strong>EOF</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>fclose()函数</strong></p>
<ul>
<li><p>程序可以使用<code>fclose()</code><strong>关闭文件</strong>，必要时<strong>刷新缓冲区</strong>，其接受<strong>一个参数</strong>，即<strong>文件指针</strong>，如<code>fclose(fp)</code>函数<strong>关闭 fp 指定的文件</strong></p>
</li>
<li><p>对于<strong>较正式的程序</strong>，应该检查<strong>是否成功关闭文件</strong>。如果成功关闭，<code>fclose()</code><strong>返回 0</strong>，否则返回<strong>EOF</strong></p>
</li>
</ul>
</li>
<li><p><strong>指向标准文件的指针</strong></p>
<table>
<thead>
<tr>
<th align="center">标准文件</th>
<th align="center">文件指针</th>
<th align="center">通常使用的设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准输入</td>
<td align="center">stdin</td>
<td align="center">键盘</td>
</tr>
<tr>
<td align="center">标准输出</td>
<td align="center">stdout</td>
<td align="center">显示器</td>
</tr>
<tr>
<td align="center">标准错误</td>
<td align="center">stderr</td>
<td align="center">显示器</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="简单的文件压缩程序"><a href="#简单的文件压缩程序" class="headerlink" title="简单的文件压缩程序"></a><strong>简单的文件压缩程序</strong></h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将文件压缩成原来的1/3*(仅压缩大小) */</span>
<span class="token comment">/* 同样本程序依然使用命令行参数传入参数 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> <span class="token comment">// 提供 exit() 的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> <span class="token comment">// 提供 strcpy()、strcat()的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEN</span> <span class="token expression"><span class="token number">40</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    FILE <span class="token operator">*</span>in<span class="token punctuation">,</span> <span class="token operator">*</span>out<span class="token punctuation">;</span> <span class="token comment">// 声明两个文件指针</span>
    <span class="token keyword">int</span> ch<span class="token punctuation">;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储输出文件名</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 检查命令行参数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Usage: %s filename\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 设置输入</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>in <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 以读模式打开文件</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"I couldn't open the file '%s' \n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 设置输出</span>
    <span class="token function">strncpy</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> LEN <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝文件名，LEN-5留出5字符添加文件后缀名</span>
    name<span class="token punctuation">[</span>LEN <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token function">strcat</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">".red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 在文件名后添加.red后缀</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>out <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 以写模式打开文件</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Can't create output file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 拷贝数据</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getc</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">++</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">putc</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印每三个字符的第一个字符</span>

    <span class="token comment">// 关闭文件，收尾</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fclose</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">fclose</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Error in closing files\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h4 id="文件-I-x2F-O"><a href="#文件-I-x2F-O" class="headerlink" title="文件 I&#x2F;O"></a><strong>文件 I&#x2F;O</strong></h4><ul>
<li><p><strong>fprintf()、fscanf()函数和 rewind()函数</strong></p>
<ul>
<li><p><code>fprintf()</code>和<code>fscanf()</code>函数的<strong>工作方式</strong>与我们熟悉的<code>printf()</code>和<code>scanf()</code><strong>相似</strong>，只是前两者需要用<strong>第一个参数</strong>指定<strong>待处理的文件</strong></p>
</li>
<li><p><code>rewind()</code>可以让程序回到<strong>文件开始处</strong>，其接受<strong>一个参数</strong>，即<strong>文件指针</strong></p>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将终端输入的字符存入文件，并从文件再次读取输出到终端 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX</span> <span class="token expression"><span class="token number">41</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>
    <span class="token keyword">char</span> words<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"wordy"</span><span class="token punctuation">,</span> <span class="token string">"a+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"Can't open 'wordy' file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入单词将其添加到文件中，在新的一行输入#符号退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 终端提示语</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">fscanf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token string">"%40s"</span><span class="token punctuation">,</span> words<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 从 stdin 接受至多40字符存入 words，且首字符不为#</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span>                                  <span class="token comment">// 向 fp 指向的文件输出字符串，内容为 words 的字符</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"文件预览："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                              <span class="token comment">// 终端提示语</span>
    <span class="token function">rewind</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                      <span class="token comment">// 回到文件开始处</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> words<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                             <span class="token comment">// 从 fp 指向的文件接受字符，存入 words</span>
        <span class="token function">puts</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                 <span class="token comment">// 输出到屏幕上</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>fgets()和 fputs()函数</strong></p>
<ul>
<li><p><strong>第 11 章</strong>简要介绍过这两个函数，在此简单回顾</p>
</li>
<li><p><code>fgets()</code><strong>函数</strong></p>
<blockquote>
<p>1、语法<code>fgets(words,STLEN,fp);</code>。<strong>第一个参数</strong>为<strong>存储字符串的地址</strong>，<strong>第二个参数</strong>为<strong>输入字符串的大小</strong>，<strong>第三个参数</strong>为<strong>文件指针</strong><br>2、<code>fgets()</code><strong>读取输入</strong>，直到<strong>第一个换行符后</strong>，或<strong>文件结尾</strong>，或<code>STLEN-1</code><strong>个字符</strong>，在末尾添加一个<strong>空字符</strong>使其成为<strong>字符串</strong><br>3、<code>fgets()</code><strong>遇到 EOF</strong>时将<strong>返回 NULL 值</strong>，可以利用这一特性检查<strong>是否到达文件结尾</strong>；如果<strong>未遇到 EOF</strong>则<strong>返回第一个参数的地址</strong></p>
</blockquote>
</li>
<li><p><code>fputs()</code><strong>函数</strong></p>
<blockquote>
<p>1、语法<code>fputs(words,fp);</code>。<strong>第一个参数</strong>为<strong>所需输出字符串的地址</strong>，<strong>第二个参数</strong>为<strong>文件指针</strong><br>2、<code>fputs</code>在打印字符串时<strong>不会在末尾添加换行符</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="随机访问：fseek-和-stell"><a href="#随机访问：fseek-和-stell" class="headerlink" title="随机访问：fseek()和 stell()"></a><strong>随机访问：fseek()和 stell()</strong></h4><ul>
<li><p>有了<code>fseek()</code>函数，便可把<strong>文件</strong>看做是<strong>数组</strong>，在<code>fopen()</code>打开的<strong>文件</strong>中直接<strong>移动到任意字节处</strong></p>
</li>
<li><p>注意，<code>fseek()</code>有<strong>3 个参数</strong>，<strong>返回 int 类型</strong>的值；<code>ftell()</code><strong>返回 long 类型</strong>的值，表示<strong>文件</strong>中的<strong>当前位置</strong></p>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CNTL_Z</span> <span class="token char">'\032'</span> <span class="token comment">// DOS 文本文件中的文件结尾标记</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLEN</span> <span class="token expression"><span class="token number">81</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> file<span class="token punctuation">[</span>SLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>
    <span class="token keyword">long</span> count<span class="token punctuation">,</span> last<span class="token punctuation">;</span>

    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入文件名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%80s"</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 只读模式</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"无法打开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token constant">SEEK_END</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定位到文件末尾</span>
    last <span class="token operator">=</span> <span class="token function">ftell</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span> count <span class="token operator">&lt;=</span> last<span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token operator">-</span>count<span class="token punctuation">,</span> <span class="token constant">SEEK_END</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 回退(倒序输出)</span>
        ch <span class="token operator">=</span> <span class="token function">getc</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> CNTL_Z <span class="token operator">&amp;&amp;</span> ch <span class="token operator">!=</span> <span class="token char">'\r'</span><span class="token punctuation">)</span> <span class="token comment">// MS-DOS 文件</span>
            <span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>fseek()函数</strong></p>
<ul>
<li><p><code>fseek</code><strong>的使用</strong></p>
<blockquote>
<p>1、<code>fseek()</code>的<strong>第一个参数</strong>是<strong>FILE 指针</strong>，指向<strong>待查找的文件</strong>，<code>fopen()</code>应该<strong>已经打开该文件</strong><br>2、<code>fseek()</code>的<strong>第二个参数</strong>是<strong>偏移量</strong>，该参数表示从<strong>设置的起始点</strong>开始要<strong>移动的距离</strong>。该参数必须是一个<strong>long 类型</strong>的值(<strong>L 后缀</strong>表明其值是<strong>long 类型</strong>)，可以为<strong>正</strong>(<strong>前移</strong>)、<strong>负</strong>(<strong>后移</strong>)或者<strong>0</strong>(<strong>不动</strong>)<br>3、<code>fseek()</code>的<strong>第三个参数</strong>是<strong>模式</strong>，由该参数<strong>确定起始点</strong>。模式如<strong>下表</strong>(<strong>旧的实现</strong>可能<strong>缺少</strong>这些定义，可以用<strong>数值 0L、1L、2L</strong>分别表示这<strong>三种模式</strong>)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">偏移量的起始点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SEEK_SET</td>
<td align="center">文件开始处</td>
</tr>
<tr>
<td align="center">SEEK_CUR</td>
<td align="center">当前位置</td>
</tr>
<tr>
<td align="center">SEEK_END</td>
<td align="center">文件末尾</td>
</tr>
</tbody></table>
</li>
<li><p><code>fseek()</code><strong>的一些示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 定位至文件开始处</span>
<span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">10L</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 定位至文件中第10个字节</span>
<span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">2L</span><span class="token punctuation">,</span> <span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 从文件当前位置前移2字节</span>
<span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token constant">SEEK_END</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 定位至文件结尾</span>
<span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10L</span><span class="token punctuation">,</span> <span class="token constant">SEEK_END</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 从文件结尾回退10字节</span></code></pre>
</li>
<li><p>如果<strong>一切正常</strong>，<code>fseek()</code>的<strong>返回值为 0</strong>；如果<strong>出现错误</strong>(如试图移动的距离超出文件范围)，其<strong>返回值为-1</strong></p>
</li>
</ul>
</li>
<li><p><strong>ftell()函数</strong></p>
<ul>
<li><p><code>ftell()</code>函数的<strong>返回类型</strong>是<strong>long</strong>，它<strong>返回</strong>的是<strong>参数指向文件</strong>的<strong>当前位置</strong>距离<strong>文件开始处</strong>的字节数</p>
</li>
<li><p><strong>实例要素分析</strong></p>
<blockquote>
<p>1、示例中首先使用了<code>fseek(fp, 0L, SEEK_END)</code>将<strong>当前位置</strong>设置在<strong>文件末尾</strong><br>2、此时<code>ftell(fp)</code>的值就是<strong>文件开始处</strong>到<strong>结尾</strong>的<strong>字节数</strong>，<code>last = ftell(fp)</code>将其赋给<strong>last</strong><br>3、然后再是<code>for</code><strong>循环</strong>中使用了<strong>last</strong>作为<strong>条件范围</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>fgetpos()和 fsetpos()函数</strong></p>
<ul>
<li><p><strong>函数介绍</strong></p>
<blockquote>
<p>1、<code>fseek()</code>和<code>ftell()</code>的<strong>潜在问题</strong>是，他们都把大小限制在<strong>long 能表示的范围内</strong>。鉴于此，<strong>ANSI C</strong>新增了两个<strong>处理较大文件</strong>的<strong>新定位函数</strong>：<code>fgetpos()</code>和<code>fsetpos()</code><br>2、这两个函数<strong>不使用 long 类型</strong>的值表示位置，他们使用一种<strong>新类型</strong>——<strong>fpos_t</strong>(file position type，文件定位类型)。<strong>fpos_t</strong>类型<strong>不是基本类型</strong>，它根据<strong>其他类型</strong>来定义<br>3、<strong>fpos_t</strong>的<strong>变量</strong>或<strong>数据对象</strong>可以在文件中<strong>指定一个位置</strong>，它<strong>不能是数组类型</strong>，除此之外，没有其他限制。<strong>实现</strong>可以提供一个满足<strong>特殊平台要求</strong>的类型，例如<strong>fpos_t</strong>可以实现为<strong>结构</strong></p>
</blockquote>
</li>
<li><p><strong>函数使用简介</strong></p>
<blockquote>
<p>1、<code>fgetpos()</code>的函数原型为<code>int fgetpos(FILE * restrict stream, fpos_t * restrict pos);</code><br>2、调用该函数时，它把<strong>fpos_t 类型的值</strong>放在<strong>pos 指向的位置</strong>上，该值描述文件中<strong>当前位置</strong>距<strong>文件开头</strong>的字节数。如果成功，<strong>返回 0</strong>，如果失败，<strong>返回非 0</strong><br>3、<code>fsetpos()</code>的函数原型为<code>int fsetpos(FILE *stream, const fpos_t *pos);</code><br>4、调用该函数时，使用<strong>pos 指向位置</strong>上的<strong>fpos_t 类型值</strong>来设置<strong>文件指针</strong>指向<strong>偏移该值后指定的位置</strong>。如果成功，<strong>返回 0</strong>，如果失败，<strong>返回非 0</strong>。其中，<strong>fpos_t</strong>类型的值应通过<strong>之前调用的</strong><code>fgetpos()</code>获得</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="其他标准-I-x2F-O-函数"><a href="#其他标准-I-x2F-O-函数" class="headerlink" title="其他标准 I&#x2F;O 函数"></a><strong>其他标准 I&#x2F;O 函数</strong></h4><ul>
<li><p><strong>ungetc()函数</strong></p>
<blockquote>
<p>1、<strong>函数原型</strong>：<code>int ungetc(int c, FILE *fp)</code><br>2、<code>ungetc()</code>函数把<strong>c 指定的字符</strong>放回<strong>输入流</strong>中<br>3、如果把一个字符<strong>放回输入流</strong>，下次调用<strong>标准输入函数</strong>时将<strong>读取该字符</strong></p>
</blockquote>
</li>
<li><p><strong>fflush()函数</strong></p>
<blockquote>
<p>1、<strong>函数原型</strong>：<code>int fflush(FILE *fp)</code><br>2、调用<code>fflush()</code>函数引起<strong>输出缓冲区</strong>中所有的<strong>未写入数据</strong>被发送到<strong>fp 指定的输出文件</strong>，这个过程被称为<strong>刷新缓冲区</strong>。如果<strong>fp</strong>是<strong>空指针</strong>，所有<strong>输出缓冲区</strong>都被刷新<br>3、在<strong>输入流</strong>中使用<code>fflush()</code>效果是<strong>未定义</strong>的。只要<strong>最近一次操作</strong>不是输入操作，就可以用该函数来<strong>更新流</strong></p>
</blockquote>
</li>
<li><p><strong>setvbuf()函数</strong></p>
<blockquote>
<p>1、<strong>函数原型</strong>：<code>int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size)</code><br>2、<code>setvbuf()</code>函数<strong>创建</strong>了一个供<strong>标准 I&#x2F;O 函数</strong>替换使用的<strong>缓冲区</strong>。在<strong>打开文件后</strong>且<strong>未对流进行其他操作前</strong>调用该函数<br>3、<strong>指针 fp</strong>识别<strong>待处理的流</strong>；<strong>buf</strong>指向<strong>待使用的存储区</strong>；<strong>mode</strong>的选择有<strong>三种</strong>：<code>_IOFBF</code>表示<strong>完全缓冲</strong>，<code>_IOLBF</code>表示<strong>行缓冲</strong>，<code>_IONBF</code>表示<strong>无缓冲</strong><br>4、如果<strong>buf</strong>的<strong>值不是 NULL</strong>，则必须<strong>创建一个缓冲区</strong>，如果把<strong>NULL</strong>作为<strong>buf 的值</strong>，该函数会为自己<strong>分配一个缓冲区</strong><br>5、如果函数操作成功，<strong>返回 0</strong>，否则<strong>返回非 0 值</strong></p>
</blockquote>
</li>
<li><p><strong>二进制 I&#x2F;O：fread()和 fwrite()</strong></p>
<ul>
<li><p><strong>引入介绍</strong></p>
<blockquote>
<p>1、之前用到的<strong>标准 I&#x2F;O 函数</strong>都是<strong>面向文本</strong>的，用于处理<strong>字符</strong>和<strong>字符串</strong>。如何在文件中<strong>保存数值信息</strong>？<br>2、用<code>fprintf()</code><strong>函数</strong>和<code>%f</code><strong>转换说明</strong>只是把<strong>数值</strong>保存为<strong>字符串</strong>。例如有<code>double num = 1./3.;</code>的<strong>声明</strong>，有<code>fprintf(fp, &quot;%f&quot;, num);</code>的<strong>语句</strong>，<strong>num</strong>也不过只被存储为<strong>8 个字符</strong>：<code>0.333333</code>，存储后，<strong>读取文件</strong>时就<strong>无法</strong>将其<strong>恢复为更高的精度</strong>。一般而言，<code>fprintf()</code>把<strong>数值</strong>转换为<strong>字符数据</strong>，这种转换<strong>可能</strong>会<strong>改变值</strong><br>3、为保证数值在<strong>存储前后一致</strong>，<strong>最精确</strong>的做法是使用<strong>与计算机相同</strong>的<strong>位组合</strong>来存储。因此，<strong>double 类型</strong>的值应该存储在一个<strong>double 大小的单元</strong>中。如果以<strong>程序</strong>所用的<strong>表示法</strong>把数据<strong>存储在文件</strong>中，则称以<strong>二进制形式</strong>存储数据<br>4、对于<strong>标准 I&#x2F;O</strong>，<code>fread()</code>和<code>fwrite()</code>函数用于以<strong>二进制形式</strong>处理数据</p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BE%93%E5%87%BA.png" loading="lazy"></p>
</li>
<li><p><code>fwrite()</code><strong>函数</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">fwrite</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*-----------------------*/</span>
<span class="token keyword">double</span> earnings<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">fwrite</span><span class="token punctuation">(</span>earnings<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、<strong>函数原型</strong>：<code>size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)</code><br>2、<code>fwrite()</code>把<strong>二进制数据</strong>写入文件。其中<strong>指针 ptr</strong>是<strong>待写入数据块的地址</strong>，<strong>size</strong>表示<strong>待写入数据块的大小</strong>(以字节为单位)，<strong>nmemb</strong>表示<strong>待写入数据块的数量</strong>(也是一次性写入数据块的数量)，<strong>fp</strong>表示<strong>待写入的文件</strong><br>3、注意<code>fwrite()</code><strong>第一个参数</strong>类型是<strong>指向 void 的指针</strong>(通用类型指针)，因此<strong>示例</strong>中分别传入<strong>指向 char 的指针</strong>和<strong>指向 double 的指针</strong>都是合法的<br>4、<code>fwrite()</code>函数<strong>返回成功写入项的数量</strong>。正常情况下返回值就是<strong>nmemb</strong>，出现错误返回值就会<strong>比 nmemb 小</strong></p>
</blockquote>
</li>
<li><p><code>fread()</code><strong>函数</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> earnings<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">fread</span><span class="token punctuation">(</span>earnings<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、<strong>函数原型</strong>：<code>size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)</code><br>2、<code>fread()</code>函数用于<strong>读取</strong>被<code>fwrite()</code>写入文件的<strong>数据</strong>。其<strong>接受参数</strong>与<code>fwrite()</code><strong>一致</strong>，其中<strong>ptr</strong>是<strong>待读取文件数据</strong>在<strong>内存中的地址</strong>，<strong>fp</strong>指定<strong>待读取的文件</strong><br>3、<code>fread()</code>函数<strong>返回成功读取项的数量</strong>。正常情况下返回值就是<strong>nmemb</strong>，出现错误或读到文件结尾返回值就会<strong>比 nmemb 小</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>feof()和 ferror()函数</strong></p>
<blockquote>
<p>1、<strong>函数原型</strong>：<code>int feof(FILE *fp)</code>，<code>int ferror(FILE *fp)</code><br>2、如果<strong>标准输入函数</strong>返回<strong>EOF</strong>，则通常表明函数已<strong>到达文件结尾</strong>。然而当出现<strong>读取错误</strong>时，函数也会返回<strong>EOF</strong>。<code>feof()</code>和<code>ferror()</code>用于<strong>区分</strong>这<strong>两种情况</strong><br>3、当上一次<strong>输入调用</strong>检测到<strong>文件结尾</strong>时，<code>feof()</code>返回<strong>非 0 值</strong>，否则<strong>返回 0</strong>；当<strong>读或写出现错误</strong>，<code>ferror()</code>返回<strong>非 0 值</strong>，否则<strong>返回 0</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="结构和其他数据形式"><a href="#结构和其他数据形式" class="headerlink" title="结构和其他数据形式"></a><strong>结构和其他数据形式</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：初识结构体；建立结构声明；定义结构变量；初始化结构；访问结构成员；结构的初始化器；结构数组；声明结构数组；标识结构数组的成员；嵌套结构；指向结构的指针；声明和初始化结构指针；用指针访问成员；向函数传递结构的信息；传递结构成员；传递结构的地址；传递结构；其他结构特性；使用结构数组的函数；结构与内存分配；结构中的字符指针与<code>malloc()</code>；复合字面量和结构；伸缩型数组成员；匿名结构；把结构内容保存到文件；链式结构；联合简介；枚举类型；共享名称空间；<code>typedef</code>简介；其他复杂的声明；类型声明黄金法则；函数指针</p>
</blockquote>
</div>

<h4 id="初识结构体"><a href="#初识结构体" class="headerlink" title="初识结构体"></a><strong>初识结构体</strong></h4><ul>
<li><p><strong>示例问题：创建图书目录</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、假如你需要打印一份<strong>图书目录</strong>，要打印每本书的<strong>各种信息</strong>(书名、作者、出版社、日期、页数等)。<strong>这些信息</strong>其中一些可以存储在<strong>字符数组</strong>中，其他一些又需要<strong>int 数组</strong>或<strong>float 数组</strong><br>2、用<strong>7 个不同的数组</strong>分别记录<strong>比较繁琐</strong>，尤其是如果你需要<strong>多份列表</strong>(一份按书名排序，一份按作者排序等)。如果能把图书目录的<strong>信息</strong>都包含在<strong>一个数组</strong>里更好，每个元素包含<strong>一本书</strong>的<strong>相关信息</strong><br>3、我们需要一种既能<strong>包含字符串</strong>又能<strong>包含数字</strong>的<strong>数据形式</strong>，而且还要保持<strong>各信息的独立</strong>。C 的<strong>结构体</strong>就满足这种情况下的需求</p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXTITL</span> <span class="token expression"><span class="token number">41</span> </span><span class="token comment">// 书名最大长度+1</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXAUTL</span> <span class="token expression"><span class="token number">31</span> </span><span class="token comment">// 作者姓名最大长度+1</span></span>

<span class="token comment">// 之前自己自定义的 s_gets 函数</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span> <span class="token comment">// 创建指针(同时也是存储字符串的变量)</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>                    <span class="token comment">// 即，ret_val != NULL，判断是否读到文件结尾</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token comment">// 忽略跳过正常字符</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 出现换行符替换为空字符，即不存储换行符</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>                          <span class="token comment">// 否则就是读到了空字符</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 丢弃该输入行的其余字符</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 定义结构模板：标记是 book</span>
<span class="token keyword">struct</span> <span class="token class-name">book</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>MAXTITL<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> author<span class="token punctuation">[</span>MAXAUTL<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 结构模板结束，注意分号</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">book</span> library<span class="token punctuation">;</span> <span class="token comment">// 把 library 声明为一个 book 类型的变量</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入书名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>library<span class="token punctuation">.</span>title<span class="token punctuation">,</span> MAXTITL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用 s_gets 函数访问将信息写入 library.title，即结构中的 title 变量</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入作者："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>library<span class="token punctuation">.</span>author<span class="token punctuation">,</span> MAXAUTL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入价钱："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>library<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"书名：%s\n作者：%s\n价钱：%.2f"</span><span class="token punctuation">,</span> library<span class="token punctuation">.</span>title<span class="token punctuation">,</span> library<span class="token punctuation">.</span>author<span class="token punctuation">,</span> library<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>建立结构声明</strong></p>
<ul>
<li><p><strong>结构声明</strong>描述了一个<strong>结构</strong>的<strong>组织布局</strong>，声明类似下面这样：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>声明分析</strong></p>
<blockquote>
<p>1、该声明描述了一个由<strong>两个字符数组</strong>和<strong>一个 float 类型变量</strong>组成的<strong>结构</strong>。该声明并<strong>未创建实际的数据对象</strong>，只描述该对象<strong>由什么组成</strong><br>2、有时我们把<strong>结构声明</strong>称为<strong>模板</strong>，因为它勾勒出结构是<strong>如何存储数据</strong>的。但注意此<strong>模板</strong>并非<strong>C++的模板</strong>，C++的模板要<strong>更为强大</strong><br>3、定义时，首先是<strong>关键字</strong><code>struct</code>，表明<strong>跟在其后</strong>的是一个<strong>结构</strong>，后面是一个可选的<strong>标记</strong>(该例中为 book)，稍后程序中可以<strong>使用该标记引用该结构</strong>。所以后面程序<strong>可以声明</strong><code>struct book library;</code>，这把<strong>library</strong>声明为一个<strong>使用 book 结构布局</strong>的<strong>结构变量</strong><br>4、在<strong>结构声明</strong>中，用一对<strong>花括号</strong>括起来的是<strong>结构成员列表</strong>。每个成员都用<strong>自己的声明</strong>来描述，成员可以是<strong>任意一种数据类型</strong>，甚至可以是<strong>其他结构</strong>。<strong>右花括号</strong>后面的<strong>分号</strong>是必需的，表示结构布局<strong>定义结束</strong><br>5、可以把<strong>结构声明</strong>放在<strong>所有函数外部</strong>(如本例)，也可以放在<strong>一个函数定义的内部</strong>。如果放在<strong>函数内部</strong>，则该结构<strong>标记仅供该函数内部使用</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>定义结构变量</strong></p>
<ul>
<li><p><strong>定义结构变量</strong></p>
<blockquote>
<p>1、<strong>结构</strong>有<strong>两层含义</strong>。一层含义是<strong>结构布局</strong>(未让编译器为数据分配空间)；另一层含义(同时也是下一步)是<strong>创建一个结构变量</strong><br>2、程序中<strong>创建结构变量</strong>的一行是<code>struct book library;</code>，编译器执行这行代码便<strong>创建了一个结构变量 library</strong>。编译器<strong>使用 book 模板</strong>为该变量<strong>分配空间</strong>，这些<strong>分配的空间</strong>都与<strong>名称 library</strong>结合在一起<br>3、在<strong>结构变量</strong>的声明中，<code>struct book</code>所起的作用<strong>相当于</strong>一般声明中的<code>int</code>或<code>float</code>。例如，你也可以<strong>定义两个</strong><code>struct book</code>类型的变量，或者定义<strong>指向</strong><code>struct book</code><strong>类型结构</strong>的<strong>指针</strong><br>4、如<code>struct book doyle, panshin, *ptbook;</code>，其中的<strong>doyle</strong>和<strong>panshin</strong>都是<strong>以 book 为模板</strong>定义的独立的<strong>结构变量</strong>，<strong>指针 ptbook</strong>可以<strong>指向</strong>任何<strong>book 类型的结构变量</strong></p>
</blockquote>
</li>
<li><p><strong>补充说明</strong></p>
<ul>
<li><p>就<strong>计算机</strong>而言，<code>struct book library;</code>这条声明，是<strong>以下声明</strong>的<strong>简化</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> library<span class="token punctuation">;</span>  <span class="token comment">// 声明的右花括号后跟变量名</span></code></pre>
</li>
<li><p>换言之，<strong>声明结构</strong>的过程和<strong>定义结构变量</strong>的过程<strong>可以组合</strong>成一个过程。如下，组合后<strong>可以省略结构标记</strong>：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> library<span class="token punctuation">;</span></code></pre>
</li>
<li><p>然而，如果打算<strong>多次使用结构模板</strong>，就要使用<strong>带标记的形式</strong>。所以不建议使用以上形式单独组合使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>初始化结构</strong></p>
<ul>
<li><p>我们可以通过<code>int count = 0;</code>和<code>int fibo[4] = &#123;0,1,2,3&#125;;</code><strong>初始化变量和数组</strong>，<strong>结构变量</strong>能否<strong>初始化</strong>？</p>
</li>
<li><p><strong>初始化一个结构变量</strong>与<strong>初始化数组</strong>语法类似(但要注意 ANSI C 前不能用自动变量初始化结构)：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span> library <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token string">"This is book name"</span><span class="token punctuation">,</span>
    <span class="token string">"author name"</span><span class="token punctuation">,</span>
    <span class="token number">1.95</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>简言之，可以使用一对<strong>花括号</strong>括起来的<strong>初始化列表</strong>来<strong>初始化结构变量</strong>，各项用<strong>逗号分隔</strong>。示例之所以<strong>换行</strong>是为了<strong>提高代码可读性</strong></p>
</li>
</ul>
</li>
<li><p><strong>访问结构成员</strong></p>
<blockquote>
<p>1、<strong>结构</strong>就类似于一个<strong>超级数组</strong>，想要访问这个<strong>超级数组</strong>中的<strong>元素</strong>，需要使用<strong>结构成员运算符</strong>——<strong>点</strong><code>.</code><br>2、例如<code>library.value</code>即访问<strong>library</strong>的<strong>value</strong>部分。你可以像使用任何<strong>float 变量</strong>那样使用<code>library.value</code><br>3、本质上，<code>.title</code>、<code>.author</code>和<code>.value</code>就相当于<strong>book 结构</strong>的<strong>下标</strong></p>
</blockquote>
</li>
<li><p><strong>结构的初始化器</strong></p>
<ul>
<li><p><strong>C99</strong>和<strong>C11</strong>为结构提供了<strong>指定初始化器</strong>，其语法与<strong>数组</strong>的<strong>指定初始化器</strong>类似</p>
</li>
<li><p><strong>结构的初始化器</strong>使用<strong>点运算符</strong>和<strong>成员名</strong>标识特定的元素。例如<strong>先初始化 value</strong>，<strong>再初始化 author</strong>，示例如下：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span> library <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">10.99</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>author <span class="token operator">=</span> <span class="token string">"author name"</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>与数组类似，在<strong>指定初始化器</strong>后面的<strong>普通初始化器</strong>，会初始化<strong>指定成员后面的成员</strong>。如下示例，<strong>value</strong>先被<strong>指定初始化</strong>为<strong>10.01</strong>，后被<strong>普通初始化覆盖</strong>为<strong>19.11</strong>(因为其模板定义时紧跟在 author 后面，即为 author 后面的成员)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span> library <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">10.99</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>author <span class="token operator">=</span> <span class="token string">"author name"</span><span class="token punctuation">,</span>
    <span class="token number">19.11</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a><strong>结构数组</strong></h4><ul>
<li><p><strong>示例拓展</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、接下来，我们要使上面的程序拓展成<strong>可以处理多本书</strong>，<strong>每本书的信息</strong>都可以用一个<strong>book 类型</strong>的<strong>结构变量</strong>来表示<br>2、可以使用这一类型的<strong>结构数组</strong>来处理<strong>多本书</strong>，如下面的示例程序<br>3、注意示例程序创建了一个内含<strong>100 个结构变量</strong>的<strong>结构数组</strong>。由于该数组是<strong>自动存储类别</strong>的对象，<strong>信息</strong>被存储在<strong>栈</strong>中。如此大的数组需要<strong>很大一块内存</strong>，这可能导致一些问题，比如<strong>栈溢出</strong>。这是由于编译器可能使用了一个<strong>默认大小的栈</strong>，要修正这个问题，可以使用<strong>编译器选项</strong>设置<strong>栈大小</strong>为<strong>10000</strong>，或者也可以创建<strong>静态或外部数组</strong>(这样不会存储在栈内)</p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXTITL</span> <span class="token expression"><span class="token number">41</span> </span><span class="token comment">// 书名最大长度+1</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXAUTL</span> <span class="token expression"><span class="token number">31</span> </span><span class="token comment">// 作者姓名最大长度+1</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXBKS</span> <span class="token expression"><span class="token number">100</span> </span><span class="token comment">// 书籍最大数量</span></span>

<span class="token comment">// 之前自己自定义的 s_gets 函数</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span> <span class="token comment">// 创建指针(同时也是存储字符串的变量)</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>                    <span class="token comment">// 即，ret_val != NULL，判断是否读到文件结尾</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token comment">// 忽略跳过正常字符</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 出现换行符替换为空字符，即不存储换行符</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>                          <span class="token comment">// 否则就是读到了空字符</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 丢弃该输入行的其余字符</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">struct</span> <span class="token class-name">book</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>MAXTITL<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> author<span class="token punctuation">[</span>MAXAUTL<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">book</span> library<span class="token punctuation">[</span>MAXBKS<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// book 类型结构的数组</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入书名，在新行行首换行停止程序："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 计数小于最大书籍数 &amp;&amp; 输入title正常 &amp;&amp; 不停止程序</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> MAXBKS <span class="token operator">&amp;&amp;</span> <span class="token function">s_gets</span><span class="token punctuation">(</span>library<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span> MAXTITL<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> library<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"现在输入作者："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">s_gets</span><span class="token punctuation">(</span>library<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">.</span>author<span class="token punctuation">,</span> MAXAUTL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"现在输入价钱："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>library<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输入结束后，count++</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>             <span class="token comment">// 清理输入行(scanf输入会保留换行符)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> MAXBKS<span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入下一本书名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这是你的书籍信息单：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s  %s  %.2f\n"</span><span class="token punctuation">,</span> library<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span> library<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>author<span class="token punctuation">,</span> library<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"没有书籍信息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>声明结构数组</strong></p>
<blockquote>
<p>1、声明<strong>结构数组</strong>和声明<strong>其他类型的数组</strong>类似，例如<code>struct book library[50]</code><br>2、以上代码把<strong>library</strong>声明为一个<strong>内含 50 个元素</strong>的数组。数组的<strong>每个元素</strong>都是一个<strong>book 类型</strong>的<strong>结构</strong><br>3、因此，<code>library[0]</code>是<strong>第 1 个 book 类型结构变量</strong>，<code>library[1]</code>是<strong>第 2 个 book 类型结构变量</strong><br>4、<strong>数组名 library</strong>本身<strong>不是结构名</strong>，它只是一个<strong>数组名</strong></p>
</blockquote>
</li>
<li><p><strong>标识结构数组的成员</strong></p>
<blockquote>
<p>1、为了标识<strong>结构数组</strong>的<strong>成员</strong>，可以采用<strong>访问单独结构</strong>的规则：<strong>结构名</strong>后加一个<strong>点运算符</strong>，再写<strong>成员名</strong><br>2、只是对于<strong>结构数组</strong>，结构名为<code>library[0]</code>这种形式，而非<code>library</code>(library 只是数组名)<br>3、因此<strong>访问对象</strong>为<code>library[0].title</code>、<code>library[1].author</code>等等</p>
</blockquote>
</li>
</ul>
<h4 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a><strong>嵌套结构</strong></h4><ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEN</span> <span class="token expression"><span class="token number">20</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">names</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> first<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> last<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">guy</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">names</span> handle<span class="token punctuation">;</span> <span class="token comment">// 嵌套结构</span>
    <span class="token keyword">char</span> favfood<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> job<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> income<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 初始化结构变量</span>
    <span class="token keyword">struct</span> <span class="token class-name">guy</span> fellow <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span><span class="token string">"Ewen"</span><span class="token punctuation">,</span> <span class="token string">"Villard"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token string">"grilled salmon"</span><span class="token punctuation">,</span>
        <span class="token string">"personality coach"</span><span class="token punctuation">,</span>
        <span class="token number">68112.00</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"朋友信息：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"名：%s  姓：%s\n"</span><span class="token punctuation">,</span> fellow<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>first<span class="token punctuation">,</span> fellow<span class="token punctuation">.</span>handle<span class="token punctuation">.</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"喜欢的食物：%s\n职业：%s\n收入：%.2f"</span><span class="token punctuation">,</span>fellow<span class="token punctuation">.</span>favfood<span class="token punctuation">,</span> fellow<span class="token punctuation">.</span>job<span class="token punctuation">,</span> fellow<span class="token punctuation">.</span>income<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>示例解析</strong></p>
<blockquote>
<p>1、首先注意如何在<strong>结构声明</strong>中<strong>创建嵌套结构</strong>。和声明<strong>int 类型变量</strong>一样，先进行声明<code>struct names handle</code>，该声明表示<strong>handle</strong>是一个<strong>struct names</strong>类型的<strong>变量</strong>(当然文件中应<strong>提前声明 names</strong>)<br>2、其次注意如何<strong>访问嵌套结构</strong>的<strong>成员</strong>。此时应使用两次<strong>点运算符</strong>，如<code>fellow.handle.first</code>，意为找到<strong>fellow</strong>中嵌套的<strong>handle</strong>，再找到<strong>handle</strong>的<strong>first 成员</strong><br>3、<strong>初始化</strong>结构变量时，<strong>嵌套的结构</strong>也仍需按照<strong>初始化语法</strong>进行初始化，即需要用<strong>花括号</strong>包裹</p>
</blockquote>
</li>
</ul>
<h4 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a><strong>指向结构的指针</strong></h4><ul>
<li><p><strong>为何要使用指向结构的指针</strong></p>
<blockquote>
<p>1、就像<strong>指向数组的指针</strong>比<strong>数组本身</strong>更容易操控(如排序问题)一样，<strong>指向结构的指针</strong>通常比<strong>结构本身</strong>更容易操控<br>2、在一些<strong>早期的 C 实现</strong>中，结构<strong>不能作为参数</strong>传递给函数，但是<strong>可以传递指向结构的指针</strong><br>3、即使能传递一个结构，传递指针通常<strong>更有效率</strong><br>4、一些用于<strong>表示数据的结构</strong>中包含<strong>指向其他结构的指针</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEN</span> <span class="token expression"><span class="token number">20</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">names</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> first<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> last<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">guy</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">names</span> handle<span class="token punctuation">;</span>
    <span class="token keyword">char</span> favfood<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> job<span class="token punctuation">[</span>LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> income<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">guy</span> fellow<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span>
            <span class="token punctuation">&#123;</span><span class="token string">"Ewen"</span><span class="token punctuation">,</span> <span class="token string">"Villard"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token string">"grilled salmon"</span><span class="token punctuation">,</span>
            <span class="token string">"personality coach"</span><span class="token punctuation">,</span>
            <span class="token number">68112.00</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span>
            <span class="token punctuation">&#123;</span><span class="token string">"Rodney"</span><span class="token punctuation">,</span> <span class="token string">"Swillbelly"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token string">"tripe"</span><span class="token punctuation">,</span>
            <span class="token string">"tabloid editor"</span><span class="token punctuation">,</span>
            <span class="token number">432400.00</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">guy</span> <span class="token operator">*</span>him<span class="token punctuation">;</span>      <span class="token comment">// 一个指向结构的指针</span>
    him <span class="token operator">=</span> <span class="token operator">&amp;</span>fellow<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 指针指向 fellow[0]</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fellow<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fellow<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p %p\n"</span><span class="token punctuation">,</span> him<span class="token punctuation">,</span> him <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"him->income: %.2f  (*him).income: %.2f\n"</span><span class="token punctuation">,</span> him<span class="token operator">-></span>income<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>him<span class="token punctuation">)</span><span class="token punctuation">.</span>income<span class="token punctuation">)</span><span class="token punctuation">;</span>
    him <span class="token operator">++</span><span class="token punctuation">;</span>               <span class="token comment">// 指向下一个结构</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"him->favfood: %s  (*him).handle.last: %s\n"</span><span class="token punctuation">,</span> him<span class="token operator">-></span>favfood<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>him<span class="token punctuation">)</span><span class="token punctuation">.</span>handle<span class="token punctuation">.</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">000000000061FD70 000000000061FDC4
000000000061FD70 000000000061FDC4
him-&gt;income: 68112.00  (*him).income: 68112.00
him-&gt;favfood: tripe  (*him).handle.last: Swillbelly</code></pre>
</li>
<li><p><strong>声明和初始化结构指针</strong></p>
<blockquote>
<p>1、声明<strong>结构指针</strong>很简单：<code>struct guy *him;</code>。首先是<strong>关键字</strong><code>struct</code>，其次是<strong>结构标记</strong><code>guy</code>，然后是<strong>一个星号</strong><code>*</code>，其后跟着<strong>指针名</strong><code>him</code>。这个语法和<strong>其他指针声明</strong>一样<br>2、该声明并<strong>未创建</strong>一个<strong>新的结构</strong>，但是<strong>指针 him</strong>可以<strong>指向任意</strong>现有的<strong>guy 类型结构</strong><br>3、<strong>和数组不同</strong>的是，<strong>结构变量名</strong>并不是<strong>结构变量的地址</strong>，因此要在<strong>结构变量名</strong>前面加上<strong>取地址运算符</strong><code>&amp;</code><br>4、在本例中，<strong>fellow</strong>是一个<strong>结构数组</strong>，这意味着<code>fellow[0]</code><strong>才是一个结构</strong>。所以要让<strong>him</strong>指向<code>fellow[0]</code><br>5、比较<strong>输出的前两行</strong>，发现<code>him + 1</code>相当于<code>him</code><strong>指向的地址+84</strong>(十六进制 DC4 - D70 &#x3D; 54，换算十进制 84)。这是因为<strong>每个 guy 结构</strong>都占<strong>84 字节</strong>内存(20+20+20+20+4)<br>6、在有些系统中，一个结构的大小<strong>可能大于各成员大小之和</strong>，这是因为系统对<strong>数据</strong>进行<strong>校准</strong>的过程中产生了一些<strong>缝隙</strong>。例如有些操作系统必须把<strong>每个成员</strong>都放在<strong>偶数地址</strong>或<strong>4 的倍数</strong>的地址上</p>
</blockquote>
</li>
<li><p><strong>用指针访问成员</strong></p>
<blockquote>
<p>1、第一种方法是使用<code>-&gt;</code><strong>运算符</strong>，有以下关系：<code>him == &amp;barney</code>，那么<code>him-&gt;income</code>即是<code>barney.income</code>。换句话说，<strong>指向结构的指针</strong>后面的<code>-&gt;</code><strong>运算符</strong>和<strong>结构变量名</strong>后面的<code>.</code><strong>运算符</strong>工作方式相同。这里要注意<strong>him</strong>是一个<strong>指针</strong>，<code>him-&gt;income</code>是<strong>指针所指结构</strong>的<strong>一个成员</strong><br>2、第二种方法是：如果<code>him == &amp;fellow[0]</code>，那么<code>*him == fellow[0]</code>，因为<code>&amp;</code>和<code>*</code>是一对<strong>互逆运算符</strong>。因此有<code>fellow[0].income == (*him).income</code>。注意<strong>必须使用圆括号</strong>，因为<code>.</code>比<code>*</code><strong>优先级更高</strong></p>
</blockquote>
</li>
</ul>
<h4 id="向函数传递结构的信息"><a href="#向函数传递结构的信息" class="headerlink" title="向函数传递结构的信息"></a><strong>向函数传递结构的信息</strong></h4><ul>
<li><p><strong>传递结构成员</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">struct</span> <span class="token class-name">funds</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> bankfund<span class="token punctuation">;</span>
    <span class="token keyword">double</span> savefund<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">funds</span> stan <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token number">4032.27</span><span class="token punctuation">,</span>
        <span class="token number">8543.94</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">// 传参</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>stan<span class="token punctuation">.</span>bankfund<span class="token punctuation">,</span> stan<span class="token punctuation">.</span>savefund<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、只要<strong>结构成员</strong>是一个<strong>具有单个值</strong>的数据类型，即可把它<strong>作为参数</strong>传递给<strong>接受该类型</strong>的函数<br>2、当然，如果需要在<strong>被调函数</strong>中修改<strong>主调函数</strong>中成员的值，需要<strong>传递成员的地址</strong>(<code>&amp;stan.bankfund</code>)</p>
</blockquote>
</li>
<li><p><strong>传递结构的地址</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">struct</span> <span class="token class-name">funds</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> bankfund<span class="token punctuation">;</span>
    <span class="token keyword">double</span> savefund<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">funds</span> <span class="token operator">*</span>money<span class="token punctuation">)</span> <span class="token comment">// 参数是一个指针</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>money<span class="token operator">-></span>bankfund <span class="token operator">+</span> money<span class="token operator">-></span>savefund<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过指针访问成员</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">funds</span> stan <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token number">4032.27</span><span class="token punctuation">,</span>
        <span class="token number">8543.94</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">// 传参</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stan<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、这次将<strong>结构的地址</strong>作为参数，<code>sum()</code><strong>函数</strong>使用<strong>指向 funds 结构的指针</strong>(money)作为参数，，把地址<code>&amp;stan</code>传给函数，使<strong>money</strong>指向<strong>结构变量 stan</strong><br>2、函数中，通过<strong>指针访问成员</strong>(<code>-&gt;</code>运算符)，获取<code>stan.bankfund</code>和<code>stan.savefund</code>的值<br>3、由于该函数并不能改变<strong>指针所指向值</strong>的<strong>内容</strong>，所以把<strong>money</strong>声明为一个<strong>指向 const 的指针</strong></p>
</blockquote>
</li>
<li><p><strong>传递结构</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">struct</span> <span class="token class-name">funds</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> bankfund<span class="token punctuation">;</span>
    <span class="token keyword">double</span> savefund<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">funds</span> moolah<span class="token punctuation">)</span> <span class="token comment">// 参数是一个结构</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>moolah<span class="token punctuation">.</span>bankfund <span class="token operator">+</span> moolah<span class="token punctuation">.</span>savefund<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过结构变量访问成员</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">funds</span> stan <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token number">4032.27</span><span class="token punctuation">,</span>
        <span class="token number">8543.94</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">// 传参</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>stan<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、对于<strong>允许把结构作为参数</strong>的编译器(一些旧的实现不允许这样做)，可以通过<strong>上述示例</strong>方式传递结构<br>2、<strong>函数</strong><code>sum()</code>被调用时，<strong>创建</strong>了一个名为<strong>moolah</strong>的<strong>自动结构变量</strong>，其<strong>各成员</strong>被<strong>初始化</strong>为<strong>stan 结构变量相应成员</strong>的值的<strong>副本</strong><br>3、因此，<strong>传递指针</strong>的方式使用的是<strong>原始的结构</strong>进行计算，而这种方式使用的是<strong>新创建的 moolah 副本</strong>进行计算，因此该程序使用<code>moolah.bankfund</code>访问<strong>成员</strong></p>
</blockquote>
</li>
<li><p><strong>其他结构特性</strong></p>
<ul>
<li><p><strong>结构赋值</strong></p>
<blockquote>
<p>1、现在的 C 允许<strong>把一个结构赋值给另一个结构</strong>(但是数组不能这样做)<br>2、也就是说，如果<strong>n_data</strong>和<strong>o_data</strong>都是<strong>相同类型的结构</strong>，可以这样做：<code>o_data = n_data</code><br>3、这条语句把<strong>n_data</strong>的<strong>每个成员的值</strong>都赋给<strong>o_data</strong>的<strong>相应成员</strong>。即使<strong>成员是数组</strong>，<strong>也能完成赋值</strong></p>
</blockquote>
</li>
<li><p><strong>结构作为返回值</strong></p>
<blockquote>
<p>1、现在的 C，<strong>函数</strong>不仅能把<strong>结构</strong>作为<strong>参数</strong>传递，还能把<strong>结构</strong>作为<strong>返回值</strong>返回<br>2、例如一个<strong>常规的函数</strong>，接受一个<strong>指向结构的指针</strong>作为<strong>参数</strong>，并通过指针<strong>改变数据</strong>。现在还可以在<strong>函数</strong>内<strong>定义单独的结构变量</strong>，在<strong>函数内</strong>对该<strong>结构变量</strong>进行操作，最后将其<strong>作为返回值</strong>返回。<br>3、例如<strong>函数</strong>为<code>void def(void)</code>，函数内定义<strong>结构变量</strong>为<strong>person</strong>，函数<strong>返回语句</strong>为<code>return person;</code>，主函数有<strong>同类型结构变量 person_data</strong>，便可以通过<code>person_data = def();</code>将<code>def()</code><strong>函数内</strong>的<strong>person</strong>，<strong>作为返回值赋给 person_data</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>使用结构数组的函数</strong></p>
<blockquote>
<p>1、整体传参方式和之前<strong>传递一个数组</strong>类似。<strong>数组名</strong>就是<strong>首元素地址</strong>(数组地址)，可以将其<strong>传给指针</strong>，另外该函数还需要访问<strong>结构模板</strong><br>2、<strong>函数定义</strong>时参数定义大致为<code>double sum(struct funds money[], int n);</code>，其中<code>money[]</code>就是一个<strong>指针</strong>(也可以写为<code>*money</code>，这样写是为了提醒他人这是一个数组地址)，<strong>n</strong>为数组<strong>元素个数</strong><br>3、在主函数中<strong>调用函数</strong><code>sum(jones, 5)</code>(其中 jones 被定义为<code>struct funds jones[5]</code>)。<strong>数组名 jones</strong>就是<strong>首元素地址</strong>，因此<strong>指针 money</strong>初始值相当于<code>money = &amp;jones[0]</code><br>4、因为<strong>money</strong>指向<strong>jones 的首元素</strong>，所以<code>money[0]</code>就是<code>jones[0]</code>的<strong>另一个名称</strong>。与此类似，<code>money[1]</code>就是<strong>第二个元素</strong>，在<strong>函数中</strong>便使用<code>money[下标].成员名</code>访问成员</p>
</blockquote>
</li>
</ul>
<h4 id="结构与内存分配"><a href="#结构与内存分配" class="headerlink" title="结构与内存分配"></a><strong>结构与内存分配</strong></h4><ul>
<li><p><strong>结构中的字符指针与 malloc()</strong></p>
<ul>
<li><p><strong>问题分析</strong></p>
<blockquote>
<p>1、到目前为止，我们在<strong>结构</strong>中都是使用<strong>字符数组</strong>存储字符串，能否像学习<strong>字符串</strong>时使用<strong>指向 char 的指针</strong>存储字符串？<br>2、通常而言是可行的，但是<strong>实际使用</strong>时，也会出现<strong>指向 char 的指针</strong>存储字符串时的<strong>通病</strong>——<strong>内存分配</strong><br>3、使用<strong>这样的方式</strong>存储字符串，由于<strong>指针所指向的位置</strong>并<strong>未被分配</strong>，因此其<strong>存储的位置地址</strong>可以是<strong>任何值</strong>，这可能会<strong>篡改程序</strong>的<strong>其他数据</strong>，导致程序崩溃<br>4、因此如果要用<strong>结构存储字符串</strong>，用<strong>字符数组</strong>较为简单，如果使用<strong>指针</strong>，误用可能导致严重的问题，因此最好配合<code>malloc()</code><strong>函数</strong>提前分配内存</p>
</blockquote>
</li>
<li><p><strong>指针与</strong><code>malloc()</code><strong>函数</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> <span class="token comment">// 提供 strcpy()、strlen()的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> <span class="token comment">// 提供 malloc()、free()的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLEN</span> <span class="token expression"><span class="token number">81</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">namect</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>fname<span class="token punctuation">;</span> <span class="token comment">// 使用指针存储字符串</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>lname<span class="token punctuation">;</span>
    <span class="token keyword">int</span> letters<span class="token punctuation">;</span> <span class="token comment">// 统计名字字符数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 之前自定义的 s_gets() 函数</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span> <span class="token comment">// 创建指针(同时也是存储字符串的变量)</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>                    <span class="token comment">// 即，ret_val != NULL，判断是否读到文件结尾</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token comment">// 忽略跳过正常字符</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 出现换行符替换为空字符，即不存储换行符</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>                          <span class="token comment">// 否则就是读到了空字符</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 丢弃该输入行的其余字符</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 获取信息</span>
<span class="token keyword">void</span> <span class="token function">getinfo</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">namect</span> <span class="token operator">*</span>pst<span class="token punctuation">)</span> <span class="token comment">// 传递指针</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> temp<span class="token punctuation">[</span>SLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入名字："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> SLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 分配内存以存储名字</span>
    pst<span class="token operator">-></span>fname <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配存储 temp+1 所需的大小</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>pst<span class="token operator">-></span>fname<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 拷贝字符串</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入姓氏："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> SLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pst<span class="token operator">-></span>lname <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>pst<span class="token operator">-></span>lname<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 处理信息</span>
<span class="token keyword">void</span> <span class="token function">makeinfo</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">namect</span> <span class="token operator">*</span>pst<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 计算名字字符个数</span>
    pst<span class="token operator">-></span>letters <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pst<span class="token operator">-></span>fname<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pst<span class="token operator">-></span>lname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 打印信息</span>
<span class="token keyword">void</span> <span class="token function">showinfo</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">namect</span> <span class="token operator">*</span>pst<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s  %s  %d\n"</span><span class="token punctuation">,</span> pst<span class="token operator">-></span>fname<span class="token punctuation">,</span> pst<span class="token operator">-></span>lname<span class="token punctuation">,</span> pst<span class="token operator">-></span>letters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 释放分配的内存</span>
<span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">namect</span> <span class="token operator">*</span>pst<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>pst<span class="token operator">-></span>fname<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>pst<span class="token operator">-></span>lname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">namect</span> person<span class="token punctuation">;</span> <span class="token comment">// 名为person的结构变量</span>
    <span class="token function">getinfo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">makeinfo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">showinfo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>复合字面量和结构</strong></p>
<blockquote>
<p>1、<strong>C99</strong>的<strong>复合字面量</strong>特性不仅可以用于<strong>数组</strong>，还可以用于<strong>结构</strong>。如果只需要一个<strong>临时结构值</strong>，复合字面量很好用<br>2、可以使用<strong>复合字面量</strong>创建一个<strong>结构</strong>作为<strong>函数的参数</strong>或<strong>赋给另一个结构</strong><br>3、语法与<strong>数组复合字面量</strong>相似，将<strong>类型名</strong>放在<strong>圆括号</strong>中，后面紧跟一个用<strong>花括号</strong>括起来的<strong>初始化列表</strong>，示例如下</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">book</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> author<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">book</span> readfirst<span class="token punctuation">;</span>
    readfirst <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">book</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token string">"food"</span><span class="token punctuation">,</span><span class="token string">"Nick"</span><span class="token punctuation">,</span><span class="token number">11.25</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">// 使用复合字面量创建临时结构值赋值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>伸缩型数组成员</strong></p>
<ul>
<li><p><strong>简介</strong></p>
<blockquote>
<p>1、<strong>C99</strong>新增了一个特性：<strong>伸缩型数组成员</strong>。利用这项特性声明的<strong>结构</strong>，其<strong>最后一个数组成员</strong>具有一些<strong>特性</strong><br>2、第 1 个特性是，该数组<strong>不会立即存在</strong><br>3、第 2 个特性是，使用这个<strong>伸缩型数组成员</strong>可以编写合适的代码，就<strong>好像</strong>它<strong>确实存在</strong>并<strong>具有所需数目的元素</strong></p>
</blockquote>
</li>
<li><p><strong>声明伸缩型数组成员</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">flex</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token keyword">double</span> average<span class="token punctuation">;</span>
    <span class="token keyword">double</span> score<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 伸缩型数组成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、<strong>伸缩型数组成员</strong>必须是结构的<strong>最后一个成员</strong><br>2、结构中必须<strong>至少有一个成员</strong><br>3、<strong>伸缩数组</strong>的声明类似于<strong>普通数组</strong>，只是<strong>方括号中是空的</strong></p>
</blockquote>
</li>
<li><p><strong>使用伸缩型数组成员</strong></p>
<ul>
<li><p>声明一个<strong>struct flex</strong>类型的<strong>结构变量</strong>时，不能用<strong>score</strong>去做任何事，因为<strong>没有</strong>给这个数组<strong>预留存储空间</strong></p>
</li>
<li><p>实际上，<strong>C99</strong>的意图不是让你声明<strong>struct flex</strong>类型的<strong>结构变量</strong>，而是希望你声明<strong>指向 struct flex 类型的指针</strong>，然后用<code>malloc()</code>函数来<strong>分配足够的空间</strong>，以存储<strong>struct flex</strong>类型结构的<strong>常规内容</strong>和<strong>伸缩型数组成员</strong>所需的<strong>额外空间</strong></p>
</li>
<li><p>例如，假设用<strong>score</strong>表示一个<strong>内含 5 个 double 类型值</strong>的<strong>数组</strong>，可以这样做：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">flex</span> <span class="token operator">*</span> pf<span class="token punctuation">;</span>   <span class="token comment">// 声明一个指针</span>
<span class="token comment">// 请求为一个结构和一个数组分配存储空间</span>
pf <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">flex</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 一个struct flex的空间 + 5个double的空间</span></code></pre>
</li>
<li><p>现在有<strong>足够储存空间</strong>存储<strong>count</strong>、<strong>average</strong>和一个<strong>内含 5 个 double 类型值</strong>的<strong>数组</strong>，可以用<strong>指针 pf</strong>访问这些成员：</p>
<pre class="language-c" data-language="c"><code class="language-c">pf <span class="token operator">-></span> count <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token comment">// 访问 count 成员</span>
pf <span class="token operator">-></span> score<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">18.5</span><span class="token punctuation">;</span>  <span class="token comment">// 访问数组的一个元素</span></code></pre>
</li>
<li><p>此时，可以将<strong>5 个 double 类型值</strong>的<strong>5</strong>换为一个<strong>变量 n</strong>，就可以更方便的<strong>伸缩数组大小</strong>。即<code>malloc()</code>分配时，<code>malloc(sizeof(struct flex) + n * sizeof(double))</code>，其中<strong>n</strong>就表示<strong>伸缩型数组成员</strong>的<strong>元素个数</strong></p>
</li>
</ul>
</li>
<li><p><strong>一些特殊的处理要求</strong></p>
<blockquote>
<p>1、第一，<strong>不能</strong>用结构进行<strong>赋值或拷贝</strong>(即<code>*pf1 = *pf2</code>这样)，这样做只会拷贝<strong>除伸缩型数组成员外</strong>的<strong>其他成员</strong>。如果确实要拷贝，应使用<code>memcpy()</code>函数(第 16 章介绍)<br>2、不要以<strong>按值方式</strong>把这种结构<strong>传递给函数</strong>。原因相同，<strong>按值传递</strong>一个参数与<strong>赋值</strong>类似。应该把<strong>结构的地址</strong>传给函数<br>3、不要使用<strong>带伸缩型数组成员的结构</strong>作为<strong>数组成员</strong>或<strong>另一个结构的成员</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>匿名结构</strong></p>
<ul>
<li><p><strong>匿名结构</strong>是一个<strong>没有名称的结构成员</strong>。<strong>C11</strong>中，可以用<strong>嵌套</strong>的<strong>匿名成员结构</strong>定义结构：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">person</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> first<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">char</span> last<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 匿名结构</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>特点</strong></p>
<blockquote>
<p>1、假设需要一个<strong>struct person</strong>类型的<strong>结构变量 ted</strong>，<strong>初始化 ted</strong>的方式与初始化一个<strong>嵌套结构</strong>方式相同：<code>struct person ted = &#123;12, &#123;&quot;Ted&quot;, &quot;Grass&quot;&#125;&#125;;</code><br>2、但是在<strong>访问 ted 时</strong>，相比嵌套结构<strong>简化了步骤</strong>。只需把<strong>first</strong>和<strong>last</strong>看作<strong>person 的成员</strong>，使用<code>ted.first</code>即可访问，而不需要像<strong>嵌套结构</strong>那样使用<code>ted.xxxxx.first</code>访问<br>3、当然，这样看来也可以把<strong>first</strong>和<strong>last</strong>直接作为<strong>person 的成员</strong>，<strong>匿名特性</strong>在<strong>嵌套联合</strong>中更加有用，后续介绍</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="把结构内容保存到文件"><a href="#把结构内容保存到文件" class="headerlink" title="把结构内容保存到文件"></a><strong>把结构内容保存到文件</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、由于<strong>结构</strong>可以<strong>存储不同类型</strong>的信息，所以它是<strong>构建数据库</strong>的重要工具。我们要把这些信息<strong>存储在文件</strong>中，并且能<strong>再次检索</strong><br>2、<strong>数据库文件</strong>可以包含<strong>任意数量</strong>的此类数据对象。存储在一个结构中的<strong>整套信息</strong>被称为<strong>记录</strong>，<strong>单独的项</strong>被称为<strong>字段</strong><br>3、或许<strong>存储记录</strong>最没效率的方法是用<code>fprintf()</code>。首先便是当结构的<strong>成员更多</strong>时，<code>fprintf()</code>所需要使用的<strong>转换说明</strong>也更多；其次<strong>检索</strong>时还<strong>存在问题</strong>，因为程序要知道<strong>一个字段结束</strong>和<strong>另一个字段开始</strong>的<strong>位置</strong><br>4、更好的方案是使用<code>fread()</code>和<code>fwrite()</code>函数读写<strong>结构大小</strong>的<strong>单元</strong>。回忆一下，这两个函数使用与程序相同的<strong>二进制表示法</strong>，如<code>fwrite(&amp;primer, sizeof(struct book), 1, pbooks);</code>。定位到<strong>primer 结构变量</strong>开始的位置，并把结构中的<strong>所有字节</strong>都拷贝到<strong>pbooks 所指文件</strong>中，<code>sizeof(struct book)</code>告诉函数<strong>待拷贝的一块数据的大小</strong>(即 struct book 类型的大小)，<strong>1</strong>表示<strong>一次拷贝一块数据</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXTITL</span> <span class="token expression"><span class="token number">40</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXAUTL</span> <span class="token expression"><span class="token number">40</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXBKS</span> <span class="token expression"><span class="token number">10</span> </span><span class="token comment">// 最大书籍数量</span></span>

<span class="token keyword">struct</span> <span class="token class-name">book</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>MAXTITL<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> author<span class="token punctuation">[</span>MAXAUTL<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 之前自定义的 s_gets() 函数</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">book</span> library<span class="token punctuation">[</span>MAXBKS<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义结构数组</span>
    <span class="token keyword">int</span> ct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> filecount<span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>pbooks<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">book</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 打开文件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pbooks <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"book.dat"</span><span class="token punctuation">,</span> <span class="token string">"a+b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"无法打开book.dat\n"</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 读取数据文件中已经存储的数据，存入library，并打印之前存储的数据</span>
    <span class="token function">rewind</span><span class="token punctuation">(</span>pbooks<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定位到文件开始处</span>
    <span class="token comment">// 遍历的 ct 小于数组元素个数 &amp;&amp; 读取二进制内容并写入library正常</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>ct <span class="token operator">&lt;</span> MAXBKS <span class="token operator">&amp;&amp;</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>library<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> pbooks<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ct <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"book.dat当前的内容："</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首次的提示语</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s  %s  %.2f\n"</span><span class="token punctuation">,</span> library<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span> library<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">.</span>author<span class="token punctuation">,</span> library<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ct<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// filecount 记录以前已写到结构数组第几个元素。判断目前结构数组是否有多余位置存储新数据</span>
    filecount <span class="token operator">=</span> ct<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ct <span class="token operator">==</span> MAXBKS<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"book.dat文件已满\n"</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 向library写入新数据</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"请添加新的书籍名称：(在新的一行回车停止)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 遍历的 ct 小于数组元素个数 &amp;&amp; 读取书籍名称正常 &amp;&amp; 不在新的一行回车停止程序</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>ct <span class="token operator">&lt;</span> MAXBKS <span class="token operator">&amp;&amp;</span> <span class="token function">s_gets</span><span class="token punctuation">(</span>library<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span> MAXTITL<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> library<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"现在输入作者："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">s_gets</span><span class="token punctuation">(</span>library<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">.</span>author<span class="token punctuation">,</span> MAXAUTL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"现在输入价钱(或编号)："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>library<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 清理输入行</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ct <span class="token operator">&lt;</span> MAXBKS<span class="token punctuation">)</span>
            <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入下一本书的标题："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ct<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 输出添加后的library，并写入数据文件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ct <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"这是新的书单列表："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> ct<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s  %s  %.2f\n"</span><span class="token punctuation">,</span> library<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span> library<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>author<span class="token punctuation">,</span> library<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>library<span class="token punctuation">[</span>filecount<span class="token punctuation">]</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> ct <span class="token operator">-</span> filecount<span class="token punctuation">,</span> pbooks<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"没有新书写入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>pbooks<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>示例重点</strong></p>
<blockquote>
<p>1、以<code>a+b</code>模式<strong>打开文件</strong>。<code>a+</code>模式允许程序<strong>读取文件</strong>并可以在<strong>末尾追加内容</strong>，<code>b</code>表明程序将使用<strong>二进制文件格式</strong><br>2、选择<strong>二进制模式</strong>是因为<code>fread()</code>和<code>fwrite()</code>要使用二进制文件。<code>rewind()</code>函数确保<strong>文件指针</strong>处于<strong>文件开始处</strong>，为读文件做好准备<br>3、<strong>写入新的数据</strong>时，我们本也可以用一个<strong>循环</strong>在<strong>文件末尾</strong>使用<code>fwrite()</code><strong>一次添加一个结构</strong>，但示例中使用<code>fwrite()</code><strong>一次写入一块数据</strong>。<strong>filecount</strong>表示<strong>第一个新写入的结构</strong>的下标，表达式<code>ct - filecount</code>就是<strong>新添加书籍的数量</strong><br>4、虽然<strong>结构</strong>中有些内容是<strong>文本</strong>，但<strong>value</strong>成员不是文本。如果使用<strong>文本编辑器</strong>查看<strong>book.dat</strong>，其中<strong>文本部分</strong>内容显示正常，但<strong>数值部分</strong>内容不可读，甚至可能乱码</p>
</blockquote>
</li>
</ul>
<h4 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a><strong>链式结构</strong></h4><ul>
<li><p><strong>结构</strong>有很多种用途，除了前面介绍的，还有一种是<strong>创建新的数据形式</strong></p>
<blockquote>
<p>1、计算机用户已经开发出的一些<strong>数据形式</strong>比我们提到过的<strong>数组</strong>和<strong>简单结构</strong>能更有效地<strong>解决特定问题</strong><br>2、这些形式包括<strong>队列</strong>、<strong>二叉树</strong>、<strong>堆</strong>、<strong>哈希表</strong>和<strong>图表</strong>，许多这样的形式都由<strong>链式结构</strong>组成<br>3、通常，每个结构都包含<strong>一两个数据项</strong>和<strong>一两个指向其他同类型结构</strong>的<strong>指针</strong>。这些指针把<strong>一个结构</strong>和<strong>另一个结构</strong>链接起来，并<strong>提供一种路径</strong>能遍历<strong>整个彼此链接的结构</strong></p>
</blockquote>
</li>
<li><p><strong>二叉树演示</strong></p>
<blockquote>
<p>1、下图是一个<strong>二叉树结构</strong>的示意图<br>2、考虑有<strong>10 个节点的树</strong>的情况下，他有 2<sup>10</sup>-1 个(或 1023 个)<strong>节点</strong>，可以<strong>存储 1023 个单词</strong><br>3、如果这些单词<strong>以某种规则排列</strong>，自上而下<strong>逐级查找</strong>，<strong>最多</strong>只需要<strong>移动 9 次</strong>即可找到；如果放在数组中，至多需要遍历<strong>1023 个元素</strong>才能找到</p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84.png" loading="lazy"></p>
</li>
</ul>
<h4 id="联合简介"><a href="#联合简介" class="headerlink" title="联合简介"></a><strong>联合简介</strong></h4><ul>
<li><p><strong>概述</strong></p>
<blockquote>
<p>1、<strong>联合</strong>是一种<strong>数据类型</strong>，它能在<strong>同一个内存空间</strong>中存储<strong>不同的数据类型</strong>(不是同时存储)<br>2、其典型的用法是，设计一种表以<strong>存储既无规律</strong>、<strong>事先也不知道顺序</strong>的<strong>混合类型</strong><br>3、使用<strong>联合类型</strong>的<strong>数组</strong>，其中的联合都<strong>大小相等</strong>，每个联合可以存储<strong>各种数据类型</strong></p>
</blockquote>
</li>
<li><p><strong>声明联合</strong></p>
<ul>
<li><p>创建<strong>联合</strong>和创建<strong>结构</strong>的方式相同，需要一个<strong>联合模板</strong>和一个<strong>联合变量</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 声明联合模板</span>
<span class="token keyword">union</span> hold
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> digit<span class="token punctuation">;</span>
    <span class="token keyword">double</span> bigfl<span class="token punctuation">;</span>
    <span class="token keyword">char</span> letter<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 声明联合变量</span>
<span class="token keyword">union</span> hold fit<span class="token punctuation">;</span>       <span class="token comment">// hold 类型的联合变量</span>
<span class="token keyword">union</span> hold save<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 内含10个联合变量的数组</span>
<span class="token keyword">union</span> hold <span class="token operator">*</span>pu<span class="token punctuation">;</span>       <span class="token comment">// 指向 hold 类型联合变量的指针</span></code></pre>
</li>
<li><p><strong>联合与结构的不同</strong></p>
<blockquote>
<p>1、根据<strong>如上示例</strong>声明的<strong>结构</strong>，可以存储<strong>一个 int 类型</strong>、<strong>一个 double 类型</strong>和<strong>一个 char 类型</strong>的值(三种类型都可以存储)<br>2、然而，声明的<strong>联合</strong>，只能存储<strong>一个 int 类型</strong>或<strong>一个 double 类型</strong>或<strong>一个 char 类型</strong>的值(只能存储其一)</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>初始化联合</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">union</span> hold valA<span class="token punctuation">;</span>
valA<span class="token punctuation">.</span>letter <span class="token operator">=</span> <span class="token char">'R'</span><span class="token punctuation">;</span>
<span class="token keyword">union</span> hold valB <span class="token operator">=</span> valA<span class="token punctuation">;</span>             <span class="token comment">// 用另一个联合来初始化</span>
<span class="token keyword">union</span> hold valC <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">88</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">// 初始化联合的第一个元素：digit 成员</span>
<span class="token keyword">union</span> hold valD <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span>bigfl <span class="token operator">=</span> <span class="token number">118.2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 指定初始化器</span></code></pre>

<blockquote>
<p>1、可以<strong>初始化联合</strong>，但要注意，联合<strong>只能存储一个值</strong>。<br>2、共有<strong>三种</strong>初始化的方法：把<strong>一个联合</strong>初始化为<strong>另一个同类型的联合</strong>；初始化<strong>联合的第一个元素</strong>；或者根据<strong>C99</strong>标准，使用<strong>指定初始化器</strong></p>
</blockquote>
</li>
<li><p><strong>使用联合</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 使用联合</span>
fit<span class="token punctuation">.</span>digit <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>       <span class="token comment">// 把 23 存储在 fit 中，占 2 字节</span>
fit<span class="token punctuation">.</span>bigfl <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>      <span class="token comment">// 清除 23，存储 2.0，占 8 字节</span>
fit<span class="token punctuation">.</span>letter <span class="token operator">=</span> <span class="token char">'h'</span><span class="token punctuation">;</span>     <span class="token comment">// 清除 2.0，存储 h，占 1 字节</span>

<span class="token comment">// 使用指针访问联合</span>
pu <span class="token operator">=</span> <span class="token operator">&amp;</span>fit<span class="token punctuation">;</span>            <span class="token comment">// 此处 pu 是一个指向联合的指针</span>
x <span class="token operator">=</span> pu<span class="token operator">-></span>digit<span class="token punctuation">;</span>        <span class="token comment">// 相当于 x = fit.digit</span></code></pre>

<blockquote>
<p>1、<strong>点运算符</strong>表示<strong>正在使用哪种数据类型</strong><br>2、在联合中，<strong>一次只储一个值</strong>。即使有<strong>足够的空间</strong>，也<strong>不能同时存储</strong>一个<strong>char 类型值</strong>和一个<strong>int 类型值</strong>。编写代码时要注意<strong>当前存储</strong>在联合中的<strong>数据类型</strong><br>3、和<strong>用指针访问结构</strong>一样，<strong>用指针访问联合</strong>也要用<code>-&gt;</code><strong>运算符</strong></p>
</blockquote>
</li>
<li><p><strong>联合的一种用途</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、<strong>联合</strong>的<strong>主要用途之一</strong>是，在<strong>结构</strong>中存储<strong>与其成员有从属关系的信息</strong><br>2、例如，用<strong>一个结构</strong>表示<strong>一辆汽车</strong>。如果汽车<strong>属于驾驶者</strong>，就用一个<strong>结构成员</strong>描述这个<strong>所有者</strong>；如果<strong>汽车被租赁</strong>，就用<strong>一个成员</strong>来描述其<strong>租赁公司</strong></p>
</blockquote>
</li>
<li><p><strong>示例思路</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">owner</span>    <span class="token comment">// 个人拥有者信息</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> socsecurity<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">leasecompany</span>   <span class="token comment">// 租赁公司信息</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> headquarters<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">union</span> data    <span class="token comment">// 创建联合</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">owner</span> owncar<span class="token punctuation">;</span>            <span class="token comment">// 创建成员，为 owner 类型结构变量</span>
    <span class="token keyword">struct</span> <span class="token class-name">leasecompany</span> leasecar<span class="token punctuation">;</span>   <span class="token comment">// 创建成员，为 leasecompany 类型结构变量</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">car_data</span>     <span class="token comment">// 使用结构表示一辆车的信息</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> make<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> status<span class="token punctuation">;</span>   <span class="token comment">// 人为约定私有为 0， 租赁为 1</span>
    <span class="token keyword">union</span> data onwerinfo<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>示例说明</strong></p>
<blockquote>
<p>1、假设有<strong>flits</strong>是<strong>car_data 类型</strong>的<strong>结构变量</strong><br>2、如果<code>flits.status == 0</code>(即私有)，程序将设计为使用<code>flits.ownerinfo.owncar.socsecurity</code><br>3、如果<code>flits.status == 1</code>(即租赁)，程序将设计为使用<code>flits.ownerinfo.leasecar.name</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>匿名联合</strong></p>
<ul>
<li><p><strong>匿名联合</strong>和<strong>匿名结构</strong>的工作原理相同，即<strong>匿名联合</strong>是一个结构或联合的<strong>无名联合成员</strong></p>
</li>
<li><p>例如，我们可以把上面程序的<code>car_data</code>重新定义：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">owner</span>    <span class="token comment">// 个人拥有者信息</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> socsecurity<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">leasecompany</span>   <span class="token comment">// 租赁公司信息</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> headquarters<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">car_data</span>     <span class="token comment">// 使用结构表示一辆车的信息</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> make<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> status<span class="token punctuation">;</span>   <span class="token comment">// 人为约定私有为 0， 租赁为 1</span>
    <span class="token keyword">union</span>         <span class="token comment">// 创建匿名联合</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">struct</span> <span class="token class-name">owner</span> owncar<span class="token punctuation">;</span>            <span class="token comment">// 创建成员，为 owner 类型结构变量</span>
        <span class="token keyword">struct</span> <span class="token class-name">leasecompany</span> leasecar<span class="token punctuation">;</span>   <span class="token comment">// 创建成员，为 leasecompany 类型结构变量</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>现在，像<strong>匿名结构</strong>一样，可以用<code>flits.owncar.socsecurity</code>代替原先的<code>flits.owninfo.owncar.socsecurity</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><strong>枚举类型</strong></h4><ul>
<li><p><strong>简介</strong></p>
<blockquote>
<p>1、可以用<strong>枚举类型</strong>声明<strong>符号名称</strong>来表示<strong>整型常量</strong><br>2、使用<code>enum</code><strong>关键字</strong>，可以<strong>创建一个新</strong>“<strong>类型</strong>”并指定它<strong>可具有的值</strong><br>3、实际上，<strong>enum</strong>常量是<strong>int</strong>类型，因此，只要能使用<strong>int 类型</strong>的地方就可以使用<strong>枚举类型</strong><br>4、<strong>枚举类型</strong>的<strong>目的</strong>，是<strong>提高程序的可读性</strong>，它的语法<strong>与结构的语法相同</strong></p>
</blockquote>
</li>
<li><p><strong>声明与使用枚举类型</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 声明枚举类型</span>
<span class="token keyword">enum</span> <span class="token class-name">spectrum</span> <span class="token punctuation">&#123;</span>red<span class="token punctuation">,</span> orange<span class="token punctuation">,</span> yellow<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> violet<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">// 枚举声明</span>
<span class="token keyword">enum</span> <span class="token class-name">spectrum</span> color<span class="token punctuation">;</span>    <span class="token comment">// 声明枚举变量</span>

<span class="token comment">// 使用枚举类型</span>
color <span class="token operator">=</span> blue<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">==</span> yellow<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>color <span class="token operator">=</span> red<span class="token punctuation">;</span> color <span class="token operator">&lt;=</span> violet<span class="token punctuation">;</span> color<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span></code></pre>

<blockquote>
<p>1、第一个声明创建了<strong>spectrum</strong>作为<strong>标记名</strong>，允许把<code>enum spectrum</code>作为一个<strong>类型名</strong>使用。第二个声明使<strong>color</strong>作为<strong>该类型的变量</strong><br>2、第一个声明中的<strong>花括号</strong>内的<strong>标识符</strong>枚举了<strong>spectrum 变量可能有的值</strong>。因此，<strong>color</strong>可能的值是<strong>red</strong>、<strong>orange</strong>、<strong>yellow</strong>等。这些<strong>符号常量</strong>被称为<strong>枚举符</strong><br>3、虽然<strong>枚举符</strong>是<strong>int 类型</strong>，但是<strong>枚举变量</strong>可以是<strong>任意整数类型</strong>，前提是该整数类型<strong>可以存储枚举常量</strong><br>4、例如，<strong>spectrum</strong>的<strong>枚举符</strong>范围是<strong>0 ~ 5</strong>，所以编译器可以用<code>unsigned char</code>类型来<strong>表示 color 变量</strong></p>
</blockquote>
</li>
<li><p><strong>C 与 C++的枚举兼容性</strong></p>
<blockquote>
<p>1、<strong>C</strong> 枚举的一些特性<strong>并不适用于 C++</strong><br>2、例如，C 允许<strong>枚举变量</strong>使用<code>++</code><strong>运算符</strong>，但 <strong>C++ 标准不允许</strong><br>3、所以，如果需要<strong>和 C++ 标准兼容</strong>，必须把<strong>上面例子</strong>的<strong>color</strong>声明为<strong>int 类型</strong></p>
</blockquote>
</li>
<li><p><strong>enum 常量</strong></p>
<blockquote>
<p>1、<strong>blue</strong>和<strong>red</strong>到底是什么？从<strong>技术层面</strong>看，它们是<strong>int 类型的常量</strong><br>2、例如假定有前面的枚举声明，<code>printf(&quot;red = %d, orange = %d&quot;, red, orange)</code><strong>的输出为</strong><code>red = 0, orange = 1</code><br>3、<strong>red</strong>成为一个<strong>有名称的常量</strong>，<strong>代表整数 0</strong>。类似的，其他<strong>标识符</strong>都是<strong>有名称的常量</strong>，分别代表<strong>1~5</strong><br>4、只要<strong>能使用整型常量</strong>的地方就<strong>都能使用枚举常量</strong>。例如<strong>声明数组</strong>时，可以用<strong>枚举常量</strong>表示<strong>数组的大小</strong>；在<code>switch</code><strong>语句</strong>中，可以把<strong>枚举常量</strong>作为<strong>标签</strong><br>5、默认情况下，<strong>枚举列表</strong>中的<strong>常量</strong>都被赋予<strong>0</strong>、<strong>1</strong>、<strong>2</strong>等</p>
</blockquote>
</li>
<li><p><strong>枚举常量赋值</strong></p>
<blockquote>
<p>1、<strong>枚举声明</strong>中，可以为<strong>枚举常量</strong>指定<strong>整数值</strong>。如<code>enum levels &#123;low = 100, medium = 500, high = 2000&#125;;</code><br>2、如果<strong>只给一个</strong>枚举常量赋值，没有对<strong>后面的</strong>枚举常量赋值，那么<strong>后面的常量</strong>会被赋予<strong>后续的值</strong><br>3、例如<code>enum feline&#123;cat, lynx = 10, puma, tiger&#125;;</code>，<strong>cat</strong>的值为<strong>0</strong>(默认)，<strong>lynx</strong>、<strong>puma</strong>与<strong>tiger</strong>的值分别为<strong>10</strong>、<strong>11</strong>、<strong>12</strong></p>
</blockquote>
</li>
<li><p><strong>共享名称空间</strong></p>
<blockquote>
<p>1、C 语言使用<strong>名称空间</strong>(namespace)，标识<strong>程序中的各部分</strong>，即<strong>通过名称</strong>来识别<br>2、<strong>作用域</strong>是<strong>名称空间</strong>概念的<strong>一部分</strong>：两个<strong>不同作用域</strong>的<strong>同名变量不冲突</strong>，两个<strong>相同作用域</strong>的<strong>同名变量冲突</strong><br>3、<strong>名称空间</strong>是<strong>分类别</strong>的，在<strong>特定作用域</strong>中的<strong>结构标记</strong>、<strong>联合标记</strong>、<strong>枚举标记</strong>都<strong>共享相同的名称空间</strong>，<strong>该名称空间</strong>与普通变量使用的<strong>空间不同</strong><br>4、例如<strong>在 C 中</strong>，<strong>同时声明</strong><code>struct rect &#123;double x; double y;&#125;;</code>和<code>int rect;</code><strong>不会产生冲突</strong><br>5、尽管如此，以<strong>两种不同的方式</strong>使用<strong>相同的标识符</strong>会造成混乱。另外<strong>C++ 不允许这样做</strong>，因为它将<strong>标识名</strong>和<strong>变量名</strong>放在<strong>相同的名称空间</strong>里</p>
</blockquote>
</li>
</ul>
<h4 id="typedef-简介"><a href="#typedef-简介" class="headerlink" title="typedef 简介"></a><strong>typedef 简介</strong></h4><ul>
<li><p><strong>typedef 简介</strong></p>
<blockquote>
<p>1、<code>typedef</code>工具是一个<strong>高级数据特性</strong>，利用<code>typedef</code>可以为某一类型<strong>自定义名称</strong>。这方面与<code>#define</code><strong>类似</strong>，但是两者有<strong>3 处不同</strong><br>2、与<code>#define</code>不同，<code>typedef</code>创建的<strong>符号名只受限于类型</strong>，<strong>不能用于值</strong><br>3、<code>typedef</code>由<strong>编译器</strong>解释，而不是<strong>预处理器</strong><br>4、在其受限范围内，<code>typedef</code><strong>比</strong><code>#define</code><strong>更灵活</strong></p>
</blockquote>
</li>
<li><p><strong>typedef 的使用</strong></p>
<blockquote>
<p>1、假设用<strong>BYTE</strong>表示<strong>1 字节的数组</strong>，只需像定义<strong>char 类型变量</strong>一样定义<strong>BYTE</strong>，然后在定义<strong>前面加上关键字</strong><code>typedef</code>：即<code>typedef char BYTE;</code><br>2、随后，便可以使用<strong>BYTE</strong>来<strong>定义变量</strong>，如<code>BYTE x, y[10], *z;</code><br>3、该定义的<strong>作用域</strong>取决于<code>typedef</code><strong>定义所在的位置</strong>，<code>typedef</code>中使用的名称<strong>遵循变量的命名规则</strong><br>4、通常<code>typedef</code>定义中用<strong>大写字母</strong>表示<strong>被定义的名称</strong>，以<strong>提醒用户</strong>这个类型名是一个<strong>符号缩写</strong></p>
</blockquote>
</li>
<li><p><strong>typedef 的一些用途</strong></p>
<ul>
<li><p><code>typedef</code>的<strong>一些特性</strong>与<code>#define</code>的<strong>功能重合</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> BYTE<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BYTE</span> <span class="token expression"><span class="token keyword">char</span></span></span></code></pre>
</li>
<li><p>但是<code>typedef</code>也有<code>#define</code><strong>没有的功能</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> STRING<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span> STRING<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STRING</span> <span class="token expression"><span class="token keyword">char</span> <span class="token operator">*</span></span></span></code></pre>

<blockquote>
<p>1、<strong>没有</strong><code>typedef</code>关键字的话，<strong>编译器</strong>会把<strong>STRING</strong>识别为<strong>指向 char 的指针</strong><br>2、<strong>使用</strong><code>typedef</code>，<strong>编译器</strong>将<strong>STRING</strong>解释成<strong>类型的标识符</strong>，该<strong>类型</strong>是<strong>指向 char 的指针</strong><br>3、<strong>使用</strong><code>typedef</code>，<code>STRING name, sign;</code><strong>相当于</strong><code>char *name, *sign;</code>，声明的<strong>两个变量都是指针</strong><br>4、但如果<strong>使用</strong><code>#define</code>，<code>STRING name, sign;</code><strong>会相当于</strong><code>char *name, sign;</code>，则<strong>只有 name 是指针</strong></p>
</blockquote>
</li>
<li><p>还可以把<code>typedef</code><strong>用于结构</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">complex</span><span class="token punctuation">&#123;</span>   <span class="token comment">//此处 complex 标识名可省略</span>
    <span class="token keyword">float</span> real<span class="token punctuation">;</span>
    <span class="token keyword">float</span> imag<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> CONPLEX<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">complex</span> num1<span class="token punctuation">;</span>
COMPLEX num2<span class="token punctuation">;</span></code></pre>
</li>
<li><p>此外，<code>typedef</code>更常用于<strong>给复杂的类型命名</strong>，如<code>typedef char (* FRPTC())[5] TYPENAME;</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="其他复杂的声明"><a href="#其他复杂的声明" class="headerlink" title="其他复杂的声明"></a><strong>其他复杂的声明</strong></h4><ul>
<li><p>C 允许用户<strong>自定义数据形式</strong>。虽然我们常用的是一些<strong>简单的形式</strong>，但是<strong>根据需要</strong>有时也会用到一些<strong>复杂的形式</strong></p>
</li>
<li><p><strong>复杂声明可使用的符号</strong></p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="center">表示一个指针</td>
</tr>
<tr>
<td align="center">()</td>
<td align="center">表示一个函数</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">表示一个数组</td>
</tr>
</tbody></table>
</li>
<li><p><strong>一些复杂声明的示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> board<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 声明一个指向 int 数组的数组</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">;</span>              <span class="token comment">// 声明一个指向指针的指针，被指向的指针指向 int</span>
<span class="token keyword">int</span> <span class="token operator">*</span>risks<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 声明一个内含10个元素的数组，每个元素都是一个指向 int 的指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rusk<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 声明一个指向数组的指针，该数组内含10个 int 类型的值</span>
<span class="token keyword">int</span> <span class="token operator">*</span>oof<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 声明一个3*4的二维数组，每个元素都是指向 int 的指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>uuf<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 声明一个指向3*4二维数组的指针，该数组中内含 int 类型的值</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>uof<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 声明一个内含3个元素的数组，其中每个指针都指向一个内含4个 int 类型值的数组</span></code></pre>
</li>
<li><p><strong>符号优先级</strong></p>
<blockquote>
<p>1、要看懂以上的声明，需要<strong>注意符号的优先级</strong><br>2、<strong>数组名</strong>后面的<code>[]</code>和<code>()</code>具有<strong>相同优先级</strong>，他们<strong>比</strong><code>*</code><strong>优先级更高</strong><br>3、<code>[]</code>和<code>()</code><strong>优先级相同</strong>，因此正常情况下，<strong>自左向右看</strong></p>
</blockquote>
</li>
<li><p><strong>类型声明黄金法则</strong></p>
<blockquote>
<p>详见我的另一篇博文，点击跳转：<a href="../6981023b/">类型声明黄金法则</a></p>
</blockquote>
</li>
<li><p>对于这种<strong>复杂声明</strong>，使用<code>typedef</code>的<strong>作用</strong>就<strong>逐渐明显</strong>了</p>
</li>
</ul>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><strong>函数指针</strong></h4><ul>
<li><p>通过上一节的学习可知，可以声明一个<strong>指向函数的指针</strong>。通常，<strong>函数指针</strong>用作<strong>另一个函数的参数</strong>，告诉该函数<strong>要使用哪一个函数</strong></p>
</li>
<li><p><strong>函数指针简介与声明</strong></p>
<blockquote>
<p>1、假设有一个<strong>指向 int 类型变量的指针</strong>，该指针就<strong>存储</strong>着这个<strong>int 类型变量</strong>存储在内存位置的<strong>地址</strong>。同样，<strong>函数也有地址</strong>，因为函数的<strong>机器语言实现</strong>由<strong>载入内存</strong>的代码组成，<strong>指向函数的指针</strong>中存储着<strong>函数代码的起始处地址</strong><br>2、声明一个<strong>数据指针</strong>时，必须声明指针所<strong>指向的数据类型</strong>。对于声明<strong>函数指针</strong>，必须声明指针<strong>指向的的函数类型</strong>。为此，要<strong>指明函数签名</strong>，即函数的<strong>返回类型</strong>和<strong>形参类型</strong><br>3、例如现有<strong>函数原型</strong><code>void ToUpper(char *);</code>，声明<strong>函数指针</strong>应为<code>void (*pf)(char *);</code>。注意由于<strong>运算符优先级</strong>必须要使用<strong>圆括号</strong>，否则<code>void *pf(char *);</code>意为<strong>pf 是一个返回字符指针的函数</strong></p>
</blockquote>
</li>
<li><p><strong>使用函数指针</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">ToLower</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">round</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pf <span class="token operator">=</span> ToUpper<span class="token punctuation">;</span>         <span class="token comment">// 有效，ToUpper是该类型函数的地址</span>
pf <span class="token operator">=</span> ToLower<span class="token punctuation">;</span>         <span class="token comment">// 有效，ToUpper是该类型函数的地址</span>
pf <span class="token operator">=</span> round<span class="token punctuation">;</span>           <span class="token comment">// 无效，round与指针类型不匹配</span>
pf <span class="token operator">=</span> <span class="token function">ToLower</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 无效，ToLower()不是地址</span>

pf <span class="token operator">=</span> ToUpper<span class="token punctuation">;</span>
<span class="token keyword">char</span> mis<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Nina Metier"</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span>mis<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 语法1</span>
<span class="token function">pf</span><span class="token punctuation">(</span>mis<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 语法2</span></code></pre>

<blockquote>
<p>1、声明了<strong>函数指针</strong>后，可以把<strong>类型匹配</strong>的<strong>函数地址</strong>赋给它。在这种上下文中，<strong>函数名</strong>可以用作表示<strong>函数的地址</strong><br>2、既然可以<strong>用数据指针访问数据</strong>，就可以<strong>用函数指针访问函数</strong>。只是有两种<strong>逻辑上不一致</strong>的语法能这样做<br>3、<strong>语法 1</strong>中，由于<strong>pf 指向</strong><code>ToUpper</code><strong>函数</strong>，那么<code>*pf</code>就<strong>相当于</strong><code>ToUpper</code><strong>函数</strong>。所以<code>(*pf)(mis)</code>与<code>ToUpper(mis)</code>等效<br>4、<strong>语法 2</strong>中，由于<strong>函数名</strong>是<strong>指针</strong>，那么<strong>指针和函数名</strong>可以<strong>互换使用</strong>(从 pf 的赋值表达式就能看出 ToUpper 和 pf 是等价的)。因此<code>pf(mis)</code>和<code>ToUpper(mis)</code>等效</p>
</blockquote>
</li>
<li><p><strong>函数指针作为参数</strong></p>
<blockquote>
<p>1、作为<strong>函数的参数</strong>是<strong>数值指针</strong>最常见的用法之一，<strong>函数指针</strong>亦如此。考虑以下<strong>函数原型</strong>：<code>void show(void (*fp)(char *), char *str);</code><br>2、它声明了<strong>两个形参</strong>，<strong>fp</strong>和<strong>str</strong>。<strong>fp</strong>是一个<strong>函数指针</strong>，<strong>str</strong>是一个<strong>数据指针</strong>。更具体地说，<strong>fp</strong>指向的函数<strong>接受</strong><code>char *</code><strong>类型</strong>，<strong>返回类型为 void</strong>；<strong>str</strong>指向一个<strong>char 类型的值</strong><br>3、可以这样<strong>调用函数</strong>：<code>show(ToUpper, mis);</code>。在函数内仍可以通过<strong>函数指针 fp</strong>来<strong>调用函数</strong>：<code>(*fp)(mis);</code></p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a><strong>位操作</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：二进制数、位、字节；二进制整数；有符号整数；二进制浮点数；其他进制数；八进制；十六进制；进制赋值；C 按位运算符；按位逻辑运算符；移位运算符；常用用法；掩码；打开位；关闭位；切换位；检查位的值；乘除次幂；位字段；简介与声明；位字段的使用；位字段越界问题；位字段示例；对齐特性；对齐特性介绍；<code>_Alignof</code>运算符；<code>_Alignas</code>说明符；使用示例</p>
</blockquote>
</div>

<h4 id="二进制数、位、字节"><a href="#二进制数、位、字节" class="headerlink" title="二进制数、位、字节"></a><strong>二进制数、位、字节</strong></h4><ul>
<li><p><strong>二进制整数</strong></p>
<blockquote>
<p>1、通常，<strong>1 字节</strong>(1 byte)包含<strong>8 位</strong>(8 bits)。C 语言用<strong>字节</strong>表示<strong>存储系统字符集</strong>所需的大小，所以 C 字节可能是<strong>8 位</strong>、<strong>9 位</strong>、<strong>16 位</strong>或其他值<br>2、不过，描述<strong>存储器芯片</strong>和<strong>数据传输率</strong>中所用的字节指的是<strong>8 位字节</strong>。简化起见，我们假定<strong>1 字节</strong>是<strong>8 位</strong>(计算机界常用<strong>八位组</strong>这个术语特指<strong>8 位字节</strong>)<br>3、可以<strong>从左往右</strong>给这 8 位分别编号<strong>7~0</strong>。在一字节中，<strong>编号是 7</strong>的位称为<strong>高阶位</strong>，<strong>编号是 0</strong>的位称为<strong>低阶位</strong>，每一位的<strong>编号</strong>对应<strong>2 的相应指数</strong><br>4、<strong>8 位字节</strong>能表示的最大的数是<strong>11111111</strong>，即<strong>255</strong>；能表示的最小的数是<strong>00000000</strong>，即<strong>0</strong><br>5、因此<strong>一字节</strong>可存储<strong>0~255 范围内</strong>共<strong>256 种值</strong>，程序可以用<strong>1 字节</strong>存储<strong>自-128 至 127</strong>同样<strong>256 种值</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0.png" loading="lazy"></p>
</li>
<li><p><strong>有符号整数</strong></p>
<ul>
<li><p><strong>符号量表示法</strong></p>
<blockquote>
<p>1、如何表示<strong>有符号整数</strong>取决于<strong>硬件</strong>，而不是 C 语言<br>2、也许<strong>表示有符号数</strong>最简单的办法是<strong>用 1 位</strong>(如高阶位)<strong>存储符号</strong>，<strong>剩下 7 位</strong>表示<strong>数字本身</strong>。用这种<strong>符号量表示法</strong>，表示的<strong>范围为-127~127</strong><br>3、这种方法的缺点是有<strong>两个 0</strong>，即 +0 和 -0，很容易混淆，而且用<strong>两个位组合</strong>表示<strong>一个数字</strong>有些浪费</p>
</blockquote>
</li>
<li><p><strong>二进制补码</strong></p>
<blockquote>
<p>1、<strong>二进制补码</strong>避免了这个问题，是当今<strong>最常用的系统</strong><br>2、<strong>二进制补码</strong>用 1 字节中的<strong>后 7 位</strong>表示<strong>0~127</strong>，通常高阶位<strong>设置为 0</strong>，表明<strong>值为正</strong>。如果<strong>高阶位是 1</strong>，则表明<strong>值为负</strong>，然后从一个<strong>9 位组合</strong>的<strong>100000000</strong>(即二进制的 256)<strong>减去</strong>一个<strong>负数的位组合</strong>，结果是<strong>该负值的量</strong><br>3、假设一个<strong>负值的位组合</strong>是<strong>10000000</strong>。作为一个<strong>无符号整数</strong>，该组合<strong>表示 128</strong>；作为一个<strong>有符号整数</strong>，该组合表示的<strong>值为负</strong>(高阶位是 1)，值为<strong>100000000 - 10000000</strong>，<strong>该数位-128</strong>。类似的，<strong>10000001</strong>则<strong>表示-127</strong>，<strong>11111111</strong>则<strong>表示-1</strong>。这种方法可以<strong>表示-128~127 范围内</strong>的数<br>4、要得到一个<strong>二进制补码数</strong>的<strong>相反数</strong>，最简单的方法是<strong>反转每一位然后+1</strong>。如<strong>1 是 00000001</strong>，则<strong>表示-1</strong>应为<strong>11111110+1</strong>，即<strong>11111111</strong></p>
</blockquote>
</li>
<li><p><strong>二进制反码</strong></p>
<blockquote>
<p>1、<strong>二进制反码</strong>通过<strong>反转位组合</strong>中的<strong>每一位</strong>形成一个<strong>负数</strong>。例如<strong>00000001 是 1</strong>，<strong>11111110 即为-1</strong><br>2、但这种方法<strong>也有一个-0</strong>，且<strong>仅能表示-127~127 之间的数</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>二进制浮点数</strong></p>
<ul>
<li><p><strong>浮点数</strong>分<strong>两部分存储</strong>：<strong>二进制小数</strong>和<strong>二进制指数</strong></p>
</li>
<li><p><strong>二进制小数</strong></p>
<blockquote>
<p>1、一个普通的<strong>浮点数 0.527</strong>，表示如下：<code>5/10 + 2/100 + 7/1000</code>。从左往右，各分母都是<strong>10 的递增次幂</strong><br>2、类似的，在<strong>二进制小数中</strong>，使用<strong>2 的递增次幂</strong>作为分母<br>3、所以<strong>二进制小数 .101</strong>表示为<code>1/2 + 0/4 + 1/8</code>，换为<strong>十进制</strong>为<code>0.5 + 0 + 0.125</code>，即<strong>0.625</strong><br>4、许多分数<strong>不能用十进制精确表示</strong>(如 1&#x2F;3)，同样的，许多分数也<strong>不能用二进制精确表示</strong>。二进制表示法只能精确表示<strong>多个 1&#x2F;2 的幂的和</strong>，像<strong>1&#x2F;3</strong>或<strong>2&#x2F;5</strong>就不能精确表示</p>
</blockquote>
</li>
<li><p><strong>浮点数表示法</strong></p>
<blockquote>
<p>1、为了在计算机中表示一个<strong>浮点数</strong>，要<strong>留出若干位</strong>(因系统而异)<strong>存储二进制分数</strong>，其他位<strong>存储指数</strong><br>2、一般而言，<strong>数字的实际值</strong>是由<strong>二进制小数</strong>乘以<strong>2 的指定次幂</strong>组成<br>3、在实际计算时，一个<strong>浮点数*4</strong>，那么<strong>二进制小数不变</strong>，而是<strong>指数*2</strong>，<strong>二进制分数不变</strong><br>4、如果一份<strong>浮点数</strong>乘以一个<strong>不是 2 的幂</strong>的数，会<strong>改变小数部分</strong>，如有必要，也会<strong>改变指数部分</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="其他进制数"><a href="#其他进制数" class="headerlink" title="其他进制数"></a><strong>其他进制数</strong></h4><ul>
<li><p>计算机界通常使用<strong>八进制</strong>计数系统和<strong>十六进制</strong>计数系统。因为<strong>8 和 16</strong>都是<strong>2 的幂</strong>，比<strong>十进制</strong>更接近计算机的<strong>二进制系统</strong></p>
</li>
<li><p><strong>八进制</strong></p>
<blockquote>
<p>1、<strong>八进制</strong>指<strong>八进制计数系统</strong>。该系统<strong>基于 8 的幂</strong>，用<strong>0~7 表示数字</strong>，<strong>满八进一</strong><br>2、了解<strong>八进制</strong>最简单的办法是，每个<strong>八进制位</strong>对应<strong>3 个二进制位</strong>。八进制转二进制时，<strong>每一位</strong>对应<strong>3 位二进制位</strong>，通过二进制<strong>对应 2 的幂</strong>凑出这一位八进制的值<br>3、例如，八进制的<strong>6</strong>转换二进制为<strong>110</strong>(4+2+0)，八进制的<strong>35</strong>转换二进制为<strong>011101</strong>(三位拆开看，0+2+1，4+0+1)。左侧的 0 可以省略，<strong>中间和右侧的 0 不能省略</strong></p>
</blockquote>
</li>
<li><p><strong>十六进制</strong></p>
<blockquote>
<p>1、<strong>十六进制</strong>指<strong>十六进制计数系统</strong>。该系统<strong>基于 16 的幂</strong>，用<strong>0~9</strong>表示正常的<strong>0~9</strong>，用<strong>A~F</strong>表示<strong>10~15</strong>，<strong>满十六进一</strong><br>2、因此十进制的<strong>17</strong>用十六进制表示为<strong>11</strong>(16+1)，十进制的<strong>33</strong>表示为<strong>21</strong>(16*2+1)，十进制的<strong>30</strong>表示为<strong>1E</strong>(16+14)<br>3、每个<strong>十六进制位</strong>对应<strong>4 个二进制位</strong>，因此<strong>两个十六进制位</strong>恰好对应一个<strong>8 位字节</strong>，此外十六进制与二进制的转换方法与八进制类似<br>4、例如十六进制<strong>E1</strong>转换二进制为<strong>11100001</strong>(四位拆开看，8+4+2+0，0+0+0+1)</p>
</blockquote>
</li>
<li><p><strong>进制赋值</strong></p>
<blockquote>
<p>1、为<strong>变量赋值</strong>时可以分别使用<code>0b</code>、<code>0o</code>、<code>0x</code>表示<strong>赋值的数</strong>分别为<strong>二进制</strong>、<strong>八进制</strong>、<strong>十六进制</strong><br>2、例如可以这样写：<code>num = 0b1001</code>、<code>num = 0o1007</code>、<code>num = 0x100F</code></p>
</blockquote>
</li>
</ul>
<h4 id="C-按位运算符"><a href="#C-按位运算符" class="headerlink" title="C 按位运算符"></a><strong>C 按位运算符</strong></h4><ul>
<li><p>C 提供<strong>按位逻辑运算符</strong>和<strong>移位运算符</strong>。在下面的例子中，为了方便理解，使用<strong>二进制计数法</strong>写出值</p>
</li>
<li><p><strong>按位逻辑运算符</strong></p>
<ul>
<li><p>4 个<strong>按位逻辑运算符</strong>都用于<strong>整型数据</strong>，包括<strong>char</strong>。之所以叫做<strong>按位</strong>运算，是因为这些操作<strong>针对每一个位进行</strong>，不影响它左右两边的位</p>
</li>
<li><p><strong>按位取反</strong>：<code>~</code></p>
<blockquote>
<p>1、<strong>一元运算符</strong><code>~</code>可以将<strong>二进制</strong>中的<strong>1 变成 0</strong>，<strong>0 变成 1</strong>。如<strong>表达式</strong><code>~(10011010)</code>的<strong>结果为 01100101</strong><br>2、假设<strong>变量 val</strong>已被赋值<strong>2</strong>。在二进制中，<strong>00000010</strong>表示<strong>2</strong>，那么<code>~val</code>的值是<strong>11111101</strong>，即<strong>253</strong><br>3、注意，<strong>只是使用</strong>运算符<strong>不会改变 val 的值</strong>，只是创建了一个可以<strong>使用或赋值</strong>的<strong>新值</strong>：<code>newval = ~val</code>。如果<strong>需要改变</strong>val 的值需要<strong>对 val 赋值</strong>：<code>val = ~val</code></p>
</blockquote>
</li>
<li><p><strong>按位与</strong>：<code>&amp;</code></p>
<blockquote>
<p>1、<strong>二元运算符</strong><code>&amp;</code>通过<strong>逐位比较</strong>两个运算对象，<strong>生成一个新值</strong><br>2、对于<strong>每个位</strong>，只有<strong>两个运算对象</strong>中<strong>相应的位都为 1</strong>时，<strong>对应结果位</strong>的<strong>值为 1</strong><br>3、如<strong>表达式</strong><code>(10010011) &amp; (00111101)</code>的<strong>结果为 00010001</strong></p>
</blockquote>
</li>
<li><p><strong>按位或</strong>：<code>|</code></p>
<blockquote>
<p>1、<strong>二元运算符</strong><code>|</code>通过<strong>逐位比较</strong>两个运算对象，<strong>生成一个新值</strong><br>2、对于<strong>每个位</strong>，只要<strong>两个运算对象</strong>中<strong>相应的位至少有一个为 1</strong>时，<strong>对应结果位</strong>的<strong>值为 1</strong><br>3、如<strong>表达式</strong><code>(10010011) | (00111101)</code>的<strong>结果为 10111111</strong></p>
</blockquote>
</li>
<li><p><strong>按位异或</strong>：<code>^</code></p>
<blockquote>
<p>1、<strong>二元运算符</strong><code>^</code>通过<strong>逐位比较</strong>两个运算对象，<strong>生成一个新值</strong><br>2、对于<strong>每个位</strong>，<strong>两个运算对象</strong>中<strong>相应的位不同</strong>时，<strong>对应结果位</strong>的<strong>值为 1</strong><br>3、如<strong>表达式</strong><code>(10010011) ^ (00111101)</code>的<strong>结果为 10101110</strong></p>
</blockquote>
</li>
<li><p>对于<code>&amp;</code>、<code>|</code>、<code>^</code><strong>运算符</strong>，同样也有<strong>复合运算符</strong><code>&amp;=</code>、<code>|=</code>、<code>^=</code></p>
</li>
</ul>
</li>
<li><p><strong>补充：按位运算的性质</strong></p>
<blockquote>
<p>1、<strong>异或</strong><code>^</code>：有<strong>结合律</strong>(<code>a ^ (b ^ c) = (a ^ b) ^ c</code>)和<strong>交换律</strong>(<code>a ^ b = b ^ a</code>)，<strong>没有分配律</strong><br>2、常用的<strong>异或结论</strong>：<code>a ^ 0 = a</code>，<code>a ^ a = 0</code>，在<strong>方程中</strong>常会用来<strong>消元或移项</strong><br>3、<strong>加法结论</strong>：<code>a + b = 2 * (a &amp; b) + (a ^ b)</code>，因为<code>a ^ b</code>是<strong>无进位加法</strong>，<code>a &amp; b</code>可以获取<strong>需要进位的位</strong>，<code>2 * (a &amp; b)</code>等同于将需要进位的位<strong>左移一位</strong>。该结论常用于证明<code>a + b &gt;= a ^ b</code>，因为在<strong>非负整数</strong>前提下<code>a &amp; b &gt;= 0</code></p>
</blockquote>
</li>
<li><p><strong>移位运算符</strong></p>
<ul>
<li><p>下面介绍 C 的<strong>移位运算符</strong>，移位运算符<strong>向左或向右移动位</strong>。示例中同样使用<strong>二进制数</strong>便于理解</p>
</li>
<li><p><strong>左移运算符</strong>：<code>&lt;&lt;</code></p>
<blockquote>
<p>1、<strong>左移运算符</strong>将其左侧的<strong>运算对象每一位的值</strong>，<strong>向左移动指定位数</strong><br>2、左侧运算对象<strong>移出左末尾端的值丢失</strong>，用<strong>0</strong>填补<strong>空缺位置</strong><br>3、如<strong>表达式</strong><code>(10001010) &lt;&lt; 2</code>的<strong>结果为 00101000</strong></p>
</blockquote>
</li>
<li><p><strong>右移运算符</strong>：<code>&gt;&gt;</code></p>
<blockquote>
<p>1、<strong>右移运算符</strong>将其左侧的<strong>运算对象每一位的值</strong>，<strong>向右移动指定位数</strong><br>2、左侧运算对象<strong>移出右末尾端的值丢失</strong>。对于<strong>无符号类型</strong>，用<strong>0</strong>填补<strong>空缺位置</strong>；对于<strong>有符号类型</strong>，结果<strong>取决于机器</strong>，空出的位置<strong>可用 0 填充</strong>，或者用<strong>符号位</strong>(即最左端的位)<strong>副本</strong>填充<br>3、如<strong>表达式</strong><code>(10001010) &gt;&gt; 2</code>的<strong>结果可能为 00100010 或 11100010</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序：数字转为二进制</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;limits.h></span> <span class="token comment">// 提供 CHAR_BIT 的定义，CHAR_BIT 表示 char 中的位数</span></span>

<span class="token comment">// 整数转换为二进制字符串</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">itobs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>ps<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> CHAR_BIT <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">)</span>
        ps<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">01</span> <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token char">'0'</span><span class="token punctuation">;</span>
    ps<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> <span class="token comment">// 添加空字符</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 4位一组显示二进制字符串</span>
<span class="token keyword">void</span> <span class="token function">show_bstr</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 不是空字符串</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 每4位添加空格</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>i <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> bin_str<span class="token punctuation">[</span>CHAR_BIT <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// CHAR_BIT * sizeof(int) 表示 int 类型的位数，+1 留出一位给空字符</span>
    <span class="token keyword">int</span> number<span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入一个数字："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>number<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">itobs</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> bin_str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d is "</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">show_bstr</span><span class="token punctuation">(</span>bin_str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、<code>itobs()</code>函数中有对<code>01 &amp; n</code>求值。<strong>01</strong>是一个<strong>八进制掩码</strong>，其只有<strong>0 号位为 1</strong>，因此<code>01 &amp; n</code>就是<strong>n 最后一位的值</strong>(值为 1 或 0)<br>2、但对于数组而言，需要的是<strong>字符</strong>而<strong>不是数值</strong>，因此该值<code>+ &#39;0&#39;</code>(或加上对应 ASCII 码值 48)即可<strong>完成转换</strong>。其结果存放在数组<strong>倒数第二个元素</strong>中(size - 1)<br>3、然后，<strong>循环执行</strong><code>i--</code>和<code>n &gt;&gt;= 1</code>，。<code>i--</code>移动到数组<strong>前一个元素</strong>，<code>n&gt;&gt;=1</code>使<strong>所有位右移 1</strong>。进入下一轮迭代，处理的是<strong>n</strong>中<strong>新的最右端的值</strong>，将其结果存储在<strong>倒数第三个元素</strong>中，以此类推</p>
</blockquote>
</li>
<li><p><strong>示例程序：切换一个值的后 n 位</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 该函数可被上个示例调用</span>
<span class="token keyword">int</span> <span class="token function">invert_end</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> bits<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> bitval <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>bits<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        mask <span class="token operator">|=</span> bitval<span class="token punctuation">;</span>
        bitval <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> num <span class="token operator">^</span> mask<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、<code>~</code><strong>运算符</strong>切换一个字节的<strong>所有位</strong>，而不是选定的<strong>少数位</strong>。但是<code>^</code>运算符可用于<strong>切换单个位</strong><br>2、<code>while</code>循环用于<strong>创建所需的掩码 mask</strong>。起初，<strong>mask</strong>所有位<strong>都为 0</strong>，第一轮循环将<strong>mask</strong>的<strong>0 号位</strong>设置为<strong>1</strong>，第二轮将<strong>1 号位</strong>设置为<strong>1</strong>，以此类推<br>3、循环<strong>bits</strong>次，<strong>mask</strong>的<strong>后 bits 位</strong>就都被<strong>设置为 1</strong>。最后，<code>num ^ mask</code>运算即得<strong>所需结果</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="运算符常用用法"><a href="#运算符常用用法" class="headerlink" title="运算符常用用法"></a><strong>运算符常用用法</strong></h4><ul>
<li><p><strong>掩码</strong></p>
<ul>
<li><p><strong>按位与运算符</strong>常用于<strong>掩码</strong>。所谓<strong>掩码</strong>指的是一些<strong>设置为开</strong>(1)<strong>或关</strong>(0)的<strong>位组合</strong></p>
</li>
<li><p><strong>掩码的认识与使用</strong></p>
<blockquote>
<p>1、假设定义符号常量<strong>MASK</strong>为<strong>2</strong>，其<strong>二进制</strong>为<strong>00000010</strong>，研究该语句：<code>flags = flags &amp; MASK;</code><br>2、使用<strong>按位与运算符</strong>任何位<strong>与 0 组合</strong>都<strong>得 0</strong>，因此对该语句只有<strong>1 号位</strong>的<strong>值不变</strong>(因为 MASK 只有 1 号位为 1)。<strong>这个过程</strong>叫做<strong>使用掩码</strong>，因为<strong>掩码中的 0 隐藏了 flags 中相应的位</strong><br>3、可以这样类比，把掩码中的<strong>0 看做不透明</strong>，<strong>1 看做透明</strong>。因此只有<strong>MASK 为 1 的位</strong>才<strong>可见</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E6%8E%A9%E7%A0%81.png" loading="lazy"></p>
</li>
</ul>
</li>
<li><p><strong>打开位</strong>(<strong>设置位</strong>)</p>
<ul>
<li><p>有时，需要<strong>打开一个值</strong>的<strong>特定位</strong>，同时保持<strong>其他位不变</strong>。这种情况可以使用<strong>按位或运算符</strong></p>
</li>
<li><p><strong>打开位的使用</strong></p>
<blockquote>
<p>1、对于<code>flags = flags | MASK;</code>语句，可以通过<strong>设置 MASK 的值</strong>来控制<strong>打开 flags 的特定位</strong><br>2、因为使用<code>|</code>运算符，任何位<strong>与 0 组合</strong>，<strong>结果都为本身</strong>；任何位<strong>与 1 组合</strong>，<strong>结果都为 1</strong><br>3、例如需要设置 flags 的<strong>1 和 3 号位为开</strong>(1)，则可以设置<strong>MASK</strong>为<strong>10</strong>(二进制为 00001010)，通过<code>flags |= MASK;</code>实现</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>关闭位</strong>(<strong>清空位</strong>)</p>
<ul>
<li><p>和<strong>打开特定的位</strong>类似，有时也需要在<strong>不影响其他位</strong>的情况下<strong>关闭指定的位</strong></p>
</li>
<li><p><strong>关闭位的使用</strong></p>
<blockquote>
<p>1、对于<code>flags = flags &amp; ~MASK;</code>语句，可以通过<strong>设置 MASK 的值</strong>来控制<strong>关闭 flags 的特定位</strong><br>2、因为使用<code>&amp;</code>运算符，任何位<strong>与 1 组合</strong>，<strong>结果都为本身</strong>；任何位<strong>与 0 组合</strong>，<strong>结果都为 0</strong><br>3、例如需要设置 flags 的<strong>1 和 3 号位为关</strong>(0)，则可以设置<strong>MASK</strong>为<strong>10</strong>(二进制为 00001010)，通过<code>flags &amp;= ~MASK;</code>实现<br>4、根据个人喜好，也可以不使用<code>~MASK</code>而<strong>直接使用 MASK</strong>，这种表示方法便<strong>以 0 标记需要关闭的位</strong>，<strong>MASK</strong>应为<strong>11110101</strong>，语句为<code>flags &amp;= MASK;</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>切换位</strong></p>
<ul>
<li><p><strong>切换位</strong>指的是<strong>打开已关闭的位</strong>，或<strong>关闭已打开的位</strong>。这种情况可以使用<strong>按位异或运算符</strong></p>
</li>
<li><p><strong>切换位的使用</strong></p>
<blockquote>
<p>1、对于<code>flags ^= MASK;</code>语句，可以通过<strong>设置 MASK 的值</strong>来<strong>切换指定位的状态</strong><br>2、因为使用<code>^</code>运算符，任何位<strong>与 1 组合</strong>，<strong>结果都会切换</strong>(1 变 0,0 变 1)；任何位<strong>与 0 组合</strong>，<strong>结果都不变</strong><br>3、例如需要<strong>切换</strong> flags 的<strong>1 和 3 号位的状态</strong>(0)，则可以设置<strong>MASK</strong>为<strong>10</strong>(二进制为 00001010)，通过<code>flags ^= MASK;</code>实现</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>检查位的值</strong></p>
<ul>
<li><p>有时需要<strong>检查确认某位的值</strong>，例如<strong>flags 的 1 号位是否为 1</strong>，<strong>不能</strong>像下面这样<strong>直接比较</strong>(即使 flags 的 1 号位为 1，其他位也会导致结果为假)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">==</span> MASK<span class="token punctuation">)</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Wow!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 不能正常工作</span></code></pre>
</li>
<li><p>必须先<strong>覆盖 flags 的其他位</strong>，<strong>只用 1 号位</strong>比较</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> flags<span class="token punctuation">,</span> MASK1<span class="token punctuation">,</span> MASK0<span class="token punctuation">;</span>
<span class="token comment">// MASK1 用于比较flags 1号位是否为 1，MASK0 用于比较1号位是否为 0</span>
flags <span class="token operator">=</span> <span class="token number">0</span>b1011<span class="token punctuation">;</span>
MASK1 <span class="token operator">=</span> <span class="token number">0</span>b0010<span class="token punctuation">;</span>
MASK0 <span class="token operator">=</span> <span class="token number">0</span>b1101<span class="token punctuation">;</span>

<span class="token comment">// 比较flags的 1号位是否为 1</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> MASK1<span class="token punctuation">)</span> <span class="token operator">==</span> MASK1<span class="token punctuation">)</span>    <span class="token comment">// &amp; 优先级比 == 低，所以需要括号</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Wow!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 比较flags的 1号位是否为 0</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">|</span> MASK0<span class="token punctuation">)</span> <span class="token operator">==</span> MASK0<span class="token punctuation">)</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Wow!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>乘除次幂</strong></p>
<ul>
<li><p><strong>移位运算符</strong>针对<strong>2 的幂</strong>提供快速有效的<strong>乘除法</strong>(类似十进制移动小数点快速乘除 10)</p>
<pre class="language-c" data-language="c"><code class="language-c">number <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span>      <span class="token comment">// number 乘以 2 的 n次幂</span>
number <span class="token operator">>></span> n<span class="token punctuation">;</span>      <span class="token comment">// number 为非负时，number 除以 2 的 n次幂</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a><strong>位字段</strong></h4><ul>
<li><p><strong>简介与声明</strong></p>
<blockquote>
<p>1、<strong>操控位</strong>的第二种方法是<strong>位字段</strong>。<strong>位字段</strong>是一个<strong>signed int</strong>或<strong>unsigned int</strong>类型变量中的<strong>一组相邻的位</strong><br>2、<strong>位字段</strong>通过一个<strong>结构声明</strong>来建立，该结构声明<strong>为每个字段提供标签</strong>，并确定该字段的<strong>宽度</strong><br>3、随后，可通过普通的<strong>结构成员运算符</strong><code>.</code><strong>单独</strong>给这些字段<strong>赋值</strong><br>4、由于<strong>每个字段恰好为 1 位</strong>，所以<strong>只能赋值 1 或 0</strong>。<strong>结构变量</strong>被存储在<strong>int 大小的内存单元</strong>中，但是在本例中<strong>只使用了其中 4 位</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 建立一个 4个 1位 的字段：</span>
<span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> autfd <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bldfc <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> undln <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> itals <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> prnt<span class="token punctuation">;</span>

<span class="token comment">// 为字段单独赋值：</span>
prnt<span class="token punctuation">.</span>itals <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
prnt<span class="token punctuation">.</span>undln <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>位字段的使用</strong></p>
<ul>
<li><p><strong>带有位字段的结构</strong>提供一种<strong>记录设置</strong>的方便途径。许多设置(如字体的粗体或斜体)就是<strong>简单的二选一</strong>，例如<strong>开或关</strong>、<strong>真或假</strong>等。如果<strong>只需要使用 1 位</strong>，就<strong>不需要使用整个变量</strong></p>
</li>
<li><p>有时，某些设置也有<strong>多个选择</strong>，因此<strong>需要多位来表示</strong>。这没问题，字段<strong>不限制 1 位大小</strong>，可以使用如下的示例。只是，要确保<strong>赋值不超过字段可容纳范围</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 创建 2个 2位 的字段和 1个 8位 的字段：</span>
<span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> code1 <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// 2位 为 2位二进制，即可表示 2^2 个数，范围为 0~3</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> code2 <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> code3 <span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> prcode<span class="token punctuation">;</span>

<span class="token comment">// 赋值：</span>
prcode<span class="token punctuation">.</span>code1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
prcode<span class="token punctuation">.</span>code2 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
prcode<span class="token punctuation">.</span>code3 <span class="token operator">=</span> <span class="token number">102</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>位字段越界问题</strong></p>
<blockquote>
<p>1、如果<strong>声明的总位数</strong>超过了<strong>一个 unsigned int 类型</strong>的大小，会用到<strong>下一个 unsigned int 类型</strong>的<strong>存储位置</strong><br>2、一个字段<strong>不允许跨越</strong>两个<strong>unsigned int</strong>之间的<strong>边界</strong>。<strong>编译器</strong>会自动<strong>移动跨界的字段</strong>，保持<strong>unsigned int</strong>的<strong>边界对齐</strong><br>3、一旦发生这种情况，<strong>第一个 unsigned int</strong>中会留下一个<strong>未命名的</strong>“<strong>洞</strong>”。可以使用<strong>未命名的字段宽度</strong>来<strong>填充</strong>未命名的洞；可以使用一个<strong>宽度为 0 的未命名字段</strong>迫使下一个字段与下一个整数<strong>对齐</strong><br>4、示例中，<code>stuff.field1</code>和<code>stuff.field2</code>之间，有一个<strong>2 位的空隙</strong>；<code>stuff.field3</code>将<strong>存储在下一个 unsigned int 中</strong><br>5、<strong>字段存储</strong>在一个 int 中的<strong>顺序取决于机器</strong>。另外，不同的机器中<strong>两个字段边界的位置也有区别</strong>。由于这些原因，位字段通常都<strong>不容易移植</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field1 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field2 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> field3 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> stuff<span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>位字段示例</strong></p>
<ul>
<li><p><strong>打印方框属性</strong></p>
<blockquote>
<p>1、在屏幕上表<strong>示一个方框的属性</strong>。为简化问题，假设方框具有如下几种属性<br>2、方框是<strong>透明或不透明</strong>的<br>3、<strong>填充色</strong>：黑、红、绿、黄、蓝、紫、青、白<br>4、边框<strong>可见或隐藏</strong><br>5、<strong>边框颜色</strong>：与填充色相同的可能<br>6、边框使用<strong>实线</strong>、<strong>点线或虚线</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span>

<span class="token comment">/* 线的样式 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SOLID</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DOTTED</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DASHED</span> <span class="token expression"><span class="token number">2</span></span></span>
<span class="token comment">/* 三原色 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BLUE</span> <span class="token expression"><span class="token number">4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GREEN</span> <span class="token expression"><span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RED</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token comment">/* 混合色 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BLACK</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">YELLOW</span> <span class="token expression"><span class="token punctuation">(</span>RED <span class="token operator">|</span> GREEN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAGENTA</span> <span class="token expression"><span class="token punctuation">(</span>RED <span class="token operator">|</span> BLUE<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CYAN</span> <span class="token expression"><span class="token punctuation">(</span>BLUE <span class="token operator">|</span> GREEN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">WHITE</span> <span class="token expression"><span class="token punctuation">(</span>RED <span class="token operator">|</span> GREEN <span class="token operator">|</span> BLUE<span class="token punctuation">)</span></span></span>

<span class="token comment">// 定义颜色的字符串</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>colors<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"black"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"magenta"</span><span class="token punctuation">,</span> <span class="token string">"cyan"</span><span class="token punctuation">,</span> <span class="token string">"white"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 定义位字段</span>
<span class="token keyword">struct</span> <span class="token class-name">box_props</span>
<span class="token punctuation">&#123;</span>
    bool opaque <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>               <span class="token comment">// 1 为透明，0 为不透明</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> fill_color <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token comment">// 左侧位表示蓝色，中间位绿色，右侧位红色，通过三原色调色表示其他色</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span>              <span class="token comment">// 填充位</span>
    bool show_border <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// 1 为可见，0 为不可见</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> border_color <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 同 fill_color</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> border_style <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 0、1、2分别表示实线、点线、虚线</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>              <span class="token comment">// 填充位</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 显示设置的函数</span>
<span class="token keyword">void</span> <span class="token function">show_setting</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">box_props</span> <span class="token operator">*</span>pb<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Box is %s.\n"</span><span class="token punctuation">,</span> pb<span class="token operator">-></span>opaque <span class="token operator">==</span> true <span class="token operator">?</span> <span class="token string">"opaque"</span> <span class="token operator">:</span> <span class="token string">"transparent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The fill color is %s.\n"</span><span class="token punctuation">,</span> colors<span class="token punctuation">[</span>pb<span class="token operator">-></span>fill_color<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Border %s.\n"</span><span class="token punctuation">,</span> pb<span class="token operator">-></span>show_border <span class="token operator">==</span> true <span class="token operator">?</span> <span class="token string">"shown"</span> <span class="token operator">:</span> <span class="token string">"not shown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The border color is %s.\n"</span><span class="token punctuation">,</span> colors<span class="token punctuation">[</span>pb<span class="token operator">-></span>border_color<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The border style is "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>pb<span class="token operator">-></span>border_style<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> SOLID<span class="token operator">:</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"solid.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> DOTTED<span class="token operator">:</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dotted.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> DASHED<span class="token operator">:</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dashed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"unknown.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/* 创建并初始化 box_props 结构 */</span>
    <span class="token keyword">struct</span> <span class="token class-name">box_props</span> box <span class="token operator">=</span> <span class="token punctuation">&#123;</span>true<span class="token punctuation">,</span> YELLOW<span class="token punctuation">,</span> true<span class="token punctuation">,</span> GREEN<span class="token punctuation">,</span> DASHED<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Original box settings:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">show_setting</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>box<span class="token punctuation">)</span><span class="token punctuation">;</span>

    box<span class="token punctuation">.</span>opaque <span class="token operator">=</span> false<span class="token punctuation">;</span>
    box<span class="token punctuation">.</span>fill_color <span class="token operator">=</span> WHITE<span class="token punctuation">;</span>
    box<span class="token punctuation">.</span>border_color <span class="token operator">=</span> MAGENTA<span class="token punctuation">;</span>
    box<span class="token punctuation">.</span>border_style <span class="token operator">=</span> SOLID<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nModified box settings:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">show_setting</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>box<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="对齐特性"><a href="#对齐特性" class="headerlink" title="对齐特性"></a><strong>对齐特性</strong></h4><ul>
<li><p><strong>对齐特性介绍</strong></p>
<blockquote>
<p>1、<strong>C11</strong>的<strong>对齐特性</strong>比<strong>用位填充字节</strong>更自然，它们还代表 C 在处理<strong>硬件相关问题</strong>上的能力。在这种上下文中，<strong>对齐</strong>指的是<strong>如何安排对象在内存中的位置</strong><br>2、例如，为了<strong>效率最大化</strong>，系统可能要把一个<strong>double 类型值</strong>存储在<strong>4 字节内存地址</strong>上，但却允许把<strong>char</strong>存储在<strong>任意地址</strong><br>3、大多数程序员都对<strong>对齐</strong>不以为然，但是，有些情况又<strong>受益于对齐控制</strong>。例如把<strong>数据</strong>从一个<strong>硬件位置</strong>转移到<strong>另一个位置</strong>，或者<strong>调用指令</strong>同时操作<strong>多个数据项</strong></p>
</blockquote>
</li>
<li><p><strong>_Alignof 运算符</strong></p>
<blockquote>
<p>1、<code>_Alignof</code><strong>运算符</strong>给出<strong>一个类型</strong>的<strong>对齐要求</strong>，在<strong>关键字</strong><code>_Alignof</code>后面的<strong>圆括号</strong>写上<strong>类型名</strong>即可：<code>size_t d_align = _Alignof(float);</code><br>2、假设<strong>d_align</strong>的<strong>值是 4</strong>，意思是<strong>float 类型对象</strong>的<strong>对齐要求是 4</strong>。也就是说，<strong>4</strong>是存储该类型值<strong>相邻地址</strong>的<strong>字节数</strong><br>3、一般而言，<strong>对齐值</strong>都应该是<strong>2 的非负整数次幂</strong>。<strong>较大的对齐值</strong>被称为<strong>stricter</strong>或<strong>stronger</strong>，<strong>较小的对齐值</strong>被称为<strong>weaker</strong></p>
</blockquote>
</li>
<li><p><strong>_Alignas 说明符</strong></p>
<blockquote>
<p>1、<code>_Alignas</code><strong>说明符</strong>指定<strong>一个变量</strong>或<strong>一个类型</strong>的<strong>对齐值</strong>。但是，<strong>不应该要求该值小于基本对齐值</strong><br>2、例如，如果<strong>float 类型</strong>的<strong>基本对齐值是 4</strong>，就<strong>不该请求其对齐值</strong>为<strong>1 或 2</strong><br>3、该<strong>说明符</strong>用作<strong>声明的一部分</strong>，说明符后面的<strong>圆括号</strong>内包含<strong>对齐值的类型</strong>：<code>_Alignas(double) char c1;</code>、<code>_Alignas(8) char c2;</code>、<code>char _Alignas(double) c_arr[sizeof(double)];</code><br>4、注意，<strong>Clang 3.2 版本</strong>要求<code>_Alignas(type)</code>说明符<strong>在类型说明符后面</strong>，如上<strong>第三个示例</strong>。但后来<strong>Clang 3.3 版本</strong>也支持了<strong>前两种在后的顺序</strong>，<strong>GCC 4.7.3 版本</strong>也能识别<strong>这两种顺序</strong></p>
</blockquote>
</li>
<li><p><strong>使用示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> dx<span class="token punctuation">;</span>
    <span class="token keyword">char</span> ca<span class="token punctuation">;</span>
    <span class="token keyword">char</span> cx<span class="token punctuation">;</span>
    <span class="token keyword">double</span> dz<span class="token punctuation">;</span>
    <span class="token keyword">char</span> cb<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token keyword">_Alignas</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> cz<span class="token punctuation">;</span> <span class="token comment">// 设置变量 cz 的对齐值为double类型的对齐值</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"char alignment:   %zd\n"</span><span class="token punctuation">,</span> <span class="token keyword">_Alignof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 利用_Alignof()获取char类型对齐值</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"double alignment: %zd\n"</span><span class="token punctuation">,</span> <span class="token keyword">_Alignof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 利用_Alignof()获取double类型对齐值</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cz alignment:     %zd\n"</span><span class="token punctuation">,</span> <span class="token keyword">_Alignof</span><span class="token punctuation">(</span>cz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 利用_Alignof()获取cz类型对齐值</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;dx: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;ca: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;cx: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;dz: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;cb: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;cz: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">char alignment:   1
double alignment: 8
cz alignment:     8
&amp;dx: 000000000061FE18
&amp;ca: 000000000061FE17
&amp;cx: 000000000061FE16
&amp;dz: 000000000061FE08
&amp;cb: 000000000061FE07
&amp;cz: 000000000061FE00</code></pre></li>
</ul>
<hr>
<h3 id="C-预处理器和-C-库"><a href="#C-预处理器和-C-库" class="headerlink" title="C 预处理器和 C 库"></a><strong>C 预处理器和 C 库</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：翻译程序的第一步；明示常量：<code>#define</code>；明示常量简介；记号；重定义常量；在<code>#define</code>中使用参数；用宏参数创建字符串：<code>#</code>运算符；预处理器粘合剂：<code>##</code>运算符；变参宏：<code>...</code>和<code>__VA_ARGS__</code>；文件包含：<code>#include</code>；使用头文件；头文件常用形式；头文件的使用价值；其他指令；<code>#undef</code>指令；从 C 预处理器角度看已定义；条件编译；预定义宏；<code>#line</code>和<code>#error</code>；<code>#pragma</code>；泛型选择<code>_Generic</code>；函数说明符；内联函数<code>inline</code>；<code>_Noreturn</code>说明符；C 库；数学库<code>math.h</code>；类型变体；<code>tgmath.h</code>库；通用工具库<code>stdlib.h</code>；断言库<code>assert.h</code>；字符串库<code>string.h</code>；可变参数库<code>stdarg.h</code></p>
</blockquote>
</div>

<h4 id="翻译程序的第一步"><a href="#翻译程序的第一步" class="headerlink" title="翻译程序的第一步"></a><strong>翻译程序的第一步</strong></h4><ul>
<li><p>在<strong>预处理</strong>之前，<strong>编译器</strong>必须对该程序进行一些<strong>翻译处理</strong></p>
<blockquote>
<p>1、首先，编译器把<strong>源代码</strong>中出现的字符<strong>映射</strong>到<strong>源字符集</strong>。该过程处理<strong>多字节字符</strong>和<strong>三字符序列</strong>——<strong>字符拓展</strong>让 C 更加<strong>国际化</strong><br>2、编译器定位每个<strong>反斜杠后面跟着换行符</strong>的实例(注意此处的换行符指的是按下<code>Enter</code>在源代码中换行产生的字符，而不是符号表征<code>\n</code>)，并<strong>删除它们</strong>。也就是说，将后面示例中的<strong>多个物理行</strong>转换成<strong>一个逻辑行</strong><br>3、编译器把文本划分成<strong>预处理记号序列</strong>、<strong>空白序列</strong>和<strong>注释序列</strong>(记号是由空格、制表符或换行符分隔的项)。这里要注意的是，编译器将<strong>用空格替换每一条注释</strong><br>4、最后，程序已经准备好进入<strong>预处理阶段</strong>，<strong>预处理器</strong>查找一行中<strong>以</strong><code>#</code><strong>开始</strong>的<strong>预处理指令</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 多个物理行</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"That's wond\
      erful!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将被替换为一个逻辑行</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"That's wonderful!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 源码中的注释</span>
<span class="token keyword">int</span><span class="token comment">/*这是一条注释*/</span>fox<span class="token punctuation">;</span>
<span class="token comment">// 将被替换为空格</span>
<span class="token keyword">int</span> fox<span class="token punctuation">;</span></code></pre></li>
</ul>
<h4 id="明示常量：-define"><a href="#明示常量：-define" class="headerlink" title="明示常量：#define"></a><strong>明示常量：#define</strong></h4><ul>
<li><p><code>#define</code><strong>预处理器指令</strong>和其他预处理器指令一样，以<code>#</code>作为<strong>一行的开始</strong>。之前我们大量使用<code>#define</code>指令来定义<strong>明示常量</strong>(符号常量)，但该指令还有<strong>许多其他用途</strong></p>
</li>
<li><p><strong>明示常量简介</strong></p>
<blockquote>
<p>1、<code>#define</code><strong>指令</strong>可以出现在<strong>源文件</strong>的<strong>任何地方</strong>，其定义从<strong>指令出现处</strong>到<strong>文件末尾</strong>有效<br>2、<strong>预处理器指令</strong>从<code>#</code><strong>开始</strong>运行，到后面的<strong>第一个换行符为止</strong>。也就是说，指令的长度<strong>仅限一行</strong>(然而，预处理开始前，编译器会把多个物理行处理为一行逻辑行，所以可以使用<code>\</code>换行)<br>3、每行<code>#define</code>都由<strong>三部分组成</strong>。第一部分是<code>#define</code><strong>指令本身</strong>；第二部分是<strong>选定的缩写</strong>，也称为<strong>宏</strong>；第三部分称为<strong>替换列表</strong>或<strong>替换体</strong><br>4、有些<strong>宏</strong>代表<strong>值</strong>，这些<strong>宏</strong>被称为<strong>类对象宏</strong>，C 语言还有<strong>类函数宏</strong>，稍后讨论。<strong>宏的名称</strong>中<strong>不允许有空格</strong>，且必须<strong>遵循 C 变量命名规则</strong><br>5、一旦<strong>预处理器</strong>在程序中找到<strong>宏的实例</strong>后，就会<strong>用替换体代替该宏</strong>(也有例外)。从<strong>宏</strong>变成<strong>最终替换文本</strong>的过程称为<strong>宏展开</strong></p>
</blockquote>
</li>
<li><p><strong>简单示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TWO</span> <span class="token expression"><span class="token number">2</span></span></span>
<span class="token comment">// 反斜杠利用预处理前的翻译处理规则，把定义延续到下一行</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OW</span> <span class="token string">"Consistency is the last refuge of the unimagina\
tive. - Oscar Wilde\n"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOUR</span> <span class="token expression">TWO<span class="token operator">*</span>TWO</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PX</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"X is %d.\n"</span><span class="token expression"><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FMT</span> <span class="token string">"X is %d.\n"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> TWO<span class="token punctuation">;</span>
    <span class="token comment">// 调用类函数宏 PX</span>
    PX<span class="token punctuation">;</span>
    x <span class="token operator">=</span> FOUR<span class="token punctuation">;</span>
    <span class="token comment">// 调用 FMT 字符串</span>
    <span class="token function">printf</span><span class="token punctuation">(</span>FMT<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> OW<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 字符串内并不会调用宏，仅为正常字符</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TWO: OW\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">X is 2.
X is 4.
Consistency is the last refuge of the unimaginative. - Oscar Wilde
TWO: OW</code></pre>
</li>
<li><p><strong>记号</strong></p>
<blockquote>
<p>1、从<strong>技术角度</strong>看，可以把<strong>宏的替换体</strong>看做是<strong>记号型字符串</strong>，而不是<strong>字符型字符串</strong><br>2、C<strong>预处理器记号</strong>是宏定义的<strong>替换体</strong>中<strong>单独的词</strong>，用<strong>空白</strong>把这些<strong>词</strong>分开<br>3、例如<code>#define FOUR 2*2</code>中，该宏定义<strong>有一个记号</strong>，即<code>2*2</code>；在<code>#define SIX 2 * 3</code>中，则<strong>有三个记号</strong>，即<code>2</code>、<code>*</code>、<code>3</code><br>4、如果<strong>预处理器</strong>把该替换体解释为<strong>字符型字符串</strong>，则用<code>2 * 3</code>替换<strong>SIX</strong>，即<strong>额外的空格是替换体的一部分</strong>。如果将其解释为<strong>记号型字符串</strong>，则用<strong>3 个的记号</strong><code>2</code>、<code>*</code>、<code>3</code>(将原先空格视为各记号的分隔符)来替换<strong>SIX</strong><br>5、<strong>实际应用</strong>中，也有一些 C 编译器把<strong>宏替换体</strong>视为<strong>字符串</strong>而不是<strong>记号</strong>。只有在<strong>更复杂的情况</strong>下，二者的区别才有<strong>实际意义</strong></p>
</blockquote>
</li>
<li><p><strong>重定义常量</strong></p>
<blockquote>
<p>1、假设先<strong>把 LIMIT 定义为 20</strong>，稍后在该文件中<strong>又把它定义为 25</strong>，这个过程称为<strong>重定义常量</strong><br>2、不同的<strong>实现</strong>采用不同的<strong>重定义方案</strong>，除非<strong>新定义</strong>与<strong>旧定义</strong>相同，否则<strong>可能将其视为错误</strong>。另外一些实现<strong>允许重定义</strong>，但会<strong>给出警告</strong><br>3、<strong>ANSI</strong>标准采用<strong>第一种方案</strong>，即<strong>新旧定义完全相同</strong>才允许重定义。此处的<strong>相同</strong>指<strong>相同的记号</strong>，如<code>#define FOUR 2*2</code>与<code>#define FOUR 2 * 2</code><strong>并不相同</strong><br>4、如果需要<strong>重定义宏</strong>，可以使用<code>#undef</code><strong>指令</strong>(稍后介绍)</p>
</blockquote>
</li>
</ul>
<h4 id="在-define-中使用参数"><a href="#在-define-中使用参数" class="headerlink" title="在 #define 中使用参数"></a><strong>在 #define 中使用参数</strong></h4><ul>
<li><p><strong>简介概述</strong></p>
<blockquote>
<p>1、在<code>#define</code>中<strong>使用参数</strong>可以创建<strong>外形和作用与函数类似</strong>的<strong>类函数宏</strong><br>2、<strong>带有参数的宏</strong>看起来很像<strong>函数</strong>，因为这样的宏<strong>也使用圆括号</strong><br>3、<strong>类函数宏定义</strong>的圆括号内可以有<strong>一个或多个参数</strong>，随后这些<strong>参数</strong>出现在<strong>替换体</strong>中</p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> X <span class="token operator">*</span>X</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> z<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SQUARE(x)：     %d\n"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SQUARE(x)：     %d\n"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SQUARE(x + 2)： %d\n"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span><span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SQUARE(++x)：   %d\n"</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">x &#x3D; 5
SQUARE(x)：     25
SQUARE(x)：     4
SQUARE(x + 2)： 17
SQUARE(++x)：   42</code></pre>

<blockquote>
<p>1、前两行的结果与预期相符，但第三行的<code>SQUARE(x + 2)</code>的结果为<strong>17</strong>，你可能认为其结果是<strong>7*7 &#x3D; 49</strong>。实际原因是，<strong>预处理器不做计算</strong>、<strong>不求值</strong>，<strong>只替换字符序列</strong><br>2、因此<strong>预处理器</strong>把<strong>出现 x 的地方</strong>都<strong>替换为 x+2</strong>，即<code>SQUARE(x + 2)</code>表达式的<strong>值为 5+2*5+2 &#x3D; 17</strong>。要解决这个问题，需要将<strong>宏定义</strong>改为<code>#define SQUARE(x) (x)*(x)</code>，这样表达式的<strong>值为(5+2)*(5+2) &#x3D; 49</strong>。因此，使用<strong>足够多的括号</strong>可以确保<strong>运算和结合</strong>的<strong>正确顺序</strong><br>3、尽管如此，还是<strong>无法避免</strong>最后一种情况，<code>SQUARE(++x)</code>变成了<code>++x*++x</code>，<strong>递增了两次 x</strong>。此处运算为<strong>6*7 &#x3D; 42</strong>，有些编译器会在<strong>乘法运算之前</strong>完成<strong>第二次递增</strong>，结果可能为<strong>7*7 &#x3D; 49</strong>。但无论哪种解释，结果<strong>都不是</strong>我们想要的<strong>6*6 &#x3D; 36</strong>，因此应<strong>避免</strong>用<code>++x</code>等<strong>递增递减运算符</strong>作为<strong>宏参数</strong></p>
</blockquote>
</li>
<li><p><strong>用宏参数创建字符串：#运算符</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、有<code>#define PSQR(X) printf(&quot;the square of X is %d&quot;, ((X) * (X)));</code>的<strong>宏定义</strong><br>2、假设这样<strong>使用宏</strong>：<code>PSQR(8)</code>，输出为<code>the square of X is 64</code><br>3、此时<strong>双引号字符串</strong>内的<strong>X</strong>被视为<strong>普通文本</strong>，而不是一个<strong>可被替换的记号</strong></p>
</blockquote>
</li>
<li><p><code>#</code><strong>运算符</strong></p>
<blockquote>
<p>1、C 允许在<strong>字符串</strong>中包含<strong>宏参数</strong>。在<strong>类函数宏</strong>的<strong>替换体</strong>中，<code>#</code>作为一个<strong>预处理运算符</strong>，可以把<strong>记号</strong>转换成<strong>字符串</strong><br>2、例如如果<strong>X</strong>是一个<strong>宏形参</strong>，那么<code>#X</code>就是转换为<strong>字符串 X 的形参名</strong>。这个过程称为<strong>字符串化</strong><br>3、例如有<code>#define PSQR(X) printf(&quot;the square of &quot; #X &quot; is %d&quot;, ((X) * (X)));</code>的<strong>定义</strong><br>4、此时定义<code>y=5</code>，<code>PSQR(y);</code>的<strong>输出为</strong><code>the square of y is 25</code>；<code>PSQR(2 + 4);</code>的<strong>输出为</strong><code>the square of 2 + 4 is 36</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>预处理器粘合剂：##运算符</strong></p>
<blockquote>
<p>1、与<code>#</code>类似，<code>##</code><strong>运算符</strong>可以用于<strong>类函数宏</strong>的替换部分。而且，<code>##</code>还可用于<strong>类对象宏</strong>的替换部分<br>2、<code>##</code>把<strong>两个记号</strong>组合成<strong>一个记号</strong>。例如有<code>#define XNAME(N) x ## N</code>的定义<br>3、此时<code>XNAME(y)</code>将<strong>展开为</strong><code>xy</code>；<code>XNAME(4)</code>将<strong>展开为</strong><code>x4</code></p>
</blockquote>
</li>
<li><p><strong>变参宏：…和__VA_ARGS__</strong></p>
<blockquote>
<p>1、一些<strong>函数</strong>(如<code>printf()</code>)接受<strong>数量可变的参数</strong>。<code>stdvar.h</code><strong>头文件</strong>提供了工具(稍后介绍)，让用户自定义带<strong>可变参数</strong>的<strong>函数</strong><br>2、<strong>C99&#x2F;C11</strong>也对<strong>宏</strong>提供了这样的工具，通过把<strong>宏参数列表</strong>中<strong>最后的参数</strong>写成<code>...</code>来实现这一功能。这样，<strong>预定义宏</strong><code>__VA_ARGS__</code>可用在<strong>替换部分</strong>中，表明省略号<strong>代表什么</strong><br>3、例如有<code>#define PR(X, ...) printf(&quot;Message &quot; #X &quot;：&quot; __VA_ARGS__)</code>的<strong>定义</strong><br>4、此时<code>PR(1, &quot;hello&quot;);</code>的<strong>输出为</strong><code>Message 1： hello</code>；<code>PR(2)</code>的<strong>输出为</strong><code>Message 2：</code></p>
</blockquote>
</li>
</ul>
<h4 id="文件包含：-include"><a href="#文件包含：-include" class="headerlink" title="文件包含：#include"></a><strong>文件包含：#include</strong></h4><ul>
<li><p><strong>简介概述</strong></p>
<blockquote>
<p>1、当<strong>预处理器</strong>发现<code>#include</code>指令时，会<strong>查看</strong>后面的<strong>文件名</strong>，并把<strong>文件的内容</strong>包含到<strong>当前文件</strong>中(即替换源文件中的<code>#include</code>指令)<br>2、<code>#include</code>有<strong>两种形式</strong>：<code>#include &lt;stdio.h&gt;</code>和<code>#include &quot;mystuff.h&quot;</code>，即<strong>尖括号</strong>和<strong>双引号</strong><br>3、<strong>尖括号</strong>告诉<strong>预处理器</strong>在<strong>标准系统目录</strong>中查找文件，<strong>双引号</strong>告诉<strong>预处理器</strong>首先在<strong>当前目录</strong>中查找，后查找<strong>标准系统目录</strong><br>4、<strong>集成开发环境</strong>(<strong>IDE</strong>)也有<strong>标准路径</strong>或<strong>系统头文件的路径</strong>。许多<strong>IDE</strong>提供<strong>菜单选项</strong>，<strong>指定</strong>用<strong>尖括号</strong>时的<strong>查找路径</strong>。使用<strong>双引号</strong>时有些<strong>编译器</strong>会搜索<strong>源代码文件所在目录</strong>，有的会搜索<strong>当前工作目录</strong>，有的会搜索<strong>项目文件所在目录</strong><br>5、<strong>ANSI C</strong>不为文件提供<strong>统一的目录模型</strong>，因为不同计算机所用<strong>系统不同</strong>。一般而言，<strong>命名文件</strong>的方法<strong>因系统而异</strong>，但是<strong>尖括号</strong>和<strong>双引号</strong>的规则<strong>与系统无关</strong><br>6、C 语言习惯用<code>.h</code><strong>后缀</strong>表示<strong>头文件</strong>，这些文件<strong>包含需要放在程序顶部的信息</strong>。头文件经常包含一些<strong>预处理器指令</strong><br>7、包含一个<strong>大型头文件</strong>不一定显著增加程序大小。在大部分情况下，<strong>头文件的内容</strong>是<strong>编译器</strong>生成最终代码时<strong>所需要的信息</strong>，而<strong>不是添加到最终代码中的材料</strong></p>
</blockquote>
</li>
<li><p><strong>使用头文件</strong></p>
<ul>
<li><p>浏览任何一个<strong>标准头文件</strong>都可以了解<strong>头文件</strong>的<strong>基本信息</strong>，头文件中最常用的形式如下</p>
</li>
<li><p><strong>头文件常用形式</strong></p>
<blockquote>
<p>1、<strong>明示常量</strong>：例如<strong>头文件</strong><code>stdio.h</code>中定义的<strong>EOF</strong>、<strong>NULL</strong>和<strong>BUFSIZE</strong>(标准 I&#x2F;O 缓冲区大小)<br>2、<strong>宏函数</strong>：例如<code>getchar()</code>通常用<code>getc(stdin)</code>定义，而<code>getc()</code>经常用于定义<strong>较复杂的宏</strong>，<strong>头文件</strong><code>ctype.h</code>通常包含<strong>ctype 系列函数</strong>的<strong>宏定义</strong><br>3、<strong>函数声明</strong>：例如<strong>头文件</strong><code>string.h</code>，包含<strong>字符串系列函数</strong>的<strong>函数声明</strong><br>4、<strong>结构模板定义</strong>：<strong>标准 I&#x2F;O 函数</strong>使用<strong>FILE 结构</strong>，该结构中包含了<strong>文件和文件缓冲区</strong>相关的信息。<strong>FILE 结构</strong>在<strong>头文件</strong><code>stdio.h</code>中<br>5、<strong>类型定义</strong>：<strong>标准 I&#x2F;O 函数</strong>使用<strong>指向 FILE 的指针</strong>作为参数。通常，<strong>头文件</strong><code>stdio.h</code>用<code>#define</code>或<code>typedef</code>把<strong>FILE</strong>定义为<strong>指向结构的指针</strong>。类似的，<code>size_t</code>和<code>time_t</code>定义在头文件中</p>
</blockquote>
</li>
<li><p><strong>头文件的使用价值</strong></p>
<blockquote>
<p>1、许多程序员都在程序中<strong>使用自己开发的标准头文件</strong>。如果<strong>开发一系列相关的函数或结构</strong>，那么这种方法特别有价值<br>2、另外，还可以使用头文件<strong>声明外部变量</strong>供<strong>其他文件共享</strong>。在<strong>源代码</strong>中定义一个<strong>文件作用域</strong>的<strong>外部链接变量</strong><code>int a = 0;</code>，然后在<strong>与之关联的头文件</strong>中进行<strong>引用式声明</strong><code>extern int a;</code>，这样<strong>这行代码</strong>便会出现在<strong>包含了该头文件的其实文件</strong>中<br>3、需要包含头文件的另一种情况是，<strong>使用</strong>具有<strong>文件作用域</strong>、<strong>内部链接</strong>和<code>const</code><strong>限定符</strong>的<strong>变量或数组</strong>。<code>const</code>防止值被<strong>意外修改</strong>，内部链接<code>static</code>意味着每个<strong>包含该头文件的文件</strong>都获得<strong>一份副本</strong>。因此不需要在一个文件中进行<strong>定义式声明</strong>，在其他文件中进行<strong>引用式声明</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a><strong>其他指令</strong></h4><ul>
<li><p><strong>#undef 指令</strong></p>
<blockquote>
<p>1、<code>#undef</code>指令用于<strong>取消已定义的</strong><code>#define</code><strong>指令</strong><br>2、也就是说，假如有<code>#define LIMIT 400</code>，可以通过<code>#undef LIMIT</code><strong>移除上面的定义</strong>。现在就可以把<strong>LIMIT</strong>重新定义为一个新值<br>3、如果想使用一个名称，又不确定之前是否已经使用过，为<strong>安全起见</strong>，可以<strong>先用</strong><code>#undef</code><strong>取消定义</strong></p>
</blockquote>
</li>
<li><p><strong>从 C 预处理器角度看已定义</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIMIT</span> <span class="token expression"><span class="token number">1000</span>          </span><span class="token comment">// LIMIT是已定义的</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GOOD</span>                <span class="token comment">// GOOD是已定义的</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">A</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span>   </span><span class="token comment">// A是已定义的</span></span>
<span class="token keyword">int</span> q<span class="token punctuation">;</span>                      <span class="token comment">// q不是宏，因此是未定义的</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">GOOD                 </span><span class="token comment">// GOOD取消定义，是未定义的</span></span></code></pre>

<blockquote>
<p>1、<strong>预处理器</strong>在<strong>识别标识符</strong>时，遵循<strong>与 C 相同的规则</strong>(标识符的命名规则)<br>2、当<strong>预处理器</strong>在<strong>预处理器指令</strong>中发现一个<strong>标识符</strong>时，会将该<strong>标识符</strong>当做<strong>已定义的</strong>或<strong>未定义的</strong>。<br>3、这里的<strong>已定义</strong>表示<strong>由预处理器定义</strong>。如果<strong>标识符</strong>是同一个文件中由前面的<code>#define</code><strong>创建的一个宏名</strong>，而且没有用<code>#undef</code><strong>关闭</strong>，那么该<strong>标识符</strong>是<strong>已定义</strong>的<br>4、如果<strong>标识符不是宏</strong>，假设是一个<strong>文件作用域</strong>的<strong>C 变量</strong>，那么该标识符<strong>对预处理器而言</strong>就是<strong>未定义的</strong></p>
</blockquote>
</li>
<li><p><strong>条件编译</strong></p>
<ul>
<li><p>可以使用<strong>其他指令</strong>创建<strong>条件编译</strong>。也就是说，可以使用这些指令告诉<strong>编译器</strong>根据<strong>编译时的条件</strong>而<strong>执行或忽略</strong>信息(或代码)块</p>
</li>
<li><p><code>#ifdef</code>、<code>#else</code>、<code>#endif</code><strong>指令</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 使用语法</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">MAVIS              </span><span class="token comment">// 如果已经用 #define 定义了 MAVIS，则执行下面的指令</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"horse.h"</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STABLES</span> <span class="token expression"><span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>                     <span class="token comment">// 如果没有用 #define 定义 MAVIS，则执行下面的指令</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cow.h"</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STABLES</span> <span class="token expression"><span class="token number">15</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">// 实际使用示例</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">JUST_CHECKING</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> LIMIT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    total <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">JUST_CHECKING</span></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%d total=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、这里使用的<strong>较新的编译器和 ANSI 标准支持</strong>的<strong>缩进格式</strong>。如果使用<strong>旧的编译器</strong>，则必须<strong>左对齐</strong>所有指令或<strong>至少左对齐</strong><code>#</code>号<br>2、<code>#ifdef</code>指令说明，如果预处理器<strong>已定义</strong>了后面的<strong>标识符</strong>，则执行<code>#else</code><strong>或</strong><code>#endif</code><strong>指令之前</strong>的<strong>所有指令</strong><br>3、如果预处理器<strong>未定义</strong>后面的<strong>标识符</strong>，且有<code>#else</code>指令，则执行<code>#else</code><strong>和</strong><code>#endif</code><strong>之间</strong>的<strong>所有代码</strong></p>
</blockquote>
</li>
<li><p><code>#ifndef</code><strong>指令</strong></p>
<blockquote>
<p>1、<code>#ifndef</code><strong>指令</strong>与<code>#ifdef</code><strong>指令</strong>用法类似，也可以和<code>#else</code>、<code>#ifdef</code><strong>一起使用</strong>，但他们的<strong>逻辑相反</strong><br>2、<code>#ifndef</code>判断后面的<strong>标识符</strong>是否是<strong>未定义的</strong>，常用于<strong>定义之前未定义的常量</strong></p>
</blockquote>
</li>
<li><p><code>#if</code><strong>和</strong><code>#elif</code><strong>指令</strong></p>
<blockquote>
<p>1、<code>#if</code>指令<strong>很像</strong>C 语言的<code>if</code>，后面跟<strong>整型常量表达式</strong>，如果<strong>表达式为非零</strong>，则<strong>表达式为真</strong>。同样<code>#elif</code>也<strong>很像</strong>C 语言的<code>else if</code><br>2、<strong>较新的编译器</strong>提供另一种方法<strong>测试名称是否已定义</strong>，即用<code>#if defined (VAX)</code>代替<code>#ifdef VAX</code><br>3、这里的<code>defined</code>是一个<strong>预处理运算符</strong>，如果它的参数用<code>#defined</code><strong>定义过</strong>，则<strong>返回 1</strong>，否则<strong>返回 0</strong>。这种方法的好处是可以和<code>#elif</code>一起使用</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>预定义宏</strong></p>
<ul>
<li><p>C 规定了一些<strong>预定义宏</strong>，如下表：</p>
<table>
<thead>
<tr>
<th align="center">宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">__DATE__</td>
<td>预处理的日期(Mmm dd yyyy 形式的字符串字面量，如 Nov 23 2013)</td>
</tr>
<tr>
<td align="center">__FILE__</td>
<td>表达当前源代码文件名的字符串字面量</td>
</tr>
<tr>
<td align="center">__LINE__</td>
<td>表示当前源代码文件中行号的整型常量</td>
</tr>
<tr>
<td align="center">__STDC__</td>
<td>设置为 1 时，表明实现遵循 C 标准</td>
</tr>
<tr>
<td align="center">__STDC_HOSTED__</td>
<td>本机环境设置为 1，否则设置为 0</td>
</tr>
<tr>
<td align="center">__STDC_VERSION__</td>
<td>支持 C99 标准，设置为 199901L；支持 C11 标准，设置为 201112L</td>
</tr>
<tr>
<td align="center">__TIME__</td>
<td>翻译代码的时间，格式为 hh:mm:ss</td>
</tr>
</tbody></table>
</li>
<li><p><strong>C99</strong>提供<code>__func__</code>的<strong>预定义标识符</strong>，它展开为一个<strong>代表函数名的字符串</strong>(该函数包含该标识符)。那么，<code>__func__</code>必须具有<strong>函数作用域</strong>而不是<strong>文件作用域</strong>，因此<code>__func__</code>是<strong>预定义标识符</strong>而不是<strong>预定义宏</strong></p>
</li>
</ul>
</li>
<li><p><strong>#line 和 #error</strong></p>
<ul>
<li><p><code>#line</code>指令<strong>重置</strong><code>__LINE__</code>和<code>__FILE__</code>宏报告的<strong>行号和文件名</strong>，可以这样使用：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">line</span> <span class="token expression"><span class="token number">1000</span>            </span><span class="token comment">// 把当前行号重置为 1000</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">line</span> <span class="token expression"><span class="token number">10</span> </span><span class="token string">"cool.c"</span>     <span class="token comment">// 把当前行号重置为 10，文件名重置为 cool.c</span></span></code></pre>
</li>
<li><p><code>#error</code>指令让<strong>预处理器发出一条错误信息</strong>，该消息包含<strong>指令中的文本</strong>。如果可能的话，<strong>编译过程应该中断</strong>，可以这样使用：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">__STDC_VERSION__ <span class="token operator">!=</span> <span class="token number">201112L</span></span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token expression">Not C11</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre></li>
</ul>
</li>
<li><p><strong>#pragma</strong></p>
<blockquote>
<p>1、在现在的编译器中，可以通过<strong>命令行参数</strong>或<strong>IDE 菜单</strong>修改<strong>编译器的一些设置</strong>。<code>#pragma</code>把<strong>编译器指令</strong>放入<strong>源代码</strong>中<br>2、例如在开发<strong>C99</strong>时，<strong>标准</strong>被称为<strong>C9X</strong>，可以使用下面的<strong>编译指示</strong>让编译器支持<strong>C9X</strong>：<code>#pragma c9x on</code><br>3、一般而言，<strong>编译器</strong>都有自己的<strong>编译指示集</strong>。例如，<strong>编译指示</strong>可能用于控制分配给自动变量的<strong>内存量</strong>，或者设置错误检查的<strong>严格程度</strong>，或者<strong>启用非标准语言特性</strong>等<br>4、<strong>C99</strong>还提供<code>_Pragma</code><strong>预处理器运算符</strong>，该运算符把<strong>字符串</strong>转换成普通的<strong>编译指示</strong>。该运算符<strong>不使用</strong><code>#</code><strong>符号</strong>，所以可以把它<strong>作为宏展开的一部分</strong><br>5、例如<code>_Pragma(&quot;nonstandardtreatmenttypeB on&quot;)</code><strong>等价于</strong><code>#pragma nonstandardtreatmenttypeB on</code></p>
</blockquote>
</li>
<li><p><strong>泛型选择 _Generic</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、在程序设计中，<strong>泛型编程</strong>指那些<strong>没有特定类型</strong>，但是一旦<strong>指定一种类型</strong>，就可以<strong>转换成指定类型</strong>的代码<br>2、例如在<strong>C++<strong>模板中可以创建</strong>泛型算法</strong>，然后编译器<strong>根据指定的类型</strong>自动使用<strong>实例化代码</strong><br>3、但是 C 没有这种功能。然而<strong>C11</strong>新增了一种表达式，叫做<strong>泛型选择表达式</strong>，可根据<strong>表达式的类型</strong>选择一个值<br>4、泛型选择表达式<strong>不是预处理器指令</strong>，但是在一些<strong>泛型编程</strong>中它常作<code>#define</code><strong>宏定义</strong>的一部分</p>
</blockquote>
</li>
<li><p><code>_Generic</code></p>
<blockquote>
<p>1、这是一个<strong>泛型选择表达式</strong>的示例：<code>_Generic(x, int:0, float:1, double:2, default:3)</code><br>2、<code>_Generic</code>是<strong>C11</strong>的关键字，后面的<strong>圆括号</strong>中包含多个用<strong>逗号分隔</strong>的<strong>项</strong>。第一个项是一个<strong>表达式</strong>，后面的每个项都由<strong>一个类型</strong>、<strong>一个冒号</strong>和<strong>一个值</strong>组成<br>3、<strong>第一个项</strong>的<strong>类型</strong>匹配哪个<strong>标签</strong>，<strong>整个表达式的值</strong>就是<strong>该标签后的值</strong>。如上面例子的<strong>x</strong>为<strong>int 类型</strong>，则值为<code>int:</code><strong>后的值</strong>(即 0)，如果没有类型匹配的标签，表达式的值就是<code>default:</code><strong>后的值</strong><br>4、<strong>泛型选择语句</strong>与<code>switch</code>语句<strong>类似</strong>，只是前者用<strong>表达式的类型</strong>匹配标签，后者用<strong>表达式的值</strong>匹配标签<br>5、下面是一个把<strong>泛型选择语句</strong>与<strong>宏定义</strong>组合的例子：</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 使用 \符号 把一条逻辑行分为多条物理行 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MYTYPE</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">_Generic</span><span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">int</span><span class="token operator">:</span> </span><span class="token string">"int"</span><span class="token expression"><span class="token punctuation">,</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">float</span><span class="token operator">:</span> </span><span class="token string">"float"</span><span class="token expression"><span class="token punctuation">,</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">double</span><span class="token operator">:</span> </span><span class="token string">"double"</span><span class="token expression"><span class="token punctuation">,</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">default</span><span class="token operator">:</span> </span><span class="token string">"other"</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">)</span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="函数说明符"><a href="#函数说明符" class="headerlink" title="函数说明符"></a><strong>函数说明符</strong></h4><ul>
<li><p><strong>内联函数简介</strong></p>
<blockquote>
<p>1、通常，<strong>函数调用</strong>都有一定的<strong>开销</strong>，因为函数的<strong>调用过程</strong>包含<strong>建立调用</strong>、<strong>传递参数</strong>、<strong>跳转到函数代码返回</strong><br>2、使用<strong>宏</strong>使<strong>代码内联</strong>，可以<strong>避免</strong>这样的<strong>开销</strong>。<strong>C99</strong>还提供另一种方法：<strong>内联函数</strong><br>3、<strong>C99</strong>标准中对其的叙述是：把<strong>函数</strong>变成<strong>内联函数</strong>意味着<strong>尽可能快地调用</strong>该函数，其具体效果由实现定义。因此把函数变成<strong>内联函数</strong>，<strong>编译器</strong>可能会用<strong>内联代码</strong>替换<strong>函数调用</strong>，并执行一些<strong>其他的优化</strong>，也<strong>可能不起作用</strong></p>
</blockquote>
</li>
<li><p><strong>创建内联函数</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">eatline</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// 内联函数定义/原型</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、<strong>创建内联函数的定义</strong>有多种方法，<strong>标准规定</strong>一个具有<strong>内部链接</strong>的函数可以成为<strong>内联函数</strong>，还规定<strong>内联函数的定义</strong>与<strong>调用该函数的代码</strong>必须在<strong>同一文件</strong><br>2、因此，最简单的办法是使用<strong>函数说明符</strong><code>inline</code>和<strong>存储类别说明符</strong><code>static</code>来<strong>创建内联函数</strong><br>3、由于并<strong>未给内联函数预留单独的代码块</strong>，所以<strong>无法获得</strong>内联函数的<strong>地址</strong>(实际上可以获得，不过这样做之后，编译器会生成一个非内联函数)。另外，<strong>内联函数</strong>无法在<strong>调试器</strong>中显示<br>4、<strong>内联函数</strong>应该<strong>比较短小</strong>，较长的函数变成内联并为节约多少时间，因为<strong>执行函数体</strong>的时间比<strong>调用函数</strong>的时间长得多</p>
</blockquote>
</li>
<li><p><strong>_Noreturn 函数</strong></p>
<blockquote>
<p>1、<strong>C99</strong>新增<code>inline</code>关键字时，它是唯一的函数说明符。后来<strong>C11</strong>新增了<strong>第二个函数说明符</strong><code>_Noreturn</code><br>2、<code>_Noreturn</code>表明<strong>调用完成后函数不返回主函数</strong>。<code>exit()</code>函数是<code>_Noreturn</code>函数的<strong>一个示例</strong>，一旦调用<code>exit()</code>，它便<strong>不会再返回</strong>主调函数<br>3、<code>_Noreturn</code>的目的是告诉<strong>用户和编译器</strong>，这个特殊的函数不会把控制返回主调程序。<strong>告诉用户避免滥用</strong>该函数，<strong>通知编译器可优化</strong>这些代码</p>
</blockquote>
</li>
</ul>
<h4 id="C-库"><a href="#C-库" class="headerlink" title="C 库"></a><strong>C 库</strong></h4><ul>
<li><p>最初，并没有<strong>官方的 C 库</strong>。后来<strong>基于 UNIX 的 C 实现</strong>成为了<strong>标准</strong>，<strong>ANSI C</strong>委员会主要<strong>以这个标准为基础</strong>，开发了一个<strong>官方的标准库</strong>。在意识到 C 语言应用范围扩大后，委员会<strong>重新定义了这个库</strong>，使之可以<strong>应用于其他系统</strong></p>
</li>
<li><p><strong>数学库 math.h</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述(1 弧度 &#x3D; 180&#x2F;π &#x3D; 57.296°)</th>
</tr>
</thead>
<tbody><tr>
<td>double acos(double x)</td>
<td>返回余弦值为 x 的角度(0 ~ π 弧度)</td>
</tr>
<tr>
<td>double asin(double x)</td>
<td>返回正弦值为 x 的角度(-π&#x2F;2 ~ π&#x2F;2 弧度)</td>
</tr>
<tr>
<td>double atan(double x)</td>
<td>返回正切值为 x 的角度(-π&#x2F;2 ~ π&#x2F;2 弧度)</td>
</tr>
<tr>
<td>double atan2(double y, double x)</td>
<td>返回正切值为 y&#x2F;x 的角度(-π&#x2F;2 ~ π&#x2F;2 弧度)</td>
</tr>
<tr>
<td>double cos(double x)</td>
<td>返回 x 的余弦值，x 的单位为弧度</td>
</tr>
<tr>
<td>double sin(double x)</td>
<td>返回 x 的正弦值，x 的单位为弧度</td>
</tr>
<tr>
<td>double tan(double x)</td>
<td>返回 x 的正切值，x 的单位为弧度</td>
</tr>
<tr>
<td>double exp(double x)</td>
<td>返回 x 的指数函数的值</td>
</tr>
<tr>
<td>double log(double x)</td>
<td>返回 x 的自然对数值</td>
</tr>
<tr>
<td>double log10(double x)</td>
<td>返回 x 的以 10 为底的对数值</td>
</tr>
<tr>
<td>double pow(double x, double y)</td>
<td>返回 x 的 y 次幂</td>
</tr>
<tr>
<td>double sqrt(double x)</td>
<td>返回二次根下 x 的值</td>
</tr>
<tr>
<td>double cbrt(double x)</td>
<td>返回三次根下 x 的值</td>
</tr>
<tr>
<td>double ceil(double x)</td>
<td>返回不小于 x 的最小整数值</td>
</tr>
<tr>
<td>double fabs(double x)</td>
<td>返回 x 的绝对值</td>
</tr>
<tr>
<td>double floor(double x)</td>
<td>返回不大于 x 的最大整数值</td>
</tr>
</tbody></table>
</li>
<li><p><strong>类型变体</strong></p>
<blockquote>
<p>1、基本的<strong>浮点型数学函数</strong>接受<strong>double 类型</strong>的参数，并<strong>返回 double 类型</strong>的值。当然，也可以把<strong>float</strong>或<strong>long double</strong>参数传递给这些函数，它们也能正常工作<br>2、这样做很方便，但<strong>不是最好的处理方式</strong>。例如如果<strong>不需要双精度</strong>，<strong>float</strong>单精度<strong>速度会更快</strong>；<strong>long double 类型</strong>的值传给<strong>double</strong>可能会<strong>损失精度</strong>，值可能<strong>不是原来的值</strong><br>3、<strong>C 标准</strong>专门为<strong>float</strong>和<strong>long double</strong>提供了标准函数，即<strong>原函数名后</strong>加上<code>f</code>或<code>l</code><strong>后缀</strong>。因此<code>sqrtf()</code>是<code>sqrt()</code>的<strong>float 版本</strong>，<code>sqrtl()</code>是<code>sqrt()</code>的<strong>long double 版本</strong><br>4、可以利用<strong>C11</strong>新增的<strong>泛型选择表达式</strong>定义一个<strong>泛型宏</strong>，根据<strong>参数类型</strong>选择合适的数学函数版本，如下：</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span>

<span class="token comment">// 主体为 _Generic(X) (X)，注意分辨，_Generic部分用于选择版本(即函数名)，与后面的(X)拼接形成函数</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQRT</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">_Generic</span><span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token operator">:</span> sqrtl<span class="token punctuation">,</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">float</span><span class="token operator">:</span> sqrtf<span class="token punctuation">,</span></span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">default</span><span class="token operator">:</span> sqrt<span class="token punctuation">)</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span>
<span class="token comment">// 这样定义，在调用时只需要调用 SQRT(X) 就可以自动选择最合适的版本</span></code></pre>
</li>
<li><p><strong>tgmath.h 库</strong></p>
<blockquote>
<p>1、<strong>C99</strong>提供的<code>tgmath.h</code>头文件中定义了<strong>泛型类型宏</strong>，其效果与上面<strong>类型变体</strong>的程序示例<strong>类似</strong><br>2、<code>tgmath.h</code>创建一个<strong>泛型类型宏</strong>，与<strong>原来 double 版本</strong>的函数名<strong>同名</strong>。其会根据<strong>参数类型</strong>自动选择<strong>展开对应版本</strong><br>3、<code>complex.h</code>中声明了与<strong>复数运算</strong>相关的函数，例如<code>csqrtf()</code>、<code>csqrt()</code>、<code>csqrtl()</code>，也分别对应<strong>不同版本</strong>。如果提供这些支持，<code>tgmath.h</code>中的<code>sqrt()</code>宏<strong>也能展开</strong>为相应的<strong>复数平方根函数</strong><br>4、如果包含<code>tgmath.h</code>，要调用<code>sqrt()</code><strong>函数</strong>而不是<code>sqrt()</code><strong>宏</strong>，可以把被调用的函数名<strong>括起来</strong>：<code>(sqrt)(x)</code></p>
</blockquote>
</li>
<li><p><strong>通用工具库 stdlib.h</strong></p>
<ul>
<li><p><code>exit()</code><strong>和</strong><code>atexit()</code><strong>函数</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、在前面的章节已经使用过<code>exit()</code>函数。而且，在<code>main()</code><strong>返回系统时</strong>将自动调用<code>exit()</code><br>2、<strong>ANSI 标准</strong>还新增了一些不错的功能，注重最重要的是<strong>可以指定在执行</strong><code>exit()</code><strong>时</strong>调用的<strong>特定函数</strong><br>3、<code>atexit()</code>通过<strong>注册要在退出时调用的函数</strong>来<strong>提供这一特性</strong>，<code>atexit()</code>函数接受一个<strong>函数指针</strong>作为参数</p>
</blockquote>
</li>
<li><p><code>atexit()</code><strong>的用法</strong></p>
<blockquote>
<p>1、函数使用<strong>函数指针</strong>。要使用<code>atexit()</code><strong>函数</strong>，只需把<strong>退出时要调用的函数地址</strong>传递给<code>atexit()</code>即可(<strong>函数名</strong>作为<strong>函数参数</strong>时相当于<strong>函数地址</strong>)<br>2、<strong>传入参数</strong>后，<code>atexit()</code><strong>注册</strong>函数列表中的<strong>函数</strong>，当<strong>调用</strong><code>exit()</code>时就会<strong>执行这些函数</strong>。<strong>ANSI</strong>保证，在这个<strong>列表中至少可以放 32 个函数</strong><br>3、最后<strong>调用</strong><code>exit()</code>时，<code>exit()</code>会<strong>执行这些函数</strong>。<strong>执行顺序</strong>与<strong>列表中函数顺序相反</strong>，即<strong>最后添加的函数最先执行</strong><br>4、<code>atexit()</code>注册的函数<strong>应该不带任何参数</strong>且<strong>返回类型为 void</strong>。通常这些函数会执行一些<strong>清理任务</strong>，如<strong>更新监视程序的文件</strong>或<strong>重置环境变量</strong></p>
</blockquote>
</li>
<li><p><strong>程序示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">void</span> <span class="token function">sign_off</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Thus terminates another magnificent program from"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Seesaw Software"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">too_bad</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Seesaw Software extends its heartfelt condolences"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"to you upon the failure of your program"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token function">atexit</span><span class="token punctuation">(</span>sign_off<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注册 sign_off 函数</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Enter an integer:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"That's no integer!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">atexit</span><span class="token punctuation">(</span>too_bad<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注册 too_bad 函数</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d is %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"even"</span> <span class="token operator">:</span> <span class="token string">"odd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">Enter an integer:
212
212 is even
Thus terminates another magnificent program from
Seesaw Software</code></pre>

<pre class="language-none"><code class="language-none">Enter an integer:
a
That&#39;s no integer!
Seesaw Software extends its heartfelt condolences
to you upon the failure of your program
Thus terminates another magnificent program from
Seesaw Software</code></pre></li>
</ul>
</li>
<li><p><code>qsort()</code><strong>函数</strong></p>
<ul>
<li><p><code>qsort()</code><strong>的用法</strong></p>
<blockquote>
<p>1、对<strong>较大型的数组</strong>而言，<strong>快速排序</strong>算法是<strong>最有效的排序算法之一</strong>。<strong>快速排序</strong>算法在 C 实现的名称是<code>qsort()</code><br>2、<code>qsort()</code>函数<strong>排序数组的数据对象</strong>，其原型为<code>void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</code><br>3、<strong>第一个参数</strong>是<strong>指针</strong>，指向待排序<strong>数组的首元素</strong>(void 类型指针，可以引入任何类型数组)<br>4、<strong>第二个参数</strong>是<strong>待排序项的数量</strong>。函数原型将该值<strong>转换为 size_t 类型</strong><br>5、<strong>第三个参数</strong>是待排序数组<strong>每个元素的大小</strong>(由于第一个参数转换为 void 指针，所以函数不知道每个元素的大小，因此需要补偿该信息)<br>6、<strong>第四个参数</strong>是一个<strong>指向函数的指针</strong>，指向一个<strong>自定义的比较函数</strong>，用于<strong>确定排序的顺序</strong><br>7、<strong>自定义的比较函数</strong>应接受<strong>两个参数</strong>，分别指向<strong>待比较两项的指针</strong>。<strong>返回值</strong>为<strong>int 类型</strong>，<strong>返回正数</strong>则告知<code>qsort()</code><strong>交换</strong>，相等<strong>返回 0</strong>，<strong>返回负数</strong>则<strong>不操作</strong>(见示例程序)</p>
</blockquote>
</li>
<li><p><strong>程序示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 程序自动随机生成一组浮点数数组，并排序 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM</span> <span class="token expression"><span class="token number">40</span> </span><span class="token comment">// 数组元素数</span></span>

<span class="token comment">// 随机生成数组</span>
<span class="token keyword">void</span> <span class="token function">fillarray</span><span class="token punctuation">(</span><span class="token keyword">double</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
        ar<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 打印数组</span>
<span class="token keyword">void</span> <span class="token function">showarray</span><span class="token punctuation">(</span><span class="token keyword">double</span> ar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> index<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%9.4f "</span><span class="token punctuation">,</span> ar<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">%</span> <span class="token number">6</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span>
            <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">%</span> <span class="token number">6</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 自定义排序函数，按从小到大排序</span>
<span class="token keyword">int</span> <span class="token function">mycomp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 要使用指向对应类型(double)的指针来访问这两个值</span>
    <span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>a1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span><span class="token punctuation">)</span>p1<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>a2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span><span class="token punctuation">)</span>p2<span class="token punctuation">;</span>

    <span class="token comment">// 如果此处符号改为 > ，则从大到小排序</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>a1 <span class="token operator">&lt;</span> <span class="token operator">*</span>a2<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>a1 <span class="token operator">==</span> <span class="token operator">*</span>a2<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> vals<span class="token punctuation">[</span>NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">fillarray</span><span class="token punctuation">(</span>vals<span class="token punctuation">,</span> NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Random list:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">showarray</span><span class="token punctuation">(</span>vals<span class="token punctuation">,</span> NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>vals<span class="token punctuation">,</span> NUM<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mycomp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\nSorted list:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">showarray</span><span class="token punctuation">(</span>vals<span class="token punctuation">,</span> NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-none"><code class="language-none">Random list:
  0.0000    0.0022    0.2390    1.2191    0.3910    1.1021
  0.2027    1.3835    20.2830   0.2508    0.8880    2.2179
  25.4866   0.0236    0.9308    0.9911    0.2507    1.2802
  0.0939    0.9760    1.7217    1.2054    1.0326    3.7892
  1.9635    4.1137    0.9241    0.9971    1.5582    0.8955
  35.3798   4.0579    12.0460   0.0096    1.0109    0.8506
  1.1529    2.3614    1.5876    0.4825

Sorted list:
  0.0000    0.0022    0.0096    0.0236    0.0939    0.2027
  0.2390    0.2507    0.2508    0.3910    0.4825    0.8506
  0.8880    0.8955    0.9241    0.9308    0.9760    0.9911
  0.9971    1.0109    1.0326    1.1021    1.1529    1.2054
  1.2191    1.2802    1.3835    1.5582    1.5876    1.7217
  1.9635    2.2179    2.3614    3.7892    4.0579    4.1137
  12.0460   20.2830   25.4866   35.3798</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>断言库 assert.h</strong></p>
<ul>
<li><p><code>assert()</code><strong>宏</strong></p>
<blockquote>
<p>1、<code>assert.h</code><strong>断言库</strong>是一个<strong>辅助调试程序</strong>的小型库<br>2、<code>assert()</code><strong>宏</strong>接受一个<strong>整形表达式</strong>作为参数。如果表达式<strong>求值为假</strong>，<code>assert()</code>则在<strong>标准错误流</strong>(stderr)中<strong>写入一条错误信息</strong>，并<strong>调用</strong><code>abort()</code><strong>函数</strong>(定义在<code>stdlib.h</code>)<strong>终止程序</strong><br>3、<code>assert()</code>是为了<strong>标识</strong>出程序中<strong>某些条件为真</strong>的<strong>关键位置</strong>，如果为<strong>假</strong>则<strong>终止程序</strong>。<strong>终止程序</strong>后会显示<strong>失败的测试</strong>、<strong>包含测试的文件名和行号</strong><br>4、使用<code>assert()</code>有<strong>几个好处</strong>：它不仅能<strong>自动标识文件</strong>和出问题的<strong>行号</strong>，还能<strong>无需更改代码做到自动开启或关闭</strong><br>5、如果认为已经<strong>排除了 bug</strong>，可以把<code>#define NDEBUG</code><strong>宏</strong>写在<code>#include &lt;assert.h&gt;</code>前面，重新编译后就会<strong>禁用所有</strong><code>assert()</code>语句</p>
</blockquote>
</li>
<li><p><code>_Static_assert</code><strong>宏</strong></p>
<blockquote>
<p>1、<code>assert()</code>是在<strong>运行时进行检查</strong>。<strong>C11</strong>新增的<code>_Static_assert()</code>可以在<strong>编译时检查</strong><br>2、因此，<code>assert()</code>会导致<strong>运行中</strong>的程序<strong>终止</strong>，而<code>_Static_assert()</code>会导致程序<strong>无法通过编译</strong><br>3、<code>_Static_assert()</code>接受<strong>两个参数</strong>：第一个是<strong>整型常量表达式</strong>，第二个是<strong>一个字符串</strong><br>4、如果第一个表达式<strong>求值为假</strong>，编译器会<strong>显示字符串</strong>并且<strong>不编译程序</strong><br>5、使用示例：<code>_Static_assert(CHAR_BIT == 16, &quot;16-bit char falsely assumed&quot;)</code>(包含<code>limits.h</code>)</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>字符串库 string.h</strong></p>
<ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、不能把一个<strong>数组赋给</strong>另一个<strong>数组</strong>，所以要通过<strong>循环</strong>把数组中的<strong>每个元素赋给</strong>另一个数组<strong>相应的元素</strong><br>2、有一个<strong>例外的情况</strong>：使用<code>strcpy()</code>和<code>strncpy()</code>函数来<strong>处理字符数组</strong>。此外<code>memcpy()</code>和<code>memmove()</code>函数提供<strong>类似的方法</strong>处理<strong>任何类型的数组</strong></p>
</blockquote>
</li>
<li><p><code>memcpy()</code><strong>与</strong><code>memmove()</code></p>
<blockquote>
<p>1、两个<strong>函数的原型</strong>：<code>void *memcpy(void *restrict s1, const void *restrict s2, size_t n);</code>与<code>void memmove(void *s1, const void *s2, size_t n);</code><br>2、这<strong>两个函数</strong>都从<strong>s2</strong>指向的位置<strong>拷贝 n 字节</strong>到<strong>s1</strong>指向的位置，且<strong>都返回 s1 的值</strong><br>3、<code>memcpy()</code>的参数<strong>带关键字</strong><code>restrict</code>，即其<strong>假设两个内存区域之间没有重叠</strong>；而<code>memmove()</code>不做这样的假设，所以<strong>拷贝过程</strong>类似先把所有字节拷贝到一个<strong>临时缓存区</strong>，再拷贝到<strong>最终目的地</strong><br>4、如果使用<code>memcpy()</code>时<strong>两区域出现重叠</strong>，该行为是<strong>未定义的</strong>。这意味着函数<strong>可能正常工作</strong>，也<strong>可能失败</strong><br>5、由于函数被设计用于<strong>任何数据类型</strong>，所以使用<strong>指向 void 的指针</strong>。因此，<strong>第三个参数</strong>的<strong>字节数</strong>应指明待拷贝字节数，如<code>10 * sizeof(double)</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>可变参数库 stdarg.h</strong></p>
<ul>
<li><p>本章前面提到过<strong>变参宏</strong>，而<code>stdarg.h</code>头文件为<strong>函数</strong>提供了一个<strong>类似的功能</strong>，但用法较为复杂，<strong>必须按如下步骤进行</strong>：</p>
<blockquote>
<p>1、提供一个<strong>使用省略号</strong>的<strong>函数原型</strong><br>2、在<strong>函数定义</strong>中创建一个<code>va_list</code><strong>类型的变量</strong><br>3、用<strong>宏</strong>把该<strong>变量初始化</strong>为一个<strong>参数列表</strong><br>4、用<strong>宏访问参数列表</strong><br>5、用<strong>宏完成清理工作</strong></p>
</blockquote>
</li>
<li><p><strong>提供一个使用省略号的函数原型</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 有效</span>
<span class="token keyword">int</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 有效</span>
<span class="token keyword">char</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">char</span> c1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">char</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 无效，省略号不在最后</span>
<span class="token keyword">double</span> <span class="token function">f4</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 无效，没有形参</span>
<span class="token comment">/*---------------------------------------------------------*/</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 2表示省略号部分接受 2个额外参数</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">117</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>                  <span class="token comment">// 4表示省略号部分接受 4个额外参数</span></code></pre>

<blockquote>
<p>1、这种<strong>函数原型</strong>应该有一个<strong>形参列表</strong>，其中<strong>至少有一个形参</strong>和<strong>一个省略号</strong>(省略号应在最右侧)<br>2、<strong>最右边的形参</strong>(即省略号左边的形参)有着特殊的作用，标准用<strong>parmN</strong>这个术语来描述<strong>该形参</strong>(<code>f1()</code>中 parmN 为 n，<code>f2()</code>中 parmN 为 k)<br>3、传递给<strong>parmN 形参</strong>的<strong>实际参数</strong>是<strong>省略号部分</strong>代表的<strong>参数数量</strong>，如示例中的调用</p>
</blockquote>
</li>
<li><p><strong>创建一个 va_list 类型变量并初始化参数列表</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> lim<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    va_list ap<span class="token punctuation">;</span>         <span class="token comment">// 声明一个存储参数的对象</span>
    <span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> lim<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 把 ap 初始化为参数列表</span>
    <span class="token comment">/*
    后续代码
    */</span>
<span class="token punctuation">&#125;</span></code></pre>

<blockquote>
<p>1、声明在<code>stdarg.h</code>中的<code>va_list</code><strong>类型</strong>代表一种用于存储<strong>形参对应的形参列表</strong>中<strong>省略号部分的数据对象</strong><br>2、<strong>变参函数</strong>的<strong>定义起始部分</strong>类似上述示例，该例中<strong>lim</strong>是<strong>parmN 形参</strong>，表明<strong>变参列表</strong>中<strong>参数数量</strong><br>3、然后使用<code>va_start()</code><strong>宏</strong>，将<strong>参数列表</strong>拷贝到<code>va_list</code><strong>变量</strong>中。宏接受<strong>两个参数</strong>：<code>va_list</code><strong>变量</strong>和<strong>parmN 形参</strong>。如该例为<code>va_start(ap, lim);</code></p>
</blockquote>
</li>
<li><p><strong>访问参数列表内容与清理工作</strong></p>
<blockquote>
<p>1、访问<strong>参数列表</strong>的<strong>内容</strong>涉及到另一个<strong>宏</strong><code>va_arg()</code>。其接受<strong>两个参数</strong>：<code>va_list</code><strong>变量</strong>和<strong>一个类型名</strong><br>2、<strong>表示类型的参数</strong>指定<strong>返回的类型</strong>，注意<strong>要与传入参数类型一一对应</strong><br>3、<strong>第一次调用</strong><code>va_arg()</code>返回<strong>参数列表第 1 项</strong>，<strong>第二次调用</strong>返回<strong>第 2 项</strong>，以此类推<br>4、最后，应使用<code>val_end()</code><strong>完成清理</strong>，<strong>释放动态分配的内存</strong>，释放后将<strong>不能通过被释放的</strong><code>va_list</code><strong>变量访问列表</strong>，如有需要访问则需要<strong>重新执行</strong><code>va_start()</code><br>5、但因为<code>val_arg()</code>不提供<strong>返回之前参数</strong>的方法，所以有必要保存<code>va_list</code><strong>类型变量</strong>的<strong>副本</strong>。使用<strong>C99</strong>新增的<code>va_copy()</code>接受<strong>两个</strong><code>va_list</code><strong>变量</strong>，将<strong>第二个参数</strong>拷贝给<strong>第一个参数</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="高级数据表示"><a href="#高级数据表示" class="headerlink" title="高级数据表示"></a><strong>高级数据表示</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：研究数据表示；结构数组的局限；从数组到链表；优化指针数组；链表引入；使用链表；抽象数据类型(ADT)；建立抽象；建立接口；实现接口；使用接口；队列 ADT；定义队列 ADT；建立接口；实现接口；测试队列；用队列进行模拟；链表和数组与查找方式；链表和数组的性质对比；访问元素的方式；顺序查找；二分查找；二分查找的原理；二分查找的优势；二分查找的实现；二叉查找树；二叉树简介；二叉树 ADT；建立接口；实现接口；使用接口；树的思想</p>
</blockquote>
</div>

<h4 id="研究数据表示"><a href="#研究数据表示" class="headerlink" title="研究数据表示"></a><strong>研究数据表示</strong></h4><ul>
<li><p><strong>本章总览</strong></p>
<blockquote>
<p>1、学习计算机语言和学习音乐、木工或工程学一样，首先要学会<strong>使用工具</strong>。对目前为止，我们也一直都在<strong>学习各种编程技能</strong><br>2、然而，如果要<strong>提高到更高层次</strong>，<strong>工具是次要的</strong>，真正的挑战是<strong>设计和创建一个项目</strong><br>3、本章将<strong>重点介绍这个更高的层次</strong>，涉及的内容可能会比较难，但这些内容十分有价值<br>4、本章还会<strong>介绍一些算法</strong>，即<strong>操控数据的方法</strong>，并进一步研究<strong>设计数据类型</strong>的过程。这是一个把<strong>算法</strong>和<strong>数据表示</strong>相匹配的过程，期间会用到一些常见的<strong>数据形式</strong>，如<strong>队列</strong>、<strong>列表</strong>、<strong>二叉树</strong><br>5、本章还将介绍<strong>抽象数据类型</strong>(ADT)的概念。<strong>抽象数据类型</strong>以<strong>面向问题</strong>而不是<strong>面向语言</strong>的方式，把<strong>解决问题的方法</strong>和<strong>数据表示</strong>结合起来。理解<strong>ADT</strong>可以为学习<strong>面向对象程序设计</strong>和<strong>C++语言</strong>做好准备</p>
</blockquote>
</li>
<li><p><strong>问题引入</strong></p>
<blockquote>
<p>1、我们来处理一个<strong>数据表示的示例</strong>。假设要编写一个程序，让用户输入<strong>一年内</strong>看过的<strong>所有电影</strong>，要存储<strong>每部影片</strong>的<strong>各种信息</strong>(片名、年份、导演、主演、片长、种类等)<br>2、建议使用<strong>一个结构</strong>存储<strong>每部电影</strong>，<strong>一个数组</strong>存储<strong>一年内看过的电影</strong>。为简单起见，我们假定结构<strong>只有两个成员</strong>：<strong>片名</strong>和<strong>评级</strong><br>3、对此，我们按照这种思路编写如下程序：</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 使用一个结构数组 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSIZE</span> <span class="token expression"><span class="token number">45</span> </span><span class="token comment">// 存储片名的数组大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FMAX</span> <span class="token expression"><span class="token number">5</span>   </span><span class="token comment">// 影片的最大数量</span></span>

<span class="token comment">// 定义结构模板，标记为 film</span>
<span class="token keyword">struct</span> <span class="token class-name">film</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>TSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rating<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 之前自定义的 s_gets() 函数</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 定义结构数组</span>
    <span class="token keyword">struct</span> <span class="token class-name">film</span> movies<span class="token punctuation">[</span>FMAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span>

    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入电影名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> FMAX <span class="token operator">&amp;&amp;</span> <span class="token function">s_gets</span><span class="token punctuation">(</span>movies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span> TSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> movies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入评分&lt;0-10>："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>movies<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rating<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入下一部电影名(或换行退出)："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"没有写入数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"获取的电影表格：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"电影：%s，    评分：%d\n"</span><span class="token punctuation">,</span> movies<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span> movies<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>rating<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>结构数组的局限</strong></p>
<blockquote>
<p>1、该程序创建了一个<strong>结构数组</strong>，然后把用户输入的<strong>数据存储在数组</strong>中<br>2、这样设计程序有点问题。首先，电影名的<strong>字符数组大小</strong>和<strong>整个结构数组大小</strong>可能会不够。当然<strong>可以增加</strong>，但程序却会<strong>浪费很多空间</strong><br>3、另外，一些<strong>编译器</strong>对<strong>自动存储类别变量</strong>(如 movie)的<strong>内存数量</strong>做了<strong>默认限制</strong>，<strong>大型数组</strong>可能会<strong>超过默认设置的值</strong>。可以把数组声明为<strong>静态</strong>或<strong>外部数组</strong>，或者<strong>设置编译器</strong>使用<strong>更大的栈</strong>，但这样并<strong>不能从根本解决问题</strong><br>4、程序<strong>真正的问题</strong>是<strong>数据表示不够灵活</strong>，在<strong>运行时再确定所需内存量</strong>会更好。为此，应使用<strong>动态内存分配</strong>，这样便可以更灵活地分配大小：</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSIZE</span> <span class="token expression"><span class="token number">45</span> </span><span class="token comment">// 存储片名的数组大小</span></span>
<span class="token keyword">struct</span> <span class="token class-name">film</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>TSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rating<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span>i<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span>movies<span class="token punctuation">;</span>  <span class="token comment">// 声明指向结构的指针</span>
<span class="token comment">// ...</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入电影的数量：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
movies <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">film</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 malloc() 分配内存</span></code></pre></li>
</ul>
<h4 id="从数组到链表"><a href="#从数组到链表" class="headerlink" title="从数组到链表"></a><strong>从数组到链表</strong></h4><ul>
<li><p><strong>进一步优化</strong></p>
<blockquote>
<p>1、对于<strong>上面的例子</strong>，我们可以<strong>进一步优化</strong>。最理想的情况是，用户可以<strong>不确定的添加数据</strong>(而不是事先指定输入多少项)，也<strong>不用分配多余的空间</strong><br>2、这可以通过在<strong>输入每一项后点调用</strong><code>malloc()</code>函数分配<strong>能储存该项的空间</strong>。如果用户<strong>输入 300 部</strong>，就<strong>调用 300 次</strong><code>malloc()</code><br>3、不过，我们又制造了<strong>另一个麻烦</strong>。如果<strong>调用一次</strong><code>malloc()</code>直接分配 300 个<strong>film 结构</strong>，分配的是<strong>连续的内存块</strong>，只需要用一个<strong>单独的指向 struct 变量的指针</strong>，<strong>指向第一个结构</strong>，就能通过<strong>数组表示法</strong>访问<strong>块中的每个结构</strong>。而现在<strong>调用 300 次</strong><code>malloc()</code>,<strong>无法保证</strong>每次调用<code>malloc()</code>都能分配到<strong>连续的内存块</strong>，因此你可能需要<strong>300 个指针</strong>，<strong>每个指针</strong>指向一个<strong>单独存储的结构</strong><br>4、<strong>一种解决方法</strong>是创建一个<strong>大型的指针数组</strong>，并在<strong>分配新结构时</strong>逐个<strong>为这些指针赋值</strong>(如示例)<br>5、但我们并不打算用这种方法。虽然如果<strong>用不完 500 个指针</strong>，这种办法也<strong>节约了大量内存</strong>，因为<strong>500 个指针的数组</strong>比<strong>500 个结构的数组</strong>所占内存少得多。尽管如此，也还是会<strong>浪费一些空间</strong>，而且还是<strong>有数量上限</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 并不完美的解决方案 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSIZE</span> <span class="token expression"><span class="token number">45</span> </span><span class="token comment">// 存储片名的数组大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FMAX</span> <span class="token expression"><span class="token number">500</span> </span><span class="token comment">// 影片的最大数量</span></span>
<span class="token keyword">struct</span> <span class="token class-name">film</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>TSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rating<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span>movies<span class="token punctuation">[</span>FMAX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 定义结构指针数组</span>
<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token comment">// ...</span>
movies<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">film</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>优化指针数组</strong></p>
<blockquote>
<p>1、对于上面的问题，还有一种<strong>更好的方法</strong>。每次使用<code>malloc()</code><strong>为新结构分配空间</strong>时，<strong>也为新指针分配空间</strong><br>2、但是，这样还得需要<strong>另一个指针</strong>来跟踪<strong>新分配的指针</strong>；同样，这个<strong>用于跟踪新指针</strong>的<strong>指针</strong>本身，<strong>又需要</strong>一个指针来跟踪<br>3、因此要<strong>重新定义结构</strong>才能解决这个<strong>潜在的问题</strong>。即<strong>每个结构中</strong>，都包含<strong>指向下一个结构的指针</strong>。然后<strong>创建新结构</strong>时，可以把<strong>该结构的地址</strong>存储在<strong>上一个结构的指针</strong>中<br>4、简言之，可以<strong>这样定义结构</strong>：</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSIZE</span> <span class="token expression"><span class="token number">45</span> </span><span class="token comment">// 存储片名的数组大小</span></span>
<span class="token keyword">struct</span> <span class="token class-name">film</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>TSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rating<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">// 存储下一个结构位置的指针</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>链表引入</strong></p>
<blockquote>
<p>1、虽然<strong>结构</strong>不能含有<strong>与本身类型相同的结构</strong>，但可以含有<strong>同类型结构的指针</strong>。<strong>这种定义</strong>是<strong>定义链表</strong>的基础，<strong>链表</strong>中的<strong>每一项</strong>都包含着<strong>在何处能找到下一项</strong>的<strong>信息</strong><br>2、学习链表的代码前，先<strong>从概念上理解一个链表</strong>。假设用户输入的<strong>片名</strong>为<strong>Modern TImes</strong>，<strong>等级</strong>为<strong>10</strong><br>3、程序将为<strong>第 1 个 film 类型的结构</strong>分配空间，将<strong>字符串</strong>拷贝到<strong>title 成员</strong>，<strong>数值</strong>拷贝到<strong>rating 成员</strong>。为了表明该结构<strong>后面没有其他结构</strong>，程序要把<strong>指针变量 next</strong>设置为<strong>NULL</strong>(空指针)<br>4、当然，还需要一个<strong>单独的指针</strong>存储<strong>第一个结构的指针</strong>(<code>struct film *head;</code>)，该指针被称为<strong>头指针</strong>。<strong>头指针</strong>指向<strong>链表中的第一项</strong><br>5、现在，假设用户<strong>输入第二部电影</strong>，则程序为<strong>第 2 个 film 类型的结构</strong>分配空间，把<strong>新结构的地址</strong>存储在<strong>上一个结构</strong>(即第一个结构)的<strong>next 成员</strong>中(擦写了之前的 NULL 值)，并把<strong>第二个结构</strong>中的<strong>next 成员设置为 NULL</strong>，表明该结构目前是<strong>链表最后一个结构</strong><br>6、以此类推，通过<strong>头指针</strong>访问<strong>第一个结构</strong>，就能<strong>一个个访问 next 成员</strong>来访问<strong>下一个结构</strong>，直到<strong>最后一个结构</strong>的<strong>next 为 NULL</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%93%BE%E8%A1%A8.png" loading="lazy"></p>
</li>
<li><p><strong>使用链表</strong></p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> <span class="token comment">// 提供 malloc() 的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> <span class="token comment">// 提供 strcpy() 的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSIZE</span> <span class="token expression"><span class="token number">45</span>    </span><span class="token comment">// 存储片名的数组大小</span></span>

<span class="token comment">// 定义结构模板，标记为 film</span>
<span class="token keyword">struct</span> <span class="token class-name">film</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>TSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rating<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 指向链表中的下一个结构</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 之前定义的 s_gets() 函数</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 链表头指针(第一个结构的位置)</span>
    <span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>current<span class="token punctuation">;</span> <span class="token comment">// 上一个结构指针与当前结构指针</span>
    <span class="token keyword">char</span> input<span class="token punctuation">[</span>TSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// 临时存储电影名</span>

    <span class="token comment">// 收集并存储信息</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入第一个电影的名字："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输入input无误 且 首字符不为\0</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">s_gets</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> TSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> input<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        current <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">film</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">film</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为当前指针 current 分配一个 struct film 大小的空间用来存储结构</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                                     <span class="token comment">// 如果 current 是第一个结构</span>
            head <span class="token operator">=</span> current<span class="token punctuation">;</span>                                   <span class="token comment">// 将 head 头指针指向 current 的位置</span>
        <span class="token keyword">else</span>                                                  <span class="token comment">// 如果是后续的结构</span>
            prev<span class="token operator">-></span>next <span class="token operator">=</span> current<span class="token punctuation">;</span>                             <span class="token comment">// 上一个结构中的 next 指针指向当前 current 的位置</span>
        current<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                                 <span class="token comment">// 将当前结构的 next 成员设置为 NULL，表明是当前链表的最后一个元素</span>
        <span class="token function">strcpy</span><span class="token punctuation">(</span>current<span class="token operator">-></span>title<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 将临时存储电影名的 input 的内容复制到当前结构的 title 成员</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入你的评分&lt;1-10>："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>current<span class="token operator">-></span>rating<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入下一个电影名(或换行退出)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        prev <span class="token operator">=</span> current<span class="token punctuation">;</span> <span class="token comment">// 将表示上一个结构位置的指针 prev 指向 current</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 打印电影列表</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 头指针仍然为NULL，则没有结构</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"没有数据写入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这是你的电影列表：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    current <span class="token operator">=</span> head<span class="token punctuation">;</span>         <span class="token comment">// 让 current 指向 head 头指针</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 只要 current 不是 NULL 空指针(即不是链表最后一个元素)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"电影：%s    评分：%d\n"</span><span class="token punctuation">,</span> current<span class="token operator">-></span>title<span class="token punctuation">,</span> current<span class="token operator">-></span>rating<span class="token punctuation">)</span><span class="token punctuation">;</span>
        current <span class="token operator">=</span> current<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 让 current 指向 next 成员所指向的下一个结构的位置</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 完成任务，释放内存</span>
    current <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 让 current 指向 head 头指针</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        head <span class="token operator">=</span> current<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 提前让 head 指向下一个结构的位置</span>
        <span class="token function">free</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放 current 的内存</span>
        current <span class="token operator">=</span> head<span class="token punctuation">;</span>       <span class="token comment">// 让 current 指向提前准备好的指向下一个结构位置的 head</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>继续反思</strong></p>
<blockquote>
<p>1、程序还有<strong>些许的不足</strong>。例如程序<strong>没有检查</strong><code>malloc()</code>是否<strong>成功请求</strong>到内存，也<strong>无法删除链表中的项</strong>。不过这些不足可以弥补，例如添加代码<strong>检查</strong><code>malloc()</code><strong>返回值是否是 NULL</strong>(返回 NULL 说明未成功获得内存)。如果需要<strong>删除链表中的项</strong>，还需要额外编写更多代码<br>2、因此，这种用<strong>特定方法</strong>解决<strong>特定问题</strong>，并在<strong>需要时才添加相关功能</strong>的编程方式通常不是最好的解决方案。另一方面，通常<strong>无法预料</strong>程序要完成的<strong>所有任务</strong><br>3、如果要<strong>修改程序</strong>，首先应该<strong>强调最初的设计</strong>，并<strong>简化其他细节</strong>。上面的示例并<strong>没有遵循这个原则</strong>，它把<strong>概念模型</strong>和<strong>代码细节</strong>混在一起<br>4、例如程序的<strong>概念模型</strong>是<strong>在一个链表中添加项</strong>，但程序却<strong>把一些细节放在最明显的位置</strong>(例如<code>malloc()</code>、current-&gt;next 指针等等处理细节)，没有<strong>突出接口</strong><br>5、如果程序能<strong>以某种方式强调</strong>给链表添加项，并<strong>隐藏具体处理细节</strong>会更好。把<strong>用户接口</strong>和<strong>代码细节</strong>分开的程序，更<strong>容易理解和更新</strong>。我们下面就会学习有关内容</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型(ADT)"></a><strong>抽象数据类型(ADT)</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、在编程时，应根据<strong>编程问题</strong>匹配合适的<strong>数据类型</strong>。前例中每个<strong>链表项</strong>由<strong>一个字符串</strong>和<strong>一个 int 值</strong>构成，C 中没有直接与之匹配的基本类型，所以我们定义了一个<strong>结构</strong>来代表单独的<strong>项</strong><br>2、本质上，我们使用<strong>C 语言的功能</strong>设计了一种<strong>符合程序要求</strong>的<strong>新数据类型</strong>，只是我们的<strong>做法并不系统</strong>。现在我们将使用更系统的方法<strong>定义数据类型</strong><br>3、什么是<strong>类型</strong>？<strong>类型</strong>指两类信息：<strong>属性</strong>和<strong>操作</strong>。例如，<strong>int 类型</strong>的<strong>属性</strong>是它代表一个整数值，因此它共享整数的属性；允许对<strong>int 类型</strong>进行的<strong>算术操作</strong>有：改变类型值符号、相加、相减、相乘、相除、取模。当<strong>声明一个 int 类型变量</strong>时，就表明了<strong>只可对此变量进行这些操作</strong><br>4、假设要<strong>定义一个新的数据类型</strong>。首先，必须<strong>提供存储数据的方法</strong>，例如<strong>设计一个结构</strong>；其次，必须<strong>提供操纵数据的方法</strong><br>5、前例程序用<strong>链接的结构</strong>存储信息，通过代码实现了如何<strong>添加和显示信息</strong>，尽管如此，并<strong>未清楚表明</strong>正在创建一个<strong>新类型</strong></p>
</blockquote>
</li>
<li><p><strong>定义新类型的方法</strong></p>
<blockquote>
<p>1、<strong>计算机科学领域</strong>开发了一种<strong>定义新类型</strong>的好方法，用三个步骤完成<strong>从抽象到具体</strong>的过程：<br>2、提供<strong>类型属性和相关操作</strong>的<strong>抽象描述</strong>。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种<strong>正式的抽象描述</strong>被称为<strong>抽象数据类型</strong>(<strong>ADT</strong>)<br>3、开发一个<strong>实现 ADT</strong>的<strong>编程接口</strong>。也就是说，指明<strong>如何存储数据</strong>和<strong>执行所需操作的函数</strong>。例如 C 中，可以提供<strong>结构定义</strong>和<strong>操纵该结构的函数原型</strong>。这些<strong>作用于用户定义类型</strong>的<strong>函数</strong>相当于<strong>C 基本类型的内置运算符</strong>。需要使用该新类型的程序员可以<strong>使用这个接口</strong>进行编程<br>4、<strong>编写代码实现接口</strong>。这一步至关重要，但是使用该新类型的程序员<strong>无需了解具体的实现细节</strong></p>
</blockquote>
</li>
<li><p><strong>建立抽象</strong></p>
<ul>
<li><p><strong>分析链表类型</strong></p>
<ul>
<li><p>从根本上看，电影项目所需的是一个<strong>项链表</strong>。每一项包含<strong>电影名和评级</strong>。你所需的操作是<strong>向链表末尾添加新项</strong>和<strong>显示链表内容</strong>。我们把<strong>需要处理这些需求</strong>的<strong>抽象类型</strong>叫做<strong>链表</strong></p>
</li>
<li><p>链表具有哪些<strong>属性</strong>？链表应该<strong>能存储多个项</strong>，而且这些<strong>项以某种方式排列</strong>，这样才能描述链表的第一项、第二项或最后一项</p>
</li>
<li><p>链表应<strong>提供一些操作</strong>，如：</p>
<blockquote>
<p>1、初始化一个空链表<br>2、在链表末尾添加一个新项<br>3、确定链表是否为空<br>4、确定链表是否已满<br>5、确定链表中的项数<br>6、访问链表中的每一项执行一些操作，如显示该项</p>
</blockquote>
</li>
<li><p>对该电影程序来说，暂时不需要其他操作，但一般的<strong>链表还应该包含以下操作</strong>：</p>
<blockquote>
<p>1、在链表任意位置插入一个项<br>2、移除链表中的一个项<br>3、在链表中检索一个项(不改变链表)<br>4、用另一个项替换链表中的一个项<br>5、在链表中搜索一个项</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>该类型总结如下</strong>，下一步是为该<strong>链表 ADT</strong>开发一个<strong>C 接口</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
类型名：      简单链表
类型属性：    可以存储一系列项
类型操作：    初始化链表为空
            确定链表为空
            确定链表已满
            确定链表中的项数
            在链表末尾添加项
            遍历链表，处理链表中的项
            请空链表
*/</span></code></pre></li>
</ul>
</li>
<li><p><strong>建立接口</strong></p>
<ul>
<li><p><strong>接口数据类型</strong></p>
<ul>
<li><p>这个<strong>简单链表</strong>的<strong>接口</strong>有两个部分，第一部分是<strong>描述如何表示数据</strong>，第二部分是<strong>描述实现 ADT 操作的函数</strong></p>
</li>
<li><p><strong>接口设计</strong>应尽量与<strong>ADT 的描述</strong>保持一致，因此，应该用某种<strong>通用的 Item 类型</strong>而不是一些<strong>特殊类型</strong>(如 int 或 struct film)</p>
</li>
<li><p>可以用 C 的<code>typedef</code>功能来<strong>定义所需的 Item 类型</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSIZE</span> <span class="token expression"><span class="token number">45</span>  </span><span class="token comment">// 存储片名的数组大小</span></span>
<span class="token keyword">struct</span> <span class="token class-name">film</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>TSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rating<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 将 film 结构设置别名 Item</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">film</span> Item<span class="token punctuation">;</span></code></pre>
</li>
<li><p>然后，就可以在<strong>定义的其余部分</strong>使用 Item 类型，如果以后需要<strong>其他数据形式</strong>的<strong>链表</strong>，可以<strong>重新定义 Item 类型</strong>，而不必更改<strong>其余的接口定义</strong></p>
</li>
</ul>
</li>
<li><p><strong>进一步设计如何存储项</strong></p>
<ul>
<li><p>在之前链表的示例程序中用<strong>链式结构</strong>处理得很好，所以在这里我们也用相同的方法(链表的实现中，每一个链节叫做节点 node)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 将 node 结构设置别名为 Node</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    Item item<span class="token punctuation">;</span>            <span class="token comment">// 包含 film 结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span> next<span class="token punctuation">;</span>   <span class="token comment">// 指向下一个结构</span>
<span class="token punctuation">&#125;</span> Node<span class="token punctuation">;</span>
<span class="token comment">// 将指向 Node 的指针(实际就是一个链表)设置别名 List，表示指向链表开始处的指针</span>
<span class="token keyword">typedef</span> Node <span class="token operator">*</span> List<span class="token punctuation">;</span></code></pre>
</li>
<li><p>是否有其他方法定义<strong>List 类型</strong>？例如，还可以<strong>添加一个变量</strong>，<strong>记录项数</strong>(稍后程序示例会使用这种，现在<strong>仍使用前面的方法</strong>定义 List 类型)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>head<span class="token punctuation">;</span>    <span class="token comment">// 指向链表头的指针</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>      <span class="token comment">// 链表中的项数</span>
<span class="token punctuation">&#125;</span> List<span class="token punctuation">;</span></code></pre>
</li>
<li><p>因此，<code>List movies;</code>创建了<strong>该链表所需类型</strong>的<strong>指针 movies</strong>。这里要着重理解<strong>声明创建了一个链表</strong>，而不是<strong>一个指向节点的指针</strong>或<strong>一个结构</strong></p>
</li>
</ul>
</li>
<li><p><strong>隐藏实现细节</strong></p>
<ul>
<li><p><strong>movies</strong>代表的<strong>确切数据</strong>应该是<strong>接口层次</strong>不可见的<strong>实现细节</strong></p>
</li>
<li><p>例如，程序启动后应把<strong>头指针</strong>初始化为<strong>NULL</strong>，你的实现细节应如下</p>
<pre class="language-c" data-language="c"><code class="language-c">movies <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

<span class="token comment">// 稍后你会发现 List 类型的结构实现(即第二种定义List类型的方法)会更好，应该这样初始化</span>
movies<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
movies<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>而<strong>使用该类型的程序员</strong>不需要知道<strong>List 类型变量</strong>的<strong>实现细节</strong>，只需要使用你<strong>提前设计好的</strong><code>InitializeList()</code><strong>函数</strong>来<strong>初始化链表</strong>即可</p>
</li>
<li><p>这是<strong>数据隐藏</strong>的一个示例，<strong>数据隐藏</strong>是一个从编程的更高层次<strong>隐藏数据表示细节</strong>的艺术</p>
</li>
<li><p>为了<strong>指引用户使用</strong>，你需要在拟定的<code>InitializeList()</code><strong>函数</strong>前<strong>提供一些注释</strong>帮助使用者<strong>使用函数</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
操作：初始化一个链表
前置条件：plist指向一个链表
后置条件：链表初始化为空
*/</span>
<span class="token keyword">void</span> <span class="token function">InitializeList</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
<li><p><strong>接口头文件示例</strong>(使用<code>#ifndef</code>防止多次包含一个头文件)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* list.h 简单链表类型的接口头文件 */</span>

<span class="token comment">// 使用 #ifndef 检测是否 LIST_H_ 未定义，防止多次包含同一个文件，注意 #endif 在该头文件末尾</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LIST_H_</span></span>
<span class="token comment">// 此处预处理器定义 LIST_H_，如果再次重复调用该头文件，#ifndef 将使得这部分代码不会执行</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIST_H_</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span>

<span class="token comment">/* 特定程序的声明 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSIZE</span> <span class="token expression"><span class="token number">45</span> </span><span class="token comment">// 存储片名的数组大小</span></span>
<span class="token keyword">struct</span> <span class="token class-name">film</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> title<span class="token punctuation">[</span>TSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rating<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/* 一般类型定义 */</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">film</span> Item<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    Item item<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Node<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> Node <span class="token operator">*</span> List<span class="token punctuation">;</span>

<span class="token comment">/* 函数原型 */</span>

<span class="token comment">/*
操作：初始化一个链表
前提条件：plist 指向一个链表
后置条件：链表初始化为空
*/</span>
<span class="token keyword">void</span> <span class="token function">InitializeList</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：确定链表是否为空，plist 指向一个已初始化的链表
后置条件：如果链表为空，返回 true，否则返回 false
*/</span>
bool <span class="token function">ListIsEmpty</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：确定链表是否已满，plist 指向一个已初始化的链表
后置条件：如果链表已满，返回 true，否则返回 false
*/</span>
bool <span class="token function">ListIsFull</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：确定链表中的项数，plist 指向一个已初始化的链表
后置条件：该函数返回链表中的项数
*/</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ListItemCount</span><span class="token punctuation">(</span><span class="token keyword">const</span> List <span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：在链表末尾添加项
前提条件：item 是一个待添加至链表的项，plist 指向一个已初始化的链表
后置条件：如果可以，该函数在链表末尾添加一个项，且返回 true，否则返回 false
*/</span>
bool <span class="token function">AddItem</span><span class="token punctuation">(</span>Item item<span class="token punctuation">,</span> List <span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：把函数作用于链表的每一项
前提条件：plist 指向一个已初始化的链表，pfun 指向一个函数(该函数接受一个Item类型的参数，且无返回值)
后置条件：pfun 指向的函数作用于链表中的每一项一次
*/</span>
<span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">const</span> List <span class="token operator">*</span>plist<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：释放已分配的内存(如果有的话)，plist 指向一个已初始化的链表
后置条件：释放了为链表分配的所有内存，链表设置为空
*/</span>
<span class="token keyword">void</span> <span class="token function">EmptyTheList</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre></li>
</ul>
</li>
<li><p><strong>实现接口</strong></p>
<ul>
<li><p><strong>说明</strong></p>
<blockquote>
<p>1、当然，我们还必须<strong>实现 List 接口</strong>。C 方法是把<strong>函数定义</strong>和<strong>具体实现</strong>统一放在<code>list.c</code>文件中<br>2、然后，<strong>整个程序由</strong><code>list.h</code>(定义数据结构和提供用户接口的原型)、<code>list.c</code>(提供函数代码实现接口)、<code>film.c</code>(把链表接口应用于特定编程问题的源代码文件)<strong>组成</strong><br>3、下面，演示了<code>list.c</code>的<strong>一种实现</strong>，要<strong>运行整个电影程序</strong>，需要把<code>film.c</code>和<code>list.c</code><strong>一起编译和链接</strong></p>
</blockquote>
</li>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* list.c 支持链表操作的函数 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span>

<span class="token comment">// 局部函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">CopyToNode</span><span class="token punctuation">(</span>Item item<span class="token punctuation">,</span> Node <span class="token operator">*</span>pnode<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    pnode<span class="token operator">-></span>item <span class="token operator">=</span> item<span class="token punctuation">;</span> <span class="token comment">// 拷贝结构</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/* 接口函数 */</span>
<span class="token comment">// 把链表设置为空</span>
<span class="token keyword">void</span> <span class="token function">InitializeList</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>plist <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 如果链表为空，返回 true</span>
bool <span class="token function">ListIsEmpty</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>plist <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 如果链表已满，返回 true</span>
bool <span class="token function">ListIsFull</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>pt<span class="token punctuation">;</span>
    bool full<span class="token punctuation">;</span>

    pt <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        full <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        full <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> full<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 返回节点的数量</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">ListItemCount</span><span class="token punctuation">(</span><span class="token keyword">const</span> List <span class="token operator">*</span>plist<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    Node <span class="token operator">*</span>pnode <span class="token operator">=</span> <span class="token operator">*</span>plist<span class="token punctuation">;</span> <span class="token comment">// 设置链表的开始</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>pnode <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token operator">++</span>count<span class="token punctuation">;</span>
        pnode <span class="token operator">=</span> pnode<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 设置下一个节点</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 创建存储项的节点，并将其添加至由 plist 指向的链表末尾(较慢的实现)</span>
bool <span class="token function">AddItem</span><span class="token punctuation">(</span>Item item<span class="token punctuation">,</span> List <span class="token operator">*</span>plist<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>pnew<span class="token punctuation">;</span>
    Node <span class="token operator">*</span>scan <span class="token operator">=</span> <span class="token operator">*</span>plist<span class="token punctuation">;</span>

    pnew <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pnew <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">// 内存分配失败时退出函数</span>

    <span class="token function">CopyToNode</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> pnew<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pnew<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scan <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment">// 如果 scan(即plist)为空链表，就说明是链表第一个项</span>
        <span class="token operator">*</span>plist <span class="token operator">=</span> pnew<span class="token punctuation">;</span> <span class="token comment">// 把 pnew 放在链表的开头</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>scan<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            scan <span class="token operator">=</span> scan<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 找到链表的末尾</span>
        scan<span class="token operator">-></span>next <span class="token operator">=</span> pnew<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 访问每个节点并执行 pfun 指向的函数</span>
<span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">const</span> List <span class="token operator">*</span>plist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>pnode <span class="token operator">=</span> <span class="token operator">*</span>plist<span class="token punctuation">;</span> <span class="token comment">// 设置链表的开始</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>pnode <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>pnode<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把函数应用于链表中的项</span>
        pnode <span class="token operator">=</span> pnode<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">// 前进到下一项</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/* 释放由 malloc() 分配的内存 */</span>
<span class="token comment">// 设置链表的指针为 NULL</span>
<span class="token keyword">void</span> <span class="token function">EmptyTheList</span><span class="token punctuation">(</span>List <span class="token operator">*</span>plist<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>psave<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>plist <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        psave <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 保存下一个节点的地址</span>
        <span class="token function">free</span><span class="token punctuation">(</span><span class="token operator">*</span>plist<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 释放当前节点</span>
        <span class="token operator">*</span>plist <span class="token operator">=</span> psave<span class="token punctuation">;</span>         <span class="token comment">// 前进至下一节点</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>使用接口</strong></p>
<ul>
<li><p><strong>说明</strong></p>
<blockquote>
<p>1、我们的目标是，这个<strong>接口</strong>编写程序，但是<strong>不必知道</strong>具体的<strong>实现细节</strong>(如函数的具体实现细节)<br>2、在编写<strong>具体函数</strong>之前，我们需要重新设计一下<strong>电影程序</strong>。由于<strong>接口</strong>要使用<strong>List</strong>和<strong>Item</strong>类型，所以该程序也应该<strong>使用这些类型</strong></p>
</blockquote>
</li>
<li><p><strong>程序示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* film.c 电影程序 */</span>
<span class="token comment">/* 与 list.c 一起编译 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> <span class="token comment">// 提供 exit() 的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span>   <span class="token comment">// 定义 List、Item</span></span>

<span class="token keyword">void</span> <span class="token function">showmovies</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"电影：%s  评分：%d\n"</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span>title<span class="token punctuation">,</span> item<span class="token punctuation">.</span>rating<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    List movies<span class="token punctuation">;</span>
    Item temp<span class="token punctuation">;</span>

    <span class="token comment">// 初始化</span>
    <span class="token function">InitializeList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>movies<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ListIsFull</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>movies<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"没有空余内存\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 获取用户输入并存储</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入第一个电影名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>title<span class="token punctuation">,</span> TSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span>title<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入你的评分："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">.</span>rating<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">AddItem</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>movies<span class="token punctuation">)</span> <span class="token operator">==</span> false<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"内存分配错误\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ListIsFull</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>movies<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"列表已满\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入下一个电影名(或换行退出)："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 显示</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ListIsEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>movies<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"没有数据写入\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这是你的电影列表：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>movies<span class="token punctuation">,</span> showmovies<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"你一共添加了%d个电影\n"</span><span class="token punctuation">,</span> <span class="token function">ListItemCount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>movies<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 清理</span>
    <span class="token function">EmptyThelist</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>movies<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"再见！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="队列-ADT"><a href="#队列-ADT" class="headerlink" title="队列 ADT"></a><strong>队列 ADT</strong></h4><ul>
<li><p><strong>定义队列 ADT</strong></p>
<ul>
<li><p><strong>分析队列类型</strong></p>
<blockquote>
<p>1、<strong>队列</strong>是具有<strong>两个特殊属性</strong>的<strong>链表</strong><br>2、第一，<strong>新项只能添加到链表末尾</strong>。从这方面看，队列和简单链表类似<br>3、第二，<strong>只能从链表的开头移除项</strong><br>4、<strong>队列</strong>是一种<strong>先进先出</strong>(first in first out，缩写为 FIFO)的<strong>数据形式</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
类型名：      队列
类型属性：    可以存储一系列项
类型操作：    初始化列表为空
            确定队列为空
            确定队列已满
            确定队列中的项数
            在队列末尾添加项
            在队列开头删除或恢复项
            清空队列
*/</span></code></pre></li>
</ul>
</li>
<li><p><strong>建立接口</strong></p>
<ul>
<li><p><strong>实现接口数据表示</strong></p>
<ul>
<li><p>确定<strong>队列</strong>中使用<strong>何种 C 数据形式</strong></p>
<blockquote>
<p>1、有可能是<strong>数组</strong>。<strong>数组的优点</strong>是<strong>方便使用</strong>，而且<strong>向数组末尾添加项</strong>很简单<br>2、问题是如何<strong>从队列的开头删除项</strong>。类比于排队买票的队列，从队列的<strong>开头删除一个项</strong>包括<strong>拷贝数组首元素的值</strong>和<strong>把数组剩余各项依次向前移动一个位置</strong><br>3、<strong>编程实现</strong>这个过程很简单，但是会<strong>浪费大量的计算机时间</strong><br>4、第二种<strong>解决数组队列删除问题</strong>的方法是<strong>改变队列首端的位置</strong>，<strong>其余元素不动</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%98%9F%E5%88%971.png" loading="lazy"></p>
</li>
<li><p>进一步优化<strong>数组队列</strong>的模型</p>
<blockquote>
<p>1、解决这种问题的一个好方法是，<strong>使数组成为环形</strong>。这意味着<strong>把数组的首尾相连</strong>，即数组的<strong>首元素</strong>紧跟在<strong>最后一个元素</strong>后面<br>2、这样，当<strong>到达数组末尾</strong>时，如果<strong>首元素空出</strong>，就可以把<strong>新添加的项</strong>存储到这些<strong>空出的元素</strong>中<br>3、可以想象在一张条形的纸上画出数组，然后把数组的收尾粘起来形成一个环。当然<strong>要做一些标记</strong>，<strong>以免尾端超过首端</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E9%98%9F%E5%88%972.png" loading="lazy"></p>
</li>
<li><p><strong>使用链表实现接口数据表示</strong></p>
<ul>
<li><p>另一种方法是<strong>使用链表</strong>。好处是<strong>删除首项</strong>时<strong>不必移动其他元素</strong>，只需<strong>重置头指针指向新的首元素</strong></p>
</li>
<li><p>由于我们已经讨论过<strong>链表</strong>，<strong>所以采用这个方案</strong>。我们用一个<strong>整数队列</strong>进行测试：<code>typedef int Item;</code></p>
</li>
<li><p><strong>链表</strong>由<strong>节点</strong>构成，所以下一步是<strong>定义节点</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    Item item<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Node<span class="token punctuation">;</span></code></pre>
</li>
<li><p>对<strong>队列</strong>而言，要<strong>保存首尾项</strong>，还可以<strong>使用指针</strong>来完成。另外可以用一个<strong>计数器</strong>来记录队列中的<strong>项数</strong>。因此<strong>结构成员</strong>如下</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">queue</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>front<span class="token punctuation">;</span>      <span class="token comment">// 指向队列首项的指针</span>
    Node <span class="token operator">*</span>rear<span class="token punctuation">;</span>       <span class="token comment">// 指向队列尾项的指针</span>
    <span class="token keyword">int</span> items<span class="token punctuation">;</span>        <span class="token comment">// 队列中的项数</span>
<span class="token punctuation">&#125;</span> Queue<span class="token punctuation">;</span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>接口头文件示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* queue.h 队列的接口头文件 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">QUEUE_H_</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">QUEUE_H_</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span>

<span class="token comment">// 在这里插入 Item 类型的定义，例如</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> Item<span class="token punctuation">;</span> <span class="token comment">// 用于 use_q.c</span>
<span class="token comment">// 或者 typedef struct item&#123;int gumption; int charisma;&#125; Item;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span>
<span class="token punctuation">&#123;</span>
    Item item<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Node<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">queue</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>front<span class="token punctuation">;</span> <span class="token comment">// 指向队列首项的指针</span>
    Node <span class="token operator">*</span>rear<span class="token punctuation">;</span>  <span class="token comment">// 指向队列尾项的指针</span>
    <span class="token keyword">int</span> items<span class="token punctuation">;</span>   <span class="token comment">// 队列中的项数</span>
<span class="token punctuation">&#125;</span> Queue<span class="token punctuation">;</span>

<span class="token comment">/*
操作：初始化队列
前提条件：pq 指向一个队列
后置条件：队列被初始化为空
*/</span>
<span class="token keyword">void</span> <span class="token function">InitializeQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：检查队列是否已满
前提条件：pq 指向一个已被初始化的队列
后置条件：如果队列已满则返回 true，否则返回 false
*/</span>
bool <span class="token function">QueueIsFull</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：检查队列是否为空
前提条件：pq 指向一个已被初始化的队列
后置条件：如果队列为空则返回 true，否则返回 false
*/</span>
bool <span class="token function">QueueIsEmpty</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：确定队列中的项数
前提条件：pq 指向一个已被初始化的队列
后置条件：返回队列中的项数
*/</span>
<span class="token keyword">int</span> <span class="token function">QueueItemCount</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：在队列末尾添加项
前提条件：pq 指向一个已被初始化的队列，item 是要被添加在队列末尾的项
后置条件：如果队列不为空，item 将被添加在队列的末尾，函数返回 true；否则，队列不改变，函数返回 false
*/</span>
bool <span class="token function">EnQueue</span><span class="token punctuation">(</span>Item item<span class="token punctuation">,</span> Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：从队列开头删除项
前提条件：pq 指向一个已被初始化的队列
后置条件：如果队列不为空，队列首端的 item 将被拷贝到 *pitem 中并被删除，函数返回 true；如果该操作使得队列为空，则重置队列为空；如果执行该操作前队列为空，函数返回 false
*/</span>
bool <span class="token function">DeQueue</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pitem<span class="token punctuation">,</span> Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：清空队列
前提条件：pq 指向一个已被初始化的队列
后置条件：队列被清空
*/</span>
<span class="token keyword">void</span> <span class="token function">EmptyTheQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre></li>
</ul>
</li>
<li><p><strong>实现接口</strong></p>
<ul>
<li><p><strong>示例程序</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* queue.c 队列类型函数的实现 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"queue.h"</span></span>

<span class="token comment">// 局部函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">CopyToNode</span><span class="token punctuation">(</span>Item item<span class="token punctuation">,</span> Node <span class="token operator">*</span>pn<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    pn<span class="token operator">-></span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">CopyToItem</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>pn<span class="token punctuation">,</span> Item <span class="token operator">*</span>pi<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>pi <span class="token operator">=</span> pn<span class="token operator">-></span>item<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 实现功能函数</span>
<span class="token keyword">void</span> <span class="token function">InitializeQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    pq<span class="token operator">-></span>front <span class="token operator">=</span> pq<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    pq<span class="token operator">-></span>items <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">QueueIsFull</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> pq<span class="token operator">-></span>items <span class="token operator">==</span> MAXQUEUE<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">QueueIsEmpty</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> pq<span class="token operator">-></span>items <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">QueueItemCount</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> pq<span class="token operator">-></span>items<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">EnQueue</span><span class="token punctuation">(</span>Item item<span class="token punctuation">,</span> Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>pnew<span class="token punctuation">;</span>
    <span class="token comment">// 如果队列已满，返回 false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">QueueIsFull</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    pnew <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为 pnew 分配内存</span>
    <span class="token comment">// 如果内存分配错误(空指针)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pnew <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"无法分配内存！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">CopyToNode</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> pnew<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将值拷贝给 pnew</span>
    pnew<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token comment">// 让 pnew 的 next 指针成员指向 NULL</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">QueueIsEmpty</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">// 如果 pq 本来就为空</span>
        pq<span class="token operator">-></span>front <span class="token operator">=</span> pnew<span class="token punctuation">;</span>      <span class="token comment">// 项位于队列的首端，即首个项</span>
    <span class="token keyword">else</span>                       <span class="token comment">// 否则则不是首项</span>
        pq<span class="token operator">-></span>rear<span class="token operator">-></span>next <span class="token operator">=</span> pnew<span class="token punctuation">;</span> <span class="token comment">// 当前队列尾端 rear 的 next 指针指向 pnew 进行链接</span>
    pq<span class="token operator">-></span>rear <span class="token operator">=</span> pnew<span class="token punctuation">;</span>           <span class="token comment">// 记录队列尾端的位置，更新队列尾端指针 rear 指向 pnew</span>
    pq<span class="token operator">-></span>items<span class="token operator">++</span><span class="token punctuation">;</span>               <span class="token comment">// 队列项数+1</span>

    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">DeQueue</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pitem<span class="token punctuation">,</span> Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Node <span class="token operator">*</span>pt<span class="token punctuation">;</span>
    <span class="token comment">// 如果 pq 本来就为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">QueueIsEmpty</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>

    <span class="token function">CopyToItem</span><span class="token punctuation">(</span>pq<span class="token operator">-></span>front<span class="token punctuation">,</span> pitem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 pq 的首元素拷贝给 pitem</span>
    pt <span class="token operator">=</span> pq<span class="token operator">-></span>front<span class="token punctuation">;</span>               <span class="token comment">// 用 pt 记录目前首元素位置</span>
    pq<span class="token operator">-></span>front <span class="token operator">=</span> pq<span class="token operator">-></span>front<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">// 将首元素设置为下一个元素的位置</span>
    <span class="token function">free</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 释放原先首元素的位置</span>
    pq<span class="token operator">-></span>items<span class="token operator">--</span><span class="token punctuation">;</span>                  <span class="token comment">// 队列项数-1</span>
    <span class="token comment">// 如果删除后队列没有元素了，就初始化队列，将未操作清空的末尾设置为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token operator">-></span>items <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        pq<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">EmptyTheQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>pq<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Item dummy<span class="token punctuation">;</span> <span class="token comment">// 临时指针</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueIsEmpty</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">DeQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dummy<span class="token punctuation">,</span> pq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>测试队列</strong></p>
<ul>
<li><p><strong>说明</strong></p>
<blockquote>
<p>1、在重要程序中<strong>使用一个新的设计之前</strong>(如，队列包)，应该<strong>先测试该设计</strong><br>2、测试的一种方法是，<strong>编写一个小程序</strong>，这样的程序称为<strong>驱动程序</strong>，其<strong>唯一用途</strong>是<strong>进行测试</strong><br>3、注意编写的<strong>驱动程序</strong>必须链接所需要的<code>queue.c</code>，即<strong>多文件编译</strong>一起进行编译</p>
</blockquote>
</li>
<li><p><strong>驱动程序示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* use_q.c 驱动程序测试 Queue 接口 */</span>
<span class="token comment">/* 与 queue.c 一起编译 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"queue.h"</span> <span class="token comment">// 定义 Queue、Item</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Queue line<span class="token punctuation">;</span>
    Item temp<span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>

    <span class="token function">InitializeQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"测试队列界面，输入a添加值，输入d删除值，输入q退出程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'q'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> <span class="token char">'a'</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">!=</span> <span class="token char">'d'</span><span class="token punctuation">)</span> <span class="token comment">// 忽略其他输入</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果为 a 则添加，否则即删除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'a'</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入一个对应队列元素类型的值(该程序为整数)："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果队列未满则添加，已满则提示</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QueueIsFull</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                <span class="token function">EnQueue</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"成功将%d写入队列\n"</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span>
                <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"队列已满，未成功写入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">QueueIsEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"队列已经为空！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">&#123;</span>
                <span class="token function">DeQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"成功将%d从队列删除\n"</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"队列中有%d个元素\n"</span><span class="token punctuation">,</span> <span class="token function">QueueItemCount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入a添加值，输入d删除值，输入q退出程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">EmptyTheQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"队列已正常清空释放，程序退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="用队列进行模拟"><a href="#用队列进行模拟" class="headerlink" title="用队列进行模拟"></a><strong>用队列进行模拟</strong></h4><ul>
<li><p><strong>引入</strong></p>
<blockquote>
<p>1、经过测试，队列没问题。现在，我们用它来做一些有趣的事情。许多现实生活情景都涉及队列，我们可以用队列包模拟这些情景<br>2、假设某人在商业街设置了一个提供建议的摊位，顾客可以购买<strong>1 分钟</strong>、<strong>2 分钟</strong>、<strong>3 分钟</strong>的建议。为确保交通畅通，商业街规定每个摊位前<strong>排队等待的顾客最多 10 人</strong><br>3、假设<strong>顾客</strong>都是<strong>随机出现</strong>的，并且他们花在咨询上的<strong>时间</strong>也是<strong>随机选择</strong>的。那么摊主平均每小时要接待多少顾客？每位顾客平均要花多少时间？排队等待的顾客有多少人？</p>
</blockquote>
</li>
<li><p><strong>分析</strong></p>
<blockquote>
<p>1、首先，要<strong>确定队列里放什么</strong>。我们可以<strong>定义一个结构</strong>，存放顾客<strong>加入排队的时间</strong>和<strong>咨询所需的时间</strong>，并用该结构<strong>替换原队列包中的 Item 类型</strong>(如后示例)。因此应<strong>按需修改</strong><code>queue.h</code>和<code>queue.c</code>(必要步骤)<br>2、这里有一种方法，让时间<strong>以 1 分钟为单位递增</strong>。每递增 1 分钟，就检查<strong>是否有新顾客到来</strong>，<strong>如果有</strong>且<strong>队列未满</strong>，就将其<strong>加入队列</strong>；如果<strong>队列已满</strong>，就<strong>让该顾客离开</strong>。为了做统计，要记录<strong>顾客总数</strong>和<strong>被拒顾客数</strong><br>3、接下来，处理<strong>队列的首端</strong>。如果<strong>队列不为空</strong>且<strong>前面的顾客没有在咨询</strong>，则<strong>删除首端的项</strong>；如果摊主正忙，则不用让任何人离开队列。注意，该项中存储着<strong>顾客加入队列的时间</strong>，把<strong>该时间</strong>与<strong>当前时间</strong>比较，就得出该顾客在队列中的<strong>等待时间</strong>。该项还存储着<strong>需要咨询的分钟数</strong>，因此还需要一个变量<strong>存储这个数值</strong>，每次循环，这个<strong>记录等待时间的变量</strong>应<strong>递减 1</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">item</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> arrive<span class="token punctuation">;</span>      <span class="token comment">// 记录顾客加入队列的时间</span>
    <span class="token keyword">int</span> processtime<span class="token punctuation">;</span>  <span class="token comment">// 该顾客咨询所需要花费的时间</span>
<span class="token punctuation">&#125;</span> Item<span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>示例程序</strong>(此处演示如何使用队列模拟，<code>queue.h</code>和<code>queue.c</code>须自行修改)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* mall.c 使用 Queue 接口 */</span>
<span class="token comment">/* 与 queue.c 一起编译(注意需要自行修改) */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>     <span class="token comment">// 提供 rand() 和 srand() 的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span>       <span class="token comment">// 提供 time() 的原型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"queue.h"</span>      <span class="token comment">// 已更改 Item 的 typedef</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MIN_PER_HR</span> <span class="token expression"><span class="token number">60.0</span> </span><span class="token comment">// 每小时的分钟数</span></span>

<span class="token comment">// 是否有新顾客到来</span>
<span class="token comment">// x 是顾客到来的平均时间。如果1分钟内有顾客到来，则返回 true</span>
bool <span class="token function">newcustomer</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> x <span class="token operator">/</span> RAND_MAX <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 设置顾客参数</span>
<span class="token comment">// when 是顾客到来的时间。该函数返回一个 Item 结构，该顾客到达的时间设置为 when，咨询时间设置为 1~3 的随机值</span>
Item <span class="token function">customertime</span><span class="token punctuation">(</span><span class="token keyword">long</span> when<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Item cust<span class="token punctuation">;</span>
    cust<span class="token punctuation">.</span>processtime <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    cust<span class="token punctuation">.</span>arrive <span class="token operator">=</span> when<span class="token punctuation">;</span>
    <span class="token keyword">return</span> cust<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Queue line<span class="token punctuation">;</span>
    Item temp<span class="token punctuation">;</span>              <span class="token comment">// 新的顾客数据</span>
    <span class="token keyword">int</span> hours<span class="token punctuation">;</span>              <span class="token comment">// 模拟的小时数</span>
    <span class="token keyword">int</span> perhour<span class="token punctuation">;</span>            <span class="token comment">// 每小时平均多少位顾客</span>
    <span class="token keyword">long</span> cycle<span class="token punctuation">,</span> cyclelimit<span class="token punctuation">;</span> <span class="token comment">// 循环计数器、计数器的上限</span>
    <span class="token keyword">long</span> turnaways <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 因队列已满被拒的顾客数</span>
    <span class="token keyword">long</span> customers <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 加入队列的顾客数</span>
    <span class="token keyword">long</span> served <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 在模拟期间咨询过的顾客数</span>
    <span class="token keyword">long</span> sum_line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">// 累积的队列总长</span>
    <span class="token keyword">int</span> wait_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">// 从当前时间到摊主空闲所需的时间</span>
    <span class="token keyword">double</span> min_per_cust<span class="token punctuation">;</span>    <span class="token comment">// 顾客到来的平均时间</span>
    <span class="token keyword">long</span> line_wait <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 队列累计的等待时间</span>

    <span class="token function">InitializeQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rand() 随机初始化</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入你要模拟的时长："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hours<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cyclelimit <span class="token operator">=</span> MIN_PER_HR <span class="token operator">*</span> hours<span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入每小时平均多少位顾客："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>perhour<span class="token punctuation">)</span><span class="token punctuation">;</span>
    min_per_cust <span class="token operator">=</span> MIN_PER_HR <span class="token operator">/</span> perhour<span class="token punctuation">;</span>

    <span class="token comment">// 每次迭代对应1分钟的行为</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>cycle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cycle <span class="token operator">&lt;</span> cyclelimit<span class="token punctuation">;</span> cycle<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 随机生成这1分钟有没有顾客</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">newcustomer</span><span class="token punctuation">(</span>min_per_cust<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">// 队列已满则让顾客离开并计数</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">QueueIsFull</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span>
                turnaways<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">// 队列未满则随机生成顾客信息，并将其添加到队列中</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">&#123;</span>
                customers<span class="token operator">++</span><span class="token punctuation">;</span>
                temp <span class="token operator">=</span> <span class="token function">customertime</span><span class="token punctuation">(</span>cycle<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">EnQueue</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 如果摊主目前空闲 且 队列不为空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>wait_time <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">QueueIsEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">DeQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 删除首元素并将其信息拷贝至 temp</span>
            wait_time <span class="token operator">=</span> temp<span class="token punctuation">.</span>processtime<span class="token punctuation">;</span>     <span class="token comment">// 记录摊主接下来多少分钟不空闲</span>
            line_wait <span class="token operator">+=</span> cycle <span class="token operator">-</span> temp<span class="token punctuation">.</span>arrive<span class="token punctuation">;</span> <span class="token comment">// 将该顾客的等待时间累加到队列等待总时长中</span>
            served<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 如果摊主不空闲</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>wait_time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            wait_time<span class="token operator">--</span><span class="token punctuation">;</span>
        sum_line <span class="token operator">+=</span> <span class="token function">QueueItemCount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将这一分钟队列的总长累加到队列总长中</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>customers <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"成功排队：%ld\n"</span><span class="token punctuation">,</span> customers<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"成功接待：%ld\n"</span><span class="token punctuation">,</span> served<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"离开顾客：%ld\n"</span><span class="token punctuation">,</span> turnaways<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"平均队列长度：%.2f"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>sum_line <span class="token operator">/</span> cyclelimit<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"平均等待时间：%.2f"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>line_wait <span class="token operator">/</span> served<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"没有顾客！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">EmptyTheQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"已清理队列，成功退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
<h4 id="链表和数组与查找方式"><a href="#链表和数组与查找方式" class="headerlink" title="链表和数组与查找方式"></a><strong>链表和数组与查找方式</strong></h4><ul>
<li><p><strong>链表和数组的性质对比</strong></p>
<table>
<thead>
<tr>
<th>数据形式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>C 直接支持；提供随机访问</td>
<td>需要编译时确定大小；插入和删除元素很费时</td>
</tr>
<tr>
<td>链表</td>
<td>运行时确定大小；快速插入和删除元素</td>
<td>不能随机访问；用户必须提供编程支持</td>
</tr>
</tbody></table>
</li>
<li><p><strong>访问元素的方式</strong></p>
<blockquote>
<p>1、对<strong>数组</strong>而言，使用<strong>数组下标</strong>就能<strong>直接访问任意元素</strong>，这叫做<strong>随机访问</strong><br>2、对<strong>链表</strong>而言，必须从<strong>链表的首节点</strong>开始，<strong>逐个移动</strong>到要访问的节点，这叫做<strong>顺序访问</strong><br>3、当然，也可以<strong>顺序访问数组</strong>，只需<strong>按顺序递增遍历数组</strong>即可</p>
</blockquote>
</li>
<li><p><strong>顺序查找</strong></p>
<blockquote>
<p>1、假设要<strong>查找列表</strong>中的<strong>特定项</strong>，一种算法是<strong>从列表开头按顺序查找</strong>，这叫做<strong>顺序查找</strong><br>2、如果<strong>该项并未按某种顺序排列</strong>，则<strong>只能顺序查找</strong><br>3、如果<strong>待查找的项不在列表中</strong>，也必须<strong>查找完所有项</strong>才能得知其<strong>不在列表中</strong>(这种情况下，可以使用并发编程，同时查找列表中不同的部分)<br>4、我们可以<strong>先排序列表</strong>，以<strong>改进顺序查找</strong>。这样，就<strong>不必查找</strong>排在待查找项<strong>后面的项</strong><br>5、例如一个<strong>按字母顺序排序</strong>的列表中查找<strong>Susan</strong>，如果直到<strong>Sylvia</strong>都<strong>没有找到</strong>，就可以<strong>退出查找</strong>了，因为<strong>Susan</strong>应<strong>排在 Sylvia 前面</strong></p>
</blockquote>
</li>
<li><p><strong>二分查找</strong></p>
<ul>
<li><p>对于一个<strong>已排序的列表</strong>，用<strong>二分查找</strong>比<strong>顺序查找</strong>好得多</p>
</li>
<li><p><strong>二分查找的原理</strong></p>
<blockquote>
<p>1、首先，假设把<strong>待查找的项</strong>称为<strong>目标项</strong>，而且假设列表中的各项<strong>按字母排序</strong><br>2、然后，比较列表的<strong>中间项</strong>和<strong>目标项</strong>。如果<strong>两者相等</strong>，则<strong>找到目标项</strong>，查找结束；如果<strong>不相等</strong>，假设<strong>目标项在列表中</strong>的话，如果<strong>中间项</strong>排在<strong>目标项前面</strong>，那<strong>目标项</strong>一定在列表的<strong>后半部分</strong>，反之则一定在<strong>前半部分</strong>。无论哪种情况，两项的<strong>比较结果</strong>都确定了<strong>下次查找的范围</strong>只有<strong>列表的一半</strong><br>3、接着，继续使用这种方法，把需要查找的<strong>剩下的一半的中间项</strong>与<strong>目标项比较</strong>，继续<strong>缩小一半范围</strong><br>4、以此类推，直到<strong>找到目标项</strong>或<strong>发现列表中没有目标项</strong>为止</p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png" loading="lazy"></p>
</li>
<li><p><strong>二分查找的优势</strong></p>
<blockquote>
<p>1、这种方法<strong>非常有效率</strong>。假如有<strong>127 个项</strong>，<strong>顺序查找</strong>平均要<strong>进行 64 次比较</strong>才能得出结果，而<strong>二分查找</strong>则<strong>至多只用 7 次比较</strong><br>2、一般而言，<strong>n 次比较</strong>能处理有 2<sup>n</sup> -1 个元素的数组。所以<strong>项数越多</strong>，越能体现<strong>二分查找</strong>的优势</p>
</blockquote>
</li>
<li><p><strong>二分查找的实现</strong></p>
<blockquote>
<p>1、用<strong>数组</strong>实现<strong>二分查找</strong>很简单，因为可以使用<strong>数组下标</strong>确定数组任意部分的<strong>中点</strong>，只要把这部分<strong>首下标</strong>和<strong>尾下标</strong>进行<strong>相加并除 2</strong>即可。比较后<strong>确定新范围</strong>，再<strong>获取中点继续比较</strong>，以此类推<br>2、这体现了<strong>随机访问</strong>的特性，可以从<strong>一个位置跳至另一个位置</strong>，不用<strong>依次访问</strong>中间的项<br>3、但是，<strong>链表</strong>只支持<strong>顺序访问</strong>，不能<strong>跳至中间节点</strong>，所以<strong>链表</strong>中<strong>无法使用二分查找</strong><br>4、如果需要一种既支持<strong>频繁插入和删除项</strong>又支持<strong>频繁查找</strong>的<strong>数据形式</strong>，<strong>数组和链表</strong>都不能胜任。这种情况下，应使用<strong>二叉查找树</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a><strong>二叉查找树</strong></h4><ul>
<li><p><strong>二叉树简介</strong></p>
<blockquote>
<p>1、<strong>二叉查找树</strong>是一种结合了<strong>二分查找</strong>策略的<strong>链接结构</strong>。<strong>二叉树</strong>的<strong>每个节点</strong>都包含<strong>一个项</strong>和<strong>两个指向其他子节点的指针</strong>(如后图)<br>2、<strong>二叉树</strong>中的<strong>每个节点</strong>都包含<strong>两个子节点</strong>，即<strong>左节点</strong>和<strong>右节点</strong>，其<strong>顺序</strong>按<strong>如下规定</strong>：<strong>左节点</strong>的项在<strong>父节点</strong>的项<strong>前面</strong>，<strong>右节点</strong>的项在<strong>父节点</strong>的项<strong>后面</strong><br>3、<strong>树的顶部</strong>为<strong>根</strong>，<strong>树</strong>具有<strong>分层</strong>组织，所以以这种方式<strong>存储的数据</strong>也以<strong>等级或层次</strong>组织。一般而言，<strong>每级</strong>都有<strong>上一级</strong>和<strong>下一级</strong>。如果<strong>二叉树是满的</strong>，那么<strong>每一级的节点数</strong>都是<strong>上一级节点数</strong>的<strong>两倍</strong><br>4、<strong>二叉树</strong>的<strong>每个节点</strong>都是其<strong>后代节点</strong>的<strong>根</strong>，<strong>该节点</strong>与其<strong>后代节点</strong>构成了一个<strong>子树</strong><br>5、假设要在<strong>二叉树</strong>中<strong>查找一个项</strong>。如果<strong>目标项</strong>在<strong>根节点前面</strong>，就只需查找<strong>左子树</strong>，反之只需查找<strong>右子树</strong>。因此，<strong>每次比较</strong>就<strong>排除半个树</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%91.png" loading="lazy"></p>
</li>
<li><p><strong>二叉树 ADT</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
类型名：      二叉查找树
类型属性：    二叉树要么是空节点的集合(空树)，要么是有一个根节点的节点集合
            每个节点都有两个子树，叫左子树和右子树
            每个子树本身也是一个二叉树，也有可能是空树
            二叉查找树是一个有序的二叉树，每个节点包含一个项
            左子树的所有项都在根节点项的前面，右子树的所有项都在根节点项的后面
类型操作：    初始化树为空
            确定树是否为空
            确定树是否已满
            确定树中的项数
            在树中添加一个项
            在树中删除一个项
            在树中查找一个项
            在树中访问一个项
            清空树
*/</span></code></pre>
</li>
<li><p><strong>建立接口</strong></p>
<ul>
<li><p><strong>实现接口数据表示</strong></p>
<blockquote>
<p>1、原则上，可以用多种方法实现<strong>二叉查找树</strong>，甚至可以通过<strong>操纵数组下标</strong>用数组实现<br>2、但是，实现<strong>二叉查找树</strong>最直接的方法是<strong>通过指针动态分配链式节点</strong></p>
</blockquote>
</li>
<li><p><strong>接口头文件示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* tree.h 二叉查找树的接口头文件 */</span>
<span class="token comment">// 树中不允许有重复的项</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">TREE_H_</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TREE_H_</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span>

<span class="token comment">// 根据具体情况重新定义 Item</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLEN</span> <span class="token expression"><span class="token number">20</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">item</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> petname<span class="token punctuation">[</span>SLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> petkind<span class="token punctuation">[</span>SLEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Item<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXITEMS</span> <span class="token expression"><span class="token number">10</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">trnode</span>
<span class="token punctuation">&#123;</span>
    Item item<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">trnode</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>  <span class="token comment">// 指向左分支的指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">trnode</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">// 指向右分支的指针</span>
<span class="token punctuation">&#125;</span> Trnode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tree</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>root<span class="token punctuation">;</span> <span class="token comment">// 指向根节点的指针</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>     <span class="token comment">// 树的项数</span>
<span class="token punctuation">&#125;</span> Tree<span class="token punctuation">;</span>

<span class="token comment">/*
操作：初始化树
前提条件：ptree 指向一个树
后置条件：树被初始化为空
*/</span>
<span class="token keyword">void</span> <span class="token function">InitializeTree</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：检查树是否为空
前提条件：ptree 指向一个树
后置条件：如果树为空则返回 true，否则返回 false
*/</span>
bool <span class="token function">TreeIsEmpty</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：检查树是否已满
前提条件：ptree 指向一个树
后置条件：如果树已满则返回 true，否则返回 false
*/</span>
bool <span class="token function">TreeIsFull</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：确定树的项数
前提条件：ptree 指向一个树
后置条件：返回树的项数
*/</span>
<span class="token keyword">int</span> <span class="token function">TreeItemCount</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：在树中添加一个项
前提条件：pi 是待添加项的地址，ptree 指向一个已初始化的树
后置条件：如果可以添加，该函数将在树中添加一个项，并返回 true；否则返回 false
*/</span>
bool <span class="token function">AddItem</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：从树中查找一个项
前提条件：pi 指向一个项，ptree 指向一个已初始化的树
后置条件：如果在树中找到指定项，则返回 true；否则返回 false
*/</span>
bool <span class="token function">InTree</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：从树中删除一个项
前提条件：pi 是删除项的地址，ptree 指向一个已初始化的树
后置条件：如果从树中成功删除一个项，则返回 true；否则返回 false
*/</span>
bool <span class="token function">DeleteItem</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：把函数应用于树中的每一项
前提条件：ptree 指向一个树，pfun 指向一个函数，该函数接受一个 Item 类型的参数且无返回值
后置条件：pfun 指向的这个函数为树中的每一项执行一次
*/</span>
<span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
操作：清空树中的所有内容
前提条件：ptree 指向一个已被初始化的树
后置条件：树被清空
*/</span>
<span class="token keyword">void</span> <span class="token function">DeleteAll</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre></li>
</ul>
</li>
<li><p><strong>实现接口</strong></p>
<ul>
<li><p><strong>添加项</strong></p>
<ul>
<li><p><strong>添加项的实现思路</strong></p>
<blockquote>
<p>1、在树中<strong>添加一个项</strong>，首先要<strong>检查是否有空余位置</strong>。由于我们定义<strong>二叉树</strong>时规定<strong>其中的项不重复</strong>，所以还要检查树中<strong>是否已有该项</strong><br>2、通过这两步检查后，便可<strong>创建一个新节点</strong>，把<strong>待添加项</strong>拷贝到该节点中，并设置节点的<strong>左指针</strong>和<strong>右指针</strong>都为<strong>NULL</strong>，这表明<strong>该节点没有子节点</strong><br>3、然后，更新<strong>Tree</strong>结构的<strong>size</strong>成员，统计<strong>新增一项</strong><br>4、接下来，必须找出应该把这个新节点<strong>放在树中哪个位置</strong>。如果<strong>树为空</strong>，则应设置<strong>根节点指针</strong>指向<strong>该新节点</strong>；否则，<strong>遍历树</strong>找到合适位置<strong>存放节点</strong><br>5、注意该<strong>函数中</strong>仍使用了一些<strong>静态函数</strong>来实现功能，这些函数将在<strong>后续说明</strong></p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">AddItem</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>new_node<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TreeIsFull</span><span class="token punctuation">(</span>ptree<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"树已满!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SeekItem</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> ptree<span class="token punctuation">)</span><span class="token punctuation">.</span>child <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"添加的项重复!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    new_node <span class="token operator">=</span> <span class="token function">MakeNode</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指向新节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"无法分配内存!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 成功创建了一个新节点</span>
    ptree<span class="token operator">-></span>size<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptree<span class="token operator">-></span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token comment">// 如果根为空</span>
        ptree<span class="token operator">-></span>root <span class="token operator">=</span> new_node<span class="token punctuation">;</span>         <span class="token comment">// 则这是第一个项，令根节点指向该节点</span>
    <span class="token keyword">else</span>                                <span class="token comment">// 否则</span>
        <span class="token function">AddNode</span><span class="token punctuation">(</span>new_node<span class="token punctuation">,</span> ptree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在树中添加节点</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>部分静态函数的实现思路</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> Trnode <span class="token operator">*</span><span class="token function">MakeNode</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>new_node<span class="token punctuation">;</span>
    new_node <span class="token operator">=</span> <span class="token punctuation">(</span>Trnode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Trnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 分配内存</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>new_node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                          <span class="token comment">// 如果内存成功分配，就初始化新节点</span>
    <span class="token punctuation">&#123;</span>
        new_node<span class="token operator">-></span>item <span class="token operator">=</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span>
        new_node<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> new_node<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">AddNode</span><span class="token punctuation">(</span>Trnode <span class="token operator">*</span>new_node<span class="token punctuation">,</span> Trnode <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// ToLeft() 和 ToRight() 判断该左移还是右移</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ToLeft</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>new_node<span class="token operator">-></span>item<span class="token punctuation">,</span> <span class="token operator">&amp;</span>root<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token comment">// 空子树</span>
            root<span class="token operator">-></span>left <span class="token operator">=</span> new_node<span class="token punctuation">;</span>         <span class="token comment">// 在此处添加节点</span>
        <span class="token keyword">else</span>                               <span class="token comment">// 否则</span>
            <span class="token function">AddNode</span><span class="token punctuation">(</span>new_node<span class="token punctuation">,</span> root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继续处理该子树</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ToRight</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>new_node<span class="token operator">-></span>item<span class="token punctuation">,</span> <span class="token operator">&amp;</span>root<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            root<span class="token operator">-></span>right <span class="token operator">=</span> new_node<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">AddNode</span><span class="token punctuation">(</span>new_node<span class="token punctuation">,</span> root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"AddNode() 函数执行错误!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> bool <span class="token function">ToLeft</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>i1<span class="token punctuation">,</span> Item <span class="token operator">*</span>i2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 比对字符串</span>
    <span class="token keyword">int</span> comp1<span class="token punctuation">;</span>
    <span class="token comment">// 比对 petname，如果 i1 的小于 i2 的，则 comp1 小于 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>comp1 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>i1<span class="token operator">-></span>petname<span class="token punctuation">,</span> i2<span class="token operator">-></span>petname<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token comment">// 如果 petname 相同，则比对 petkind 的字符串</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>comp1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>i1<span class="token operator">-></span>petkind<span class="token punctuation">,</span> i2<span class="token operator">-></span>petkind<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>查找项</strong></p>
<ul>
<li><p><strong>查找项的数据类型</strong></p>
<blockquote>
<p>1、<strong>3 个接口函数</strong>都要在树中<strong>查找特定项</strong>：<code>AddItem()</code>、<code>InTree()</code>和<code>DeleteItem()</code>。这些函数的实现中使用<code>SeekItem()</code><strong>函数</strong>进行查找<br>2、<code>DeleteItem()</code>有一个<strong>额外的要求</strong>：该函数要知道<strong>待删除项</strong>的<strong>父节点</strong>，以便在删除子节点后<strong>更新父节点指向子节点的指针</strong><br>3、因此，我们设计<code>SeekItem()</code>函数<strong>返回的结构</strong>包含<strong>两个指针</strong>：一个指向<strong>包含项的节点</strong>(未找到则为 NULL)，一个指向<strong>父节点</strong>(如果该节点为根节点，则没有父节点，则为 NULL)。因此，<strong>结构类型定义</strong>如下：</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pair</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">// 指向查找项的父节点</span>
    Trnode <span class="token operator">*</span>child<span class="token punctuation">;</span>  <span class="token comment">// 指向查找项</span>
<span class="token punctuation">&#125;</span> Pair<span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>查找项的实现思路</strong></p>
<blockquote>
<p>1、<code>SeekItem()</code>函数可以用<strong>递归</strong>的方式实现。但<strong>为了介绍更多技巧</strong>，我们这里使用<code>while</code><strong>循环</strong>处理查找<br>2、开始时，<code>SeekItem()</code>设置<code>look.child</code><strong>指向该树根节点</strong>。然后沿着<strong>目标项应在的路径</strong>(通过<code>ToLeft()</code>和<code>ToRight()</code>导航)重置<code>look.child</code><strong>指向后续的子树</strong>，同时设置<code>look.parent</code><strong>指向后续的父节点</strong><br>3、如果<strong>没有找到匹配的项</strong>，<code>look.child</code>设置为<strong>NULL</strong>。如果<strong>在根节点找到</strong>，<code>look.parent</code>设置为<strong>NULL</strong>(根节点没有父节点)</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> Pair <span class="token function">SeekItem</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Pair look<span class="token punctuation">;</span>
    look<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    look<span class="token punctuation">.</span>child <span class="token operator">=</span> ptree<span class="token operator">-></span>root<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>child <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> look<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>child <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ToLeft</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>look<span class="token punctuation">.</span>child<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            look<span class="token punctuation">.</span>parent <span class="token operator">=</span> look<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
            look<span class="token punctuation">.</span>child <span class="token operator">=</span> look<span class="token punctuation">.</span>child<span class="token operator">-></span>left<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ToRight</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>look<span class="token punctuation">.</span>child<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            look<span class="token punctuation">.</span>parent <span class="token operator">=</span> look<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
            look<span class="token punctuation">.</span>child <span class="token operator">=</span> look<span class="token punctuation">.</span>child<span class="token operator">-></span>right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>       <span class="token comment">// 如果前两种都不满足，那必然相等</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 打断循环，look.child 就是目标项节点，已找到</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> look<span class="token punctuation">;</span> <span class="token comment">// 返回的是一个结构</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>删除项</strong></p>
<ul>
<li><p><strong>删除项</strong>是最复杂的任务，因为必须<strong>重新连接剩余子树</strong>形成<strong>有效的树</strong></p>
</li>
<li><p><strong>删除节点的子节点情况讨论</strong></p>
<ul>
<li><p><strong>没有子节点</strong></p>
<blockquote>
<p>1、待删除的节点<strong>没有子节点</strong>，这样的节点被称为<strong>叶节点</strong>，这种情况<strong>最简单</strong><br>2、只需要把<strong>父节点的指针</strong>重置为<strong>NULL</strong>，并使用<code>free()</code><strong>释放已删除节点的内存</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%910.png" loading="lazy"></p>
</li>
<li><p><strong>一个子节点</strong></p>
<blockquote>
<p>1、删除带有<strong>一个子节点</strong>的情况<strong>比较复杂</strong>。删除该节点会导致其<strong>子树</strong>与<strong>其他部分</strong>脱离<br>2、为了<strong>修正这种情况</strong>，要把<strong>被删除节点</strong>的<strong>父节点</strong>中<strong>存储该节点的地址</strong>更新为<strong>该节点子树的地址</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%911.png" loading="lazy"></p>
</li>
<li><p><strong>两个子节点</strong></p>
<blockquote>
<p>1、最后一种情况是删除<strong>有两个子树的节点</strong>。<strong>其中一个子树</strong>(如左子树)可以连接在<strong>被删除节点</strong>之前链接的位置，但是<strong>另一个子树</strong>怎么处理？<br>2、牢记树的<strong>基本设计</strong>：<strong>左子树所有项</strong>都在<strong>父节点项</strong>的<strong>前面</strong>，<strong>右子树所有项</strong>都在<strong>父节点项</strong>的<strong>后面</strong>。也就是说，<strong>右子树所有项</strong>都在<strong>左子树所有项</strong>的<strong>后面</strong><br>3、而且，因为该<strong>右子树</strong>曾经是<strong>被删除节点的父节点</strong>的<strong>左子树</strong>中的一部分，所以该<strong>右节点所有项</strong>都在<strong>被删除节点的父节点项</strong>的<strong>前面</strong><br>4、该<strong>右子树的头</strong>的<strong>位置</strong>应该在<strong>被删除节点的父节点</strong>前面，因此要<strong>沿着父节点的左子树向下找</strong>，同时<strong>这些项</strong>又在<strong>被删除节点</strong>的<strong>左子树所有项</strong>后面<br>5、因此要查看<strong>左子树的右支</strong>是否有<strong>新节点的空位</strong>。如果没有，就要沿着<strong>左子树的右支</strong>向下找，<strong>直到找到一个空位</strong></p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%912.png" loading="lazy"></p>
</li>
</ul>
</li>
<li><p><strong>删除项的实现思路</strong></p>
<ul>
<li><p><strong>删除一个节点</strong></p>
<blockquote>
<p>1、<strong>删除节点</strong>要<strong>注意两点</strong>：程序必须标识<strong>待删除节点</strong>的<strong>父节点</strong>；为了<strong>修改指针</strong>，代码必须把该<strong>指针的地址</strong>传给<strong>执行删除任务的函数</strong><br>2、第一点稍后讨论，先<strong>分析第二点</strong>。要修改的<strong>指针</strong>本身是<code>Trnode *</code>类型，即<strong>指向 Trnode 的指针</strong>；由于<strong>该函数的参数</strong>是<strong>该指针的地址</strong>，所以<strong>参数类型</strong>是<code>Trnode **</code>，即<strong>指向指针的指针</strong><br>3、我们分为<strong>三种情况</strong>讨论：<strong>没有左子节点</strong>的节点、<strong>没有右子节点</strong>的节点、<strong>有两个子节点</strong>的节点。其中<strong>前两种情况同时成立</strong>则包含了<strong>两个节点都没有</strong>的情况</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">DeleteNode</span><span class="token punctuation">(</span>Trnode <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span>
<span class="token comment">// ptr 是指向目标节点的父节点指针成员的地址</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        temp <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
        <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>right<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        temp <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
        <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>left<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 被删除的节点有两个子节点</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 找到重新连接右子树的位置</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>left<span class="token punctuation">;</span> temp<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> temp <span class="token operator">=</span> temp<span class="token operator">-></span>right<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        temp<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>right<span class="token punctuation">;</span>
        temp <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
        <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>left<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>删除一个项</strong></p>
<blockquote>
<p>1、剩下的问题是把<strong>一个节点</strong>与<strong>特定项</strong>相<strong>关联</strong>。可以使用<code>SeekItem()</code><strong>函数</strong>来完成<br>2、回忆一下，该函数<strong>返回一个结构</strong>，包含<strong>两个指针</strong>：一个指向<strong>父节点</strong>，一个指向<strong>包含特定项的节点</strong><br>3、然后就可以通过<strong>父节点的指针</strong>获得<strong>相应的地址</strong>传给<code>DeleteNode()</code>函数</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c">bool <span class="token function">DeleteItem</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Pair look<span class="token punctuation">;</span>
    look <span class="token operator">=</span> <span class="token function">SeekItem</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>child <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token function">DeleteNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除根节点</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>parent<span class="token operator">-></span>left <span class="token operator">==</span> look<span class="token punctuation">.</span>child<span class="token punctuation">)</span>
        <span class="token function">DeleteNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>look<span class="token punctuation">.</span>parent<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">DeleteNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>look<span class="token punctuation">.</span>parent<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptree<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>遍历树</strong></p>
<ul>
<li><p><strong>遍历树的实现思路</strong></p>
<blockquote>
<p>1、<strong>遍历树</strong>比遍历链表<strong>更复杂</strong>，因为<strong>每个节点</strong>都有<strong>两个分支</strong>。这种<strong>分支特性</strong>很适合使用<strong>分而治之</strong>的<strong>递归</strong>来处理<br>2、对于<strong>每个节点</strong>，<strong>执行遍历任务</strong>的<strong>函数</strong>都要做<strong>如下工作</strong>：<strong>处理节点中的项</strong>、<strong>处理左子树</strong>(递归调用)、<strong>处理右子树</strong>(递归调用)<br>3、可以把<strong>遍历</strong>分为<strong>两个函数</strong>来完成：<code>Traverse()</code>和<code>InOrder()</code>。注意<code>InOrder()</code>函数<strong>处理左子树</strong>，然后<strong>处理项</strong>，最后<strong>处理右子树</strong>。这种<strong>遍历树的顺序</strong>是按<strong>字母排序</strong>进行的</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>Trnode <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> pfun<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>root<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> pfun<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>ptree<span class="token operator">-></span>root<span class="token punctuation">,</span> pfun<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>清空树</strong></p>
<ul>
<li><p><strong>清空树的实现思路</strong></p>
<blockquote>
<p>1、<strong>清空树</strong>基本上和<strong>遍历树</strong>过程相同，即清空树的代码也要<strong>访问每个节点</strong>，而且要用<code>free()</code><strong>释放内存</strong><br>2、除此之外，还要<strong>重置 Tree 类型结构的成员</strong>，表明<strong>该树为空</strong><br>3、<code>DeleteAll()</code>函数负责<strong>处理 Tree 类型结构</strong>，并把<strong>释放内存</strong>的任务交给<code>DeleteAllNodes()</code>函数</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">DeleteAllNodes</span><span class="token punctuation">(</span>Trnode <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>pright<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        pright <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">DeleteAllNodes</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">DeleteAllNodes</span><span class="token punctuation">(</span>pright<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DeleteAll</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token function">DeleteAllNodes</span><span class="token punctuation">(</span>ptree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptree<span class="token operator">-></span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    ptree<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>完整的实现接口示例</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* tree.c 二叉查找树类型函数的实现 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tree.h"</span></span>

<span class="token comment">//局部数据类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pair</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    Trnode <span class="token operator">*</span>child<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Pair<span class="token punctuation">;</span>

<span class="token comment">// 局部函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>Trnode <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> pfun<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>root<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> pfun<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">DeleteAllNodes</span><span class="token punctuation">(</span>Trnode <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>pright<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        pright <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>
        <span class="token comment">// 递归</span>
        <span class="token function">DeleteAllNodes</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">DeleteAllNodes</span><span class="token punctuation">(</span>pright<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> bool <span class="token function">ToLeft</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>i1<span class="token punctuation">,</span> Item <span class="token operator">*</span>i2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 比对字符串</span>
    <span class="token keyword">int</span> comp1<span class="token punctuation">;</span>
    <span class="token comment">// 比对 petname，如果 i1 的小于 i2 的，则 comp1 小于 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>comp1 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>i1<span class="token operator">-></span>petname<span class="token punctuation">,</span> i2<span class="token operator">-></span>petname<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token comment">// 如果 petname 相同，则比对 petkind 的字符串</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>comp1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>i1<span class="token operator">-></span>petkind<span class="token punctuation">,</span> i2<span class="token operator">-></span>petkind<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> bool <span class="token function">ToRight</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>i1<span class="token punctuation">,</span> Item <span class="token operator">*</span>i2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 比对字符串</span>
    <span class="token keyword">int</span> comp1<span class="token punctuation">;</span>
    <span class="token comment">// 比对 petname，如果 i1 的大于 i2 的，则 comp1 大于 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>comp1 <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>i1<span class="token operator">-></span>petname<span class="token punctuation">,</span> i2<span class="token operator">-></span>petname<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token comment">// 如果 petname 相同，则比对 petkind 的字符串</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>comp1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>i1<span class="token operator">-></span>petkind<span class="token punctuation">,</span> i2<span class="token operator">-></span>petkind<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">AddNode</span><span class="token punctuation">(</span>Trnode <span class="token operator">*</span>new_node<span class="token punctuation">,</span> Trnode <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// ToLeft() 和 ToRight() 判断该左移还是右移</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ToLeft</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>new_node<span class="token operator">-></span>item<span class="token punctuation">,</span> <span class="token operator">&amp;</span>root<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token comment">// 空子树</span>
            root<span class="token operator">-></span>left <span class="token operator">=</span> new_node<span class="token punctuation">;</span>         <span class="token comment">// 在此处添加节点</span>
        <span class="token keyword">else</span>                               <span class="token comment">// 否则</span>
            <span class="token function">AddNode</span><span class="token punctuation">(</span>new_node<span class="token punctuation">,</span> root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继续处理该子树</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ToRight</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>new_node<span class="token operator">-></span>item<span class="token punctuation">,</span> <span class="token operator">&amp;</span>root<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            root<span class="token operator">-></span>right <span class="token operator">=</span> new_node<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">AddNode</span><span class="token punctuation">(</span>new_node<span class="token punctuation">,</span> root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"AddNode() 函数执行错误!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> Trnode <span class="token operator">*</span><span class="token function">MakeNode</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>new_node<span class="token punctuation">;</span>
    new_node <span class="token operator">=</span> <span class="token punctuation">(</span>Trnode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Trnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配内存</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        new_node<span class="token operator">-></span>item <span class="token operator">=</span> <span class="token operator">*</span>pi<span class="token punctuation">;</span>
        new_node<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> new_node<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> Pair <span class="token function">SeekItem</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Pair look<span class="token punctuation">;</span>
    look<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    look<span class="token punctuation">.</span>child <span class="token operator">=</span> ptree<span class="token operator">-></span>root<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>child <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> look<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>child <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ToLeft</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>look<span class="token punctuation">.</span>child<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            look<span class="token punctuation">.</span>parent <span class="token operator">=</span> look<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
            look<span class="token punctuation">.</span>child <span class="token operator">=</span> look<span class="token punctuation">.</span>child<span class="token operator">-></span>left<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ToRight</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>look<span class="token punctuation">.</span>child<span class="token operator">-></span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            look<span class="token punctuation">.</span>parent <span class="token operator">=</span> look<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
            look<span class="token punctuation">.</span>child <span class="token operator">=</span> look<span class="token punctuation">.</span>child<span class="token operator">-></span>right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>       <span class="token comment">// 如果前两种都不满足，那必然相等</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 打断循环，look.child 就是目标项节点，已找到</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> look<span class="token punctuation">;</span> <span class="token comment">// 返回的是一个结构</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">DeleteNode</span><span class="token punctuation">(</span>Trnode <span class="token operator">*</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span>
<span class="token comment">// ptr 是指向目标节点的父节点指针成员的地址</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        temp <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
        <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>right<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        temp <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
        <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>left<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 被删除的节点有两个子节点</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 找到重新连接右子树的位置</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>left<span class="token punctuation">;</span> temp<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> temp <span class="token operator">=</span> temp<span class="token operator">-></span>right<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        temp<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>right<span class="token punctuation">;</span>
        temp <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
        <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>left<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 实现功能函数</span>
<span class="token keyword">void</span> <span class="token function">InitializeTree</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    ptree<span class="token operator">-></span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    ptree<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">TreeIsEmpty</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptree<span class="token operator">-></span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">TreeIsFull</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptree<span class="token operator">-></span>size <span class="token operator">==</span> MAXITEMS<span class="token punctuation">)</span>
        <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">TreeItemCount</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> ptree<span class="token operator">-></span>size<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">AddItem</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Trnode <span class="token operator">*</span>new_node<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TreeIsFull</span><span class="token punctuation">(</span>ptree<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"树已满!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">SeekItem</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> ptree<span class="token punctuation">)</span><span class="token punctuation">.</span>child <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"添加的项重复!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    new_node <span class="token operator">=</span> <span class="token function">MakeNode</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指向新节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"无法分配内存!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 成功创建了一个新节点</span>
    ptree<span class="token operator">-></span>size<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptree<span class="token operator">-></span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token comment">// 如果根为空</span>
        ptree<span class="token operator">-></span>root <span class="token operator">=</span> new_node<span class="token punctuation">;</span>         <span class="token comment">// 则这是第一个项，令根节点指向该节点</span>
    <span class="token keyword">else</span>                                <span class="token comment">// 否则</span>
        <span class="token function">AddNode</span><span class="token punctuation">(</span>new_node<span class="token punctuation">,</span> ptree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在树中添加节点</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">InTree</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">SeekItem</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> ptree<span class="token punctuation">)</span><span class="token punctuation">.</span>child <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">?</span> false <span class="token operator">:</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

bool <span class="token function">DeleteItem</span><span class="token punctuation">(</span>Item <span class="token operator">*</span>pi<span class="token punctuation">,</span> Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Pair look<span class="token punctuation">;</span>
    look <span class="token operator">=</span> <span class="token function">SeekItem</span><span class="token punctuation">(</span>pi<span class="token punctuation">,</span> ptree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>child <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token function">DeleteNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ptree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除根节点</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>look<span class="token punctuation">.</span>parent<span class="token operator">-></span>left <span class="token operator">==</span> look<span class="token punctuation">.</span>child<span class="token punctuation">)</span>
        <span class="token function">DeleteNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>look<span class="token punctuation">.</span>parent<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">DeleteNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>look<span class="token punctuation">.</span>parent<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptree<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfun<span class="token punctuation">)</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token function">InOrder</span><span class="token punctuation">(</span>ptree<span class="token operator">-></span>root<span class="token punctuation">,</span> pfun<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">DeleteAll</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>ptree<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token function">DeleteAllNodes</span><span class="token punctuation">(</span>ptree<span class="token operator">-></span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptree<span class="token operator">-></span>root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    ptree<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ul>
</li>
<li><p><strong>使用接口</strong>(实现宠物俱乐部花名册)</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* petclub.c 使用二叉树接口 */</span>
<span class="token comment">/* 与 tree.c 一起编译 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctype.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tree.h"</span></span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">s_gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ret_val<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ret_val <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_val<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\0'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
            str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret_val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 将字符串转换为大写</span>
<span class="token keyword">void</span> <span class="token function">uppercase</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        str<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 打印成员</span>
<span class="token keyword">void</span> <span class="token function">printitem</span><span class="token punctuation">(</span>Item item<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"宠物：%-19s 品种：%-19s\n"</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span>petname<span class="token punctuation">,</span> item<span class="token punctuation">.</span>petkind<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">char</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> ch<span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\n宠物俱乐部成员程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入对应字母选择功能："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"a) 添加一只宠物      l) 显示宠物菜单"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"n) 显示宠物数量      f) 查找宠物"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"d) 删除一只宠物      q) 退出程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 处理输入队列多余内容</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        ch <span class="token operator">=</span> <span class="token function">tolower</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 统一转换为小写</span>
        <span class="token comment">// strchr() 确定 "alfndq" 中是否包含 ch 对应字符，并返回对应位置指针，如果不包含则返回 NULL</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strchr</span><span class="token punctuation">(</span><span class="token string">"alfndq"</span><span class="token punctuation">,</span> ch<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"请输入a,l,f,n,d,q："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>
        ch <span class="token operator">=</span> <span class="token char">'q'</span><span class="token punctuation">;</span> <span class="token comment">// 退出程序</span>
    <span class="token keyword">return</span> ch<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">addpet</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Item temp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TreeIsFull</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"俱乐部成员已满！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入宠物的名字："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petname<span class="token punctuation">,</span> SLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入宠物的品种："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petkind<span class="token punctuation">,</span> SLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">uppercase</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petname<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">uppercase</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petkind<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">AddItem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">showpets</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TreeIsEmpty</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"没有成员！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">Traverse</span><span class="token punctuation">(</span>pt<span class="token punctuation">,</span> printitem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">findpet</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Item temp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TreeIsEmpty</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"没有成员！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 退出函数</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入要查找的宠物名称："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petname<span class="token punctuation">,</span> SLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入该宠物的品种："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petkind<span class="token punctuation">,</span> SLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">uppercase</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petname<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">uppercase</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petkind<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s(%s) "</span><span class="token punctuation">,</span> temp<span class="token punctuation">.</span>petname<span class="token punctuation">,</span> temp<span class="token punctuation">.</span>petkind<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">InTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"已在俱乐部中\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不在俱乐部中\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">droppet</span><span class="token punctuation">(</span>Tree <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Item temp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TreeIsEmpty</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"没有成员！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 退出函数</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入要删除的宠物名称："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petname<span class="token punctuation">,</span> SLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"输入该宠物的品种："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">s_gets</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petkind<span class="token punctuation">,</span> SLEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">uppercase</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petname<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">uppercase</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>petkind<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s(%s) "</span><span class="token punctuation">,</span> temp<span class="token punctuation">.</span>petname<span class="token punctuation">,</span> temp<span class="token punctuation">.</span>petkind<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">DeleteItem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> pt<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"已经删除\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"本就不在俱乐部中\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Tree pets<span class="token punctuation">;</span>
    <span class="token keyword">char</span> choice<span class="token punctuation">;</span>

    <span class="token function">InitializeTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pets<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>choice <span class="token operator">=</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'q'</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>choice<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> <span class="token char">'a'</span><span class="token operator">:</span>
            <span class="token function">addpet</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pets<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token char">'l'</span><span class="token operator">:</span>
            <span class="token function">showpets</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pets<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token char">'f'</span><span class="token operator">:</span>
            <span class="token function">findpet</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pets<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token char">'n'</span><span class="token operator">:</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"俱乐部中共有 %d 只宠物\n"</span><span class="token punctuation">,</span> <span class="token function">TreeItemCount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pets<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token char">'d'</span><span class="token operator">:</span>
            <span class="token function">droppet</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pets<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"switch() 执行错误！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">DeleteAll</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pets<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"已成功释放内存，运行结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p><strong>树的思想</strong></p>
<ul>
<li><p><strong>二叉查找树的缺陷</strong></p>
<blockquote>
<p>1、<strong>二叉查找树</strong>也有<strong>一些缺陷</strong>。例如<strong>二叉查找树</strong>只有在<strong>满员</strong>(或平衡)时<strong>效率最高</strong><br>2、假设用户<strong>按字母顺序输入</strong>数据，那么<strong>每个新节点</strong>都应该被<strong>添加到右边</strong>(如下图)，查找这种<strong>不平衡的树</strong>并不比查找<strong>链表</strong>要快</p>
</blockquote>
<p><img src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8D%E5%B9%B3%E8%A1%A1.png" loading="lazy"></p>
</li>
<li><p><strong>避免串状树</strong></p>
<blockquote>
<p>1、避免<strong>串状树</strong>的方法之一是在<strong>创建树时多加注意</strong>。如果<strong>树或子树</strong>的<strong>一边或另一边</strong>不太平衡，就需要<strong>重新排列节点</strong>使之恢复平衡。与此类似，可能在<strong>进行删除操作</strong>后也要<strong>重新排列树</strong><br>2、德国数学家 Adel’son-Vel’skii 和 Landis <strong>发明了一种算法</strong>来解决这个问题，根据他们的算法<strong>创建的树</strong>称为<strong>AVL 树</strong><br>3、因为要<strong>重构</strong>，所以<strong>创建一个平衡的树</strong>要<strong>花费更多时间</strong>，但这样的树可以<strong>确保搜索效率最大化</strong></p>
</blockquote>
</li>
<li><p><strong>存储相同项的思路</strong></p>
<blockquote>
<p>1、你可能需要一个<strong>能存储相同项</strong>的<strong>二叉查找树</strong>。例如在分析文本时，统计<strong>某个单词出现的次数</strong><br>2、一种方法是把 <strong>Item</strong> 定义为包含<strong>一个单词</strong>和<strong>一个数字</strong>的结构。<strong>第一次遇到</strong>这个单词时将其<strong>添加到树中</strong>，并且该单词<strong>计数器+1</strong>；<strong>下一次遇到</strong>时直接<strong>找到该节点</strong>并<strong>递增计数器</strong>。使用这种方法<strong>修改二叉查找树的特性</strong>，并不费多少功夫</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h3><hr>
<div class="success">

<blockquote>
<p><strong>章节概要</strong>：C 运算符；ANSI C 库函数、宏和类型；拓展整数类型<code>inttypes.h</code>；拓展字符支持</p>
</blockquote>
</div>

<h4 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C 运算符"></a><strong>C 运算符</strong></h4><ul>
<li><p><strong>运算符优先级</strong></p>
<table>
<thead>
<tr>
<th>运算符(优先级从高至低)</th>
<th align="center">结合律</th>
</tr>
</thead>
<tbody><tr>
<td>++(后缀) –(后缀) ()(函数调用) [] {}(复合字面量) . -&gt;</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>++(前缀) –(前缀) -(负号) +(正号) *(解引用) &amp;(取址) ~(按位取反) !(逻辑非) sizeof _Alignof(类型名)</td>
<td align="center">从右往左</td>
</tr>
<tr>
<td>(类型名)(强制类型转换)</td>
<td align="center">从右往左</td>
</tr>
<tr>
<td>* &#x2F; %</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>+(加) -(减)</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt;</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>&lt; &gt; &lt;&#x3D; &gt;&#x3D;</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>&#x3D;&#x3D; !&#x3D;</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>&amp;</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>^</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>|</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>||</td>
<td align="center">从左往右</td>
</tr>
<tr>
<td>?:(条件(三目)运算符)</td>
<td align="center">从右往左</td>
</tr>
<tr>
<td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; |&#x3D; ^&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;</td>
<td align="center">从右往左</td>
</tr>
<tr>
<td>,(逗号运算符)</td>
<td align="center">从左往右</td>
</tr>
</tbody></table>
</li>
<li><p><strong>算术运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">算术运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td>把右边的值加到左边的值上</td>
</tr>
<tr>
<td align="center">+</td>
<td>作为一元运算符，生成一个大小和符号都与右边值相同的值</td>
</tr>
<tr>
<td align="center">-</td>
<td>从左边的值中减去右边的值</td>
</tr>
<tr>
<td align="center">-</td>
<td>作为一元运算符，生成一个与右边值大小相等符号相反的值</td>
</tr>
<tr>
<td align="center">*</td>
<td>把左边的值乘以右边的值</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td>把左边的值除以右边的值；如果两个运算对象都是整数，其结果要被截断</td>
</tr>
<tr>
<td align="center">%</td>
<td>得左边值除以右边值时的余数</td>
</tr>
<tr>
<td align="center">++</td>
<td>++把右边变量的值加 1(前缀模式)，或把左边变量的值加 1(后缀模式)</td>
</tr>
<tr>
<td align="center">–</td>
<td>–把右边变量的值减 1(前缀模式)，或把左边变量的值减 1(后缀模式)</td>
</tr>
</tbody></table>
</li>
<li><p><strong>关系运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">关系运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;</td>
<td>小于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td>大于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td align="center">&#x3D;&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td>不等于</td>
</tr>
</tbody></table>
</li>
<li><p><strong>赋值(复合)运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">赋值(复合)运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td>把它右边的值赋给其左边的左值</td>
</tr>
<tr>
<td align="center">+&#x3D;</td>
<td>把左边的变量加上右边的量，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">-&#x3D;</td>
<td>从左边的变量中减去右边的量，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">*&#x3D;</td>
<td>把左边的变量乘以右边的量，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">&#x2F;&#x3D;</td>
<td>把左边的变量除以右边的量，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">%&#x3D;</td>
<td>得到左边量除以右边量的余数，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">&amp;&#x3D;</td>
<td>把 L &amp; R 的值赋给左边的量，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">|&#x3D;</td>
<td>把 L | R 的值赋给左边的量，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">^&#x3D;</td>
<td>把 L ^ R 的值赋给左边的量，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">&gt;&gt;&#x3D;</td>
<td>把 L &gt;&gt; R 的值赋给左边的量，并把结果存储在左边的变量中</td>
</tr>
<tr>
<td align="center">&lt;&lt;&#x3D;</td>
<td>把 L &lt;&lt; R 的值赋给左边的量，并把结果存储在左边的变量中</td>
</tr>
</tbody></table>
</li>
<li><p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">逻辑运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td align="center">||</td>
<td>逻辑或</td>
</tr>
<tr>
<td align="center">!</td>
<td>逻辑非</td>
</tr>
</tbody></table>
</li>
<li><p><strong>按位运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">按位运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">~(按位取反)</td>
<td>它通过翻转运算对象的每一位得到一个值</td>
</tr>
<tr>
<td align="center">&amp;(按位与)</td>
<td>只有当两个运算对象中对应的位都为 1 时，它生成的值中对应的位才为 1</td>
</tr>
<tr>
<td align="center">|(按位或)</td>
<td>只要两个运算对象中对应的位有一位为 1，它生成的值中对应的位就为 1</td>
</tr>
<tr>
<td align="center">^(按位异或)</td>
<td>只有两个运算对象中对应的位中只有一位为 1(不能全为 1)，它生成的值中对应的位才为 1</td>
</tr>
<tr>
<td align="center">&lt;&lt;(左移运算符)</td>
<td>把左边运算对象中的位向左移动得到一个值。移动的位数由该运算符右边的运算对象确定，空出的位用 0 填充</td>
</tr>
<tr>
<td align="center">&gt;&gt;(右移运算符)</td>
<td>把左边运算对象中的位向右移动得到一个值。移动的位数由该运算符右边的运算对象确定，空出的位用 0 填充</td>
</tr>
</tbody></table>
</li>
<li><p><strong>条件(三目)运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">条件(三目)运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(关系表达式)?(语句 1):(语句 2)</td>
<td>如果关系表达式为真，则执行语句 1，否则执行语句 2</td>
</tr>
</tbody></table>
</li>
<li><p><strong>指针有关运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">指针有关运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;(地址运算符)</td>
<td>给出后面变量的地址</td>
</tr>
<tr>
<td align="center">*(间接运算符、解引用运算符)</td>
<td>给出后面指针指向地址的值</td>
</tr>
</tbody></table>
</li>
<li><p><strong>结构和联合运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">结构和联合运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.(成员运算符)</td>
<td>name.member 获取 name 结构中的 member 成员</td>
</tr>
<tr>
<td align="center">-&gt;(间接成员运算符、结构指针运算符)</td>
<td>ptrname-&gt;member 获取 ptrname 所指向结构中的 member 成员</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="ANSI-C-库函数、宏和类型"><a href="#ANSI-C-库函数、宏和类型" class="headerlink" title="ANSI C 库函数、宏和类型"></a><strong>ANSI C 库函数、宏和类型</strong></h4><ul>
<li><p><strong>断言</strong><code>assert.h</code></p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void assert (int exprs);</td>
<td>如果 exprs 为真，宏什么也不做。如果 exprs 为假，assert()就显示该表达式和其所在的行号和文件名。然后，assert()调用 abort()</td>
</tr>
<tr>
<td>static_assert</td>
<td>展开为 _Static_assert。其中 _Static_assert(常量表达式,字符串字面量) 如果常量表达式为假，编译器给出包含字符串字面量的错误信息(C11)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>复数</strong><code>complex.h</code>(C99)</p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>complex</td>
<td>展开为类型关键字_Complex</td>
</tr>
<tr>
<td>_Complex_I</td>
<td>展开为 const float _Complex 类型的表达式，其值的平方为-1</td>
</tr>
<tr>
<td>imaginary</td>
<td>如果支持虚数类型，展开为类型关键字_Imaginary</td>
</tr>
<tr>
<td>_Imaginary_I</td>
<td>如果支持虚数类型，展开为 const float _Imaginary 类型的表达式，其值的平方为-1</td>
</tr>
<tr>
<td>I</td>
<td>展开为_Complex_I 或_Imaginary_I</td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong>(另有 float 和 long double 版本，在函数名后加上 f 或 l 即可切换，角度的单位是弧度)</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double complex cacos(double complex z);</td>
<td>返回 z 的复数反余弦</td>
</tr>
<tr>
<td>double complex casin(double complex z);</td>
<td>返回 z 的复数反正弦</td>
</tr>
<tr>
<td>double complex catan (double complex z);</td>
<td>返回 z 的复数反正切</td>
</tr>
<tr>
<td>double complex ccos (double complex z);</td>
<td>返回 z 的复数余弦</td>
</tr>
<tr>
<td>double complex csin(double complex z);</td>
<td>返回 z 的复数正弦</td>
</tr>
<tr>
<td>double complex ctan(double complex z);</td>
<td>返回 z 的复数正切</td>
</tr>
<tr>
<td>double complex cacosh(double complex z);</td>
<td>返回 z 的复数反双曲余弦</td>
</tr>
<tr>
<td>double complex casinh(double complex z);</td>
<td>返回 z 的复数反双曲正弦</td>
</tr>
<tr>
<td>double complex catanh (double complex z);</td>
<td>返回 z 的复数反双曲正切</td>
</tr>
<tr>
<td>double complex ccosh(double complex z);</td>
<td>返回 z 的复数双曲余弦</td>
</tr>
<tr>
<td>double complex csinh(double complex z);</td>
<td>返回 z 的复数双曲正弦</td>
</tr>
<tr>
<td>double complex ctanh (double complex z);</td>
<td>返回 z 的复数双曲正切</td>
</tr>
<tr>
<td>double complex cexp(double complex z);</td>
<td>返回 e 的 z 次幂复数值</td>
</tr>
<tr>
<td>double complex clog(double complex z);</td>
<td>返回 z 的自然对数(以 e 为底)的复数值</td>
</tr>
<tr>
<td>double cabs(double complex z);</td>
<td>返回 z 的绝对值(或大小)</td>
</tr>
<tr>
<td>double complex cpows (double complex z,double complex y);</td>
<td>返回 z 的 y 次幂</td>
</tr>
<tr>
<td>double complex csqrt (double complex z);</td>
<td>返回 z 的复数平方根</td>
</tr>
<tr>
<td>double carg(double complex z);</td>
<td>以孤度为单位返回 z 的相位角(或幅角)</td>
</tr>
<tr>
<td>double cimag(double complex z);</td>
<td>以实数形式返回 z 的虚部</td>
</tr>
<tr>
<td>double complex conj(double complex z);</td>
<td>返回 z 的共轭复数</td>
</tr>
<tr>
<td>double complex cproj(double complex z);</td>
<td>返回 z 在黎曼球面上的投影</td>
</tr>
<tr>
<td>double complex CMPLX(double x,double y);</td>
<td>返回实部为 x、虚部为 y 的复数(C11)</td>
</tr>
<tr>
<td>double creal(double complex z);</td>
<td>以实数形式返回 z 的实部</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>字符处理</strong><code>ctype.h</code></p>
<ul>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int isalnum(int c);</td>
<td>如果 c 是字母或数字，则返回真</td>
</tr>
<tr>
<td>int isalpha(int c);</td>
<td>如果 c 是字母，则返回真</td>
</tr>
<tr>
<td>int isblank(int c);</td>
<td>如果 c 是空格或水平制表符，则返回真(C99)</td>
</tr>
<tr>
<td>int iscntrl(int c);</td>
<td>如果 c 是控制字符（如 Ctr1+B),则返回真</td>
</tr>
<tr>
<td>int isdigit(int c);</td>
<td>如果 c 是数字，则返回真</td>
</tr>
<tr>
<td>int isgraph(int c);</td>
<td>如果 c 是非空格打印字符，则返回真</td>
</tr>
<tr>
<td>int islower(int c);</td>
<td>如果 c 是小写字符，则返回真</td>
</tr>
<tr>
<td>int isprint(int c);</td>
<td>如果 c 是打印字符，则返回真</td>
</tr>
<tr>
<td>int ispunct(int c);</td>
<td>如果 c 是标点字符（除了空格、字母、数字以外的字符），则返回真</td>
</tr>
<tr>
<td>int isspace(int c);</td>
<td>如果 c 是空白字符（空格、换行符、换页符、回车符、垂直或水平制表符，或者其他实现定义的字符)，则返回真</td>
</tr>
<tr>
<td>int isxdigit(int c);</td>
<td>如果 C 是十六进制数字字符，则返回真</td>
</tr>
<tr>
<td>int isupper(int c);</td>
<td>如果 c 是大写字符，则返回真</td>
</tr>
<tr>
<td>int tolower(int c);</td>
<td>如果 c 是大写字符，则返回其小写字符；否则返回 c</td>
</tr>
<tr>
<td>int toupper(int c);</td>
<td>如果 c 是小写字符，则返回其大写字符；否则返回 c</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>错误报告</strong><code>errno.h</code></p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EDOM</td>
<td>函数调用中的域错误(参数越界)</td>
</tr>
<tr>
<td>ERANGE</td>
<td>函数返回值的范围错误(返回值越界)</td>
</tr>
<tr>
<td>EILSEQ</td>
<td>宽字符转换错误</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>浮点环境</strong><code>fenv.h</code>(C99)</p>
<ul>
<li><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>表示</th>
</tr>
</thead>
<tbody><tr>
<td>fenv_t</td>
<td>整个浮点环境</td>
</tr>
<tr>
<td>fexcept_t</td>
<td>浮点状态标志集合</td>
</tr>
</tbody></table>
</li>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>标准异常宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FE_DIVBYZERO</td>
<td>抛出被零除异常</td>
</tr>
<tr>
<td>FE_INEXACT</td>
<td>抛出不精确值异常</td>
</tr>
<tr>
<td>FE_INVALID</td>
<td>抛出无效值异常</td>
</tr>
<tr>
<td>FE_OVERFLOW</td>
<td>抛出上溢异常</td>
</tr>
<tr>
<td>FE_UNDERFLOW</td>
<td>抛出下溢异常</td>
</tr>
<tr>
<td>FE_ALL_EXCEPT</td>
<td>实现支持的所有浮点异常的按位或</td>
</tr>
<tr>
<td>FE_DOWNWARD</td>
<td>向下舍入</td>
</tr>
<tr>
<td>FE_TONEAREST</td>
<td>向最近的舍入</td>
</tr>
<tr>
<td>FE_TOWARDZERO</td>
<td>趋 0 舍入</td>
</tr>
<tr>
<td>FE_UPWARD</td>
<td>向上舍入</td>
</tr>
<tr>
<td>FE_DFL_ENV</td>
<td>表示默认环境，类型是 const fenv_t *</td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void feclearexcept(int excepts);</td>
<td>清理 excepts 表示的异常</td>
</tr>
<tr>
<td>void fegetexceptflag(fexcept_t *flagp,int excepts);</td>
<td>把 excepts 指明的浮点状态标志存储在 flagp 指向的对象中</td>
</tr>
<tr>
<td>void feraiseexcept (int excepts);</td>
<td>抛出 excepts 指定的异常</td>
</tr>
<tr>
<td>void fesetexceptflag(const fexcept_t *flagp,int excepts);</td>
<td>把 excepts 指明的浮点状态标志设置为 flagp 的值；在此之前，fegetexceptflag()调用应该设置 flagp 的值</td>
</tr>
<tr>
<td>int fetestexcept (int excepts);</td>
<td>测试 excepts 指定的状态标志；该函数返回指定状态标志的按位或</td>
</tr>
<tr>
<td>int fegetround (void);</td>
<td>返回当前的舍入方向</td>
</tr>
<tr>
<td>int fesetround(int round);</td>
<td>把舍入方向设置为 round 的值；当且仅当设置成功时，函数返回 0</td>
</tr>
<tr>
<td>void fegetenv (fenv_t *envp);</td>
<td>把当前环境存储至 envp 指向的位置中</td>
</tr>
<tr>
<td>int feholdexcept (fenv_t *envp);</td>
<td>把当前浮点环境存储至 envp 指向的位置中，清除浮点状态标志，然后如果可能的话就设置非停模式(nonstop mode).,在这种模式中即使发生异常也继续执行。当且仅当执行成功时，函数返回 0</td>
</tr>
<tr>
<td>void fesetenv(const fenv_t *envp);</td>
<td>建立 envp 表示的浮点环境；envp 应指向一个之前通过调用 fegetenv()、feholdexcept()或浮点环境宏设置的数据对象</td>
</tr>
<tr>
<td>void feupdateenv(const fenv_t *envp);</td>
<td>函数在自动存储区中存储当前抛出的异常，建立 envp 指向的对象表示的浮点环境，然后抛出已存储的浮点异常；envp 应指向一个之前通过调用 fegetenv()、feholdexcept()或浮点环境宏设置的数据对象</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>浮点特性</strong><code>float.h</code></p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FLT_ROUNDS</td>
<td>默认舍入方案</td>
</tr>
<tr>
<td>FLT_EVAL_METHOD</td>
<td>浮点表达式求值的默认方案</td>
</tr>
<tr>
<td>FLT_HAS_SUBNORM</td>
<td>存在或缺少 float 类型的反常值</td>
</tr>
<tr>
<td>DBL_HAS_SUBNORM</td>
<td>存在或缺少 double 类型的反常值</td>
</tr>
<tr>
<td>LDBL_HAS_SUBNORM</td>
<td>存在或缺少 long double 类型的反常值</td>
</tr>
<tr>
<td>FLT_RADIX</td>
<td>指数表示法中使用的进制数(b),最小值为 2</td>
</tr>
<tr>
<td>FLT_MANT_DIG</td>
<td>以 FLT_RADIX 进制表示的 float 类型数的位数(模型中的 p)</td>
</tr>
<tr>
<td>DBL_MANT_DIG</td>
<td>以 FLT_RADIX 进制表示的 double 类型数的位数(模型中的 p)</td>
</tr>
<tr>
<td>LDBL_MANT_DIG</td>
<td>以 FLT_RADIX 进制表示的 long double 类型数的位数(模型中的 p)</td>
</tr>
<tr>
<td>FLT_DECIMAL_DIG</td>
<td>在 b 进制和十进制相互转换不损失精度的前提下，float 类型的十进制数的位数(最小值是 6)</td>
</tr>
<tr>
<td>DBL_DECIMAL_DIG</td>
<td>在 b 进制和十进制相互转换不损失精度的前提下，double 类型的十进制数的位数(最小值是 10)</td>
</tr>
<tr>
<td>LDBL_DECIMAL_DIG</td>
<td>在 b 进制和十进制相互转换不损失精度的前提下，long double 类型的十进制数的位数(最小值是 10)</td>
</tr>
<tr>
<td>DECIMAL_DIG</td>
<td>在 b 进制与十进制相互转换不损失精度的前提下，浮点类型十进制数的最大个数(最小值为 10)</td>
</tr>
<tr>
<td>FLT_DIG</td>
<td>在不损失精度的前提下，float 类型可表示的十进制数位数(最小值为 6)</td>
</tr>
<tr>
<td>DBL_DIG</td>
<td>在不损失精度的前提下，double 类型可表示的十进制数位数(最小值为 10)</td>
</tr>
<tr>
<td>LDBL_DIG</td>
<td>在不损失精度的前提下，long double 类型可表示的十进制数位数(最小值为 10)</td>
</tr>
<tr>
<td>FLT_MIN_EXP</td>
<td>float 类型 e 表示法，指数的最小负正整数值</td>
</tr>
<tr>
<td>DBL_MIN_EXP</td>
<td>double 类型 e 表示法，指数的最小负正整数值</td>
</tr>
<tr>
<td>LDBL_MIN_EXP</td>
<td>long double 类型 e 表示法，指数的最小负正整数值</td>
</tr>
<tr>
<td>FLT_MIN_10_EXP</td>
<td>用 10 的 x 次幂表示规范化 float 类型数时，x 的最小负整数值(不超过-37)</td>
</tr>
<tr>
<td>DBL_MIN_10_EXP</td>
<td>用 10 的 x 次幂表示规范化 double 类型数时，x 的最小负整数值(不超过-37)</td>
</tr>
<tr>
<td>LDBL_MIN_10_EXP</td>
<td>用 10 的 x 次幂表示规范化 long double 类型数时，x 的最小负整数值(不超过-37)</td>
</tr>
<tr>
<td>FLT_MAX_EXP</td>
<td>float 类型 e 表示法，指数的最大正整数值</td>
</tr>
<tr>
<td>DBL_MAX_EXP</td>
<td>double 类型 e 表示法，指数的最大正整数值</td>
</tr>
<tr>
<td>LDBL_MAX_EXP</td>
<td>long double 类型 e 表示法，指数的最大正整数值</td>
</tr>
<tr>
<td>FLT_MAX_10_EXP</td>
<td>用 10 的 x 次幂表示规范化 float 类型数时，x 的最大正整数值(至少+37)</td>
</tr>
<tr>
<td>DBL_MAX_10_EXP</td>
<td>用 10 的 x 次幂表示规范化 double 类型数时，x 的最大正整数值(至少+37)</td>
</tr>
<tr>
<td>LDBL_MAX_10_EXP</td>
<td>用 10 的 x 次幂表示规范化 long double 类型数时，x 的最大正整数值(至少+37)</td>
</tr>
<tr>
<td>FLT_MAX</td>
<td>float 类型的最大有限值(至少 1E+37)</td>
</tr>
<tr>
<td>DBL_MAX</td>
<td>double 类型的最大有限值(至少 1E+37)</td>
</tr>
<tr>
<td>LDBL_MAX</td>
<td>long double 类型的最大有限值(至少 1E+37)</td>
</tr>
<tr>
<td>FLT_EPSILON</td>
<td>float 类型比 1 大的最小值与 1 的差值(不超过 1E-9)</td>
</tr>
<tr>
<td>DBL_EPSILON</td>
<td>double 类型比 1 大的最小值与 1 的差值(不超过 1E-9)</td>
</tr>
<tr>
<td>LDBL_EPSILON</td>
<td>long double 类型比 1 大的最小值与 1 的差值(不超过 1E-9)</td>
</tr>
<tr>
<td>FLT_MIN</td>
<td>标准化 float 类型的最小正值(不超过 1E-37)</td>
</tr>
<tr>
<td>DBL_MIN</td>
<td>标准化 double 类型的最小正值(不超过 1E-37)</td>
</tr>
<tr>
<td>LDBL_MIN</td>
<td>标准化 long double 类型的最小正值(不超过 1E-37)</td>
</tr>
<tr>
<td>FLT_TRUE_MIN</td>
<td>float 类型的最小正值(不超过 1E-37)</td>
</tr>
<tr>
<td>DBL_TRUE_MIN</td>
<td>double 类型的最小正值(不超过 1E-37)</td>
</tr>
<tr>
<td>LDBL_TRUE_MIN</td>
<td>long double 类型的最小正值(不超过 1E-37)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>整型格式转换</strong><code>inttypes.h</code></p>
<ul>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>intmax_t imaxabs(intmax_t j);</td>
<td>返回 j 的绝对值</td>
</tr>
<tr>
<td>imaxdiv_t imaxdiv(intmax_t numer,intmax_t denom);</td>
<td>单独计算 numer&#x2F;denom 的商和余数，并把两个计算结果存储在返回的结构中</td>
</tr>
<tr>
<td>intmax_t strtoimax(const char *restrict nptr,char **restrict endptr,int base);</td>
<td>相当于 strtol()函数，但是该函数把字符串转换成 intmax_t 类型并返回该值</td>
</tr>
<tr>
<td>uintmax_t strtoumax(const char *restrict nptr,char **restrict endptr,int base);</td>
<td>相当于 strtoul()函数，但是该函数把字符串转换成 intmax_t 类型并返回该值</td>
</tr>
<tr>
<td>intmax_t wcstoimax(const wchar_t *restrict nptr,wchar_t **restrict endptr,int base);</td>
<td>strtoimax()函数的 wchar_t 类型的版本</td>
</tr>
<tr>
<td>uintmax_t wcstoumax(const wchar_t *restrict nptr,wchar_t **restrict endptr,int base);</td>
<td>strtoumax()函数的 wchar_t 类型的版本</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>可选拼写</strong><code>iso646.h</code></p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th align="center">宏</th>
<th align="center">运算符</th>
<th align="center">宏</th>
<th align="center">运算符</th>
<th align="center">宏</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">and</td>
<td align="center">&amp;&amp;</td>
<td align="center">or_eq</td>
<td align="center">|&#x3D;</td>
<td align="center">bitor</td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">||</td>
<td align="center">not</td>
<td align="center">!&#x3D;</td>
<td align="center">xor</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">not</td>
<td align="center">!</td>
<td align="center">compl</td>
<td align="center">~</td>
<td align="center">xor_eq</td>
<td align="center">^&#x3D;</td>
</tr>
<tr>
<td align="center">and_eq</td>
<td align="center">&amp;&#x3D;</td>
<td align="center">bitand</td>
<td align="center">&amp;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>本地化</strong><code>locale.h</code></p>
<ul>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>char *setlocale(int category, const char *locale);</td>
<td>该函数把某些值设置为本地和 locale 指定的值。category 的值决定要设置哪些本地值(后附)。如果成功设置本地化，该函数将返回一个在新本地化中与指定类别相关联的指针；如果不能完成本地化请求，则返回空指针</td>
</tr>
<tr>
<td>struct lconv *localeconv(void);</td>
<td>返回一个指向 struct lconv 类型结构(后附)的指针，该结构中存储着当前的本地值</td>
</tr>
</tbody></table>
</li>
<li><p><strong>category 宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>本地化设置不变，返回指向当前本地化的指针</td>
</tr>
<tr>
<td>LC_ALL</td>
<td>改变所有的本地值</td>
</tr>
<tr>
<td>LC_COLLATE</td>
<td>改变 strcoll()和 strxfrm()所用的排列顺序的本地值</td>
</tr>
<tr>
<td>LC_CTYPE</td>
<td>改变字符处理函数和多字节函数的本地值</td>
</tr>
<tr>
<td>LC_MONETARY</td>
<td>改变货币格式信息的本地值</td>
</tr>
<tr>
<td>LC_NUMERIC</td>
<td>改变十进制小数点符号和格式化 I&#x2F;O 使用的非货币格式本地值</td>
</tr>
<tr>
<td>LC_TIME</td>
<td>改变 strftime()所用的时间格式本地值</td>
</tr>
</tbody></table>
</li>
<li><p><strong>struct lconv 成员</strong></p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>char *decimal_point</td>
<td>非货币值的小数点字符</td>
</tr>
<tr>
<td>char *thousands_sep</td>
<td>非货币值中小数点前面的千位分隔符</td>
</tr>
<tr>
<td>char *grouping</td>
<td>一个字符串，表示非货币量中每组数字的大小</td>
</tr>
<tr>
<td>char *int_curr_symbol</td>
<td>国际货币符号</td>
</tr>
<tr>
<td>char *currency_symbol</td>
<td>本地货币符号</td>
</tr>
<tr>
<td>char *mon_decimal_point</td>
<td>贷币值的小数点符号</td>
</tr>
<tr>
<td>char *mon_thousands_sep</td>
<td>货币值的千位分隔符</td>
</tr>
<tr>
<td>char *mon_grouping</td>
<td>一个字符串，表示货币量中每组数字的大小</td>
</tr>
<tr>
<td>char *positive_sign</td>
<td>指明非负格式化货币值的字符串</td>
</tr>
<tr>
<td>char *negative_sign</td>
<td>指明负格式化货币值的字符串</td>
</tr>
<tr>
<td>char int_frac_digits</td>
<td>国际格式化货币值中，小数点后面的数字个数</td>
</tr>
<tr>
<td>char frac_digits</td>
<td>本地格式化货币值中，小数点后面的数字个数</td>
</tr>
<tr>
<td>char p_cs_precedes</td>
<td>如果该值为 1，则 currency_symbol 在非负格式化货币值的前面；如果该值为 0，则 currency_symbol 在非负格式化货币值的后面</td>
</tr>
<tr>
<td>char p_sep_by_space</td>
<td>如果该值为 1，则用空格把 currency_symbol 和非负格式化货币值隔开；如果该值为 0，则不用空格分隔 currency_symbol 和非负格式化货币值</td>
</tr>
<tr>
<td>char n_cs_precedes</td>
<td>如果该值为 1,则 currency_symbol 在负格式化货币值的前面；如果该值为 0，则 currency_symbol 在负格式化货币值的后面</td>
</tr>
<tr>
<td>char n_sep_by_space</td>
<td>如果该值为 1，则用空格把 currency_symbol 和负格式化货币值隔开；如果该值为 O,则不用空格分隔 currency_symbol 和负格式化货币值</td>
</tr>
<tr>
<td>char p_sign_posn</td>
<td>其值表示 positive_sign 字符串的位置：0 表示用圆括号把数值和货币符号括起来；1 表示字符串在数值和货币符号前面；2 表示字符串在数值和货币符号后面；3 表示直接把字符串放在货币前面；4 表示字符串紧跟在货币符号后面</td>
</tr>
<tr>
<td>char n_sign_posn</td>
<td>其值表示 negative_sign 字符串的位置，含义与 p_sign_posn 相同</td>
</tr>
<tr>
<td>char int_p_cs_precedes</td>
<td>如果该值为 1,则 int_currency_symbol 在非负格式化货币值的前面；如果该值为 O,则 int_currency_symbol 在非负格式化货币值的后面</td>
</tr>
<tr>
<td>char int_p_sep_by_space</td>
<td>如果该值为 1，则用空格把 int_currency_symbol 和非负格式化货币值隔开；如果该值为 0，则不用空格分隔 int_currency_symbol 和非负格式化货币值</td>
</tr>
<tr>
<td>char int_n_cs_precedes</td>
<td>如果该值为 1,则 int_currency_symbol 在负格式化货币值的前面；如果该值为 O,则 int_currency_symbol 在负格式化货币值的后面</td>
</tr>
<tr>
<td>char int_n_sep_by_space</td>
<td>如果该值为 1，则用空格把 int_currency_symbol 和负格式化货币值隔开；如果该值为 0，则不用空格分隔 int_currency_symbol 和负格式化货币值</td>
</tr>
<tr>
<td>char int_p_sign_posn</td>
<td>其值表示 positive_sign 相对于非负国际格式化货币值的位置</td>
</tr>
<tr>
<td>char int_n_sign_posn</td>
<td>其值表示 negative_sign 相对于负国际格式化货币值的位置</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>数学库</strong><code>cmath.h</code></p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HUGE_VAL</td>
<td>正双精度常量，不一定能用浮点数表示；在过去，函数的计算结果超过了可表示的最大值时，就用它作为函数的返回值</td>
</tr>
<tr>
<td>HUGE_VALF</td>
<td>与 HUGE_VAL 类似，适用于 float 类型</td>
</tr>
<tr>
<td>HUGE_VALL</td>
<td>与 HUGE_VAL 类似，适用于 long double 类型</td>
</tr>
<tr>
<td>INFINITY</td>
<td>如果允许的话，展开为一个表示无符号或正无穷大的常量 float 表达式；否则，展开为一个在编译时溢出的正浮点常量</td>
</tr>
<tr>
<td>NAN</td>
<td>当且仅当实现支持 float 类型的 NaN 时才被定义(NaN 是 Not-a-Number 的缩写，表示“非数”，用于处理计算中的错误情况，如除以 0.0 或求负数的平方根)</td>
</tr>
<tr>
<td>FP_INFINITE</td>
<td>分类数，表示一个无穷大的浮点值</td>
</tr>
<tr>
<td>FP_NAN</td>
<td>分类数，表示一个不是数的浮点值</td>
</tr>
<tr>
<td>FP_NORMAL</td>
<td>分类数，表示一个正常的浮点值</td>
</tr>
<tr>
<td>FP_SUBNORMAL</td>
<td>分类数，表示一个低于正常浮点值的值(精度被降低)</td>
</tr>
<tr>
<td>FP_ZERO</td>
<td>分类数，表示 0 的浮点值</td>
</tr>
<tr>
<td>FP_FAST_FMA</td>
<td>(可选)如果已定义，对于 double 类型的运算对象，该宏表明 fma()函数与先乘法运算后加法运算的速度相当或更快</td>
</tr>
<tr>
<td>FP_FAST_FMAF</td>
<td>(可选)如果已定义，对于 double 类型的运算对象，该宏表明 fmaf()函数与先乘法运算后加法运算的速度相当或更快</td>
</tr>
<tr>
<td>FP_FAST_FMAL</td>
<td>(可选)如果已定义，对于 long double 类型的运算对象，该宏表明 fmall()函数与先乘法运算后加法运算的速度相当或更快</td>
</tr>
<tr>
<td>FP_ILOGB0</td>
<td>整型常量表达式，表示 ilogn(0)的返回值</td>
</tr>
<tr>
<td>FP_ILOGBNAN</td>
<td>整型常量表达式，表示 ilogn(NaN)的返回值</td>
</tr>
<tr>
<td>MATH_ERRNO</td>
<td>展开为整型常量 1</td>
</tr>
<tr>
<td>MATH_ERREXCEPT</td>
<td>展开为整型常量 2</td>
</tr>
<tr>
<td>math_errhandling</td>
<td>值为 MATH_ERRNO、MATH_ERREXCEPT 或这两个值的按位或</td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong>(C99 另有 float 和 long double 版本，在函数名后加上 f 或 l 即可切换，常量 FLT_RADIX 表示内部浮点表示法中幂的底数)</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int classify(real-floating x);</td>
<td>C99 宏，返回适合 x 的浮点分类值</td>
</tr>
<tr>
<td>int isfinite(real-floating x);</td>
<td>C99 宏，当且仅当 x 为有穷时返回一个非 0 值</td>
</tr>
<tr>
<td>int isfin(real-floating x);</td>
<td>C99 宏，当且仅当 x 为无穷时返回一个非 0 值</td>
</tr>
<tr>
<td>int isnan (real-floating x);</td>
<td>C99 宏，当且仅当 x 为 NaN 时返回一个非 0 值</td>
</tr>
<tr>
<td>int isnormal(real-floating x);</td>
<td>C99 宏，当且仅当 x 为正常数时返回一个非 0 值</td>
</tr>
<tr>
<td>int signbit(real-floating x);</td>
<td>C99 宏，当且仅当 x 的符号为负时返回一个非 0 值</td>
</tr>
<tr>
<td>double acos (double x);</td>
<td>返回余弦为 x 的角度(0 ~ π 弧度)</td>
</tr>
<tr>
<td>double asin(double x);</td>
<td>返回正弦为 x 的角度(-π&#x2F;2 ~ π&#x2F;2 弧度)</td>
</tr>
<tr>
<td>double atan(double x);</td>
<td>返回正切为 x 的角度(-π&#x2F;2 ~ π&#x2F;2 弧度)</td>
</tr>
<tr>
<td>double atan2(double y,double x);</td>
<td>返回正切为 y&#x2F;x 的角度(-π ~ π 弧度)</td>
</tr>
<tr>
<td>double cos(double x);</td>
<td>返回 x(弧度)的余弦值</td>
</tr>
<tr>
<td>double sin(double x);</td>
<td>返回 x(弧度)的正弦值</td>
</tr>
<tr>
<td>double tan (double x);</td>
<td>返回 x(弧度)的正切值</td>
</tr>
<tr>
<td>double cosh(double x);</td>
<td>返回 x 的双曲余弦值</td>
</tr>
<tr>
<td>double sinh(double x);</td>
<td>返回 x 的双曲正弦值</td>
</tr>
<tr>
<td>double tanh(double x);</td>
<td>返回 x 的双曲切值</td>
</tr>
<tr>
<td>double exp(double x);</td>
<td>返回 e 的 x 次幂(e<sup>x</sup>)</td>
</tr>
<tr>
<td>double exp2(double x);</td>
<td>返回 2 的 x 次幂(2<sup>x</sup>)</td>
</tr>
<tr>
<td>double expml(double x);</td>
<td>返回 e<sup>x</sup>-1(C99)</td>
</tr>
<tr>
<td>double frexp(double v,int *pt_e);</td>
<td>把 v 的值分成两部分，一个是返回的规范化小数；一个是 2 的幂，存储在 pt_e 指向的位置上</td>
</tr>
<tr>
<td>int ilogb(double x);</td>
<td>以 signed int 类型返回 x 的指数(C99)</td>
</tr>
<tr>
<td>double ldexp(double x,int p);</td>
<td>返回 x 乘以 2 的 p 次幂（即 x*2<sup>p</sup>)</td>
</tr>
<tr>
<td>double log(double x);</td>
<td>返回 x 的自然对数</td>
</tr>
<tr>
<td>double log10(double x);</td>
<td>返回以 10 为底 x 的对数</td>
</tr>
<tr>
<td>double log1p(double x);</td>
<td>返回 log(1+x)(C99)</td>
</tr>
<tr>
<td>double log2(double x);</td>
<td>返回以 2 为底 x 的对数(C99)</td>
</tr>
<tr>
<td>double logb(double x);</td>
<td>返回 FLT_RADIX 为底 x 的有符号对数(C99)</td>
</tr>
<tr>
<td>double modf(double x,double *p);</td>
<td>把 x 分成整数部分和小数部分，两部分的符号相同，返回小数部分，并把整数部分存储在 p 所指向的位置上</td>
</tr>
<tr>
<td>double scalbn(double x,int n);</td>
<td>返回 x*FLT_RADIX<sup>n</sup>(C99)</td>
</tr>
<tr>
<td>double scalbln(double x,long n);</td>
<td>返回 x*FLT_RADIX<sup>n</sup>(C99)</td>
</tr>
<tr>
<td>double hypot(double x,double y);</td>
<td>返回 x 平方与 y 平方之和的平方根(C99)</td>
</tr>
<tr>
<td>double pow(double x,double y);</td>
<td>返回 x 的 y 次幂</td>
</tr>
<tr>
<td>double sqrt(double x);</td>
<td>返回 x 的平方根</td>
</tr>
<tr>
<td>double cbrt(double x);</td>
<td>返回 x 的立方根(C99)</td>
</tr>
<tr>
<td>double erf(double x);</td>
<td>返回 x 的误差函数(C99)</td>
</tr>
<tr>
<td>double lgamma (double x);</td>
<td>返回 x 的伽马函数绝对值的自然对数(C99)</td>
</tr>
<tr>
<td>double tgamma(double x);</td>
<td>返回 x 的伽马函数(C99)</td>
</tr>
<tr>
<td>double fabs (double x);</td>
<td>返回 x 的绝对值</td>
</tr>
<tr>
<td>double ceil(double x);</td>
<td>返回不小于 x 的最小整数值(向上取整)</td>
</tr>
<tr>
<td>double floor(double x);</td>
<td>返回不大于 x 的最大整数值(向下取整)</td>
</tr>
<tr>
<td>double nearbyint (double x);</td>
<td>以浮点格式把 x 四舍五入为最接近的整数；使用浮点环境指定的舍入规则(C99)</td>
</tr>
<tr>
<td>double rint(double x);</td>
<td>与 nearbyint()类似，但是该函数会抛出“不精确”异常</td>
</tr>
<tr>
<td>long int lrint (double x);</td>
<td>以 long int 格式把 x 舍入为最接近的整数；使用浮点环境指定的舍入规则(C99)</td>
</tr>
<tr>
<td>longlong int llrint(double x);</td>
<td>以 long long int 格式把 x 舍入为最接近的整数；使用浮点环境指定的舍入规则(C99)</td>
</tr>
<tr>
<td>double round(double x);</td>
<td>以浮点格式把 x 舍入为最接近的整数，总是四舍五入</td>
</tr>
<tr>
<td>long int lround(double x);</td>
<td>与 round()类似，但是该函数返回值的类型是 long int</td>
</tr>
<tr>
<td>longlong int llround(double x);</td>
<td>与 round()类似，但是该函数返回值的类型是 long long int</td>
</tr>
<tr>
<td>double trunc (double x);</td>
<td>以浮点格式把 x 舍入为最接近的整数，其结果的绝对值不大于 x 的绝对值(C99)</td>
</tr>
<tr>
<td>int fmod(double x,double y);</td>
<td>返回 x&#x2F;y 的小数部分，如果 y 不是 0，则其计算结果的符号与 x 相同，而且该结果的绝对值要小于 y 的绝对值</td>
</tr>
<tr>
<td>double remainder(double x,double y);</td>
<td>返回 × 除以 y 的余数，IEC 60559 定义为 x-n*y,n 取与 x&#x2F;y 最接近的整数；如果(n-x&#x2F;y)的绝对值是 1&#x2F;2，n 取偶数</td>
</tr>
<tr>
<td>double remquo(double x,double y,int *quo);</td>
<td>返回与 remainder()相同的值；把 x&#x2F;y 的整数大小求模 2<sup>k</sup>的值存储在 quo 所指向的位置中，符号与 x&#x2F;y 的符号相同，其中 k 为整数，至少是 3，具体值因实现而异(C99)</td>
</tr>
<tr>
<td>double copysign(double x,double y);</td>
<td>返回 x 的大小和 y 的符号(C99)</td>
</tr>
<tr>
<td>double nan(const char *tagp);</td>
<td>返回以 double 类型表示的 quiet NaN;nan(“n-char-seg”)与 strtod(“NAN(n-char-seq)”,(char**)NULL)等价；nan(“”)与 strtod(“NAN()”,(char**)NULL)等价。如果不支持 quiet NaN,则返回 0</td>
</tr>
<tr>
<td>double nextafter(double x,double y);</td>
<td>返回 x 在 y 方向上可表示的最接近的 double 类型值；如果 x 等于 y,则返回 x(C99)</td>
</tr>
<tr>
<td>double nexttoward(double x,long double y);</td>
<td>与 nextafter()类似，但该函数的第 2 个参数是 long double 类型；如果 x 等于 y,则返回转换为 double 类型的 y(C99)</td>
</tr>
<tr>
<td>double fdim(double x,double y);</td>
<td>如果大于 y,则返回 x-y 的值；如果 x 小于或等于 y,则返回 0(C99)</td>
</tr>
<tr>
<td>double fmax(double x,double y);</td>
<td>返回参数的最大值，如果一个参数是 NaN、另一个参数是数值，则返回数值(C99)</td>
</tr>
<tr>
<td>double fmin(double x,double y);</td>
<td>返回参数的最小值，如果一个参数是 NaN、另一个参数是数值，则返回数值(C99)</td>
</tr>
<tr>
<td>double fma(double x,double y, double z);</td>
<td>返回三元运算(x*y)+z 的大小，只在最后舍入一次(C99)</td>
</tr>
<tr>
<td>int isgreater(real-floating x, real-floating y);</td>
<td>C99 宏，返回(x)&gt;(y)的值，如果有参数是 NaN,不会抛出无效浮点异常</td>
</tr>
<tr>
<td>int isgreaterequal(real-floating x,real-floating y);</td>
<td>C99 宏，返回(x)&gt;&#x3D;(y)的值，如果有参数是 NaN,不会抛出无效浮点异常</td>
</tr>
<tr>
<td>int isless(real-floating x,real-floating y);</td>
<td>C99 宏，返回(x)&lt;(y)的值，如果有参数是 NaN,不会抛出无效浮点异常</td>
</tr>
<tr>
<td>int islessequal(real-floating x,real-floating y);</td>
<td>C99 宏，返回(x)&lt;&#x3D;(y)的值，如果有参数是 NaN,不会抛出无效浮点异常</td>
</tr>
<tr>
<td>int islessgreater(real-floating x,real-floating y);</td>
<td>C99 宏，返回(x)&lt;(y) || (x)&gt;(y)的值，如果有参数是 NaN,不会抛出无效浮点异常</td>
</tr>
<tr>
<td>int isunordered(real-floating x,real-floating y）;</td>
<td>如果参数不按顺序排列(至少有一个参数是 NaN),函数返回 1；否则，返回 0</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>非本地跳转</strong><code>setjmp.h</code></p>
<ul>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int setjmp(jmp_buf env);</td>
<td>把调用环境存储在数组 env 中，如果是直接调用，则返回 0；如果是通过 longjmp()调用，则返回非 0</td>
</tr>
<tr>
<td>void longjmp(jmp_buf env,int val);</td>
<td>恢复最近的 setjmp()调用(设置 env 数组)存储的环境；完成后，程序继续像调用 setjmp()那样执行该函数，返回 val(但是该函数不允许返回 0，会将其转换成 1)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>对齐</strong><code>stdalign.h</code></p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>alignas</td>
<td>展开为关键字_Alignas</td>
</tr>
<tr>
<td>alignof</td>
<td>展开为关键字_Alignof</td>
</tr>
<tr>
<td>__alignas_is_defined</td>
<td>展开为整型常量 1，适用于#if</td>
</tr>
<tr>
<td>__alignof_is_defined</td>
<td>展开为整型常量 1，适用于#if</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>可变参数</strong><code>stdarg.h</code></p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void va_start(va_list ap,parmN);</td>
<td>该宏在 va_arg()和 va_end()使用 ap 之前初始化 ap,parmN 是形参列表中最后一个形参名的标识符</td>
</tr>
<tr>
<td>type va_arg(va_list ap,type);</td>
<td>该宏展开为一个表达式，其值和类型都与 ap 表示的形参列表的下一项相同，type 是该项的类型。每次调用该宏都前进到 ap 中的下一项</td>
</tr>
<tr>
<td>void va_end(va_list ap);</td>
<td>该宏关闭以上过程，可能导致 ap 在再次调用 va_start()之前不可用</td>
</tr>
<tr>
<td>void va_copy(va list dest,va list src);</td>
<td>该宏把 dest 初始化为 srt 当前状态的备份(C99)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>布尔支持</strong><code>stdbool.h</code></p>
<ul>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>展开为_Bool</td>
</tr>
<tr>
<td>false</td>
<td>展开为整型常量 0</td>
</tr>
<tr>
<td>true</td>
<td>展开为整型常量 1</td>
</tr>
<tr>
<td>__bool_true_false_are_defined</td>
<td>展开为整型常量 1</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>通用定义</strong><code>stddef.h</code></p>
<ul>
<li><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ptrdiff_t</td>
<td>有符号整数类型，表示两个指针之差</td>
</tr>
<tr>
<td>size_t</td>
<td>无符号整数类型，表示 sizeof 运算符的结果</td>
</tr>
<tr>
<td>wchar_t</td>
<td>整数类型，表示支持的本地化所指定的最大扩展字符集</td>
</tr>
</tbody></table>
</li>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>实现定义的常量，表示空指针</td>
</tr>
<tr>
<td>offsetof(type,member-designator)</td>
<td>展开为 size_t 类型的值，表示 type 类型结构的指定成员在该结构中的偏移量，以字节为单位。如果成员是一个位字段，该宏的行为是未定义的</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>整数类型</strong><code>stdint.h</code></p>
<ul>
<li><p><strong>精确宽度类型</strong></p>
<table>
<thead>
<tr>
<th>typedef 名</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>int8_t</td>
<td>8 位，有符号</td>
</tr>
<tr>
<td>intl6_t</td>
<td>16 位，有符号</td>
</tr>
<tr>
<td>int32_t</td>
<td>32 位，有符号</td>
</tr>
<tr>
<td>int64_t</td>
<td>64 位，有符号</td>
</tr>
<tr>
<td>uint8_t</td>
<td>8 位，无符号</td>
</tr>
<tr>
<td>uint16_t</td>
<td>16 位，无符号</td>
</tr>
<tr>
<td>uint32_t</td>
<td>32 位，无符号</td>
</tr>
<tr>
<td>uint64_t</td>
<td>64 位，无符号</td>
</tr>
</tbody></table>
</li>
<li><p><strong>最小宽度类型</strong></p>
<table>
<thead>
<tr>
<th>typedef 名</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>int_least8_t</td>
<td>至少 8 位，有符号</td>
</tr>
<tr>
<td>int_least16_t</td>
<td>至少 16 位，有符号</td>
</tr>
<tr>
<td>int_least32_t</td>
<td>至少 32 位，有符号</td>
</tr>
<tr>
<td>int_least64_t</td>
<td>至少 64 位，有符号</td>
</tr>
<tr>
<td>uint_least8_t</td>
<td>至少 8 位，无符号</td>
</tr>
<tr>
<td>uint_least16_t</td>
<td>至少 16 位，无符号</td>
</tr>
<tr>
<td>uint_least32_t</td>
<td>至少 32 位，无符号</td>
</tr>
<tr>
<td>uint_least64_t</td>
<td>至少 64 位，无符号</td>
</tr>
</tbody></table>
</li>
<li><p><strong>最快最小宽度类型</strong></p>
<table>
<thead>
<tr>
<th>typedef 名</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>int_fast8_t</td>
<td>至少 8 位有符号</td>
</tr>
<tr>
<td>int_fast16_t</td>
<td>至少 16 位有符号</td>
</tr>
<tr>
<td>int_fast32_t</td>
<td>至少 32 位有符号</td>
</tr>
<tr>
<td>int_fast64_t</td>
<td>至少 64 位有符号</td>
</tr>
<tr>
<td>uint_fast8_t</td>
<td>至少 8 位无符号</td>
</tr>
<tr>
<td>uint_fast16_t</td>
<td>至少 16 位无符号</td>
</tr>
<tr>
<td>uint_fast32_t</td>
<td>至少 32 位无符号</td>
</tr>
<tr>
<td>uint_fast64_t</td>
<td>至少 64 位无符号</td>
</tr>
</tbody></table>
</li>
<li><p><strong>最大宽度类型</strong></p>
<table>
<thead>
<tr>
<th>typedef 名</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>intmax_t</td>
<td>最大宽度的有符号类型</td>
</tr>
<tr>
<td>uintmax_t</td>
<td>最大宽度的无符号类型</td>
</tr>
</tbody></table>
</li>
<li><p><strong>可存储指针值的整数类型</strong></p>
<table>
<thead>
<tr>
<th>typedef 名</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>intptr_t</td>
<td>可存储指针值的有符号类型</td>
</tr>
<tr>
<td>uintptr_t</td>
<td>可存储指针值的无符号类型</td>
</tr>
</tbody></table>
</li>
<li><p><strong>整型常量</strong></p>
<table>
<thead>
<tr>
<th>常量标识符</th>
<th>最小值</th>
</tr>
</thead>
<tbody><tr>
<td>INTN_MIN</td>
<td>等于-(2<sup>n-1</sup>-1)</td>
</tr>
<tr>
<td>INTN_MAX</td>
<td>等于 2<sup>n-1</sup>-1</td>
</tr>
<tr>
<td>UINTN_MAX</td>
<td>等于 2<sup>n-1</sup>-1</td>
</tr>
<tr>
<td>INT_LEASTN_MIN</td>
<td>-(2<sup>n-1</sup>-1)</td>
</tr>
<tr>
<td>INT_LEASTN_MAX</td>
<td>2<sup>n-1</sup>-1</td>
</tr>
<tr>
<td>UINT_LEASTN_MAX</td>
<td>2<sup>n</sup>-1</td>
</tr>
<tr>
<td>INT_FASTN_MIN</td>
<td>-(2<sup>n-1</sup>-1)</td>
</tr>
<tr>
<td>INT_FASTN_MAX</td>
<td>2<sup>n-1</sup>-1</td>
</tr>
<tr>
<td>UINT_FASN_MAX</td>
<td>2<sup>n</sup>-1</td>
</tr>
<tr>
<td>INTPTR_MIN</td>
<td>-(2<sup>15</sup>-1)</td>
</tr>
<tr>
<td>INTPTR_MAX</td>
<td>2<sup>15</sup>-1</td>
</tr>
<tr>
<td>UINTPTR_MAX</td>
<td>2<sup>16</sup>-1</td>
</tr>
<tr>
<td>INTMAX_MIN</td>
<td>-(2<sup>15</sup>-1)</td>
</tr>
<tr>
<td>INTMAX_MAX</td>
<td>2<sup>63</sup>-1</td>
</tr>
<tr>
<td>UINTMAX_MAX</td>
<td>2<sup>64</sup>-1</td>
</tr>
</tbody></table>
</li>
<li><p><strong>其他整型常量</strong></p>
<table>
<thead>
<tr>
<th>常量标识符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PTRDIFF_MIN</td>
<td>ptrdiff_t 类型的最小值</td>
</tr>
<tr>
<td>PTRDIFF_MAX</td>
<td>ptrdiff_t 类型的最大值</td>
</tr>
<tr>
<td>SIG_ATOMIC_MIN</td>
<td>sig_atomic_t 类型的最小值</td>
</tr>
<tr>
<td>SIG_ATOMIC_MAX</td>
<td>sig_atomic_t 类型的最大值</td>
</tr>
<tr>
<td>WCHAR_MIN</td>
<td>wchar_t 类型的最小值</td>
</tr>
<tr>
<td>WCHAR_MAX</td>
<td>wchar_t 类型的最大值</td>
</tr>
<tr>
<td>WINT_MIN</td>
<td>wint_t 类型的最小值</td>
</tr>
<tr>
<td>WINT_MAX</td>
<td>wint_t 类型的最大值</td>
</tr>
<tr>
<td>SIZE_MAX</td>
<td>size_t 类型的最大值</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>标准 I&#x2F;O 库</strong><code>stdio.h</code></p>
<ul>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void clearerr(FILE *);</td>
<td>清除文件结尾和错误指示符</td>
</tr>
<tr>
<td>int fclose(FILE *);</td>
<td>关闭指定的文件</td>
</tr>
<tr>
<td>int feof(FILE *);</td>
<td>测试文件结尾</td>
</tr>
<tr>
<td>int ferror(FILE *);</td>
<td>测试错误指示符</td>
</tr>
<tr>
<td>int fflush(FILE *);</td>
<td>刷新指定的文件</td>
</tr>
<tr>
<td>int fgetc(FILE *);</td>
<td>获得指定输入流的下一个字符</td>
</tr>
<tr>
<td>int fgetpos(FILE *restrict,restrict);</td>
<td>存储文件位置指示符的 fpos_t*当前值</td>
</tr>
<tr>
<td>char fgets(char *restrict,restrict);</td>
<td>从指定流中获取下一行(或 int、FILE*指定的字符数)</td>
</tr>
<tr>
<td>FILE fopen(const char *restrict,const char *restrict);</td>
<td>打开指定的文件</td>
</tr>
<tr>
<td>int fprintf(FILE *restrict,const char *restrict, …);</td>
<td>把格式化输出写入指定流</td>
</tr>
<tr>
<td>int fputc(int,FILE *);</td>
<td>把指定字符写入指定流</td>
</tr>
<tr>
<td>int fputs(const char *restrict,FILE *restrict);</td>
<td>把第 1 个参数指向的字符串写入指定流</td>
</tr>
<tr>
<td>size_t fread(void *restrict,size_t,size_t,FILE *restrict);</td>
<td>读取指定流中的二进制数据</td>
</tr>
<tr>
<td>FILE freopen(const char *restrict,const char *restrict,FILE *restrict);</td>
<td>打开指定文件，并将其与指定流相关联</td>
</tr>
<tr>
<td>int fscanf(FILE *restrict,const char *restrict,…);</td>
<td>读取指定流中的格式化输入</td>
</tr>
<tr>
<td>int fsetpos(FILE *,const fpos_t *);</td>
<td>设置文件位置指针指向指定的值</td>
</tr>
<tr>
<td>int fseek(FILE *long,int);</td>
<td>设置文件位置指针指向指定的值</td>
</tr>
<tr>
<td>long ftell(FILE *);</td>
<td>获取当前文件位置</td>
</tr>
<tr>
<td>size_t fwrite(const void *restrict,size_t,size_t,FILE *restrict);</td>
<td>把二进制数据写入指定流</td>
</tr>
<tr>
<td>int getc(FILE *);</td>
<td>读取指定输入的下一个字符</td>
</tr>
<tr>
<td>int getchar();</td>
<td>读取标准输入的下一个字符</td>
</tr>
<tr>
<td>char gets(char *);</td>
<td>获取标准输入的下一行(C11 库已删除)</td>
</tr>
<tr>
<td>void perror(const char*);</td>
<td>把系统错误信息写入标准错误中</td>
</tr>
<tr>
<td>int printf(const char *restrict,…);</td>
<td>把格式化输出写入标准输出中</td>
</tr>
<tr>
<td>int putc(int,FILE *);</td>
<td>把指定字符写入指定输出中</td>
</tr>
<tr>
<td>int putchar(int);</td>
<td>把指定字符写入指定输出中</td>
</tr>
<tr>
<td>int puts(const char *);</td>
<td>把字符串写入标准输出中</td>
</tr>
<tr>
<td>int remove(const char *)</td>
<td>移除已命名文件</td>
</tr>
<tr>
<td>int rename(const char *,const char *)</td>
<td>重命名文件</td>
</tr>
<tr>
<td>void rewind(FILE *)</td>
<td>设置文件位置指针指向文件开始处</td>
</tr>
<tr>
<td>int scanf(const char *restrict,…);</td>
<td>读取标准输入中的格式化输入</td>
</tr>
<tr>
<td>void setbuf(FILE *restrict,char *restrict);</td>
<td>设置缓冲区大小和位置</td>
</tr>
<tr>
<td>int setvbuf(FILE *restrict,char *restrict,int,size_t);</td>
<td>设置缓冲区大小、位置和模式</td>
</tr>
<tr>
<td>int snprintf(char *restrict,size_t n,const char *restrict,…);</td>
<td>把格式化输出中的前 n 个字符写入指定字符串中</td>
</tr>
<tr>
<td>int sprintf(char *restrict,const char *restrict,…);</td>
<td>把格式化输出写入指定字符串中</td>
</tr>
<tr>
<td>int sscanf(const char *restrict,const char *restrict,…);</td>
<td>把格式化输入写入指定字符串中</td>
</tr>
<tr>
<td>FILE *tmpfile(void);</td>
<td>创建一个临时文件</td>
</tr>
<tr>
<td>char *tmpnam(char *);</td>
<td>为临时文件生成一个唯一的文件名</td>
</tr>
<tr>
<td>int ungetc(int,FILE *)</td>
<td>把指定字符放回输入流中</td>
</tr>
<tr>
<td>int vfprintf(FILE *restrict,const char *restrict,va_list);</td>
<td>与 fprintf()类似，但该函数用一个 va_list 类型形参列表(由 va_start 初始化)代替变量参数列表</td>
</tr>
<tr>
<td>int vprintf(const char *restrict,va_list);</td>
<td>与 printf()类似，但该函数用一个 va_list 类型形参列表(由 va_start 初始化)代替变量参数列表</td>
</tr>
<tr>
<td>int vsnprintf(char *restrict,size_t n,const char *restrict,va_list);</td>
<td>与 snprintf()类似，但该函数用一个 va_list 类型形参列表(由 va_start 初始化)代替变量参数列表</td>
</tr>
<tr>
<td>int vsprintf(char *restrict,const char *restrict,va_list);</td>
<td>与 sprintf()类似，但该函数用一个 va_list 类型形参列表(由 va_start 初始化)代替变量参数列表</td>
</tr>
<tr>
<td>int vscanf(const char *restrict,va_list);</td>
<td>与 scanf()类似，但该函数用一个 va_list 类型形参列表(由 va_start 初始化)代替变量参数列表</td>
</tr>
<tr>
<td>int vsscanf(const char *restrict,*restrict,va_list);</td>
<td>与 sscanf()类似，但该函数用一个 va_list 类型形参列表(由 va_start 初始化)代替变量参数列表</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>通用工具</strong><code>stdlib.h</code></p>
<ul>
<li><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>size_t</td>
<td>sizeof 运算符返回的整数类型</td>
</tr>
<tr>
<td>wchar_t</td>
<td>用于表示宽字符的整数类型</td>
</tr>
<tr>
<td>div_t</td>
<td>div()返回的结构类型，该类型中的 quot 和 rem 成员都是 int 类型</td>
</tr>
<tr>
<td>ldiv_t</td>
<td>ldiv()返回的结构类型，该类型中的 quot 和 rem 成员都是 long 类型</td>
</tr>
<tr>
<td>lldiv_t</td>
<td>lldiv()返回的结构类型，该类型中的 quot 和 rem 成员都是 1ong1ong 类型(C99)</td>
</tr>
</tbody></table>
</li>
<li><p><strong>常量</strong></p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>空指针(相当于 0)</td>
</tr>
<tr>
<td>EXIT_FAILURE</td>
<td>可用作 exit()的参数，表示执行程序失败</td>
</tr>
<tr>
<td>EXIT_SUCCESS</td>
<td>可用作 exit()的参数，表示成功执行程序</td>
</tr>
<tr>
<td>RAND_MAX</td>
<td>rand()返回的最大值(一个整数)</td>
</tr>
<tr>
<td>MB_CUR_MAX</td>
<td>当前本地化的扩展字符集中多字节字符的最大字节数</td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double atof(const char *nptr);</td>
<td>返回把字符串 nptr 开始部分的数字(和符号)字符转换为 double 类型的值，跳过开始的空白，遇到第 1 个非数字字符时结束转换；如果未发现数字则返回 0</td>
</tr>
<tr>
<td>int atoi(const char *nptr);</td>
<td>返回把字符串 nptr 开始部分的数字(和符号)字符转换为 int 类型的值，跳过开始的空白，遇到第 1 个非数字字符时结束转换；如果未发现数字则返回 0</td>
</tr>
<tr>
<td>int atol(const char *nptr);</td>
<td>返回把字符串 nptr 开始部分的数字(和符号)字符转换为 long 类型的值，跳过开始的空白，遇到第 1 个非数字字符时结束转换；如果未发现数字则返回 0</td>
</tr>
<tr>
<td>double strtod (const char *restrict npt,char **restrict ept);</td>
<td>返回把字符串 npt 开始部分的数字(和符号)字符转换为 double 类型的值，跳过开始的空白，遇到第 1 个非数字字符时结束转换；如果未发现数字则返回 0；如果转换成功，则把数字后第 1 个字符的地址赋给 ept 指向的位置；如果转换失败，则把 npt 赋给 ept 指向的位置</td>
</tr>
<tr>
<td>float strtof(const char *restrict npt,char **restrict ept);</td>
<td>与 strtod()类似，但是该函数把 npt 指向的字符串转换为 float 类型的值(C99)</td>
</tr>
<tr>
<td>long double strtols(const char *restrict npt,char **restrict ept);</td>
<td>与 strtod()类似，但是该函数把 npt 指向的字符串转换成 long double 类型的值(C99)</td>
</tr>
<tr>
<td>long strtol(const char *restrict npt, char **restrict ept,int base);</td>
<td>返回把字符串 npt 开始部分的数字(和符号)字符转换成 long 类型的值，跳过开始的空白，遇到第 1 个非数字字符时结束转换；如果未发现数字则返回 0；如果转换成功，则把数字后第 1 个字符的地址赋给 ept 指向的位置；如果转换失败，则把 npt 赋给 ept 指向的位置；假定字符串中的数字以 base 指定的数为基数</td>
</tr>
<tr>
<td>longlong strtoll (const char *restrict npt,char **restrict ept,int base);</td>
<td>与 strtol()类似，但是该函数把 npt 指向的字符串转换为 long long 类型的值(C99)</td>
</tr>
<tr>
<td>unsigned long strtoul (const char *restrict npt,char **restrict ept,int base);</td>
<td>返回把字符串 npt 开始部分的数字(和符号)字符转换为 unsigned long 类型的值，跳过开始的空白，遇到第 1 个非数字字符时结束转换；如果未发现数字则返回 0；如果转换成功，则把数字后第 1 个字符的地址赋给 ept 指向的位置；如果转换失败，则把 npt 赋给 ept 指向的位置；假定字符串中的数字以 base 指定的数为基数</td>
</tr>
<tr>
<td>unsigned long long strtoull(const char *restrict npt,char **restrict ept,int base);</td>
<td>与 strtoul()类似，但是该函数把 npt 指向的字符串转换为 unsigned long long 类型的值(C99)</td>
</tr>
<tr>
<td>int rand(void);</td>
<td>返回 O~RAND_MAX 范围内的一个伪随机整数</td>
</tr>
<tr>
<td>void srand(unsigned int seed);</td>
<td>把随机数生成器种子设置为 seed,如果在调用 rand()之前调用 srand(),则种子为 1</td>
</tr>
<tr>
<td>void *aligned_alloc(size_t algn,size_t size);</td>
<td>为对齐对象 algn 分配 size 字节的空间，应支持 algn 对齐值，size 应该是 algn 的倍数(C11)</td>
</tr>
<tr>
<td>void *calloc(size_t nmem,size_t size);</td>
<td>为内含 nmem 个成员的数组分配空间，每个元素占 size 字节大；空间中的所有位都初始化为 0；如果操作成功，该函数返回数组的地址，否则返回 NULL</td>
</tr>
<tr>
<td>void *malloc(size_t size);</td>
<td>分配 size 字节的未初始化内存块；如果成功分配，该函数返回数组的地址，否则返回 NULL</td>
</tr>
<tr>
<td>void *realloc(void *ptr,size_t size);</td>
<td>把 ptr 指向的内存块大小改为 size 字节，size 字节内的内存块内容不变。该函数返回块的位置，它可能被移动。如果不能重新分配空间，函数返回 NULL,原始块不变；如果 ptr 为 NULL,其行为与调用带 size 参数的 malloc()相同；如果 size 是 0，且 ptr 不是 NULL,其行为与调用带 ptr 参数的 free()相同</td>
</tr>
<tr>
<td>void free(void *ptr);</td>
<td>释放 ptr 指向的空间，ptr 应该是之前调用 calloc()、malloc()或 realloc()返回的值，或者 ptr 也可以是空指针，出现这种情况时什么也不做。如果 ptr 是其他值，其行为是未定义的</td>
</tr>
<tr>
<td>void abort(void);</td>
<td>除非捕获信号 SIGABRT,且相应的信号处理器没有返回，否则该函数将导致程序异常结束。是否关闭 I&#x2F;0 流和临时文件，因实现而异。该函数执行 raise(SIGABRT)</td>
</tr>
<tr>
<td>int atexit(void(*func)(void));</td>
<td>注册 func 指向的函数，使其在程序正常结束时被调用。实现应支持注册至少 32 个函数，并根据它们注册顺序的逆序调用。如果注册成功，函数返回 0；否则返回非 0</td>
</tr>
<tr>
<td>int at_quick_exit(void (*func)(void));</td>
<td>注册 func 指向的函数，如果调用 quick exit()则调用被注册的函数。实现应支持注册至少 32 个函数，并根据它们注册顺序的逆序调用。如果注册成功，函数返回 0；否则返回非 0(C11)</td>
</tr>
<tr>
<td>void exit(int status);</td>
<td>该函数将正常结束程序。首先调用由 atexit()注册的函数，然后刷新所有打开的输出流、关闭所有的 I&#x2F;0 流、关闭 tmpfile()创建的所有文件，并把控制权返回主机环境中；如果 status 是 0 或 EXIT SUCCESS,则返回一个实现定义的值，表明未成功结束程序</td>
</tr>
<tr>
<td>void _Exit(int status);</td>
<td>与 exit()类似，但是该函数不调用 atexit()注册的函数和 signal()注册的信号处理器，其处理打开流的方式依实现而异</td>
</tr>
<tr>
<td>char *getenv(const char *name);</td>
<td>返回一个指向字符串的指针，该字符串表示 name 指向的环境变量的值。如果无法匹配指定的 name,则返回 NULL</td>
</tr>
<tr>
<td>_Noreturn void quick_exit(int status);</td>
<td>该函数将正常结束程序。不调用 atexit()注册的函数和 signal()注册的信号处理器。根据 at_quick_exit()注册函数的顺序，逆序调用这些函数。如果程序多次调用 quick_exit()或者同时调用 quick_exit()和 exit(),其行为是未定义的。通过调用_Exit(status)将控制权返回主机环境(C11)</td>
</tr>
<tr>
<td>int system(const char *str);</td>
<td>把 str 指向的字符串传递给命令处理器(如 DOS 或 UNIX)执行的主机环境。如果 str 是 NULL 指针，且命令处理器可用，则该函数返回非 O,否则返回 0；如果 str 不是 NULL,返回值依实现而异</td>
</tr>
<tr>
<td>void *bsearch(const void *key,const void *base,size_t nmem,size_t size,int(*comp)(const void *,const void*));</td>
<td>查找 base 指向的一个数组(有 nmem 个元素，每个元素的大小为 size)中是否有元素匹配 key 指向的对象。通过 comp 指向的函数比较各项，如果 key 指向的对象小于数组元素，那么比较函数将返回小于 0 的值；如果两者相等，则返回 0；如果 key 指向的对象大于数组元素，则返回大于 0 的值。该函数返回指向匹配元素的指针或 NULL(如果无匹配元素)。如果有多个元素匹配，未定义返回哪一个元素</td>
</tr>
<tr>
<td>void qsort(void *base,size_t nmem,size_t size,int(*comp)(const void*,const void*));</td>
<td>根据 comp 指向的函数所提供的顺排列 base 指向的数组。该数组有 nmem 个元素，每个元素的大小是 size。如果第 1 个参数指向的对象小于数组元素，那么比较函数将返回小于 0 的值；如果两者相等，则返回 0；如果第 1 个参数指向的对象大于数组元素，则返回大于 0 的值</td>
</tr>
<tr>
<td>int abs (int n);</td>
<td>返回 n 的绝对值。如果 n 是负数但没有与之对应的正数，那么返回值是未定义的(当 n 是以二进制补码表示的 INT_MIN 时，会出现这种情况)</td>
</tr>
<tr>
<td>long labs(int n);</td>
<td>返回 n 的绝对值，如果 n 是负数但没有与之对应的正数，那么返回值是未定义的(当 n 是以二进制补码表示的 LONG_MIN 时，会出现这种情况)</td>
</tr>
<tr>
<td>long long llabs(int n);</td>
<td>返回 n 的绝对值，如果 n 是负数但没有与之对应的正数，那么返回值是未定义的(当 n 是以二进制补码表示的 LONG_LONG_MIN 时，会出现这种情况)</td>
</tr>
<tr>
<td>div t_div(int numer,int denom);</td>
<td>计算 number 除以 denom 的商和余，把商和余数分别存储在 divt 结构的 quot 成员和 rem 成员中。对于无法整除的除法，商要趋零截断(即直接截去小数部分)</td>
</tr>
<tr>
<td>ldiv_t ldiv(long numer,long denom);</td>
<td>计算 number 除以 denom 的商和余，把商和余数分别存储在 ldiv_t 结构的 guot 成员和 rem 成员中。对于无法整除的除法，商要趋零截断(即直接截去小数部分)</td>
</tr>
<tr>
<td>lldiv_t lldiv(long numer,long denom);</td>
<td>计算 number 除以 denom 的商和余，把商和余数分别存储在 lldiv_t 结构的 quot 成员和 rem 成员中。对于无法整除的除法，商要趋零截断(即直接截去小数部分)(C99)</td>
</tr>
<tr>
<td>int mblen(const char *s,size_t n);</td>
<td>返回组成 s 指向的多字节字符的字节数(最大为 n)。如果 s 指向空字符，该函数则返回 0；如果 s 未指向多字节字符，则返回-1；如果 s 是 NULL,且多字节根据状态进行编码，该函数则返回非 0，否则返回 0</td>
</tr>
<tr>
<td>int mbtowc(wchar_t *pw,const char *s,size_t n);</td>
<td>如果 s 不是 NULL,该函数确定了组成 s 指向的多字节字符的字节数(最大为 n),并确定字符的 wchar_t 类型编码。如果 pw 不是 NULL,则把类型编码赋给 pw 指向的位置。返回值与 mblen(s,n)相同</td>
</tr>
<tr>
<td>int wctomb(char *s,wchar_t wc);</td>
<td>把 wc 中的字符代码转换成相应的多字节字符表示，并将其存储在 s 指向的数组中，除非 s 是 NULL。如果 s 不是 NULL,且如果 wc 无法转换成相应的有效多字节字符，该函数返回-1；如果 wc 有效，该函数返回组成多字节的字节数；如果 s 是 NULL,且如果多字节字符根据状态进行编码，该函数则返回非 0，否则返回 0</td>
</tr>
<tr>
<td>size_t mbstowcs(wchar_t *restrict pwcs,const char *srestrict,size_t n);</td>
<td>把 s 指向的多字节字符数组转换成存储在 pwcs 开始位置的宽字符编码数组中，转换 pwcs 数组中的 n 个字符或转换到 s 数组的空字节停止。如果遇到无效的多字节字符，该函数返回(size_t)(-1),否则返回已填充的数组元素个数(如果有空字符，不包含空字符)</td>
</tr>
<tr>
<td>size_t wcstombs(char *restricts,const wchart_t *restrict pwcs,size_t n);</td>
<td>把存储在 pwcs 指向数组中的宽字符编码序列转换成一个多字节字符序列，并把它拷贝到 s 指向的位置上，存储个字节或遇到空字符时停止转换。如果遇到无效的宽字符编码，该函数返回(size_t)(-1),否则返回已填充数组的字节数(如果有空字符，不包含空字符)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>处理字符串</strong><code>string.h</code></p>
<ul>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void *memchr(const void *s,int c,size_t n);</td>
<td>在 s 指向对象的前 n 个字符中查找是否有 c。如果找到，则返回首次出现 c 处的指针，如果未找到则返回 NULL</td>
</tr>
<tr>
<td>int memcmp(const void *s1,const void *s2,size_t n);</td>
<td>比较 s1 指向对象中的前 n 个字符和 s2 指向对象的前 n 个字符，每个值都解释为 unsigned char 类型。如果 n 个字符都匹配，则两个对象完全相同；否则，比较两个对象中首次不匹配的字符对。如果两个对象相同，函数返回 0；如果在数值上第 1 个对象小于第 2 个对象，函数返回小于 0 的值；如果在数值上第 1 个对象大于第 2 个对象，函数返回大于 0 的值</td>
</tr>
<tr>
<td>void *memcpy(void *restrict s1,const void *restrict s2,size_t n);</td>
<td>把 s2 所指向位置上的 n 字节拷贝到 s1 指向的位置上，函数返回 s1 的值。如果两个位置出现重叠，其行为是未定义的</td>
</tr>
<tr>
<td>void *memmove(void *s1,const void *s2,size_t n);</td>
<td>把 s2 所指向位置上的 n 字节拷贝到 s1 指向的位置上，其行为与拷贝类似，返回 s1 的值。但是，如果出现局部重叠情况，该函数会先把重叠的内容拷贝至临时位置</td>
</tr>
<tr>
<td>void *memset (void *s,int v,size_t n);</td>
<td>把 v 的值(转换为 unsigned char)拷贝至 s 指向的前 n 字节中，函数返回 s</td>
</tr>
<tr>
<td>char *strcat(char *restrict s1,const char *restrict s2);</td>
<td>把 s2 指向的字符串拷贝到 s1 指向字符串后面，s2 字符串的第 1 个字符覆盖 s1 字符串的空字符。该函数返回 s1</td>
</tr>
<tr>
<td>char *strncat(char *restrict s1,const char *restrict s2,size_t n);</td>
<td>把 s2 指向字符串的 n 个字符拷贝到 s1 指向的字符串后面(或拷贝到 s2 的空字符为止)。s2 字符串的第 1 个字符覆盖 s1 字符串的空字符。函数返回 s1</td>
</tr>
<tr>
<td>char *strcpy(char *restrict s1,const char *restrict s2);</td>
<td>把 s2 指向的字符串拷贝到 s1 指向的位置。函数返回 s1</td>
</tr>
<tr>
<td>char *strncpy(char *restrict s1,const char *restrict s2,size_t n);</td>
<td>把 s2 指向字符串的 n 个字符拷贝到 s1 指向的位置(或拷贝到 s2 的空字符为止)。如果在拷贝 n 个字符之前遇到空字符，则在拷贝字符后面添加若干个空字符，使其长度为 n；如果拷贝 n 个字符没有遇到空字符，则不添加空字符。函数返回 s1</td>
</tr>
<tr>
<td>int strcmp(const char *s1,const char *s2);</td>
<td>比较 s1 和 s2 指向的两个字符串。如果完全匹配，则两字符串相同，否则比较首次出现不匹配的字符对。通过字符编码值比较字符。如果两个字符串相同，函数返回 0；如果第 1 个字符串小于第 2 个字符串，函数返回小于 0 的值；如果第 1 个字符串大于第 2 个字符串，函数返回大于 0 的值</td>
</tr>
<tr>
<td>int strncmp(const char *s1,const char *s2,size_t n);</td>
<td>比较 s1 和 s2 指向数组中的前 n 个字符，或比较到第 1 个空字符位置。如果所有的字符对都匹配，则两个数组相同，否则比较两个数组中首次不匹配的字符对。通过字符编码值比较字符。如果两个数组相同，函数返回 0；如果第 1 个数组小于第 2 个数组，函数返回小于 0 的值；如果第 1 个数组大于第 2 个数组，函数返回大于 0 的值</td>
</tr>
<tr>
<td>int strcoll(const char *s1,const char *s2);</td>
<td>与 strcmp()类似，但是该函数使用当前本地化的 LC_COLLATE 类别(由 setlocale()函数设置)所指定的排序方式进行比较</td>
</tr>
<tr>
<td>size_t strxfrm(char *restrict s1,const char *restrict s2,size_t n);</td>
<td>转换 s2 中的字符串，并把转换后的前 n 个字符(包括空字符)拷贝到 s1 指向的数组中。用 strcmp()比较转换后的两个字符串的结果和用 strcoll()比较两个未转换字符串的结果相同。函数返回转换后的字符串长度(不包括末尾的空字符)</td>
</tr>
<tr>
<td>char *strchr(const char *s,int c);</td>
<td>查找 s 指向的字符串中首次出现 c 的位置。空字符是字符串的一部分。函数返回一个指针，指向首次出现 c 的位置。如果没有找到指定的 c 则返回 NULL</td>
</tr>
<tr>
<td>size_t strcspn(const char *s1,const char *s2);</td>
<td>返回 s1 中未出现 s2 中任何字符的最大起始段长度</td>
</tr>
<tr>
<td>size_t strspn(const char *s1,const char *s2);</td>
<td>返回 s1 中包含 s2 所有字符的最大起始段长度</td>
</tr>
<tr>
<td>char *strpbrk(const char *s1,const char *s2);</td>
<td>返回一个指针，指向 s1 中与 s2 任意字符匹配的第 1 个字符的位置。如果未发现任何匹配的字符，函数返回 NULL</td>
</tr>
<tr>
<td>char *strrchr(const char *s,int c);</td>
<td>在 s 指向的字符串中查找末次出现 c 的位置(即从 s2 右侧开始查找字符 c 首次出现的位置)。空字符是字符串的一部分。如果找到，函数返回指向该位置的指针；如果未找到，则返回 NULL</td>
</tr>
<tr>
<td>char *strstr(const char *s1,const char *s2);</td>
<td>返回一个指针，指向 s1 中首次出现 s2 中字符序列(不包括结束的空字符)的位置。如果未找到，函数返回 NULL</td>
</tr>
<tr>
<td>char *strtok(char *restrict s1,const char *restrict s2);</td>
<td>该函数把 s1 字符串分解为单独的记号。s2 字符串包含了作为记号分隔符的字符。按顺序调用该函数。第 1 次调用时，s1 应指向待分解的字符串。函数定位到非分隔符后的第 1 个记号分隔符，并用空字符替换它。函数返回一个指针，指向存储第 1 个记号的字符串。如果未找到记号，函数返回 NULL。在此次调用 strtok()查找字符串中的更多记号。每次调用都返回指向下一个记号的指针，如果未找到则返回 NULL</td>
</tr>
<tr>
<td>char *strerror(int errnum);</td>
<td>返回一个指针，指向与存储在 errnum 中的错误号相对应的错误信息字符串(依实现而异)</td>
</tr>
<tr>
<td>int strlen(const char *s);</td>
<td>返回字符串 s 中的字符数(末尾的空字除外)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>通用数学函数</strong><code>tgmath.h</code></p>
<ul>
<li><p><strong>通用宏函数</strong>(不同库中可能有类型不同但功能类似的函数，该宏自动展开为对应类型)</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">acos</td>
<td align="center">asin</td>
<td align="center">atanb</td>
<td align="center">acosh</td>
<td align="center">asinh</td>
<td align="center">atanh</td>
</tr>
<tr>
<td align="center">cos</td>
<td align="center">sin</td>
<td align="center">tan</td>
<td align="center">cosh</td>
<td align="center">sinh</td>
<td align="center">tanh</td>
</tr>
<tr>
<td align="center">exp</td>
<td align="center">log</td>
<td align="center">pow</td>
<td align="center">sqrt</td>
<td align="center">fabs</td>
<td align="center">atan2</td>
</tr>
<tr>
<td align="center">cbrt</td>
<td align="center">ceil</td>
<td align="center">copysign</td>
<td align="center">erf</td>
<td align="center">erfc</td>
<td align="center">exp2</td>
</tr>
<tr>
<td align="center">expm1</td>
<td align="center">fdim</td>
<td align="center">floor</td>
<td align="center">fma</td>
<td align="center">famx</td>
<td align="center">fmin</td>
</tr>
<tr>
<td align="center">fmod</td>
<td align="center">frexp</td>
<td align="center">hypot</td>
<td align="center">ilogb</td>
<td align="center">ldexp</td>
<td align="center">lgamma</td>
</tr>
<tr>
<td align="center">llrint</td>
<td align="center">llround</td>
<td align="center">log10</td>
<td align="center">log1p</td>
<td align="center">log2</td>
<td align="center">logb</td>
</tr>
<tr>
<td align="center">lrint</td>
<td align="center">lround</td>
<td align="center">nearbyint</td>
<td align="center">nextafter</td>
<td align="center">nexttoward</td>
<td align="center">remainder</td>
</tr>
<tr>
<td align="center">remquo</td>
<td align="center">rint</td>
<td align="center">round</td>
<td align="center">scalbn</td>
<td align="center">scalbln</td>
<td align="center">tgamma</td>
</tr>
<tr>
<td align="center">trunc</td>
<td align="center">carg</td>
<td align="center">cimag</td>
<td align="center">conj</td>
<td align="center">cproj</td>
<td align="center">creal</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>日期和时间</strong><code>time.h</code></p>
<ul>
<li><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>size_t</td>
<td>sizeof 运算符返回的整数类型</td>
</tr>
<tr>
<td>clock_t</td>
<td>适用于表示时间的算术类型</td>
</tr>
<tr>
<td>time_t</td>
<td>适用于表示时间的算术类型</td>
</tr>
<tr>
<td>struct timespec</td>
<td>以秒和纳秒为单位存储指定时间间隔的结构(C11)</td>
</tr>
<tr>
<td>struct tm</td>
<td>存储日历时间的各部分</td>
</tr>
</tbody></table>
</li>
<li><p><strong>timespec 结构成员</strong></p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>time_t tv_sec</td>
<td>秒(&gt;&#x3D;0)</td>
</tr>
<tr>
<td>long tv_nsec</td>
<td>纳秒([0, 999999999])</td>
</tr>
</tbody></table>
</li>
<li><p><strong>tm 结构成员</strong></p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int tm_sec</td>
<td>分后的秒(0-61)</td>
</tr>
<tr>
<td>int tm_min</td>
<td>小时后的分(0-59)</td>
</tr>
<tr>
<td>int tm_hour</td>
<td>小时(0-23)</td>
</tr>
<tr>
<td>int tm_mday</td>
<td>一个月的天数(0-31)</td>
</tr>
<tr>
<td>int tm_mon</td>
<td>一月后的月数(0-11)</td>
</tr>
<tr>
<td>int tm_year</td>
<td>1900 年后的年数</td>
</tr>
<tr>
<td>int tm_wday</td>
<td>星期日开始的天数(0-6)</td>
</tr>
<tr>
<td>int tm_yday</td>
<td>从 1 月 1 日开始的天数(0-365)</td>
</tr>
<tr>
<td>int tm_isdst</td>
<td>夏令时标志(大于 0 说明夏令时有效，等于 0 说明无效，小于 0 说明信息不可用)</td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clock_t clock(void);</td>
<td>该函数返回实现从开始执行程序到调用该函数时，处理器经过的最接近的时间。该函数的返回值除以 CLOCK_PER_SEC 得到以秒为单位的时间。如果时间不可用或无法表示，函数返回(clock_t)(-1)</td>
</tr>
<tr>
<td>double difftime(time_t t1,time_t t0);</td>
<td>返回两个日历时间(t1-t0)的差值。该函数返回计算结果，单位是秒</td>
</tr>
<tr>
<td>time_t mktime(struct tm *tmptr);</td>
<td>把 tmptr 指向的结构中的分解时间转换为日历时间。其编码与 time()函数相同，但是结构改变了，以便对结构中超出范围的值进行调整(例如，2 分 100 秒会调整为 4 分 40 秒)，而且把 tm_wday 和 tm_yday 设置为其他成员指定的值。如果无法表示日历时间，该函数返回(time_t)(-1);否则以 time_t 格式返回日历时间</td>
</tr>
<tr>
<td>time_t time(time_t *ptm)</td>
<td>返回当前日历时间，并将其存储在 ptm 指向的位置，假设 ptm 不是空指针。如果日期时间不可用，该函数返回(time_t)(-1)</td>
</tr>
<tr>
<td>int timespec_get(struct timespec *ts,int base);</td>
<td>根据指定的时基，把 ts 指向的结构设置为当前日历时间。如果成功，返回 base(非 0 值)，否则返回 0(C11)</td>
</tr>
<tr>
<td>char *asctime(const struct tm *tmpt);</td>
<td>把 tmpt 指向的结构中的分解时间转换成”Thu Feb 26 1998\n\0”格式的字符串，并返回指向该字符串的指针</td>
</tr>
<tr>
<td>char *ctime(const time_t *ptm);</td>
<td>把 ptm 指向的结构中的分解时间转换成”Wed Aug 11 1999\n\0”格式的字符串，并返回指向该字符串的指针</td>
</tr>
<tr>
<td>struct tm *gmtime(const time_t *ptm);</td>
<td>把 ptm 指向的日历时间转换成协调世界时(UTC)表示的分解时间，返回一个指向结构的指针，该结构中储时间信息。如果 UTC 不可用，则返回 NULL</td>
</tr>
<tr>
<td>struct tm *localtime(const time_t *ptm);</td>
<td>把 ptm 指向的日历时间转换成本地时间表示的分解时间，存储 tm 结构并返回指向该结构的指针</td>
</tr>
<tr>
<td>size_t strftime(char *restrict s,size_t max,const char *restrict fmt,const struct tm *restrict tmpt);</td>
<td>把字符串 fmt 拷贝到字符串 s 中，用 tmp 指向的分解时间结构中的合适数据替换 fmt 中的转换说明(见后表)。最多在 s 中放入 max 个字符。该函数返回放入 s 中的字符数(不包括空格)；如果字符串中的字符数大于 max,函数返回 0，且 s 中的内容不确定</td>
</tr>
</tbody></table>
</li>
<li><p><strong>strftime()转换说明</strong></p>
<table>
<thead>
<tr>
<th>转换说明</th>
<th>被替换为</th>
</tr>
</thead>
<tbody><tr>
<td>%a</td>
<td>本地化的星期名称缩写</td>
</tr>
<tr>
<td>%A</td>
<td>本地化的星期名称全名</td>
</tr>
<tr>
<td>%b</td>
<td>本地化的月份名称缩写</td>
</tr>
<tr>
<td>%B</td>
<td>本地化的月份名称全名</td>
</tr>
<tr>
<td>%c</td>
<td>本地化指定的日期和时间</td>
</tr>
<tr>
<td>%C</td>
<td>年份的后两位数字(年份除以 100，取小数部分的数)(00-99)</td>
</tr>
<tr>
<td>%d</td>
<td>十进制数表示的月份中的某天(01-31)</td>
</tr>
<tr>
<td>%D</td>
<td>月&#x2F;日&#x2F;年，等价于“%m&#x2F;%d&#x2F;%y”</td>
</tr>
<tr>
<td>%e</td>
<td>十进制数表示的月份中的某天，在仅一位的数字前有一个空格(1-31)</td>
</tr>
<tr>
<td>%F</td>
<td>年-月-日，等价于“%Y-%m-%d”</td>
</tr>
<tr>
<td>%g</td>
<td>基于周的年份的最后两位数字(00-99)</td>
</tr>
<tr>
<td>%G</td>
<td>十进制数表示的基于周的年份</td>
</tr>
<tr>
<td>%h</td>
<td>等价于“%b”</td>
</tr>
<tr>
<td>%H</td>
<td>十进制数(00-23)表示的小时(24 小时制)</td>
</tr>
<tr>
<td>%I</td>
<td>十进制数(01-12)表示的小时(12 小时制)</td>
</tr>
<tr>
<td>%j</td>
<td>十进制数表示的一年中的某天(001-366)</td>
</tr>
<tr>
<td>%m</td>
<td>十进制数表示的月份(01-12)</td>
</tr>
<tr>
<td>%n</td>
<td>换行符</td>
</tr>
<tr>
<td>%M</td>
<td>十进制数表示的分钟(00-59)</td>
</tr>
<tr>
<td>%P</td>
<td>等价于本地 12 小时制中的 am&#x2F;pm</td>
</tr>
<tr>
<td>%r</td>
<td>本地的 12 小时制</td>
</tr>
<tr>
<td>%R</td>
<td>小时:分钟，等价于“%H:%M”</td>
</tr>
<tr>
<td>%S</td>
<td>十进制数表示的秒(00-61)</td>
</tr>
<tr>
<td>%t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>%T</td>
<td>小时:分钟:秒，等价于“%H:%M:%S”</td>
</tr>
<tr>
<td>%u</td>
<td>ISO 8601 的星期数(1~7)，星期一为 1</td>
</tr>
<tr>
<td>%U</td>
<td>一年中的周数(00~53)，把星期天作为一周的第 1 天</td>
</tr>
<tr>
<td>%V</td>
<td>ISO 8601 的一年周数(00~53)，把星期天作为一周的第 1 天</td>
</tr>
<tr>
<td>%w</td>
<td>十进制表示的星期数(0~6)，从星期天开始</td>
</tr>
<tr>
<td>%W</td>
<td>一年的周数(00~53)，把星期一作为一周的第 1 天</td>
</tr>
<tr>
<td>%x</td>
<td>本地化日期表示</td>
</tr>
<tr>
<td>%X</td>
<td>本地化时间表示</td>
</tr>
<tr>
<td>%y</td>
<td>不带世纪的十进制年份(00~99)</td>
</tr>
<tr>
<td>%Y</td>
<td>带世纪的十进制年份</td>
</tr>
<tr>
<td>%z</td>
<td>按照 ISO 8601 格式的相对 UTC 偏移(“-800”表示格林威治时间后的 8 小时，即是向西 8 小时)，如果无可用信息则无替换字符</td>
</tr>
<tr>
<td>%Z</td>
<td>时区名，如果无可用信息则无替换字符</td>
</tr>
<tr>
<td>%%</td>
<td>%(即百分号)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>统一码工具</strong><code>uchar.h</code>(针对 UTF-16 和 UTF-32)</p>
<ul>
<li><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>char16_t</td>
<td>使用 16 位字符的无符号整数类型(与 stdint.h 中的 unit_least16_t 相同)</td>
</tr>
<tr>
<td>char32_t</td>
<td>使用 32 位字符的无符号整数类型(与 stdint.h 中的 unit_least32_t 相同)</td>
</tr>
<tr>
<td>size_t</td>
<td>sizeof 运算符(stddef.h)返回的整数类型</td>
</tr>
<tr>
<td>mbstate_t</td>
<td>非数组类型，可存储多字节字符序列和宽字符相互转换的转换状态信息</td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>size_t mbrto16(char16_t *restrict pwc,const char *restrict s,size_t n,mbstate_t *restrict ps);</td>
<td>与 mbrtowc()函数相同(wchar.h),但该函数是把字符转换为 char16_t 类型，而不是 wchar_t 类型</td>
</tr>
<tr>
<td>size_t mbrto32(char32_t *restrict pwc,const char -restrict s,size_t n,mbstate_t *restrict ps);</td>
<td>与 mbrto16()函数相同，但该函数是把字符转换为 char_32_t 类型</td>
</tr>
<tr>
<td>size_t c16rtomb (char *restrict s,wchar_t wc,mbstate_t *restrict ps);</td>
<td>与 wcrtobm()函数相同（wchar.h),但该函数转换的是 char_16_t 类型字符，而不是 wchar_t 类型</td>
</tr>
<tr>
<td>size_t c32rtomb (char *restrict s,wchar_t wc,mbstate_t *restrict ps);</td>
<td>与 wcrtobm()函数相同(wchar.h),但该函数转换的是 char_32_t 类型字符，而不是 wchar_t 类型</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>拓展多字节字符和宽字符工具</strong><code>wchar.h</code>(C99)</p>
<ul>
<li><p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>wchar_t</td>
<td>整数类型，可表示本地化支持的最大扩展字符集</td>
</tr>
<tr>
<td>wint_t</td>
<td>整数类型，可存储扩展字符集的任意值和至少一个不是扩展字符集成员的值</td>
</tr>
<tr>
<td>size_t</td>
<td>sizeof 运算符返回的整数类型</td>
</tr>
<tr>
<td>mbstate_t</td>
<td>非数组类型，可存储多字节字符序列和宽字符之间转换所需的转换状态信息</td>
</tr>
<tr>
<td>struct tm</td>
<td>结构类型，用于存储日历时间的组成部分</td>
</tr>
</tbody></table>
</li>
<li><p><strong>宏</strong></p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>空指针</td>
</tr>
<tr>
<td>WCHAR_MAX</td>
<td>wchar_t 类型可存储的最大值</td>
</tr>
<tr>
<td>WCHAR_MIN</td>
<td>wchar_t 类型可存储的最小值</td>
</tr>
<tr>
<td>WEOF</td>
<td>wint_t 类型的常量表达式，不与扩展字符集的任何成员对；相当于 EOF 的宽字符表示，用于指定宽字符输入的文件结尾</td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>wint_t btowc(int c);</td>
<td>如果在初始移位状态中 c(unsigned char)是有效的单字节字符，那么该函数返回宽字节表示；否则，返回 WEOF</td>
</tr>
<tr>
<td>int wctob(wint_t c);</td>
<td>如果 c 是一个扩展字符集的成员，它在初始移位状态中的多字节字符表示的是单字节，该函数就返回一个转换为 int 类型的 unsigned char 的单字节表示；否则，函数返回 EOF</td>
</tr>
<tr>
<td>int mbsinit(const mbstate_t *ps);</td>
<td>如果 ps 是空指针或指向一个指定为初始转换状态的数据对象，函数就返回非零值；否则，函数返回 0</td>
</tr>
<tr>
<td>size_t mbrlen(const char *restrict s,size_t n,mbstate_t *restrict ps);</td>
<td>mbrlen()函数相当于调用 mbrtowc(NULL,s,n,ps!&#x3D;NULL?ps:&amp;internal),其中 internal 是 mbrlen()函数的 mbstate_t 对象，除非 ps 指定的表达式只计算一次</td>
</tr>
<tr>
<td>size_t mbrtowc(wchar_t *restrict pwc,const char *restrict s,size_t n,mbstate_t *restrict ps);</td>
<td>如果 s 是空指针，调用该函数相当于把 pwc 设置为空指针、把 n 设置为 1。如果 s 不是空指针，该函数最多检查字节以确定下一个完整的多字节字符所需的字节数(包括所有的移位序列)。如果该函数确定了下一个多字节字符的结束处且合法，它就确定了对应宽字符的值。然后，如果 pwc 不为空，则把值存储在 pwc 指向的对象中。如果对应的宽字符是空的宽字符，描述的最终状态就是初始转换状态。如果检测到空的宽字符，函数返回 0；如果检测到另一个有效宽字符，函数返回完整字符所需的字节数。如果字节不足以表示一个有效的宽字符，但是能表示其中的一部分，函数返回-2。如果出现编码错误，函数返回-1，并把 EILSEQ 存储在 errno 中，且不存储任何值</td>
</tr>
<tr>
<td>size_t wcrtomb(char *restrict s,wchar_t wc,mbstate_t *restrict ps);</td>
<td>如果 s 是空指针，那么调用该函数相当于把 wc 设置为空的宽字符，并为第 1 个参数使用内部缓冲区。如果 s 不是空指针，wcrtomb()函数则确定表示 wc 指定宽字符对应的多字节字符表示所需的字节数(包括所有移位序列)，并把多字节字符表示存储在一个数组中(s 指向该数组的第 1 个元素)，最多存储 MB_CUR_MAX 字节。如果 wc 是空的宽字符，就在初始移位状态所需的移位序列后存储一个空字节。描述的结果状态就是初始转换状态。如果 wc 是有效的宽字符，该函数返回存储多字节字符所需的字节数(包括指定移位状态的字节)。如果 wc 无效，函数则把 EILSEQ 存储在 errno 中，并返回-1</td>
</tr>
<tr>
<td>size_t mbsrtowcs(wchar_t *restrict dst,const char **restrict src,size_t len,mbstate_t *restrict ps);</td>
<td>mbstrtows()函数把 src 间接指向的数组中的多字节字符序列转换成对应的宽字符序列，从口 s 指向的对象所描述的转换状态开始，一直转换到结尾的空字符(包括该字符并存储)或转换了 len 个宽字符。如果 dst 不是空指针，则待转换的字符将存储在 dst 指向的数组中。出现这两种情况时停止转换：如果字节序列无法构成一个有效的多字节字符，或者(如果 dst 不是空指针)len 个宽字符已存储在 dst 指向的数组中。每转换一次都相当于调用一次 mbrtowc()函数。如果 dst 不是空指针，就把空指针(如果因到达结尾的空字符而停止转换)或最后一个待转换多字节字符的地址赋给 src 指向的指针对象。如果由于到达结尾的空字符而停止转换，且 dst 不是空指针，那么描述的结果状态就是初始转状态。如果执行成功，函数返回成功转换的多字节字符数(不包括空字符)；否则函数返回-1</td>
</tr>
<tr>
<td>size_t wcsrtombs(char *restrict dst,const wchar_t **restrict src,size_t len,mbstate_t *restrict ps);</td>
<td>wcsrtombs()函数把 src 间接指向的数组中的宽字符序列转换成对应的多字节字符序列(从 ps 指向的对象描述的转换状态开始)。如果 dst 不是空指针，待转换的字符将被存储在 dst 指向的数组中。一直转换到结尾的空字符(包括该字符并存储)或换了 len 个多字节字符。出现这两种情况时停止转换：如果宽字符没有对应的有效多字节字符，或者(如果 dst 不是空指针)下一个多字节字超过了存储在 dst 指向的数组中的总字节数 len 的限制。每转换一次都相当于调用一次 wcrtomb()函数。如果 dst 不是空指针，就把空指针(如果因到达结尾的空字符而停止转换)或最后一个待转换多字节字符的地址赋给 src 指向的指针对象。如果由于到达结尾的空字符而停止转换，描述的结果状态就是初始转状态。如果执行成功，函数返回成功转换的多字节字符数(不包括空字符)；否则函数返回-1</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>宽字符分类和映射工具</strong><code>wctype.h</code></p>
<ul>
<li><p><strong>类型&#x2F;宏</strong></p>
<table>
<thead>
<tr>
<th>类型&#x2F;宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>wint_t</td>
<td>整数类型，用于存储扩展字符集中的任意值，还可以存储至少一个不是扩展字符成员的值</td>
</tr>
<tr>
<td>wctrans_t</td>
<td>标量类型，可以表示本地化指定的字符映射</td>
</tr>
<tr>
<td>wctype_t</td>
<td>标量类型，可以表示本地化指定的字符分类</td>
</tr>
<tr>
<td>WEOF</td>
<td>wint_t 类型的常量表达式，不对应扩展字符集中的任何成员，相当于宽字符中的 EOF,用于表示宽字符输入的文件结尾</td>
</tr>
</tbody></table>
</li>
<li><p><strong>函数</strong></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int iswalnum(wint_t wc);</td>
<td>如果 wc 表示一个字母数字字符(字母或数字），函数返回真</td>
</tr>
<tr>
<td>int iswalpha(wint_t wc);</td>
<td>如果 wc 表示一个字母字符，函数返回真</td>
</tr>
<tr>
<td>int iswblank(wint_t wc);</td>
<td>如果 wc 表示一个空格，函数返回真</td>
</tr>
<tr>
<td>int iswcntrl(wint_t wc);</td>
<td>如果 wc 表示一个控制字符，函数返回真</td>
</tr>
<tr>
<td>int iswdigit(wint_t wc);</td>
<td>如果 wc 表示一个数字，函数返回真</td>
</tr>
<tr>
<td>int iswgraph(wint_t wc);</td>
<td>如果 iswprint(wc)为真，且 iswspace(wc)为假，函数返回真</td>
</tr>
<tr>
<td>int iswlower(wint_t wc);</td>
<td>如果 wc 表示一个小写字符，函数返回真</td>
</tr>
<tr>
<td>int iswprint(wint_t wc);</td>
<td>如果 wc 表示一个可打印字符，函数返回真</td>
</tr>
<tr>
<td>int iswpunct(wint_t wc);</td>
<td>如果 wc 表示一个标点字符，函数返回真</td>
</tr>
<tr>
<td>int iswspace(wint_t wc);</td>
<td>如果 wc 表示一个制表符、空格或换行符，函数返回真</td>
</tr>
<tr>
<td>int iswupper(wint_t wc);</td>
<td>如果 wc 表示一个大写字符，函数返回真</td>
</tr>
<tr>
<td>int iswxdigit(wint_t wc);</td>
<td>如果 wc 表示一个十六进制数字，函数返回真</td>
</tr>
<tr>
<td>int iswctype(wint_t wc,wctype_t desc);</td>
<td>如果 wc 具有 desc 描述的属性，函数返回真</td>
</tr>
<tr>
<td>wctype_t wctype(const char *property);</td>
<td>wctype()函数构建了一个 wctpe_t 类型的值，它描述了由字符串参数 property 指定的宽字符分类。如果根据当前本地化的 LC_CTYPE 类别，property 识别宽字符分类有效，wctype()函数则返回非零值(可作为 iswctype()函数的第 2 个参数)；否则，函数返回 0</td>
</tr>
<tr>
<td>wint_t towlower(wint_t wc);</td>
<td>如果 wc 是大写字符，返回其小写形式；否则返回 wc</td>
</tr>
<tr>
<td>wint_t towupper(wint_t wc);</td>
<td>如果 wc 是小写字符，返回其大写形式；否则返回 wc</td>
</tr>
<tr>
<td>wint_t towctrans(wint_t wc,wctrans_t desc);</td>
<td>如果 desc 等于 wctrans(“lower”)的返回值，函数返回 wc 的小写形式(由 LC_CTYPE 设置确定)；如果 dest 等于 wctrans(“upper”)的返回值，函数返回 wc 的大写形式(由 LC_CTYPE 设置确定)</td>
</tr>
<tr>
<td>wctrans_t wctrans(const char *property);</td>
<td>如果参数是”lower”或”upper’”，函数返回一个 wctrans_t 类型的值，可用作 towctrans()的参数并反映 LC_CTYPE 设置，否则函数返回 0</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="拓展整数类型inttypes-h"><a href="#拓展整数类型inttypes-h" class="headerlink" title="拓展整数类型inttypes.h"></a><strong>拓展整数类型</strong><code>inttypes.h</code></h4><ul>
<li><p><strong>精确宽度类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型名</th>
<th align="center">printf()说明符</th>
<th align="center">scanf()说明符</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int8_t</td>
<td align="center">PRId8</td>
<td align="center">SCNd8</td>
<td align="center">INT8_MIN</td>
<td align="center">INT8_MAX</td>
</tr>
<tr>
<td align="center">int16_t</td>
<td align="center">PRId16</td>
<td align="center">SCNd16</td>
<td align="center">INT16_MIN</td>
<td align="center">INT16_MAX</td>
</tr>
<tr>
<td align="center">int32_t</td>
<td align="center">PRId32</td>
<td align="center">SCNd32</td>
<td align="center">INT32_MIN</td>
<td align="center">INT32_MAX</td>
</tr>
<tr>
<td align="center">int64_t</td>
<td align="center">PRId64</td>
<td align="center">SCNd64</td>
<td align="center">INT64_MIN</td>
<td align="center">INT64_MAX</td>
</tr>
<tr>
<td align="center">uint8_t</td>
<td align="center">PRIu8</td>
<td align="center">SCNu8</td>
<td align="center">0</td>
<td align="center">UINT8_MAX</td>
</tr>
<tr>
<td align="center">uint16_t</td>
<td align="center">PRIu16</td>
<td align="center">SCNu16</td>
<td align="center">0</td>
<td align="center">UINT16_MAX</td>
</tr>
<tr>
<td align="center">uint32_t</td>
<td align="center">PRIu32</td>
<td align="center">SCNu32</td>
<td align="center">0</td>
<td align="center">UINT32_MAX</td>
</tr>
<tr>
<td align="center">uint64_t</td>
<td align="center">PRIu64</td>
<td align="center">SCNu64</td>
<td align="center">0</td>
<td align="center">UINT64_MAX</td>
</tr>
</tbody></table>
</li>
<li><p><strong>最小宽度类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型名</th>
<th align="center">printf()说明符</th>
<th align="center">scanf()说明符</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int_least8_t</td>
<td align="center">PRILEASTd8</td>
<td align="center">SCNLEASTd8</td>
<td align="center">INT_LEAST8_MIN</td>
<td align="center">INT_LEAST8_MAX</td>
</tr>
<tr>
<td align="center">int_least16_t</td>
<td align="center">PRILEASTd16</td>
<td align="center">SCNLEASTd16</td>
<td align="center">INT_LEAST16_MIN</td>
<td align="center">INT_LEAST16_MAX</td>
</tr>
<tr>
<td align="center">int_least32_t</td>
<td align="center">PRILEASTd32</td>
<td align="center">SCNLEASTd32</td>
<td align="center">INT_LEAST32_MIN</td>
<td align="center">INT_LEAST32_MAX</td>
</tr>
<tr>
<td align="center">int_least64_t</td>
<td align="center">PRILEASTd64</td>
<td align="center">SCNLEASTd64</td>
<td align="center">INT_LEAST64_MIN</td>
<td align="center">INT_LEAST64_MAX</td>
</tr>
<tr>
<td align="center">uint_least8_t</td>
<td align="center">PRILEASTu8</td>
<td align="center">SCNLEASTu8</td>
<td align="center">0</td>
<td align="center">UINT_LEAST8_MAX</td>
</tr>
<tr>
<td align="center">uint_least16_t</td>
<td align="center">PRILEASTu16</td>
<td align="center">SCNLEASTu16</td>
<td align="center">0</td>
<td align="center">UINT_LEAST16_MAX</td>
</tr>
<tr>
<td align="center">uint_least32_t</td>
<td align="center">PRILEASTu32</td>
<td align="center">SCNLEASTu32</td>
<td align="center">0</td>
<td align="center">UINT_LEAST32_MAX</td>
</tr>
<tr>
<td align="center">uint_least64_t</td>
<td align="center">PRILEASTu64</td>
<td align="center">SCNLEASTu64</td>
<td align="center">0</td>
<td align="center">UINT_LEAST64_MAX</td>
</tr>
</tbody></table>
</li>
<li><p><strong>最快最小宽度类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型名</th>
<th align="center">printf()说明符</th>
<th align="center">scanf()说明符</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int_fast8_t</td>
<td align="center">PRIFASTd8</td>
<td align="center">SCNFASTd8</td>
<td align="center">INT_FAST8_MIN</td>
<td align="center">INT_FAST8_MAX</td>
</tr>
<tr>
<td align="center">int_fast16_t</td>
<td align="center">PRIFASTd16</td>
<td align="center">SCNFASTd16</td>
<td align="center">INT_FAST16_MIN</td>
<td align="center">INT_FAST16_MAX</td>
</tr>
<tr>
<td align="center">int_fast32_t</td>
<td align="center">PRIFASTd32</td>
<td align="center">SCNFASTd32</td>
<td align="center">INT_FAST32_MIN</td>
<td align="center">INT_FAST32_MAX</td>
</tr>
<tr>
<td align="center">int_fast64_t</td>
<td align="center">PRIFASTd64</td>
<td align="center">SCNFASTd64</td>
<td align="center">INT_FAST64_MIN</td>
<td align="center">INT_FAST64_MAX</td>
</tr>
<tr>
<td align="center">uint_fast8_t</td>
<td align="center">PRIFASTu8</td>
<td align="center">SCNFASTu8</td>
<td align="center">0</td>
<td align="center">UINT_FAST8_MAX</td>
</tr>
<tr>
<td align="center">uint_fast16_t</td>
<td align="center">PRIFASTu16</td>
<td align="center">SCNFASTu16</td>
<td align="center">0</td>
<td align="center">UINT_FAST16_MAX</td>
</tr>
<tr>
<td align="center">uint_fast32_t</td>
<td align="center">PRIFASTu32</td>
<td align="center">SCNFASTu32</td>
<td align="center">0</td>
<td align="center">UINT_FAST32_MAX</td>
</tr>
<tr>
<td align="center">uint_fast64_t</td>
<td align="center">PRIFASTu64</td>
<td align="center">SCNFASTu64</td>
<td align="center">0</td>
<td align="center">UINT_FAST64_MAX</td>
</tr>
</tbody></table>
</li>
<li><p><strong>最大宽度类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型名</th>
<th align="center">printf()说明符</th>
<th align="center">scanf()说明符</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">intmax_t</td>
<td align="center">PRIdMAX</td>
<td align="center">SCNdMAX</td>
<td align="center">INTMAX_MIN</td>
<td align="center">INTMAX_MAX</td>
</tr>
<tr>
<td align="center">uintmax_t</td>
<td align="center">PRIuMAX</td>
<td align="center">SCNuMAX</td>
<td align="center">0</td>
<td align="center">UINTMAX_MAX</td>
</tr>
</tbody></table>
</li>
<li><p><strong>可存储指针值的整型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型名</th>
<th align="center">printf()说明符</th>
<th align="center">scanf()说明符</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">intptr_t</td>
<td align="center">PRIdPTR</td>
<td align="center">SCNdPTR</td>
<td align="center">INTPTR_MIN</td>
<td align="center">INTPTR_MAX</td>
</tr>
<tr>
<td align="center">uintptr_t</td>
<td align="center">PRIuPTR</td>
<td align="center">SCNuPTR</td>
<td align="center">0</td>
<td align="center">UINTPTR_MAX</td>
</tr>
</tbody></table>
</li>
<li><p><strong>拓展的整型常量</strong></p>
<blockquote>
<p>1、在整数后面加上<code>L</code>后缀可表示 long 类型的常量，如<code>445566L</code>。如何表示 int32_t 类型的常量？<br>2、要使用<code>inttypes.h</code>头文件中定义的宏。例如，表达式<code>INT32_C(445566)</code>展开为一个 int32_t 类型的常量<br>3、从本质上看，这种宏相当于把当前类型强制转换成底层类型，即特殊实现中表示 int32_t 类型的基本类型<br>4、宏名把相应类型名中的<code>_C</code>用<code>_t</code>替换，再把名称中所有的字母大写。例如，要把 1000 设置为 unit_least64_t 类型的常量，可以使用表达式<code>UNIT_LEAST_64C(1000)</code></p>
</blockquote>
</li>
</ul>
<h4 id="拓展字符支持"><a href="#拓展字符支持" class="headerlink" title="拓展字符支持"></a><strong>拓展字符支持</strong></h4><ul>
<li><p><strong>三字符序列</strong></p>
<table>
<thead>
<tr>
<th align="center">三字符序列</th>
<th align="center">符号</th>
<th align="center">三字符序列</th>
<th align="center">符号</th>
<th align="center">三字符序列</th>
<th align="center">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">??&#x3D;</td>
<td align="center">#</td>
<td align="center">??(</td>
<td align="center">[</td>
<td align="center">??)</td>
<td align="center">]</td>
</tr>
<tr>
<td align="center">??’</td>
<td align="center">^</td>
<td align="center">??&lt;</td>
<td align="center">{</td>
<td align="center">??&gt;</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">??-</td>
<td align="center">~</td>
<td align="center">??&#x2F;</td>
<td align="center">\</td>
<td align="center">??!</td>
<td align="center">|</td>
</tr>
</tbody></table>
</li>
<li><p><strong>双字符</strong>(C99，但不会替换双引号中的双字符)</p>
<table>
<thead>
<tr>
<th align="center">双字符序列</th>
<th align="center">符号</th>
<th align="center">双字符序列</th>
<th align="center">符号</th>
<th align="center">双字符序列</th>
<th align="center">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;:</td>
<td align="center">[</td>
<td align="center">:&gt;</td>
<td align="center">]</td>
<td align="center">&lt;%</td>
<td align="center">{</td>
</tr>
<tr>
<td align="center">%&gt;</td>
<td align="center">}</td>
<td align="center">%:</td>
<td align="center">#</td>
<td align="center">%:%:</td>
<td align="center">##</td>
</tr>
</tbody></table>
</li>
<li><p><strong>可选拼写</strong><code>iso646.h</code></p>
<ul>
<li>见前函数介绍</li>
</ul>
</li>
</ul>
<hr>
<h3 id="页底评论"><a href="#页底评论" class="headerlink" title="页底评论"></a><strong>页底评论</strong></h3><hr>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">手头阔绰?点这点这!money得斯!</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/wechatpay.png"><img loading="lazy" src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/alipay.png"><img loading="lazy" src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/alipay.png" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><span class="icon iconify" data-icon="ri:alipay-line"></span></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/QQpay.png"><img loading="lazy" src="https://jsd.vxo.im/gh/ShanMuYunQiu/Image/social/QQpay.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>山暮云秋</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://blog.muyun.space/posts/7e973705/" title="C语言基础教程">https://blog.muyun.space/posts/7e973705/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/c4eece1e/" rel="prev" title="git基础教程"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">git基础教程</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/245b3756/" rel="next" title="Python3爬虫基础"><span class="post-nav-text">Python3爬虫基础</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，也可以去B站私信我哦</span><br><span>如果较为紧急，建议添加微信或QQ，并注明来意</span><br><span>评论系统可能加载较慢，请耐心等待或刷新重试</span><br></div><div id="waline"></div><link rel="stylesheet" href="https://jsd.vxo.im/npm/@waline/client@v2/dist/waline.css"><script>window.CONFIG.waline.config.path = "/posts/7e973705/"</script><div class="js-Pjax"><script src="/js/comments/waline.js" type="module" defer></script></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2022 – 2025 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 山暮云秋</span></div><div class="live-time"><span>本博客已历经风霜坚持了</span><span id="display_live_time"></span><span class="moe-text">(￣▽￣)／</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-04-15T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="footer-custom-text"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="18px" height="18px" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve" style="vertical-align: middle;margin-right: 4px"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z" data-darkreader-inline-fill="" style="--darkreader-inline-fill:#4cc3ff;"></path></svg>Hexo</a> v6.3.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="yun-logo" stroke="#000" width="18px" height="18px" viewBox="40 40 320 320" stroke-width="16" style="vertical-align: middle; margin-right: 4px; --darkreader-inline-stroke:#fffffe;" data-darkreader-inline-stroke=""> <defs> <line id="eye" x1="0" y1="-35" x2="0" y2="35" stroke-linecap="round"> <animateTransform attributeName="transform" additive="sum" attributeType="XML" type="scale" from="1 1" to="1 0" dur="0.15s" repeatCount="2"></animateTransform> </line> </defs> <polygon stroke-linejoin="round" fill="none" points="50,250 50,150 100,150 100,100 300,100 300,150 350,150 350,250 300,250 300,300 100,300 100,250 50,250"></polygon> <use xlink:href="#eye" transform="translate(150,200)"></use> <use xlink:href="#eye" transform="translate(250,200)"></use></svg><span>Yun</span></a> v1.10.11</span><span class="footer-separator">|</span>Deploys by<a href="https://vercel.com" target="_blank" rel="noopener noreferrer"><svg width="66.33" height="15" viewBox="0 0 283 64" id="vercel-logo" fill="#000" xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle; --darkreader-inline-fill:#060606;" data-darkreader-inline-fill=""><path d="M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z"><br> <!-- 萌ICP备案 --><font style="font-size:14px"><img style="width:24px;height:24px;margin-bottom:-8px" src="https://moe.blog/content/uploadfile/Links/icp.gov.moe.png" /><a href="https://icp.gov.moe/?keyword=20245835" target="_blank"><span style="color:#ff3333">萌</span><span style="color:#ff8533">I</span><span style="color:#1f991f">C</span><span style="color:#3385ff">P</span><span style="color:#8533ff">备</span> </a><a href="https://icp.gov.moe/?keyword=20245835" target="_blank"> <span style="color:#ff3333">20</span><span style="color:#ff8533">24</span><span style="color:#1f991f">58</span><span style="color:#3385ff">35</span><span style="color:#ff3333">号</span></a></font></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="	#ff8533" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="https://jsd.vxo.im/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div class="search-result-container"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script><div id="aplayer"></div><script>function initAplayer() {
  const ap = new APlayer({
    container: document.getElementById('aplayer'),
    fixed: true,
    autoplay: true,
    theme: "	#ff8533",
    loop: "all",
    order: "random",
    preload: "auto",
    audio: [{"name":"夏天，再见","artist":"暮色 / 诗岸","url":"https://music.163.com/song/media/outer/url?id=1861068892.mp3","cover":"http://p2.music.126.net/65hyLjIBv5qFhSpQ3KlOiA==/109951166175266739.jpg","lrc":"/lrc/夏天，再见.lrc"},{"name":"流霰(星尘Infinity Version)","artist":"旅行的蜗牛 / 星尘","url":"https://music.163.com/song/media/outer/url?id=1925101032.mp3","cover":"http://p1.music.126.net/O8s988XrtOxiN30TWyAyiQ==/109951167951585729.jpg","lrc":"/lrc/流霰(星尘Infinity Version).lrc"},{"name":"巫山云(星尘Infinity Version)","artist":"旅行的蜗牛 / 星尘","url":"https://music.163.com/song/media/outer/url?id=1921741824.mp3","cover":"http://p2.music.126.net/pjre_OsOEZOglF57MKVArw==/109951167068514633.jpg","lrc":"/lrc/巫山云(星尘Infinity Version).lrc"},{"name":"月巷","artist":"星葵77 / 乐正绫","url":"https://music.163.com/song/media/outer/url?id=2123816639.mp3","cover":"http://p2.music.126.net/gGlxMNxHKkCwJeD--vKvNQ==/109951169310962799.jpg","lrc":"/lrc/月巷.lrc"},{"name":"东京不太热","artist":"Z新豪 / 洛天依Official","url":"/lrc/东京不太热.mp3","cover":"http://p1.music.126.net/8Sk3EpucLC9e8KheMe_GcQ==/109951165315088091.jpg","lrc":"/lrc/东京不太热.lrc"},{"name":"藏蓝-（绫）","artist":"残杨如血","url":"/lrc/藏蓝-（绫）.mp3","cover":"http://p2.music.126.net/qPt2fkD4DSYIgE2JfkoXdA==/109951166568711712.jpg","lrc":"/lrc/藏蓝-（绫）.lrc"},{"name":"碎梦（short ver.）","artist":"COP / 乐正绫","url":"https://music.163.com/song/media/outer/url?id=515964379.mp3","cover":"http://p1.music.126.net/MBUOR-eADofn53ksY3takw==/109951163052186407.jpg","lrc":"/lrc/碎梦（short ver.）.lrc"},{"name":"旧时约","artist":"WOVOP / 乐正绫","url":"https://music.163.com/song/media/outer/url?id=2037885601.mp3","cover":"http://p1.music.126.net/X5-IU5fcCQbJFWZ67rfpEg==/109951168535887842.jpg","lrc":"/lrc/旧时约.lrc"},{"name":"听雨（AI）","artist":"WOVOP / 洛天依","url":"https://music.163.com/song/media/outer/url?id=1962600810.mp3","cover":"http://p2.music.126.net/Atb91zHjpmraNZE7BHdtMA==/109951167646461688.jpg","lrc":"/lrc/听雨（AI）.lrc"},{"name":"淋完这场雨就忘记你吧","artist":"WOVOP / 洛天依","url":"https://music.163.com/song/media/outer/url?id=2136164855.mp3","cover":"http://p1.music.126.net/MTd6fmN9E_p4suM_VS3CqA==/109951169415944765.jpg","lrc":"/lrc/淋完这场雨就忘记你吧.lrc"},{"name":"啥啊","artist":"星葵77 / 洛天依Official","url":"https://music.163.com/song/media/outer/url?id=1963526955.mp3","cover":"http://p1.music.126.net/-Mkgn-OfUd2Q-to55fvsHA==/109951167663201782.jpg","lrc":"/lrc/啥啊.lrc"},{"name":"夏霞 (Acoustic ver.)","artist":"あたらよ","url":"/lrc/夏霞 (Acoustic ver.).mp3","cover":"http://p1.music.126.net/HymDERNi6HQa0PHVxhvstQ==/109951167607871650.jpg","lrc":"/lrc/夏霞 (Acoustic ver.).lrc"},{"name":"DROP","artist":"美波","url":"/lrc/DROP.mp3","cover":"http://p1.music.126.net/tWZUuc87BMfRDayQIYXEew==/109951166189424848.jpg","lrc":"/lrc/DROP.lrc"},{"name":"アイスクリーム","artist":"花譜","url":"/lrc/アイスクリーム.mp3","cover":"http://p2.music.126.net/M6JINT-YzbR95liqI13oBw==/109951168551085464.jpg","lrc":"/lrc/アイスクリーム.lrc"},{"name":"それを世界と言うんだね","artist":"花譜","url":"/lrc/それを世界と言うんだね.mp3","cover":"http://p2.music.126.net/vlT1L_p5ExPSydDE8HUPpQ==/109951168436884742.jpg","lrc":"/lrc/それを世界と言うんだね.lrc"},{"name":"it's 6pm but I miss u already.","artist":"bbbluelee / Furyl / Siren","url":"https://music.163.com/song/media/outer/url?id=1890756154.mp3","cover":"http://p2.music.126.net/vfArwmf4yUKmZhi-ZCwOXA==/109951166569406479.jpg","lrc":"/lrc/it's 6pm but I miss u already..lrc"},{"name":"下一个拥抱 (past times)","artist":"艾纳德 / Diorbin","url":"https://music.163.com/song/media/outer/url?id=2049786420.mp3","cover":"http://p1.music.126.net/fSCIbOxlbwHwON2cMaDbkA==/109951168633034946.jpg","lrc":"/lrc/下一个拥抱 (past times).lrc"},{"name":"鲸歌（Cover 萨满乐队）","artist":"陈亮 宋依凡","url":"https://music.163.com/song/media/outer/url?id=474667755.mp3","cover":"http://p2.music.126.net/je0ZQVB8GAKscWQOXw0B7g==/109951162814733915.jpg","lrc":"/lrc/鲸歌（Cover 萨满乐队）.lrc"},{"name":"漫步","artist":"UnicornPhantom","url":"https://music.163.com/song/media/outer/url?id=1990251011.mp3","cover":"http://p2.music.126.net/tpSYVkCGmQxbmlkJYfRrvA==/109951167975764401.jpg","lrc":"/lrc/漫步.lrc"},{"name":"独角","artist":"UnicornPhantom","url":"https://music.163.com/song/media/outer/url?id=1934213146.mp3","cover":"http://p1.music.126.net/1HOpmf61G-QHQmm5xIv9rg==/109951167230524234.jpg","lrc":"/lrc/独角.lrc"},{"name":"青空","artist":"THE ROLLING GIRLS","url":"https://music.163.com/song/media/outer/url?id=474567081.mp3","cover":"http://p1.music.126.net/_lMvCfJvymqXqI5d6R9esQ==/109951163597998554.jpg","lrc":"/lrc/青空.lrc"},{"name":"夕暮れ(カバー)","artist":"THE ROLLING GIRLS","url":"/lrc/夕暮れ(カバー).mp3","cover":"http://p1.music.126.net/3K3K5wWj3v9IjOn5TkTyPw==/109951163597992477.jpg","lrc":"/lrc/夕暮れ(カバー).lrc"},{"name":"Polaris","artist":"Asia D / JAMMERC","url":"https://music.163.com/song/media/outer/url?id=1824513851.mp3","cover":"http://p1.music.126.net/34x_GGDI47WYG-sZobR8dw==/109951165775251579.jpg","lrc":"/lrc/Polaris.lrc"},{"name":"Seasons","artist":"Rival / Cadmium / Harley Bird","url":"https://music.163.com/song/media/outer/url?id=1313014216.mp3","cover":"http://p1.music.126.net/Aeh-xCT2sl-i0tF8K5qU7w==/109951163571120456.jpg","lrc":"/lrc/Seasons.lrc"},{"name":"Miracle","artist":"Tiborg","url":"/lrc/Miracle.mp3","cover":"http://p1.music.126.net/Yr28yJDbF_Pi5Mr108Od3A==/109951164548560768.jpg","lrc":"/lrc/Miracle.lrc"},{"name":"Dirty Paws - 电影《白日梦想家》插曲","artist":"Of Monsters And Men","url":"/lrc/Dirty Paws.mp3","cover":"http://p2.music.126.net/yU_pXqN1KAjjNdKa_fXveQ==/2534374302309080.jpg","lrc":"/lrc/Dirty Paws.lrc"},{"name":"Stay Alive - 电影《白日梦想家》插曲","artist":"José González","url":"/lrc/Stay Alive.mp3","cover":"http://p2.music.126.net/yU_pXqN1KAjjNdKa_fXveQ==/2534374302309080.jpg","lrc":"/lrc/Stay Alive.lrc"},{"name":"Can We Kiss Forever?","artist":"Kina / Adriana Proenza","url":"/lrc/Can We Kiss Forever？.mp3","cover":"http://p1.music.126.net/BgsCl01scHEbWJG0ijOS4A==/109951165687403090.jpg","lrc":"/lrc/Can We Kiss Forever？.lrc"},{"name":"小孩小孩","artist":"刷牙 / ilem","url":"/lrc/小孩小孩.mp3","cover":"http://p1.music.126.net/2l6NtMgh9saAaPe3W11PdA==/109951168268946674.jpg","lrc":"/lrc/小孩小孩.lrc"},{"name":"白鸟过河滩","artist":"洛天依 / ilem","url":"/lrc/白鸟过河滩.mp3","cover":"http://p2.music.126.net/jIrh3oXTi5Yu7Xx4gKXtlw==/109951167486432220.jpg","lrc":"/lrc/白鸟过河滩.lrc"},{"name":"Wings of Piano","artist":"V.K克","url":"/lrc/Wings of Piano.mp3","cover":"https://p2.music.126.net/nxVZ033DIAM7JNHvT-DRMA==/109951163598059944.jpg","lrc":"/lrc/Wings of Piano.lrc"},{"name":"Daylight","artist":"Seredris","url":"https://music.163.com/song/media/outer/url?id=1372188635.mp3","cover":"http://p1.music.126.net/OjiWGpbpC80EbQgkxEayiA==/109951164152228527.jpg","lrc":"/lrc/Daylight.lrc"},{"name":"第105天","artist":"Pianoboy高至豪","url":"https://music.163.com/song/media/outer/url?id=139737.mp3","cover":"http://p1.music.126.net/3HT3AxHq8uXHPbFbH7Qoyw==/109951167208222169.jpg","lrc":"/lrc/第105天.lrc"},{"name":"De Ortu Solis","artist":"Charun","url":"https://music.163.com/song/media/outer/url?id=4015520.mp3","cover":"http://p1.music.126.net/qSZds9TgolZf51XpcYsciw==/703687441819461.jpg","lrc":"/lrc/De Ortu Solis.lrc"},{"name":"Long Journey","artist":"JINBAO","url":"https://music.163.com/song/media/outer/url?id=1857012588.mp3","cover":"http://p1.music.126.net/nVyoxD5yriYaDJPzhaN8Eg==/109951166129162887.jpg","lrc":"/lrc/Long Journey.lrc"},{"name":"Welcome Home","artist":"Radical Face","url":"/lrc/Welcome Home.mp3","cover":"http://p1.music.126.net/TRW7_0KbJXHsb5t3sqZsaw==/6659741930385748.jpg","lrc":"/lrc/Welcome Home.lrc"},{"name":"What U Do","artist":"Wild Culture / Shel Bee","url":"/lrc/What U Do.mp3","cover":"http://p2.music.126.net/oK9lZOiyKUlSSk7vBP7HpQ==/109951165104873935.jpg","lrc":"/lrc/What U Do.lrc"},{"name":"花と水飴、最終電車","artist":"n-buna / 初音ミク","url":"https://music.163.com/song/media/outer/url?id=33367346.mp3","cover":"http://p2.music.126.net/MLoChdXEUHXrpZSwsFPqYw==/7814229139683634.jpg","lrc":"/lrc/花と水飴、最終電車.lrc"},{"name":"ハレハレヤ-朗朗晴天","artist":"鹿小丸","url":"https://music.163.com/song/media/outer/url?id=1346946492.mp3","cover":"http://p1.music.126.net/JRZD6Yb5AVtIcTX7ocyF5w==/109951163872790053.jpg","lrc":"/lrc/ハレハレヤ-朗朗晴天.lrc"},{"name":"飞","artist":"大神慧 / 十七草","url":"https://music.163.com/song/media/outer/url?id=1412030522.mp3","cover":"http://p1.music.126.net/moCls2ann4OX8aAoffXEyg==/109951164579487317.jpg","lrc":"/lrc/飞.lrc"},{"name":"Antisocial","artist":"BEAUZ / Heather Sommer","url":"https://music.163.com/song/media/outer/url?id=550124208.mp3","cover":"http://p2.music.126.net/An4OF_5qGdI0t5MDDSNNwQ==/109951168223377068.jpg","lrc":"/lrc/Antisocial.lrc"},{"name":"Void","artist":"Kirara Magic","url":"https://music.163.com/song/media/outer/url?id=1465790878.mp3","cover":"http://p2.music.126.net/nc5H97uZ-OXgjGW45XtiJA==/109951165172063291.jpg","lrc":"/lrc/Void.lrc"},{"name":"Freefall","artist":"暴君de","url":"https://music.163.com/song/media/outer/url?id=1392203256.mp3","cover":"http://p1.music.126.net/_6L3TL_r61aU9HcjnWeoFw==/109951164376305943.jpg","lrc":"/lrc/Freefall.lrc"},{"name":"Carousel","artist":"DEAMN","url":"https://music.163.com/song/media/outer/url?id=1406443093.mp3","cover":"http://p2.music.126.net/JiQHxzcKFEJ6s8Ge_QHp5Q==/109951164515259189.jpg","lrc":"/lrc/Carousel.lrc"},{"name":"17さいのうた。","artist":"『ユイカ』","url":"https://music.163.com/song/media/outer/url?id=1951665069.mp3","cover":"http://p1.music.126.net/1bcwLzrrKPWcs137biKbpw==/109951167488734005.jpg","lrc":"/lrc/17さいのうた。.lrc"},{"name":"ただ声一つ","artist":"ロクデナシ","url":"/lrc/ただ声一つ.mp3","cover":"http://p1.music.126.net/WMAHZRjSjackfXUmA5GVWw==/109951166778043030.jpg","lrc":"/lrc/ただ声一つ.lrc"},{"name":"懒人","artist":"三无MarBlue","url":"https://music.163.com/song/media/outer/url?id=1462427219.mp3","cover":"http://p2.music.126.net/ExC40_fFwxUgydQINzjqAQ==/109951164669111492.jpg","lrc":"/lrc/懒人.lrc"},{"name":"An Old Song","artist":"MoreanP","url":"https://music.163.com/song/media/outer/url?id=462177081.mp3","cover":"http://p2.music.126.net/JoPwp8la7lf2bFi0UQKn_g==/109951162866713272.jpg","lrc":"/lrc/An Old Song.lrc"},{"name":"雨道","artist":"Otokaze","url":"https://music.163.com/song/media/outer/url?id=493903.mp3","cover":"http://p2.music.126.net/fEvTj3iuLsIcoFWBNFTC4w==/4447524534356140.jpg","lrc":"/lrc/雨道.lrc"},{"name":"夏恋","artist":"Otokaze","url":"https://music.163.com/song/media/outer/url?id=493911.mp3","cover":"http://p2.music.126.net/5gNt0nW6l-2hSAtJAnaNCw==/4450823069239492.jpg","lrc":"/lrc/夏恋.lrc"},{"name":"Cold Winter","artist":"July","url":"/lrc/Cold Winter.mp3","cover":"http://p2.music.126.net/-VVoBbON0-XHXnTg-PVXSw==/7946170535465788.jpg","lrc":"/lrc/Cold Winter.lrc"},{"name":"Where are you","artist":"AniFace","url":"https://music.163.com/song/media/outer/url?id=453843751.mp3","cover":"http://p1.music.126.net/AUfXMljLBgB3PBV731IzRg==/109951162857118370.jpg","lrc":"/lrc/Where are you.lrc"},{"name":"青空","artist":"Candy_Wind","url":"https://music.163.com/song/media/outer/url?id=32717172.mp3","cover":"http://p1.music.126.net/1uWLxBVZ5MLunwuVo5hrzg==/8002245627462629.jpg","lrc":"/lrc/青空1.lrc"},{"name":"Feeling The Rain","artist":"MoreanP","url":"https://music.163.com/song/media/outer/url?id=496774187.mp3","cover":"http://p1.music.126.net/p9Frozdg_luAkO6ENOtTXg==/109951162997219545.jpg","lrc":"/lrc/Feeling The Rain.lrc"},{"name":"森林","artist":"灰澈","url":"/lrc/森林.mp3","cover":"http://p1.music.126.net/gtnxIZw1IKVV6UoxYQoA5A==/109951163393955301.jpg","lrc":"/lrc/森林.lrc"},{"name":"Umbrella","artist":"Matte / Ember Island","url":"/lrc/Umbrella.mp3","cover":"http://p1.music.126.net/1LrtvH8EpKb5iHKR9qEU0Q==/109951163063843501.jpg","lrc":"/lrc/Umbrella.lrc"},{"name":"说书人","artist":"暗杠 / 寅子","url":"https://music.163.com/song/media/outer/url?id=1303019637.mp3","cover":"http://p1.music.126.net/JHXgLgO7SIaVYacrW_wJuw==/109951165246765187.jpg","lrc":"/lrc/说书人.lrc"},{"name":"听书","artist":"暗杠 / 寅子","url":"https://music.163.com/song/media/outer/url?id=1843986876.mp3","cover":"http://p2.music.126.net/djVhMQ8TgaI517Lrg4Fm9w==/109951165968113069.jpg","lrc":"/lrc/听书.lrc"},{"name":"神のまにまに","artist":"初音ミク / 鏡音リン / GUMI / れるりり","url":"https://music.163.com/song/media/outer/url?id=32431066.mp3","cover":"http://p2.music.126.net/DCxO3b9pfFQ8wkREgg16UQ==/109951163743139874.jpg","lrc":"/lrc/神のまにまに.lrc"},{"name":"ふわふわ時間","artist":"放課後ティータイム","url":"https://music.163.com/song/media/outer/url?id=26201899.mp3","cover":"http://p1.music.126.net/B_sCLXthAHgoVEMIRNU1hw==/109951163559682176.jpg","lrc":"/lrc/ふわふわ時間.lrc"},{"name":"朝焼けのスターマイン","artist":"今井麻美","url":"https://music.163.com/song/media/outer/url?id=35345760.mp3","cover":"http://p2.music.126.net/UrHFbNNr1e96Z9EWTQPX7w==/2912606303912879.jpg","lrc":"/lrc/朝焼けのスターマイン.lrc"},{"name":"鼓動","artist":"カグラナナ","url":"https://music.163.com/song/media/outer/url?id=1872078983.mp3","cover":"http://p1.music.126.net/D-3JSGUU_pdOn6c91Wkb6w==/109951166313861666.jpg","lrc":"/lrc/鼓動.lrc"},{"name":"In Your Eyes","artist":"DG812","url":"https://music.163.com/song/media/outer/url?id=1397502846.mp3","cover":"http://p2.music.126.net/anSN1ptUo10Jj2tltSrqew==/109951164432466046.jpg","lrc":"/lrc/In Your Eyes.lrc"},{"name":"YUMEND","artist":"MYUKKE.","url":"https://music.163.com/song/media/outer/url?id=1474404251.mp3","cover":"http://p1.music.126.net/TjCQkgXcQ7WgyYPgb1FquA==/109951166330371133.jpg","lrc":"/lrc/YUMEND.lrc"},{"name":"RyAL-All I know","artist":"Champer","url":"https://music.163.com/song/media/outer/url?id=1824058027.mp3","cover":"http://p2.music.126.net/5gerzS_NGUn3TPbgha5rbQ==/109951165770952681.jpg","lrc":"/lrc/RyAL-All I know.lrc"},{"name":"“Fall Silent”","artist":"Game Tape","url":"https://music.163.com/song/media/outer/url?id=1498957758.mp3","cover":"http://p1.music.126.net/fFUKQs4fLeBNWZA-jAhTgg==/109951165505365193.jpg","lrc":"/lrc/“Fall Silent”.lrc"},{"name":4038,"artist":"JuggShots_RADI8 / 夏璃夜 / Reggie Yang / RADI8","url":"https://music.163.com/song/media/outer/url?id=1406885246.mp3","cover":"http://p1.music.126.net/ntaw2ZudfFxKzFFAPV0OKQ==/109951164985255855.jpg","lrc":"/lrc/4038.lrc"},{"name":"Outerspace","artist":"BEAUZ","url":"/lrc/Outerspace.mp3","cover":"http://p1.music.126.net/nnhkuAvDHZI44e1xFLuLHQ==/109951165308881338.jpg","lrc":"/lrc/Outerspace.lrc"},{"name":"Bring Me Back","artist":"Miles Away","url":"/lrc/Bring Me Back.mp3","cover":"http://p1.music.126.net/m8u6XqT7V8Db8sXdw7d3ow==/109951165400340890.jpg","lrc":"/lrc/Bring Me Back.lrc"},{"name":"Starry Skies","artist":"The Darkmaker / GY","url":"https://music.163.com/song/media/outer/url?id=1836533888.mp3","cover":"http://p2.music.126.net/EOiPbTxVJJCwtj-ftKePhQ==/109951165881650817.jpg","lrc":"/lrc/Starry Skies.lrc"},{"name":"Way To You","artist":"Gareth Emery","url":"https://music.163.com/song/media/outer/url?id=1430240225.mp3","cover":"http://p2.music.126.net/MolpIGnZNmfLSxE0a4A0kg==/109951164795136845.jpg","lrc":"/lrc/Way To You.lrc"},{"name":1984,"artist":"Forwe兰斯 / WERECORDS","url":"https://music.163.com/song/media/outer/url?id=1823013624.mp3","cover":"http://p1.music.126.net/DfhuVKpiFwtzjsC6N-IUmQ==/109951165759178585.jpg","lrc":"/lrc/1984.lrc"},{"name":"Every Day","artist":"VESRIX / The Darkmaker / 赵曼伊mï","url":"https://music.163.com/song/media/outer/url?id=1804141508.mp3","cover":"http://p2.music.126.net/_ARlb95O7dWCnpmMUwpUtQ==/109951165539401727.jpg","lrc":"/lrc/Every Day.lrc"},{"name":"PLANET","artist":"ラムジ","url":"/lrc/PLANET.mp3","cover":"http://p2.music.126.net/cCyPSxi-BE2h-SmpLBztbA==/18635622580993683.jpg","lrc":"/lrc/PLANET.lrc"},{"name":"Hall of Fame","artist":"The Script / will.i.am","url":"/lrc/Hall of Fame.mp3","cover":"http://p2.music.126.net/y3NzeUWXbuHI9Mm5mghD6A==/109951165967126686.jpg","lrc":"/lrc/Hall of Fame.lrc"},{"name":"回る空うさぎ","artist":"Orangestar / 初音ミク","url":"https://music.163.com/song/media/outer/url?id=458231455.mp3","cover":"http://p2.music.126.net/WT3eISFoAum31NVAIKgKWg==/109951165868174091.jpg","lrc":"/lrc/回る空うさぎ.lrc"},{"name":"雨き声残響","artist":"Orangestar / IA","url":"https://music.163.com/song/media/outer/url?id=31830625.mp3","cover":"http://p1.music.126.net/FGYCo9ZtZd-vcOBZXeu-Cg==/109951165868160762.jpg","lrc":"/lrc/雨き声残響.lrc"},{"name":"Surges","artist":"Orangestar / IA","url":"https://music.163.com/song/media/outer/url?id=1872393298.mp3","cover":"http://p1.music.126.net/brRQMx-FhXwW1APZtmNeuw==/109951166317376612.jpg","lrc":"/lrc/Surges.lrc"},{"name":"天ノ弱","artist":"鹿乃","url":"https://music.163.com/song/media/outer/url?id=27602841.mp3","cover":"http://p1.music.126.net/ZvUIE8dl3iM15BXurWgqAg==/5507453743618637.jpg","lrc":"/lrc/天ノ弱.lrc"},{"name":"天ノ弱（Piano ver.）","artist":"Akie秋绘","url":"/lrc/天ノ弱（Piano ver.）.mp3","cover":"http://p1.music.126.net/z68-4CoPo6UQVSPPUKQjeQ==/109951167762964914.jpg","lrc":"/lrc/天ノ弱（Piano ver.）.lrc"},{"name":"アイロニ","artist":"H△G","url":"/lrc/アイロニ.mp3","cover":"http://p1.music.126.net/knuZxQIl0tWXn8bHjnyq_w==/17770306928531115.jpg","lrc":"/lrc/アイロニ.lrc"},{"name":"STAY","artist":"The Kid LAROI / Justin Bieber","url":"/lrc/STAY.mp3","cover":"http://p2.music.126.net/e5cvcdgeosDKTDrkTfZXnQ==/109951166155165682.jpg","lrc":"/lrc/STAY.lrc"},{"name":"Million Days","artist":"Sabai / Hoang / Claire Ridgely","url":"/lrc/Million Days.mp3","cover":"http://p1.music.126.net/OCXJq2VEytCN6xIuS7Raag==/109951164630509914.jpg","lrc":"/lrc/Million Days.lrc"},{"name":"Returns","artist":"Poppin'Party","url":"https://music.163.com/song/media/outer/url?id=1365428127.mp3","cover":"http://p2.music.126.net/fh55GPh3tXUS9Wt0rFNhbw==/109951164971293108.jpg","lrc":"/lrc/Returns.lrc"},{"name":"她追逐着月光的尽头","artist":"warma","url":"https://music.163.com/song/media/outer/url?id=1868711061.mp3","cover":"http://p1.music.126.net/-5kwASaP2-LcTr9VrmnmTg==/109951166273496994.jpg","lrc":"/lrc/她追逐着月光的尽头.lrc"},{"name":"帰路 - KaeriMichi -","artist":"Otokaze","url":"https://music.163.com/song/media/outer/url?id=493945.mp3","cover":"http://p1.music.126.net/tkQc2-C4KT1H8iRSrEyY9g==/858718581293350.jpg","lrc":"/lrc/帰路 - KaeriMichi -.lrc"},{"name":"儿时的夏日","artist":"余日秋山","url":"https://music.163.com/song/media/outer/url?id=467744316.mp3","cover":"http://p1.music.126.net/AoxdNp812wLheBzLBm-zXw==/109951163871163517.jpg","lrc":"/lrc/儿时的夏日.lrc"},{"name":"春日","artist":"四季音色","url":"https://music.163.com/song/media/outer/url?id=409649183.mp3","cover":"http://p2.music.126.net/IzwWL-ULrEKH9FK3pEFLFA==/17857168346938270.jpg","lrc":"/lrc/春日.lrc"},{"name":"夏夜","artist":"四季音色","url":"https://music.163.com/song/media/outer/url?id=410042763.mp3","cover":"http://p2.music.126.net/pk-xo-6Nu5bwrA-ylVJFUA==/17885755649212510.jpg","lrc":"/lrc/夏夜.lrc"},{"name":"心动讯息","artist":"BlackDD","url":"https://music.163.com/song/media/outer/url?id=1458639005.mp3","cover":"http://p2.music.126.net/7inlikcI5GuMLcOl-Zj12w==/109951168185876251.jpg","lrc":"/lrc/心动讯息.lrc"},{"name":"Forever (Epic Edition)","artist":"PIKASONIC","url":"https://music.163.com/song/media/outer/url?id=1462341831.mp3","cover":"http://p2.music.126.net/4eciQbmCZ6AH1GB39SlIfQ==/109951165133997929.jpg","lrc":"/lrc/Forever (Epic Edition).lrc"},{"name":"Never Gonna Give You Up (Piano Version)","artist":"LittleTranscriber","url":"https://music.163.com/song/media/outer/url?id=1870402236.mp3","cover":"http://p1.music.126.net/QkBjOd1aM5aw4GnRmcOUqw==/109951166294709668.jpg","lrc":"/lrc/Never Gonna Give You Up (Piano Version).lrc"},{"name":"Revolution","artist":"高仕超","url":"https://music.163.com/song/media/outer/url?id=1426163928.mp3","cover":"http://p1.music.126.net/qw1ycZSYlBv2CBh4U1H4PQ==/109951164883021091.jpg","lrc":"/lrc/Revolution.lrc"}],
    volume: 0.7,
    mutex: true,
    lrcType: 3,
    listFolded: false,
    listMaxHeight: "340px",
    storageName: "aplayer-setting"
  });
}
document.addEventListener("DOMContentLoaded", initAplayer);
document.addEventListener("pjax:success", initAplayer);</script><script src="https://jsd.vxo.im/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.2.2/js/index.js"></script><div id="widget-tree">
      <ul>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%85%B6%E4%BB%96/">
          其他
        </a>
      <span class="tree-list-count">1</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/c794d1e9/" title="hexo-encrypt密码插件测试"><i class="post-icon gg-file-document"></i>hexo-encrypt密码插件测试</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%85%B6%E4%BB%96%E6%95%99%E7%A8%8B/">
          其他教程
        </a>
      <span class="tree-list-count">7</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/33de6690/" title="Github Calendar教程文档"><i class="post-icon gg-file-document"></i>Github Calendar教程文档</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/7fa36b92/" title="Hexo博客SEO相关收录教程"><i class="post-icon gg-file-document"></i>Hexo博客SEO相关收录教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/b010393c/" title="PicGO图床配置"><i class="post-icon gg-file-document"></i>PicGO图床配置</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/5df1183b/" title="云游君Hexo部署教程"><i class="post-icon gg-file-document"></i>云游君Hexo部署教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/e5a21006/" title="云游君yun主题配置教程"><i class="post-icon gg-file-document"></i>云游君yun主题配置教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/d5012c8c/" title="搜索引擎搜索技巧"><i class="post-icon gg-file-document"></i>搜索引擎搜索技巧</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/f6c193b6/" title="解决Vercel CORS跨域问题"><i class="post-icon gg-file-document"></i>解决Vercel CORS跨域问题</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/">
          开发技能
        </a>
      <span class="tree-list-count">6</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/941aaef3/" title="$\KaTeX$ 公式大全"><i class="post-icon gg-file-document"></i>$\KaTeX$ 公式大全</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/c6c59c74/" title="Cmake基础教程"><i class="post-icon gg-file-document"></i>Cmake基础教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/249d705/" title="$\KaTeX$ 速查手册"><i class="post-icon gg-file-document"></i>$\KaTeX$ 速查手册</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/6bc3d8a/" title="Linux常用命令手册"><i class="post-icon gg-file-document"></i>Linux常用命令手册</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/cf058d62/" title="Markdown语法教程"><i class="post-icon gg-file-document"></i>Markdown语法教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/c4eece1e/" title="git基础教程"><i class="post-icon gg-file-document"></i>git基础教程</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">
          开发环境
        </a>
      <span class="tree-list-count">3</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/f9bb8de7/" title="Qt 开发环境配置"><i class="post-icon gg-file-document"></i>Qt 开发环境配置</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/54ce768c/" title="VScode基本环境配置"><i class="post-icon gg-file-document"></i>VScode基本环境配置</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/e8dec52a/" title="VScode配置Clang和Cmake环境"><i class="post-icon gg-file-document"></i>VScode配置Clang和Cmake环境</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
          数据结构与算法
        </a>
      <span class="tree-list-count">30</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/b30456ca/" title="01Trie"><i class="post-icon gg-file-document"></i>01Trie</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/1d03a887/" title="AVL树与哈夫曼树"><i class="post-icon gg-file-document"></i>AVL树与哈夫曼树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/394de44a/" title="gcd 和 lcm"><i class="post-icon gg-file-document"></i>gcd 和 lcm</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/bfaab9bd/" title="乘法逆元"><i class="post-icon gg-file-document"></i>乘法逆元</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/b81a161a/" title="二分枚举"><i class="post-icon gg-file-document"></i>二分枚举</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8b3a7218/" title="倍增LCA与Tarjan"><i class="post-icon gg-file-document"></i>倍增LCA与Tarjan</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/77a88a6b/" title="前缀和与差分"><i class="post-icon gg-file-document"></i>前缀和与差分</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/a80d0031/" title="动态规划"><i class="post-icon gg-file-document"></i>动态规划</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/a6add1c4/" title="单调栈与单调队列"><i class="post-icon gg-file-document"></i>单调栈与单调队列</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/33e6ada9/" title="图与回溯"><i class="post-icon gg-file-document"></i>图与回溯</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/91a7e4d1/" title="双指针"><i class="post-icon gg-file-document"></i>双指针</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/e8bacb09/" title="差分约束与二分图"><i class="post-icon gg-file-document"></i>差分约束与二分图</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/c517589e/" title="并查集"><i class="post-icon gg-file-document"></i>并查集</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/735e5788/" title="排序算法"><i class="post-icon gg-file-document"></i>排序算法</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/9acb5cb3/" title="最小生成树"><i class="post-icon gg-file-document"></i>最小生成树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/f216fabe/" title="最短路"><i class="post-icon gg-file-document"></i>最短路</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/6d73f605/" title="权值线段树和主席树"><i class="post-icon gg-file-document"></i>权值线段树和主席树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/263f4c38/" title="树与二叉树"><i class="post-icon gg-file-document"></i>树与二叉树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/20c47d09/" title="快速幂"><i class="post-icon gg-file-document"></i>快速幂</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/59a0de58/" title="树状数组与ST表"><i class="post-icon gg-file-document"></i>树状数组与ST表</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/89c44d72/" title="欧拉路径与哈密顿路径"><i class="post-icon gg-file-document"></i>欧拉路径与哈密顿路径</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/515818b4/" title="离散化"><i class="post-icon gg-file-document"></i>离散化</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/f3215fef/" title="算法复杂度分析"><i class="post-icon gg-file-document"></i>算法复杂度分析</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8893d943/" title="线段树"><i class="post-icon gg-file-document"></i>线段树</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/9ac1aea8/" title="组合数"><i class="post-icon gg-file-document"></i>组合数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/b2626942/" title="背包问题"><i class="post-icon gg-file-document"></i>背包问题</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/554f2221/" title="质数筛"><i class="post-icon gg-file-document"></i>质数筛</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/a4ce31d2/" title="贪心算法"><i class="post-icon gg-file-document"></i>贪心算法</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/5499b3ee/" title="重链剖分与启发式合并"><i class="post-icon gg-file-document"></i>重链剖分与启发式合并</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/5c43c6e5/" title="高精度算法"><i class="post-icon gg-file-document"></i>高精度算法</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">
          算法题
        </a>
      <span class="tree-list-count">13</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/5c63dfdb/" title="C. LR-remainders"><i class="post-icon gg-file-document"></i>C. LR-remainders</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8e48091a/" title="D - K-th Nearest"><i class="post-icon gg-file-document"></i>D - K-th Nearest</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/d9ea786c/" title="D - Synchronized Players"><i class="post-icon gg-file-document"></i>D - Synchronized Players</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/86fe45f1/" title="D. Find the Different Ones!"><i class="post-icon gg-file-document"></i>D. Find the Different Ones!</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8abc54c0/" title="E. Final Countdown"><i class="post-icon gg-file-document"></i>E. Final Countdown</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/21e58d4f/" title="P10126 「Daily OI Round 3」Pigeon"><i class="post-icon gg-file-document"></i>P10126 「Daily OI Round 3」Pigeon</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/9120d4e8/" title="P1031 [NOIP2002 提高组] 均分纸牌"><i class="post-icon gg-file-document"></i>P1031 [NOIP2002 提高组] 均分纸牌</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/cdc4662f/" title="P1036 [NOIP2002 普及组] 选数"><i class="post-icon gg-file-document"></i>P1036 [NOIP2002 普及组] 选数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/8cb1d9bf/" title="P1037 [NOIP2002 普及组] 产生数"><i class="post-icon gg-file-document"></i>P1037 [NOIP2002 普及组] 产生数</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/6cd8f33d/" title="P1060 [NOIP2006 普及组] 开心的金明"><i class="post-icon gg-file-document"></i>P1060 [NOIP2006 普及组] 开心的金明</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/59ee5a77/" title="P1090 [NOIP2004 提高组] 合并果子"><i class="post-icon gg-file-document"></i>P1090 [NOIP2004 提高组] 合并果子</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/2ad6a038/" title="P1147 连续自然数和"><i class="post-icon gg-file-document"></i>P1147 连续自然数和</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/d3586754/" title="P1364 医院设置"><i class="post-icon gg-file-document"></i>P1364 医院设置</a></li></ul></li>
      <li class="tree-list-item">
        <i class="toggle-post-icon gg-folder-add"></i>
        <a class="tree-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
          编程语言
        </a>
      <span class="tree-list-count">5</span><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/6981023b/" title="C语言类型声明黄金法则"><i class="post-icon gg-file-document"></i>C语言类型声明黄金法则</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/245b3756/" title="Python3爬虫基础"><i class="post-icon gg-file-document"></i>Python3爬虫基础</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/19856b4f/" title="Python3基础教程"><i class="post-icon gg-file-document"></i>Python3基础教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/46cf02c7/" title="Cpp基础教程"><i class="post-icon gg-file-document"></i>Cpp基础教程</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/posts/7e973705/" title="C语言基础教程"><i class="post-icon gg-file-document"></i>C语言基础教程</a></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div>
  <script data-pjax src="https://jsd.vxo.im/gh/barry-flynn/hexo-github-calendar/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://calendar.muyun.space/api/?user=ShanMuYunQiu";
            var git_color =['#ebedf0', '#ffd1b3', '#ffb380', '#ffa366', '#ff9c59', '#ff944d', '#ff8c40', '	#ff8533', '#ff7d26', '#ff7519', '#ff6600'];
            var git_user ="ShanMuYunQiu";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<head><style type="text/css">@media (max-width: 1000px){.recent-post-item{width:90% !important;}}@media (min-width: 1000px){.recent-post-item{max-width:940px;width:100%;margin:0 auto;}}@media (max-width: 480px){.recent-post-item{padding:10px;}}</style><link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml,sitemap.txt"></head><div class="recent-post-item" style="width:100%;height:auto;padding:20px;"><div id="github_loading" style="text-align:center;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" style="width:50px;height:50px;margin:0 auto;"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --><script src="https://jsd.vxo.im/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://jsd.vxo.im/npm/live2d-widget-model-wanko@latest/assets/wanko.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"right","hOffset":0,"vOffset":-100},"mobile":{"show":false},"dialog":{"enable":false,"hitokoto":false},"log":false});</script></body></html>