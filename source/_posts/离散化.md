---
title: 离散化
author: 圣奇宝枣
description: 使用离散化的方式优化更关注相对大小的数列
sticky: 0
date: 2023-08-09
updated: 2023-08-09
readmore: true
tags:
  - 离散化
  - C++
categories:
  - 算法
---

---

#### **离散化**

---

- **引入**

  > 1、对于**元素个数不多**、**值域很大**的**有序无重复数列**，且更关注**数列的相对大小**(而不是绝对大小)，可以使用**离散化**的方式优化程序。**离散化**本质上是一种**哈希**，即把**一个数字**映射为**另一个数字**  
  > 2、例如对于一个长度为 10<sup>5</sup> 的**有序无重复数列**`{1, 2, 5, ..., 10^9}`(元素最大值为 10<sup>9</sup>)，要**判断相对大小关系**。如果**将元素大小作为下标**建立新数组，**一定会爆栈**。但是还可以**将元素位置作为下标**，将数列**离散化**，**映射为**`{0, 1, 2, ...}`

<!-- more -->

- **代码实现**

  > 1、通常读入的数组**不是有序无重复的**，因此我们需要先进行**排序**和**去重**。**排序**可以**直接使用**`sort`，**去重**通常使用`unique`**配合**`erase`**实现**(此外也给出了数组的实现方式)。然后，我们需要算出**离散化后的值**，通常使用**二分查找**的方式实现  
  > 2、如下例，单独给出了**去重**和**二分**的框架。且在下面附上**完整程序**的一个示例

  ```cpp
  /* 去重 - vector */
  vector<int> vec = {1, 13, 2, 5, 10000, 2, 13}; // 使用 vector 保存原始数据
  sort(vec.begin(), vec.end());                  // 使用 sort 排序
  // unique 函数返回一个迭代器，指向不重复序列的尾后位置(即被排到末尾的重复元素的首元素位置)
  // erase 从重复元素首元素，删除到末尾，删除掉所有重复元素
  vec.erase(unique(vec.begin(), vec.end()), vec.end());

  /* 去重 - 数组 */
  int n = 7;                                     // 实际数组长度
  int arr[100001] = {1, 13, 2, 5, 10000, 2, 13}; // 使用数组保存原始数据
  sort(arr, arr + n);                            // 使用 sort 排序
  // 使用 unique 返回的位置，减去首元素位置，得到不重复数列的长度
  // 后面程序使用数组，只需要使用 arr[0] 到 arr[len] 即可，后面部分是重复元素
  int len = unique(arr, arr + n) - arr;

  /* 二分 - 查找当前数字在数组中的位置(查找映射值) */
  // 也可以直接使用 lower_bound
  // 原始数据的 vector 或 数组 是全局变量
  int binary_search(int L, int R, int key)
  {
      int mid;
      // 这种二分写法需要范围略大一些
      L--;
      R++;

      while (L + 1 != R)
      {
          mid = (R + L) / 2;
          if (vec[mid] < key)
              L = mid;
          else
              R = mid;
      }

      return R;
  }
  ```

  ```cpp
  #include <algorithm>
  #include <iostream>
  #include <vector>
  using namespace std;

  vector<int> vec, res;

  int binary_search(int L, int R, int key)
  {
      int mid;
      L--;
      R++;
      while (L + 1 != R)
      {
          mid = (R + L) / 2;
          if (vec[mid] < key)
              L = mid;
          else
              R = mid;
      }
      return R;
  }

  int main()
  {
      int n, num;
      cin >> n;
      while (n--)
      {
          cin >> num;
          vec.push_back(num);
      }

      sort(vec.begin(), vec.end());
      vec.erase(unique(vec.begin(), vec.end()), vec.end());

      int value;
      for (int key : vec)
      {
          value = binary_search(0, vec.size() - 1, key);
          res.push_back(value);
      }

      // 输出映射的结果
      for (int i = 0; i < res.size(); i++)
          cout << vec[i] << ' ' << res[i] << endl;
      return 0;
  }
  ```

---

#### **例题练习**

---

- **例题描述**

---

#### **页底评论**

---
