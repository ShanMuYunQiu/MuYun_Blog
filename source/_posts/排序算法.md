---
title: 排序算法
author: 圣奇宝枣
description: C/C++实现排序算法，了解十大排序思想
sticky: 0
date: 2023-05-04
updated: 2023-05-05
readmore: true
tags:
  - 排序
  - C语言
  - C++
categories:
  - 编程技巧与算法
---

---

_注：所有算法的排序原理动图请前往[VisualGo](https://visualgo.net/zh)观看或前往[视频 1](https://www.bilibili.com/video/BV1WP411c7hS/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=54e7eade4a03bd519275169a8a9f51f6)|[视频 2](https://www.bilibili.com/video/BV1Ur4y1w7tv/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=54e7eade4a03bd519275169a8a9f51f6)学习原理_

---

---

#### **算法复杂度与稳定性**

---

- **稳定性复杂度口诀**

  > 1、**插帽龟**(插入、冒泡、归并)，它很**稳**(稳定性)，此外还有**基你太稳**(基数排序)  
  > 2、插帽龟喜欢**选帽插**(选择、冒泡、插入)，插完就**方**了(平均时间复杂度 O(n<sup>2</sup>))  
  > 3、**快归队**(快速、归并、堆)，**n 老二**(平均时间复杂度 O(n\*log<sub>2</sub>n))

<!-- more -->

- **稳定性复杂度表格**(基数排序中 r 为关键字基数，d 为长度，n 为关键字个数)

  |   排序   |       平均 T(n)        |       辅助 S(n)        | 稳定性 |
  | :------: | :--------------------: | :--------------------: | :----: |
  | 插入排序 |    O(n<sup>2</sup>)    |          O(1)          |  稳定  |
  | 希尔排序 |   O(n<sup>2/3</sup>)   |          O(1)          | 不稳定 |
  | 选择排序 |    O(n<sup>2</sup>)    |          O(1)          | 不稳定 |
  |  堆排序  | O(n\*log<sub>2</sub>n) |          O(1)          | 不稳定 |
  | 冒泡排序 |    O(n<sup>2</sup>)    |          O(1)          |  稳定  |
  | 快速排序 | O(n\*log<sub>2</sub>n) | O(n\*log<sub>2</sub>n) | 不稳定 |
  | 归并排序 | O(n\*log<sub>2</sub>n) |          O(1)          |  稳定  |
  | 基数排序 |      O(d\*(r+n))       |       O(r\*d+n)        |  稳定  |

---

#### **冒泡排序**

---

##### **排序原理**

> 1、**冒泡排序**英文为**Bubble Sort**，是一种最基础的**交换排序**  
> 2、排序过程简述为，每轮比较过程中**比较相邻的两个数**，**按照规则交换**，每轮结束都能将该轮该数**依次罗列在末尾**

##### **代码实现**

```c
#include <stdio.h>

// 采用两层循环实现的方法
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void bubblesort1(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int temp;

    // 从末元素开始，到首元素+1，限制 j 的比对范围，共 n-1 轮对比
    // 每轮结束后，当前 i 的位置便是排序好的
    for (int i = n - 1; i > 0; i--)
    {
        // 每次只需比较 0-i 之间的元素，i 之后的元素是排序好的
        for (int j = 0; j < i; j++)
        {
            // 升序，如果当前比后一个数大，则交换
            if (arr[j] > arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// 采用递归的方法实现
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void bubblesort2(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int temp;

    // 相当于上面函数的内层循环，外层循环通过递归实现
    for (int i = 0; i < n - 1; i++)
    {
        if (arr[i] > arr[i + 1])
        {
            temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
        }
    }

    bubblesort2(arr, n - 1); // 递归实现外层循环
}

int main(void)
{
    int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

    bubblesort1(arr, 15);
    bubblesort2(arr, 15);

    // 输出
    for (int i = 0; i < 15; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

##### **排序优化**

> 1、如果**序列已经是有序的**，可以优化**冒泡排序**的方法  
> 2、具体做法是**每趟排序时**判断**是否交换过元素**，如果**没有交换**，则证明**数列已经有序**，可以**提前退出排序**

```cpp
#include <stdbool.h>
#include <stdio.h>

// 采用两层循环实现的方法
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void bubblesort(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int temp;
    bool ifswap; // 每趟过程中是否有交换

    // 从末元素开始，到首元素+1，限制 j 的比对范围，共 n-1 轮对比
    // 每轮结束后，当前 i 的位置便是排序好的
    for (int i = n - 1; i > 0; i--)
    {
        // 初始化交换标志为未交换
        ifswap = false;

        // 每次只需比较 0-i 之间的元素，i 之后的元素是排序好的
        for (int j = 0; j < i; j++)
        {
            // 升序，如果当前比后一个数大，则交换
            if (arr[j] > arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                ifswap = true; // 设定为有交换
            }
        }

        // 没有交换提前退出
        if (ifswap == false)
            return;
    }
}

int main(void)
{
    int arr[15] = {2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 48, 50, 47, 46, 44};

    // 在 38 后的部分排序完后，再经过一轮改变 ifswap 后就会直接结束排序
    bubblesort(arr, 15);

    // 输出
    for (int i = 0; i < 15; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

---

#### **选择排序**

---

##### **排序原理**

> 1、**选择排序**英文为**Selection Sort**，其原理十分简单清晰  
> 2、**从头到尾**扫描序列，找出**最大或最小的元素**，**与第一个元素交换**，然后再从**剩下的序列**中继续这种**选择交换**

##### **代码实现**

```c
#include <stdio.h>

// 采用两层循环实现的方法
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void selectsort1(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int temp, iminpos; // 最小值的下标

    // 共进行 n-1 轮比较
    for (int i = 0; i < n - 1; i++)
    {
        iminpos = i; // 默认当前位置最小

        // i+1 到 n 是这次需要对比的剩余序列
        for (int j = i + 1; j < n; j++)
        {
            // 升序，如果更小，则记录当前位置
            if (arr[j] < arr[iminpos])
                iminpos = j;
        }

        // 如果最小位置有变动，则交换它们的元素
        if (iminpos != i)
        {
            temp = arr[i];
            arr[i] = arr[iminpos];
            arr[iminpos] = temp;
        }
    }
}

// 采用递归实现的方法
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void selectsort2(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int temp, iminpos = 0; // 每趟循环最小值的下标

    for (int i = 1; i < n; i++)
    {
        // 找出更小的元素，记录它的位置
        if (arr[i] < arr[iminpos])
            iminpos = i;
    }

    // 如果本趟循环的最小元素不是起始元素，则交换它们的位置
    if (iminpos != 0)
    {
        temp = arr[0];
        arr[0] = arr[iminpos];
        arr[iminpos] = temp;
    }

    selectsort2(arr + 1, --n); // 递归，起始位置 +1，元素个数 -1
}

int main(void)
{
    int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

    selectsort1(arr, 15);
    selectsort2(arr, 15);

    // 输出
    for (int i = 0; i < 15; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

##### **排序优化**

> 1、**选择排序**一趟排序只选择**最大或最小值**，优化的办法是一趟**同时**把**最大和最小值**选出来  
> 2、排序过程中，**最小的放左边**，**最大的放右边**。这样优化可以**循环趟数减半**

```c
#include <stdio.h>

// 采用两层循环实现的方法
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void selectsort1(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int ileft = 0, iright = n - 1; // 每趟排序最左和最右的位置，最左从 0 开始，最右到 n-1 结束
    int temp, iminpos, imaxpos;    // 最小值和最大值的下标

    // 只要最左仍在最右的左边
    while (ileft < iright)
    {
        iminpos = imaxpos = ileft; // 初始化最小值和最大值的下标为最左

        // 每趟循环从最左和最右范围中选取元素
        for (int i = ileft; i <= iright; i++)
        {
            if (arr[i] < arr[iminpos])
                iminpos = i;
            if (arr[i] > arr[imaxpos])
                imaxpos = i;
        }

        // 如果本趟循环最小的元素不是最左边的元素，则交换位置
        if (iminpos != ileft)
        {
            temp = arr[ileft];
            arr[ileft] = arr[iminpos];
            arr[iminpos] = temp;
        }

        // 如果 imaxpos 的位置是 ileft，在上面代码中，ileft 已被交换到了 iminpos 的位置
        // 所以 imaxpos 的值要修改成 iminpos
        if (imaxpos == ileft)
            imaxpos = iminpos;

        // 如果本趟循环最大的元素不是最右边的元素，则交换位置
        if (imaxpos != iright)
        {
            temp = arr[iright];
            arr[iright] = arr[imaxpos];
            arr[imaxpos] = temp;
        }

        // 更改范围
        ileft++;
        iright--;
    }
}

// 采用递归实现的方法
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void selectsort2(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int ileft = 0, iright = n - 1; // 每趟排序最左和最右的位置，最左从 0 开始，最右到 n-1 结束
    int temp, iminpos = 0, imaxpos = 0; // 每趟循环最小值和最大值的下标

    // 每趟循环从最左和最右范围中选取元素
    for (int i = ileft; i <= iright; i++)
    {
        if (arr[i] < arr[iminpos])
            iminpos = i;
        if (arr[i] > arr[imaxpos])
            imaxpos = i;
    }

    // 如果本趟循环最小的元素不是最左边的元素，则交换位置
    if (iminpos != ileft)
    {
        temp = arr[ileft];
        arr[ileft] = arr[iminpos];
        arr[iminpos] = temp;
    }

    // 如果 imaxpos 的位置是 ileft，在上面代码中，ileft 已被交换到了 iminpos 的位置
    // 所以 imaxpos 的值要修改成 iminpos
    if (imaxpos == ileft)
        imaxpos = iminpos;

    // 如果本趟循环最大的元素不是最右边的元素，则交换位置
    if (imaxpos != iright)
    {
        temp = arr[iright];
        arr[iright] = arr[imaxpos];
        arr[imaxpos] = temp;
    }

    selectsort2(arr + 1, n - 2); // 递归，起始位置 +1，元素个数 -2
}

int main(void)
{
    int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

    selectsort1(arr, 15);
    selectsort2(arr, 15);

    // 输出
    for (int i = 0; i < 15; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

---

#### **插入排序**

---

##### **排序原理**

> 1、

---

#### **页底评论**

---
