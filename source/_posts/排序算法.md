---
title: 排序算法
author: 圣奇宝枣
description: C/C++实现排序算法，了解十大排序思想
sticky: 0
date: 2023-05-04
updated: 2023-05-04
readmore: true
tags:
  - 排序
  - C语言
  - C++
categories:
  - 编程技巧与算法
---

---

_注：所有算法的排序原理动图请前往[VisualGo](https://visualgo.net/zh)观看或前往[视频 1](https://www.bilibili.com/video/BV1WP411c7hS/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=54e7eade4a03bd519275169a8a9f51f6)|[视频 2](https://www.bilibili.com/video/BV1Ur4y1w7tv/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=54e7eade4a03bd519275169a8a9f51f6)学习原理_

---

---

#### **算法复杂度与稳定性**

---

- **稳定性复杂度口诀**

  > 1、**插帽龟**(插入、冒泡、归并)，它很**稳**(稳定性)，此外还有**基你太稳**(基数排序)  
  > 2、插帽龟喜欢**选帽插**(选择、冒泡、插入)，插完就**方**了(平均时间复杂度 O(n<sup>2</sup>))  
  > 3、**快归队**(快速、归并、堆)，**n 老二**(平均时间复杂度 O(n\*log<sub>2</sub>n))

<!-- more -->

- **稳定性复杂度表格**(基数排序中 r 为关键字基数，d 为长度，n 为关键字个数)

  |   排序   |       平均 T(n)        |       辅助 S(n)        | 稳定性 |
  | :------: | :--------------------: | :--------------------: | :----: |
  | 插入排序 |    O(n<sup>2</sup>)    |          O(1)          |  稳定  |
  | 希尔排序 |   O(n<sup>2/3</sup>)   |          O(1)          | 不稳定 |
  | 选择排序 |    O(n<sup>2</sup>)    |          O(1)          | 不稳定 |
  |  堆排序  | O(n\*log<sub>2</sub>n) |          O(1)          | 不稳定 |
  | 冒泡排序 |    O(n<sup>2</sup>)    |          O(1)          |  稳定  |
  | 快速排序 | O(n\*log<sub>2</sub>n) | O(n\*log<sub>2</sub>n) | 不稳定 |
  | 归并排序 | O(n\*log<sub>2</sub>n) |          O(1)          |  稳定  |
  | 基数排序 |      O(d\*(r+n))       |       O(r\*d+n)        |  稳定  |

---

#### **冒泡排序**

---

##### **排序原理**

> 1、**冒泡排序**英文为**Bubble Sort**，是一种最基础的**交换排序**  
> 2、排序过程简述为，每轮比较过程中**比较相邻的两个数**，**按照规则交换**，每轮结束都能将该轮该数**依次罗列在末尾**

##### **代码实现**

```c
#include <stdio.h>

// 采用两层循环实现的方法
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void bubblesort1(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int temp;
    // 从末元素开始，到首元素+1，限制 j 的比对范围，共 n-1 轮对比
    // 每轮结束后，当前 i 的位置便是排序好的
    for (int i = n - 1; i > 0; i--)
    {
        // 每次只需比较 0-i 之间的元素，i 之后的元素是排序好的
        for (int j = 0; j < i; j++)
        {
            // 升序，如果当前比后一个数大，则交换
            if (arr[j] > arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// 采用递归的方法实现
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void bubblesort2(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int temp;
    // 相当于上面函数的内层循环，外层循环通过递归实现
    for (int i = 0; i < n - 1; i++)
    {
        if (arr[i] > arr[i + 1])
        {
            temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
        }
    }

    bubblesort2(arr, n - 1); // 递归实现外层循环
}

int main(void)
{
    int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

    bubblesort1(arr, 15);
    bubblesort2(arr, 15);

    // 输出
    for (int i = 0; i < 15; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

##### **排序优化**

> 1、如果**序列已经是有序的**，可以优化**冒泡排序**的方法  
> 2、具体做法是**每趟排序时**判断**是否交换过元素**，如果**没有交换**，则证明**数列已经有序**，可以**提前退出排序**

```cpp
#include <stdbool.h>
#include <stdio.h>

// 采用两层循环实现的方法
// 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
void bubblesort(int arr[], unsigned int n)
{
    if (n < 2) // 参数小于2不需要排序
        return;

    int temp;
    bool ifswap; // 每趟过程中是否有交换
    // 从末元素开始，到首元素+1，限制 j 的比对范围，共 n-1 轮对比
    // 每轮结束后，当前 i 的位置便是排序好的
    for (int i = n - 1; i > 0; i--)
    {
        // 初始化交换标志为未交换
        ifswap = false;

        // 每次只需比较 0-i 之间的元素，i 之后的元素是排序好的
        for (int j = 0; j < i; j++)
        {
            // 升序，如果当前比后一个数大，则交换
            if (arr[j] > arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                ifswap = true; // 设定为有交换
            }
        }

        // 没有交换提前退出
        if (ifswap == false)
            return;
    }
}

int main(void)
{
    int arr[15] = {2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 48, 50, 47, 46, 44};

    // 在 38 后的部分排序完后，再经过一轮改变 ifswap 后就会直接结束排序
    bubblesort(arr, 15);

    // 输出
    for (int i = 0; i < 15; i++)
        printf("%d ", arr[i]);
    return 0;
}
```

---

#### **选择排序**

---

---

#### **页底评论**

---
