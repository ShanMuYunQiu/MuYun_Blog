---
title: 排序算法
author: 圣奇宝枣
description: C/C++实现排序算法，了解十大排序思想
sticky: 0
date: 2023-05-04
updated: 2023-05-06
readmore: true
tags:
  - 排序
  - C语言
  - C++
categories:
  - 算法
---

---

_注：所有算法的排序原理动图请前往[VisualGo](https://visualgo.net/zh)观看或前往[视频 1](https://www.bilibili.com/video/BV1WP411c7hS/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=54e7eade4a03bd519275169a8a9f51f6)|[视频 2](https://www.bilibili.com/video/BV1Ur4y1w7tv/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=54e7eade4a03bd519275169a8a9f51f6)学习原理_

---

---

#### **算法复杂度与稳定性**

---

- **稳定性复杂度口诀**

  > 1、**插帽龟**(插入、冒泡、归并)，它很**稳**(稳定性)，此外还有**基你太稳**(基数排序)  
  > 2、插帽龟喜欢**选帽插**(选择、冒泡、插入)，插完就**方**了(平均时间复杂度 O(n<sup>2</sup>))  
  > 3、**快归队**(快速、归并、堆)，**n 老二**(平均时间复杂度 O(n\*log<sub>2</sub>n))

<!-- more -->

- **稳定性复杂度表格**(基数排序中 r 为关键字基数，d 为长度，n 为关键字个数)

  |   排序   |       平均 T(n)        |       辅助 S(n)        | 稳定性 |
  | :------: | :--------------------: | :--------------------: | :----: |
  | 插入排序 |    O(n<sup>2</sup>)    |          O(1)          |  稳定  |
  | 希尔排序 |   O(n<sup>2/3</sup>)   |          O(1)          | 不稳定 |
  | 选择排序 |    O(n<sup>2</sup>)    |          O(1)          | 不稳定 |
  |  堆排序  | O(n\*log<sub>2</sub>n) |          O(1)          | 不稳定 |
  | 冒泡排序 |    O(n<sup>2</sup>)    |          O(1)          |  稳定  |
  | 快速排序 | O(n\*log<sub>2</sub>n) | O(n\*log<sub>2</sub>n) | 不稳定 |
  | 归并排序 | O(n\*log<sub>2</sub>n) |          O(1)          |  稳定  |
  | 基数排序 |      O(d\*(r+n))       |       O(r\*d+n)        |  稳定  |

---

#### **冒泡排序**

---

##### **原理与实现**

- **冒泡排序原理**

  > 1、**冒泡排序**英文为**Bubble Sort**，是一种最基础的**交换排序**  
  > 2、排序过程简述为，每轮比较过程中**比较相邻的两个数**，**按照规则交换**，每轮结束都能将该轮该数**依次罗列在末尾**

- **冒泡排序实现**

  ```c
  #include <stdio.h>

  // 采用两层循环实现的方法
  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void bubblesort1(int arr[], unsigned int n)
  {
      if (n < 2) // 参数小于2不需要排序
          return;

      int temp;

      // 从末元素开始，到首元素+1，限制 j 的比对范围，共 n-1 轮对比
      // 每轮结束后，当前 i 的位置便是排序好的
      for (int i = n - 1; i > 0; i--)
      {
          // 每次只需比较 0-i 之间的元素，i 之后的元素是排序好的
          for (int j = 0; j < i; j++)
          {
              // 升序，如果当前比后一个数大，则交换
              if (arr[j] > arr[j + 1])
              {
                  temp = arr[j];
                  arr[j] = arr[j + 1];
                  arr[j + 1] = temp;
              }
          }
      }
  }

  // 采用递归的方法实现
  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void bubblesort2(int arr[], unsigned int n)
  {
      if (n < 2) // 参数小于2不需要排序
          return;

      int temp;

      // 相当于上面函数的内层循环，外层循环通过递归实现
      for (int i = 0; i < n - 1; i++)
      {
          if (arr[i] > arr[i + 1])
          {
              temp = arr[i];
              arr[i] = arr[i + 1];
              arr[i + 1] = temp;
          }
      }

      bubblesort2(arr, n - 1); // 递归实现外层循环
  }

  int main(void)
  {
      int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

      bubblesort1(arr, 15);
      bubblesort2(arr, 15);

      // 输出
      for (int i = 0; i < 15; i++)
          printf("%d ", arr[i]);
      return 0;
  }
  ```

##### **排序优化**

- **冒泡排序优化方案**

  > 1、如果**序列已经是有序的**，可以优化**冒泡排序**的方法  
  > 2、具体做法是**每趟排序时**判断**是否交换过元素**，如果**没有交换**，则证明**数列已经有序**，可以**提前退出排序**

- **优化后代码**

  ```cpp
  #include <stdbool.h>
  #include <stdio.h>

  // 采用两层循环实现的方法
  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void bubblesort(int arr[], unsigned int n)
  {
      if (n < 2) // 参数小于2不需要排序
          return;

      int temp;
      bool ifswap; // 每趟过程中是否有交换

      // 从末元素开始，到首元素+1，限制 j 的比对范围，共 n-1 轮对比
      // 每轮结束后，当前 i 的位置便是排序好的
      for (int i = n - 1; i > 0; i--)
      {
          // 初始化交换标志为未交换
          ifswap = false;

          // 每次只需比较 0-i 之间的元素，i 之后的元素是排序好的
          for (int j = 0; j < i; j++)
          {
              // 升序，如果当前比后一个数大，则交换
              if (arr[j] > arr[j + 1])
              {
                  temp = arr[j];
                  arr[j] = arr[j + 1];
                  arr[j + 1] = temp;
                  ifswap = true; // 设定为有交换
              }
          }

          // 没有交换提前退出
          if (ifswap == false)
              return;
      }
  }

  int main(void)
  {
      int arr[15] = {2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 48, 50, 47, 46, 44};

      // 在 38 后的部分排序完后，再经过一轮改变 ifswap 后就会直接结束排序
      bubblesort(arr, 15);

      // 输出
      for (int i = 0; i < 15; i++)
          printf("%d ", arr[i]);
      return 0;
  }
  ```

---

#### **选择排序**

---

##### **原理与实现**

- **选择排序原理**

  > 1、**选择排序**英文为**Selection Sort**，其原理十分简单清晰  
  > 2、**从头到尾**扫描序列，找出**最大或最小的元素**，**与第一个元素交换**，然后再从**剩下的序列**中继续这种**选择交换**

- **选择排序实现**

  ```c
  #include <stdio.h>

  // 采用两层循环实现的方法
  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void selectsort1(int arr[], unsigned int n)
  {
      if (n < 2) // 参数小于2不需要排序
          return;

      int temp, iminpos; // 最小值的下标

      // 共进行 n-1 轮比较
      for (int i = 0; i < n - 1; i++)
      {
          iminpos = i; // 默认当前位置最小

          // i+1 到 n 是这次需要对比的剩余序列
          for (int j = i + 1; j < n; j++)
          {
              // 升序，如果更小，则记录当前位置
              if (arr[j] < arr[iminpos])
                  iminpos = j;
          }

          // 如果最小位置有变动，则交换它们的元素
          if (iminpos != i)
          {
              temp = arr[i];
              arr[i] = arr[iminpos];
              arr[iminpos] = temp;
          }
      }
  }

  // 采用递归实现的方法
  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void selectsort2(int arr[], unsigned int n)
  {
      if (n < 2) // 参数小于2不需要排序
          return;

      int temp, iminpos = 0; // 每趟循环最小值的下标

      for (int i = 1; i < n; i++)
      {
          // 找出更小的元素，记录它的位置
          if (arr[i] < arr[iminpos])
              iminpos = i;
      }

      // 如果本趟循环的最小元素不是起始元素，则交换它们的位置
      if (iminpos != 0)
      {
          temp = arr[0];
          arr[0] = arr[iminpos];
          arr[iminpos] = temp;
      }

      selectsort2(arr + 1, --n); // 递归，起始位置 +1，元素个数 -1
  }

  int main(void)
  {
      int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

      selectsort1(arr, 15);
      selectsort2(arr, 15);

      // 输出
      for (int i = 0; i < 15; i++)
          printf("%d ", arr[i]);
      return 0;
  }
  ```

##### **排序优化**

- **选择排序优化方案**

  > 1、**选择排序**一趟排序只选择**最大或最小值**，优化的办法是一趟**同时**把**最大和最小值**选出来  
  > 2、排序过程中，**最小的放左边**，**最大的放右边**。这样优化可以**循环趟数减半**

- **优化后代码**

  ```c
  #include <stdio.h>

  // 采用两层循环实现的方法
  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void selectsort1(int arr[], unsigned int n)
  {
      if (n < 2) // 参数小于2不需要排序
          return;

      int ileft = 0, iright = n - 1; // 每趟排序最左和最右的位置，最左从 0 开始，最右到 n-1 结束
      int temp, iminpos, imaxpos;    // 最小值和最大值的下标

      // 只要最左仍在最右的左边
      while (ileft < iright)
      {
          iminpos = imaxpos = ileft; // 初始化最小值和最大值的下标为最左

          // 每趟循环从最左和最右范围中选取元素
          for (int i = ileft; i <= iright; i++)
          {
              if (arr[i] < arr[iminpos])
                  iminpos = i;
              if (arr[i] > arr[imaxpos])
                  imaxpos = i;
          }

          // 如果本趟循环最小的元素不是最左边的元素，则交换位置
          if (iminpos != ileft)
          {
              temp = arr[ileft];
              arr[ileft] = arr[iminpos];
              arr[iminpos] = temp;
          }

          // 如果 imaxpos 的位置是 ileft，在上面代码中，ileft 已被交换到了 iminpos 的位置
          // 所以 imaxpos 的值要修改成 iminpos
          if (imaxpos == ileft)
              imaxpos = iminpos;

          // 如果本趟循环最大的元素不是最右边的元素，则交换位置
          if (imaxpos != iright)
          {
              temp = arr[iright];
              arr[iright] = arr[imaxpos];
              arr[imaxpos] = temp;
          }

          // 更改范围
          ileft++;
          iright--;
      }
  }

  // 采用递归实现的方法
  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void selectsort2(int arr[], unsigned int n)
  {
      if (n < 2) // 参数小于2不需要排序
          return;

      int ileft = 0, iright = n - 1; // 每趟排序最左和最右的位置，最左从 0 开始，最右到 n-1 结束
      int temp, iminpos = 0, imaxpos = 0; // 每趟循环最小值和最大值的下标

      // 每趟循环从最左和最右范围中选取元素
      for (int i = ileft; i <= iright; i++)
      {
          if (arr[i] < arr[iminpos])
              iminpos = i;
          if (arr[i] > arr[imaxpos])
              imaxpos = i;
      }

      // 如果本趟循环最小的元素不是最左边的元素，则交换位置
      if (iminpos != ileft)
      {
          temp = arr[ileft];
          arr[ileft] = arr[iminpos];
          arr[iminpos] = temp;
      }

      // 如果 imaxpos 的位置是 ileft，在上面代码中，ileft 已被交换到了 iminpos 的位置
      // 所以 imaxpos 的值要修改成 iminpos
      if (imaxpos == ileft)
          imaxpos = iminpos;

      // 如果本趟循环最大的元素不是最右边的元素，则交换位置
      if (imaxpos != iright)
      {
          temp = arr[iright];
          arr[iright] = arr[imaxpos];
          arr[imaxpos] = temp;
      }

      selectsort2(arr + 1, n - 2); // 递归，起始位置 +1，元素个数 -2
  }

  int main(void)
  {
      int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

      selectsort1(arr, 15);
      selectsort2(arr, 15);

      // 输出
      for (int i = 0; i < 15; i++)
          printf("%d ", arr[i]);
      return 0;
  }
  ```

---

#### **插入排序**

---

##### **原理与实现**

- **插入排序原理**

  > 1、**插入排序**英文为**Insertion sort**  
  > 2、**插入排序**原理是通过**构建有序序列**，对于**未排序数据**，在**已排序序列**中从后向前扫描，**找到相应位置**并**插入**

- **插入排序实现**

  ```c
  #include <stdio.h>

  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void insertsort(int arr[], unsigned int n)
  {
      if (n < 2) // 参数小于2不需要排序
          return;

      int i, j;
      int temp; // 当前需要排序的元素的值

      // 从第二个数开始，到最后一个数
      for (i = 1; i < n; i++)
      {
          temp = arr[i]; // 待排序元素

          // 从已排序的序列最右边开始，把大于当前元素的元素后移，同时寻找需要插入的位置
          for (j = i - 1; j >= 0; j--)
          {
              if (arr[j] > temp)
                  arr[j + 1] = arr[j]; // 逐个元素后移
              else                     // arr[j] <= temp
                  break;               // 找到了需要插入的位置，j+1 便是被排序元素的位置
          }

          // 插入当前排序的元素
          arr[j + 1] = temp;
      }
  }

  int main(void)
  {
      int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

      insertsort(arr, 15);

      // 输出
      for (int i = 0; i < 15; i++)
          printf("%d ", arr[i]);
      return 0;
  }
  ```

##### **排序优化**

- **插入排序的不足**

  > 1、寻找插入位置  
  > 2、移动元素

- **插入排序优化方案**

  > 1、对**已排序的序列**，采用**二分查找**方法  
  > 2、携带**多个元素**  
  > 3、数据**链表化**  
  > 4、**希尔排序**

---

#### **希尔排序**

---

##### **原理与实现**

- **希尔排序原理**

  > 1、**希尔排序**英文为**Shell's Sort**，是**插入排序**的一种，是针对**插入排序**的**改进**  
  > 2、**希尔排序**基本思想把**待排序的数列**分为**多个组**，然后再对**每个组**进行**插入排序**。先让数列整体**大致有序**，然后多次**调整分组方式**，使数列**更加有序**。最后再使用一次**插入排序**，整个数列将**全部有序**(建议听讲解了解原理)  
  > 3、每次分组都**每间隔 x-1 个一组**(x 为上轮分得的组数除以 2，表示这轮分出的组数)，注意分组是**间隔分组**而不是**相邻分组**。分组并排序后，每组中**较大的数**都放到每组的**靠右的位置**，整体上**较大的数**就更**偏右侧**  
  > 4、**希尔排序**的核心思想是**化远为近**，**查找次数**和**移动次数**都**有所减少**，在数据量较大时差距十分明显

- **希尔排序实现**

  ```c
  #include <stdio.h>

  // 希尔排序中的单组排序
  // arr 是待排序的数组，n 是数组总长度，ipos 是分组的起始位置， istep 是分组的步长(增量)
  void groupsort(int arr[], int n, int ipos, int istep)
  {
      // 插入排序稍作更改
      int i, j, temp; // 当前需要排序的元素的值

      // 从当前组第二个元素开始，到末尾结束，每次移动步长
      for (i = ipos + istep; i < n; i += istep)
      {
          temp = arr[i]; // 待排序元素

          // 从已排序的最右边开始，把大于当前排序的元素后移
          for (j = i - istep; j >= 0; j -= istep)
          {
              if (arr[j] > temp)
                  arr[j + istep] = arr[j];
              else
                  break;
          }

          arr[j + istep] = temp;
      }
  }

  // 希尔排序
  // 参数 arr 是待排序的数组首元素地址，n 是数组元素个数
  void shellsort(int arr[], unsigned int n)
  {
      // istep 为步长，每次减为原来的一半取整，最后一次必定为 1
      for (int istep = n / 2; istep > 0; istep /= 2)
      {
          // 共 istep 个组，对每一组都执行插入排序
          for (int i = 0; i < istep; i++)
          {
              groupsort(arr, n, i, istep);
          }
      }
  }

  int main(void)
  {
      int arr[15] = {44, 3, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

      shellsort(arr, 15);

      // 输出
      for (int i = 0; i < 15; i++)
          printf("%d ", arr[i]);
      return 0;
  }
  ```

---

#### **快速排序**

---

##### **原理与实现**

- **快速排序原理**

  > 1、

---

#### **页底评论**

---
