---
title: 算法复杂度分析
author: 圣奇宝枣
description: 分析算法的时间复杂度与空间复杂度
sticky: 0
date: 2022-12-06 15:19:55
updated: 2022-12-06 15:19:55
readmore: true
tags:
  - 理论
categories:
  - 编程技巧与算法
---

---

#### **引入**

---

- **引入**

  > 1、**算法竞赛**是思维脑力的较量。一道**好的算法题**可以区分出**好的算法程序**(可以获得较高得分)和**不那么好的算法程序**(低分甚至零分)  
  > 2、**评价算法的优劣**是有一套**标准**的。利用这套标准，可以在**动手实践之前**即可**估计这种写法是否靠谱**  
  > 3、如果判断这套算法**可能超时**或**超出内存限制**而导致无法得分，则应该想想有没有**更好的写法**  
  > 4、接下来便来学习**如何评价一套算法**

<!-- more -->

---

#### **如何评价算法**

---

- **代码可实现**

  > 1、按照**编程者的能力**可以将算法**通过代码实现**出来  
  > 2、如果想出算法但**无法实现**，或者需要**花费非常多的时间和行数**(甚至超出比赛时间)才能编写，显然是不行的

- **结果正确**

  > 1、程序能够**运行完毕**，不会在运行过程中**出错崩溃**  
  > 2、输出的**结果必须符合期望**，**通过测试点**

- **能在限定时间内运行完毕**

  > 1、在**结果正确**的前提下，**运行时间越短越好**  
  > 2、对于一些**数据量较大**的题目，需要**尽力优化程序的运行时间**，否则会因为**超时**而**无法通过测试点**

- **不超过内存等资源限制**

  > 1、计算机的**内存是有限的**，所以**使用过多的内存**也是不行的  
  > 2、竞赛通常也会**额外限制内存**，因此需注意**不要超出内存限制**

---

#### **时间复杂度**

---

- **定义**

  > 1、**一个语句**的**频度**是指该语句在算法中**被重复执行的次数**  
  > 2、算法中**所有语句的频度之和**记为 T(n)，它是该算法**问题规模 n**的函数，**时间复杂度**主要分析 T(n)的数量级  
  > 3、算法中**基本运算的频度**(即最深层循环内的语句的频度)与 T(n)同数量级，因此通常采用算法中**基本运算的频度**f(n)来分析算法的**时间复杂度**  
  > 4、因此算法的**时间复杂度**记为 T(n) = O(f(n))

- **分类**

  > 1、**最坏时间复杂度**：指在**最坏情况下**，算法的时间复杂度  
  > 2、**平均时间复杂度**：指**所有可能输入实例**在**等概率出现**的情况下，算法的期望运行时间  
  > 3、**最好时间复杂度**：指在**最好情况下**，算法的时间复杂度

- **规则**

  > 1、**加法规则**：T(n) = T<sub>1</sub>(n) + T<sub>2</sub>(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))；多项相加，**只保留最高阶的项**，**且系数变为 1**(如 O(n<sup>2</sup>) + O(n<sup>3</sup>) = O(n<sup>3</sup>))  
  > 2、**乘法规则**：T(n) = T<sub>1</sub>(n) \* T<sub>2</sub>(n) = O(f(n)) \* O(g(n)) = O(f(n)\*g(n))；多项相乘，**都保留**  
  > 3、**常见的渐进时间复杂度**：O(1) < O(log<sub>2</sub>n) < O(n) < O(n\*log<sub>2</sub>n) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)；口诀：常对幂指阶

- **含义理解**

  > 1、O(1)是**最低的时间复杂度**，也就是**耗时与输入数据大小无关**，无论 n 为几，运行步骤都是一样的  
  > 2、O(log<sub>2</sub>n)，当数据增大 n 倍时，耗时增大 log<sub>2</sub>n 倍。如数据增大 256 倍，耗时只增加 8 倍，如二分查找算法  
  > 3、O(n)，就代表**数据量增大几倍**，**耗时也增大几倍**  
  > 4、以此类推

- **例题 1**

  - **程序**

    ```c
    void fun(int n)
    {
        int i = 1;
        while (i <= n)
            i = i * 2;
    }
    ```

  - **解题步骤**

    - **找出基本运算**：`i = i * 2`

    - **设出执行时间**：`t`

    - **分析关系**

      |  t  |       i       |
      | :-: | :-----------: |
      |  1  |       2       |
      |  2  |       4       |
      |  3  |       8       |
      |  t  | 2<sup>t</sup> |

    - 因为`while()`执行`i<=n`次，即执行 2<sup>t</sup><=n 次，t<=log<sub>2</sub>n，T(n) = O(log<sub>2</sub>n)

- **例题 2**

  - **程序**

    ```c
    int x = 2;
    while (x < n / 2)
        x = 2 * x;
    ```

  - **解题步骤**

    - **找出基本运算**：`x = 2 * x`

    - **设出执行时间**：`t`

    - **分析关系**

      |  t  |        x        |
      | :-: | :-------------: |
      |  1  |        4        |
      |  2  |        8        |
      |  3  |       16        |
      |  t  | 2<sup>t+1</sup> |

    - 因为`while()`执行`x<=n/2`次，即执行 2<sup>t+1</sup><=n/2 次，t+1<=log<sub>2</sub>(n/2)，t<log<sub>2</sub>n - 2，根据加法规则 T(n) = O(log<sub>2</sub>n)

- **例题 3**

  - **程序**

    ```c
    int fact(int n)
    {
        if (n <= 1)
            return 1;
        return n * fact(n - 1);
    }
    ```

  - **解题步骤**

    - `if()`为递归出口，**始终执行一次**，即为常数级 O(1)

    - 调用递归的`return`中，n 始终执行**同样的乘法操作**，所以为 O(1)；由于**问题规模 n 的函数**与 T(n)挂钩，因此当问题规模变为 n-1 时，则应为 T(n-1)

    - 此时**分类讨论**：当 n<=1 时，T(n) = O(1)；当 n>1 时，T(n) = O(1) + T(n-1)

    - 讨论 n>1 的时候，假设 n 无限大。T(n) = O(1) + T(n-1)；此时 T(n-1)继续调用，T(n) = O(1) + O(1) + T(n-2) = 2\*O(1) + T(n-2)；再次调用，T(n) = 3\*O(1) + T(n-3)

    - 此时出现规律，假设 O(1)前面的系数为 i，则 T(n) = i\*O(1) + T(n-i)；我们的目的是要消去 T(n-i)这项，所以要将它化为 T(1)，即令 i=n-1，此时原式 = (n-1)\*O(1) + T(1)

    - 得出 T(n) = (n-1)\*O(1) + T(1)，**常数级**都可以**忽略不计**，根据加法规则，(n-1)的 -1 也可以去除，所以最终 T(n) = O(n)

- **例题 4**

  - **程序**

    ```c
    int count = 0;
    for (int k = 1; k <= n; k *= 2)
        for (int j = 1; j <= n; j++)
            count++;
    ```

  - **解题步骤**

    - **找出基本运算**：`count++`

    - **设出执行时间**：`t`

    - 易得内层循环次数为 n，设**外层循环次数**为 q

    - **分析关系**

      |  q  |       k       |
      | :-: | :-----------: |
      |  1  |       2       |
      |  2  |       4       |
      |  3  |       8       |
      |  q  | 2<sup>q</sup> |

    - 因为`k<=n`，所以 2<sup>q</sup><=n，q<=log<sub>2</sub>n

    - 外层循环循环一次，内层循环循环 n 次，那么外层 log<sub>2</sub>n 次，内层则应为 n\*log<sub>2</sub>n 次

    - 所以最终 T(n) = O(n\*log<sub>2</sub>n)

- **例题 5**

  - **程序**

    ```c
    int func(int n)
    {
        int i = 0, sum = 0;
        while (sum < n)
            sum += ++i;
        return i;
    }
    ```

  - **解题步骤**

    - **找出基本运算**：`sum += ++i`

    - **设出执行时间**：`t`

    - **分析关系**

      |  t  |     sum     |
      | :-: | :---------: |
      |  1  |     0+1     |
      |  2  |     1+2     |
      |  3  |    1+2+3    |
      |  4  |   1+2+3+4   |
      |  t  | 1+2+3+...+t |

    - 因为`sum < n`，所以`1+2+3+...+t < n`，等差数列 t(t+1) / 2 < n，化为 t(t+1) < 2n，可以**忽略常数项**，即 t<sup>2</sup> < n，则 t < √(n)

    - 因此最终 T(n) = O(n<sup>1/2</sup>)

- **例题 6**

  - **程序**

    ```c
    for (int i = n - 1; i > 1; i--)
        for (int j = 1; j < i; j++)
            if (a[j] > a[j + 1])
                // (省略代码)a[j]与a[j+1]对调
    ```

  - **解题步骤**

    - **找出基本运算**：`a[j]与a[j+1]对调`

    - **设出执行时间**：`t`

    - 易得外层循环次数为 n，设**内层循环次数**为 q

    - **分析关系**

      |  i  |  q  |      t       |
      | :-: | :-: | :----------: |
      | n-1 | n-1 | (n-1)\*(n-1) |
      | n-2 | n-2 | (n-2)\*(n-2) |
      | n-3 | n-3 | (n-3)\*(n-3) |

    - 易得 T(n) = O(n<sup>2</sup>)

- **例题 7**

  - **程序**

    ```c
    int x = 0;
    while (n >= (x + 1) * (x + 1))
        x = x + 1;
    ```

  - **解题步骤**

    - **找出基本运算**：`x = x + 1`

    - **设出执行时间**：`t`

    - **分析关系**

      |  t  |  x  |
      | :-: | :-: |
      |  1  |  1  |
      |  2  |  2  |
      |  3  |  3  |
      |  t  |  t  |

    - 因为`n >= (x + 1) * (x + 1)`，即 n >= (t+1)<sup>2</sup>

    - 所以 t+1<=√(n)，即 t <= n<sup>1/2</sup> -1

    - 根据加法规则，T(n) = O(n<sup>1/2</sup>)

---

#### **页底评论**

---
