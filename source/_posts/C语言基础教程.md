---
title: C语言基础教程
author: 圣奇宝枣
description: 有关于C语言的基础教程，包括基本语法、基础的底层逻辑知识与一部分数据结构，比较适合有一定经验的初学者上手
sticky: 1
date: 2022-05-09 08:21:06
updated: 2022-11-03 21:14:48
readmore: true
tags:
  - C语言
  - 基础语法
categories:
  - 编程语言入门
---

---

#### **初识 C 语言**

---

<div class="success">

> **章节概要**：C 语言的特点；计算机工作原理；高级计算机语言；编译器；编程步骤；C 编程机制

</div>

##### **特点**

- **设计特性**：
  > C 语言融合了**计算机科学理论**和**实践的控制特性**  
  > C 语言的设计理念让用户轻松完成**自顶向下的规划**、**结构化编程**和**模块化设计**

<!-- more -->

- **高效性**：
  > C 语言充分利用计算机的优势，因此**程序更紧凑**，**运行速度很快**  
  > C 语言具有通常汇编语言才具有的微调控制能力，可以更具具体情况**微调程序**以获得**最大运行速度**或**最有效地使用内存**
- **可移植性**：
  > C 是可移植的语言，这意味着，在一种系统中编写的 C 程序**稍作修改**或**不修改**就能在其他系统上运行  
  > 注意程序中针对**特殊硬件设备**(如显示监视器)或**操作系统特殊功能**编写的部分**通常不可移植**  
  > C 语言与 UNIX 关系密切，**UNIX 系统**通常会将 C 编译器作为**软件包**的一部分  
  > 供个人计算机使用的 C 编译器很多，因此在**各个版本的操作系统**上，都可以找到合适的 C 编译器
- **强大而灵活**：
  > C 语言功能**强大而灵活**  
  > UNIX 操作系统、其他语言(FORTRAN、Perl、Python、Pascal)等的**编译器**和**解释器**都是**用 C 语言编写**的
- **面向程序员**：
  > C 语言是为了满足程序员的需求而设计的，程序员可以利用 C **访问硬件**、**操控内存中的位**  
  > 大多数 C 实现都有一个**大型的库**，包含众多有用的 **C 函数**，可以让程序员更加方便地使用 C 语言

##### **通俗了解计算机工作原理**

- 简而言之，计算机的**工作原理**是：如果希望计算机做某些事，就必须为其提供**特殊的指令列表**(**程序**)，确切地告诉计算机要做的事以及如何做。你必须用**计算机能直接明白的语言**(**机器语言**)创建程序。这是一项繁杂、乏味、费力的任务

##### **高级计算机语言与编译器**

- **高级编程语言**(如 C 语言)以多种方式**简化了编程工作**。首先，不必用数字码表示指令；其次，使用的指令更贴近你如何想这个问题，而不是类似计算机那样繁琐的步骤
- **编译器**是把**高级语言**程序**翻译**成计算机能理解的**机器语言**指令集的程序，在计算机看来，高级语言指令就是一堆无法理解的无用数据。由此，程序员进行高级思维活动，而编译器则负责处理冗长乏味的细节工作

##### **使用 C 语言的 7 个步骤**

- C 是**编译型语言**，我们把编写 C 语言的程序分解为七个步骤：
  > 1、定义程序的目标  
  > 2、设计程序  
  > 3、编写代码  
  > 4、编译  
  > 5、运行程序  
  > 6、测试与调试程序  
  > 7、维护和修改代码

##### **编程机制**

- 用 C 语言编写程序时，编写的内容被储存在文本文件中，该文件被称为**源代码文件**(**source code file**)。大部分 C 系统，都要求文件名以`.c`结尾
- C 编程的**基本策略**是，用程序把**源代码**文件**转换**成**可执行文件**(其中包含可直接运行的机器语言代码)  
  典型的 C 实现通过**编译**和**链接**两个步骤来完成这一过程。**编译器**把源代码转换成**中间代码**，**连接器**把中间代码和其他代码**合并**，生成可执行文件  
  ![](https://s2.loli.net/2022/05/22/ZyhE6a39RIPUOg4.png)

---

#### **C 语言概述**

---

<div class="success">

> **章节概要**：C 语言程序简单示例；`#include`与头文件；主函数`main`；注释；花括号；声明与变量；赋值；`printf`函数；`return`语句；C 语言程序基础结构；多条声明；打印多个值；多个函数；关键字和保留标识符

</div>

##### **简单的 C 程序示例及分析**

- **示例程序**

  ```c
  #include <stdio.h>

  int main(void)                //一个简单的C程序
  {
      int num;                  //定义一个名为num的变量
      num = 1;                  //为num赋一个值
      printf("I am a simple "); //使用printf函数
      printf("computer.\n");
      printf("my favourite number is %d because it is first.\n", num);
      return 0;
  }
  ```

- **程序分析及知识概要**

  - `#include`指令和**头文件**
    > 1、`#include <stdio.h>`在程序的**第一行**，该语句作用相当于把`stdio.h`**文件**中的**所有内容**都**输入该行所在位置**，本质上是一种“**拷贝-粘贴**”的操作。`include`文件提供了一种方便的途径共享许多程序共有的信息  
    > 2、`#include`这行代码是一条 C**预处理器命令**，通常，C 编译器在编译前会对源码做一些**准备工作**，即**预处理**  
    > 3、所有的 C 编译器软件都提供`stdio.h`头文件，该文件包含供编译器使用的**IO 函数**(**I:input 输入，O:output 输出**)。该文件名含义为**标准输入/输出头文件**。通常，C 程序顶部的信息集合被称为**头文件**
  - `main()`函数
    > 1、`main()`函数是程序的**主函数**，它是程序的入口点，**从这里开始执行**  
    > 2、`int main()`中`int`是函数的**返回类型**，表明函数**返回操作系统**的是**整数**，此处将在后续探讨  
    > 3、如果浏览旧式的 C 代码，会发现程序如`main()`开始，C90 标准勉强接受这种形式，但 C99 和 C11 标准不允许，因此不要这样写  
    > 4、你还会看到`void main()`的形式，部分编译器允许这样写，但所有标准都未认可，因此也不要这样写
  - **注释**
    > 1、注释是一种**记录程序信息**的方式，**被注释的部分不会被程序运行**  
    > 2、可以使用`/*注释内容*/`进行注释，此类注释可以换行注释，直到`*/`为止  
    > 3、也可以使用`//`进行注释(C99 新加入)，此类注释不能换行，直到行尾为止
  - **花括号**
    > 1、程序中花括号`{}`把`main()`括起来，一般而言，所有的**C 函数**都**使用花括号标记**函数体的**开始和结束**  
    > 2、花括号还可用于把函数中**多条语句**合并为一个**单元**和**块**
  - **声明与变量**
    > 1、`int num;`这行代码叫做**声明**，声明是 C 语言中最重要的特性之一  
    > 2、该条例中，声明**完成了两件事**。其一，函数中**有一个**名为`num`的**变量**，其二，`int`表示`num`的**数据类型**是一个**整数**  
    > 3、`int`是 C 语言中的一个**关键字**，表示一种基本的 C 语言**数据类型**。关键字是**语言定义的单词**，不能用做其他用途，例如不可作为函数名或变量名  
    > 4、`num`是一个**标识符**，也就是一个**变量、函数或其他实体**的**名称**  
    > 5、把**变量**声明正确的为**数据类型**(整型、浮点型、字符等)，**计算机**才能正确的**存储、读取和解释数据**  
    > 6、变量的**命名**，要尽可能使用**有意义**的变量名或标识符，如程序需要一个变量属羊，则可起名**sheep_count**。变量命名时仅可以使用**大小写字母、数字和下划线**，且第一个字母不能是数字
  - **赋值**
    > 1、`num = 1`是**赋值表达式语句**，**赋值**是 C 语言的**基本操作**之一，意为“**把值 1 赋给变量**`num`”  
    > 2、在执行`int num`声明时，编译器在计算机**内存**中为变量`num`**预留了空间**，然后执行赋值表达式语句时，把值存储在**预留的位置**  
    > 3、注意，赋值表达式语句**从右侧把值赋给左侧**，另外，该语句以分号`;`结尾
  - `printf`函数
    > 1、`printf`是 C 语言的一个**标准函数**，圆括号`()`表明`printf`是一个**函数名**，**圆括号中的内容**是从`main()`函数**传递**给`printf`函数的信息  
    > 2、`printf`函数会查看**双引号中的内容**(**字符串**)，并将其**打印**到屏幕上  
    > 3、`\n`的作用是**换行**，`\n`组合代表一个**换行符**。换行符是一个**转义列表**，用于代表**难以表示**或**无法输入**的字符。如`\t`代表**Tab 键**，`\b`代表**Backspace 键**，每个转义序列都以**反斜杠**`\`开始  
    > 4、对比发现，参数中的`%d`被数字 1**代替**了，而 1 就是`num`的值。`%d`是一个**占位符**，其作用是**指明**输入`num`的**位置**
  - `return`语句
    > 1、`int main(void)`中的`int`表明函数`main`要**返回一个整数**，C 标准**要求**`main()`这样做。  
    > 2、**有返回值**的 C 函数要有`return`语句，该语句以`return`关键字**开始**，后面是**待返回的值**，并以分号`;`**结尾**  
    > 3、如果遗漏`main`函数末尾的`return`语句，程序在运行至最外面的`}`时，会自动**返回**一个**默认值**，**即 0**。因此此处**可以省略**，但在**其他**有返回值的函数中**不可省略**，所以**建议保留**此习惯

- **简单程序的结构**

  - 程序由**一个或多个函数**组成，**必须有**`main()`函数。
  - 函数由**函数头**和**函数体**组成，函数头包括**函数名**、**传入该函数的信息类型**和**函数的返回值类型**
  - 通过**函数名后**的**圆括号**可以识别出函数，圆括号里**可能为空**，**可能有参数**
  - **函数体**被**花括号**括起来，由一系列**语句**、**声明**组成

  ![](https://s2.loli.net/2022/05/22/Rm4WvcyqaZkgLuQ.png)

  - 简言之，一个简单的 C 语言程序格式如下(**大部分语句**都以**分号**`;`**结尾**)：

    ```c
    #include <stdio.h>
    int main(void)
    {
        //语句
        return 0;
    }
    ```

##### **进一步使用 C**

- **示例程序**

  ```c
  //把2英寻转换成英尺
  #include <stdio.h>
  int main(void)
  {
      int feet, fathoms;
      fathoms = 2;
      feet = 6 * fathoms;
      printf("There are %d feet in %d fathoms!\n", feet, fathoms);
      printf("Yes,I said %d feet!\n", 6 * fathoms);
      return 0;
  }
  ```

- **程序分析及知识概要**

  - **多条声明**

    > 1、`int feet, fathoms;`语句，使用**多条声明**声明了**两个变量**，使用**逗号**`,`隔开，此语句与`int feet;`+`int fathoms;`等价

  - **打印多个值**

    > 1、程序的**第一个**`printf()`进行了**两次替换**，**按顺序**将`feet`、`fathoms`替换了两个`%d`  
    > 2、第二个`printf()`说明待打印的值**不一定是变量**，只要**可求值**得出**合适类型值的项**即可

##### **多个函数**

- 把**自己的函数**添加到程序中，此处只做简单了解，后续学习：

  ```c
  #include <stdio.h>
  void def(void)
  {
      printf("hello world!");
  }

  int main(void)
  {
      def();
      return 0;
  }
  ```

##### **关键字和保留标识符**

- 下表中**粗体** 表示`C90`标准新增关键字，_斜体_ 表示`C99`标准新增关键字，**粗斜体** 表示`C11`标准新增关键字

  |  关键字   |  关键字  |    关键字    |        关键字         |
  | :-------: | :------: | :----------: | :-------------------: |
  |   auto    |  extern  |    short     |         while         |
  |   break   |  float   |  **signed**  |    **_\_Alignas_**    |
  |   case    |   for    |    sizeof    |    **_\_Alignof_**    |
  |   char    |   goto   |    static    |    **_\_Atomic_**     |
  | **const** |    if    |    struct    |     **_\_Bool_**      |
  | continue  | _inline_ |    switch    |    **_\_Complex_**    |
  |  default  |   int    |   typedef    |    **_\_Generic_**    |
  |    do     |   long   |    union     |   **_\_Imaginary_**   |
  |  double   | register |   unsigned   |   **_\_Noreturn_**    |
  |   else    | restrict |   **void**   | **_\_Static_assert_** |
  | **enum**  |  return  | **volatile** | **_\_Thread_local_**  |

---

#### **数据和 C**

---

<div class="success">

> **章节概要**：交互式程序；变量与常量数据；数据；位、字节、字；存储单元换算；数据类型关键字；C 语言基本数据类型；进制打印显示；可移植类型；使用程序获得数据类型大小

</div>

##### **交互式程序**

- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      float weight;
      float value;
      printf("Please enter your weight in pounds:");
      scanf("%f", &weight);
      value = 1700.0 * weight * 14.5833;
      printf("your weight in platinum is worth $%.2f.\n", value);
      return 0;
  }
  ```

- **新元素简单分析**
  - 新的**变量声明**，使用`float`**浮点数**类型，浮点类型可以**储存带小数的数字**，详细说明见本章后面部分
  - 为了打印**新类型**的变量(**浮点数**)，`printf`处使用`%f`**处理浮点值**了
  - `%.2f`用于**精确控制输出**，指定**保留小数**后两位
  - `scanf()`函数用于**读取键盘的输入**，`%f`说明`scanf()`**读取输入浮点数**，`&weight`告诉`scanf()`把输入的值**赋给**名为`weight`的**变量**
  - `scanf()`函数使用`&`**符号**表明找到`weight`变量的地点，下章将详细讨论，目前请按照这样写

##### **变量与常量数据**

- **变量**：有些**数据类型**在程序运行期间**可能会改变**或**被赋值**，这些称为**变量**
- **常量**：有些**数据类型**在程序使用之前已经**预先设定**好了，整个程序运行过程中**没有变化**，称为**常量**

##### **数据**

- **位、字节、字**

  > **位、字节、字**是描述**计算机数据单元**或**存储单元**的术语，这里主要指**储存单元**
  >
  > **位**(**bit**)：**最小的储存单元**。可以储存**0 或 1**，是计算机内存的**基本构成块**  
  > **字节**(**byte**)：**常用的**计算机存储单位，**字节**是**位**的**集合**，一个**字节**可以储存**8 位**。这是字节的**标准定义**，至少在衡量存储单位时是这样  
  > **字**(**word**)：是**设计计算机时**给定的**自然存储单位**，对于 8 位的微型计算机，一个字长只有 8 位。从那以后，个人计算机字节增至 16 位、32 位，直至目前的 64 位。计算机的**字长越大**，**数据转移越快**，允许的**内存访问也更多**

- **存储单元换算**

  > 1 TB=1024 GB  
  > 1 GB=1024 MB  
  > 1 MB=1024 KB  
  > 1 KB=1024 Bytes(字节)  
  > 1 Byte(字节)=8 bits(位)  
  > 1 Word(字)=2 Bytes(字节)

- **整数**

  - 和数学概念一样，**整数是没有小数部分的数**，例如 2、-23、2456 都是整数
  - 计算机以**二进制数字**存储整数，如整数 **7** 二进制写为 **111**，因此要在**8 位字节**中存储该数字，需要**前 5 位**设置为**0**，**后 3 位**设置为**1**

  ![](https://s2.loli.net/2022/05/22/lB6cG1hnKCqD8mY.png)

- **浮点数**

  - 与数学中**实数**概念差不多，例如 2.75、3.16E7、7.00、2e-8 都是浮点数
  - 注意，在一个值后面**加上小数点**，该值就成为一个**浮点数**，所以**7 是整数**，**7.00 是浮点数**
  - 此处简要介绍**e 计数法**(**科学计数法**)：**3.16E7**表示 **3.16 \* 10<sup>7</sup>**
  - 这里关键要理解**浮点数**与**整数**的**储存方案不同**，计算机把浮点数分成**小数部分**和**指数部分**表示，而且**分开存储这两部分**。**7.0**写成**0.7E1**，这里，**0.7 是小数部分**，**1 是指数部分**。计算机在内部使用**二进制**和**2 的幂**进行储存，后续探讨(**此处图例以十进制下理解为例**)

  ![](https://s2.loli.net/2022/05/22/3JspxLR21l7TcDd.png)

##### **数据类型关键字**

| 最初 K&R 给出的关键字 | C90 标准添加的关键字 | C99 标准添加的关键字 |
| :-------------------: | :------------------: | :------------------: |
|          int          |        signed        |        \_Bool        |
|         long          |         void         |      \_Complex       |
|         short         |                      |     \_Imaginary      |
|       unsigned        |                      |                      |
|         char          |                      |                      |
|         float         |                      |                      |
|        double         |                      |                      |

##### **C 语言基本数据类型**

- `int`**类型**

  > 1、C 语言中的**整数类型**可表示**不同的取值范围**和**正负值**，一般情况下使用`int`能应付绝大多数情况  
  > 2、`int`类型是**有符号整型**，即`int`的值**必须是整数**，可以是正整数、负整数、0  
  > 3、`int`类型的**取值范围**因**计算机系统而异**，一般而言，储存一个`int`要**占用一个机器字长**  
  > 4、早期**16 位**的取值范围为-2<sup>15</sup> ~ 2<sup>15</sup>-1，即`-32768 ~ 32767`，**ISO C 规定**`int`**最小范围**为`-32768 ~ 32767`  
  > 5、一般来说，系统会用一个**特殊位的值**(**未使用的第 16 位**)表示**有符号整数**的**正负号**  
  > 6、使用`%d`**打印**整数类型，`%d`称为**转换说明**，他**指定**应该用什么**格式**显示一个值  
  > 7、**显示不同进制**：使用`%d`显示十进制，`%o`显示八进制，`%x`显示十六进制。**显示前缀**使用`%#o`、`%#x`、`%#X`

  ```c
  #include <stdio.h>
  int main(void)
  {
      int x = 100;
      printf("dec=%d ; octal=%o ; hex=%x  \n", x, x, x);
      printf("dec=%#o ; octal=%#x ; hex=%#X", x, x, x);
      return 0;
  }
  ```

- **其他整数类型**

  > 1、`short`类型：占用空间可能比`int`少，有符号类型  
  > 2、`long`类型：占用空间可能比`int`多，有符号类型  
  > 3、`long long`类型(**C99 加入**)：占用空间可能比`long`多，**至少 64 位**，有符号类型  
  > 4、`unsigned`类型：**非负整型**，**16 位**取值范围 0 ~ 2<sup>16</sup>-1，即`0 ~ 65535`  
  > 5、**C90 后**，新增`unsigned short`、`unsigned long`；**C99 后**，新增`unsigned long long`  
  > 6、在任何**有符号类型前**添加关键字`signed`，可**强调**使用有符号类型的**意图**  
  > 7、空间“**可能**”多与少是因为 C**只规定**了`short`不能多于`int`，`long`不能少于`int`  
  > 8、现在**个人计算机**常见设置是，`long long`占**64 位**，`long`占**32 位**，`int`占**16 位**或**32 位**，`short`占**16 位**  
  > 9、打印时，使用`%u`打印`unsigned`类型，使用`%ld`打印`long`类型，使用`%lld`打印`long long`类型，使用`%hd`打印`short`类型

- **浮点数类型**

  > 1、**浮点类型**能表示**包括小数**在内更大范围的数，浮点数的表示类似**科学计数法**。在计算机中，科学计数法中的 10 的**指数**，跟写在字母`e`后面，如 1.02 \* 10<sup>3</sup>记作`1.02e3`  
  > 2、**单精度浮点数**`float`，C 语言规定其至少能表示**6 位有效数字**，且取值范围至少是 10<sup>-37</sup> ~ 10<sup>37</sup>。通常，系统储存一个浮点数要**占用 32 位**，**其中 8 位**用于表示**指数的值和符号**，**剩下 24 位**用于表示**非指数部分及其符号**  
  > 3、**双精度浮点数**`double`，其与`float`类型的**最小取值范围相同**，但必须至少能表示**10 位有效数字**，一般来说，`double`**占用 64 位**而非 32 位。一些系统将多出来的 32 位**全用来**表示**非指数部分**，不仅增加**有效数字位数**(**即精度**)，还减少了**舍入误差**；另一些系统把**其中一些位**分配给**指数部分**，以容纳**更大的指数**，增加**可表示数的范围**。无论哪种类型，`double`类型的值**至少有 13 位有效数字**  
  > 4、`long double`，可以满足比`double`更高的精度要求，不过，C 只保证`long double`类型至少与`double`类型的**精度相同**  
  > 5、浮点数后面加上`f`**或**`F`**后缀**可**覆盖默认设置**，编译器会将**浮点型常量**看做`float`类型，如**2.3f**，**9.11E9F**；使用`l`**或**`L`**后缀**使数字成为`long double`类型；没有后缀的浮点型常量是`double`类型  
  > 6、**打印浮点值**时，使用`%f`打印`float`类型，用`%e`打印**指数计数法**的浮点值，如果系统支持十六进制的浮点数，使用`%a`打印**十六进制**的浮点值，打印`double`或`long double`要使用`%Lf`、`%Le`和`%La`的转换说明

- `char`**字符类型**

  > 1、`char`类型用来**储存字符**，如**字母**或**标点符号**  
  > 2、从技术层面来看，`char`是**整数类型**，因为`char`类型**实际储存**的是**整数**而不是字符。计算机使用**数字编码**来**处理字符**，即用特定**整数**代表特定**字符**  
  > 3、C 常用编码为**ASCII**编码，其中如**整数 65**代表**大写字母 A**，**整数 97**代表**小写字母 a**，**整数 48**代表**数字 0**  
  > 4、标准**ASCII 码**范围为**0~127**，只需 7 位二进制数即可表示。通常，`char`被定义为**8 位的存储单元**  
  > 5、C 语言把**1 字节**定义为`char`类型占用的**位**(**bit**)**数**  
  > 6、`char`赋值时，需要传入**char 字符类型**的数据，即**单引号**`''`包裹的字符，如`char set = 'A'`。此外也可使用**ASCII 码**进行赋值，如`char set = 65`  
  > 7、有一些**代表行为**的**非打印字符**，如换行、退格、回车、蜂鸣等，这些字符**打印不出来**。如需要表示这些字符，可以使用**ASCII 码**，比如蜂鸣：`char beep = 7`。此外也可以使用**转义字符**，如`char beep = '\a'`  
  > 8、使用`%c`**打印**`char`类型字符，如果使用`%d`**打印**，则会打印**字符对应 ACSII 码的整数**

  | 转义序列 | 含义                                                                   |
  | :------: | ---------------------------------------------------------------------- |
  |    \a    | 警报(ANSI C)                                                           |
  |    \b    | 退格                                                                   |
  |    \f    | 换页                                                                   |
  |    \n    | 换行                                                                   |
  |    \r    | 回车                                                                   |
  |    \t    | 水平制表符                                                             |
  |    \v    | 垂直制表符                                                             |
  |   \\\    | 反斜杠(\)                                                              |
  |   \\'    | 单引号(')                                                              |
  |   \0oo   | 八进制值(`oo`必须是有效的八进制数，即每个`o`可表示`0~7`中的一个数)     |
  |   \xhh   | 十六进制值(`hh`必须是有效的十六进制数，即每个`h`可表示`0~f`中的一个数) |

- `_Bool`**布尔类型**

  > 1、**C99**标准新增了`_Bool`类型，用于表示**布尔值**，即逻辑值**true**和**false**  
  > 2、因为 C 语言用**值 1**表示**true**，**值 0**表示**false**，所以`_Bool`类型实质上也是一种**整数类型**  
  > 3、原则上它仅占用**1 位存储空间**，因为对与**0 和 1**而言，一位的存储空间足够了

- **可移植类型：**`stdint.h`**和**`inttypes.h`

  > 1、**C99**新增两个**头文件**`stdint.h`和`inttypes.h`，以确保 C 语言**各类型**在**各系统**中**功能正常**  
  > 2、C 语言为**现有类型**创建了**更多类型名**，这些新类型名**被定义在**`stdint.h`中  
  > 3、如在**精确宽度整数类型中**，`int32_t`**表示 32 位的有符号整数类型**。在使用**32 位系统**时，头文件会把`int32_t`当做`int`的**别名**；而在`int`为**16 位**，`long`为**32 位**的系统中，系统会把`int32_t`当做`long`的别名。然后，使用`int32_t`类型**编写程序并包含**`stdint.h`**头文件**时，**编译器**会把`int`或`long`**替换**成与**当前系统匹配**的类型  
  > 4、如果系统**不支持精确宽度整数类型**，可以使用**最小宽度类型**，例如`int_least8_t`是**可容纳 8 位有符号整数值**的类型中**宽度最小**的类型的一个**别名**  
  > 5、如果更关心**速度**而非空间，则可使用**最快最小宽度类型**，如`int_fast8_t`被定义为**系统中**对**8 位有符号值**而言**运算最快的整数类型**  
  > 6、如果需要**最大整数类型**，最大的有符号整数类型`intmax_t`**可储存任何有效的有符号整数值**。类似的，`uintmax_t`表示最大的无符号整数类型，这种类型可能比`long long`和`unsigned long long`**更大**  
  > 7、C 标准针对这种**输入和输出**，提供了一些**字符串宏**来显示可移植类型，例如`inttypes.h`中定义了`PRId32`**字符串宏**，代表打印**32 位有符号值**的**合适转换说明**(**如 d 或 l**)

  ```c
  #include <stdio.h>
  #include <inttypes.h>
  int main(void)
  {
      int32_t me32;
      me32 = 45933945;
      printf("me32 = %" PRId32 "\n", me32);
      return 0;
  }
  ```

- **复数和虚数**

  > 1、许多**科学**和**工程计算**都要用到**复数和虚数**，**C99**支持复数和虚数，但是**有所保留**  
  > 2、**复数类型**：有`float_Complex`、`double_Complex`和`long double_Complex`。例如`float_Complex`变量应包含**两个**`float`**类型的值**，分别表示复数的**实部和虚部**  
  > 3、**虚数类型**：有`float_Imaginary`、`double_Imaginary`和`long double_Imaginary`  
  > 4、如果包含`complex.h`头文件，便可用`complex`代替`_Complex`，用`imaginary`代替`_Imaginary`，还可以用 1 代替-1 的平方根

- **其他类型**

  > 1、C 语言中**没有字符串类型**，却也能很好的处理字符串，详见后续  
  > 2、C 语言还有一些**基本类型衍生**的其他类型，如数组、指针、结构、联合，详见后续  
  > 3、本章程序案例简单使用到了**指针**，如`scanf()`函数用到的`&`前缀，便创建了一个指针，告诉`scanf()`把数据放在何处

##### **获取类型大小**

- 可以使用`sizeof()`获取以**字节**为单位的**类型大小**，**C99**和**C11**提供`%zd`匹配`sizeof()`返回值，其余不支持的编译器可用`%u`或`%lu`代替

  ```c
  #include <stdio.h>
  int main(void)
  {
      printf("Type int has a size of %zd bytes.\n", sizeof(int));
      printf("Type char has a size of %zd bytes.\n", sizeof(char));
      printf("Type float has a size of %zd bytes.\n", sizeof(float));
      return 0;
  }
  ```

---

#### **字符串和格式化输入输出**

---

<div class="success">

> **章节概要**：字符串简介；char 类型数组与 null 字符；`strlen()`函数；常量与 C 预处理器；明示常量；`printf()`函数；参数传递；`scanf()`函数；`scanf`多个输入与返回值

</div>

##### **引入示例**

- **示例程序**

  ```c
  #include <stdio.h>
  #include <string.h>
  #define DENSITY 62.4 // 定义人体密度
  int main(void)
  {
      float weight, volume;
      int size, letters;
      char name[40];
      printf("Hi! What's your first name?\n");
      scanf("%s", name);
      printf("%s,whats's your weight in pounds?\n", name);
      scanf("%f", &weight);
      size = sizeof(name);
      letters = strlen(name);
      volume = weight / DENSITY;
      printf("well, %s, your volume is %2.2f cubic feet\n", name, volume);
      printf("Also, your first name has %d letters,\n", letters);
      printf("and we have %d bytes to store it.\n", size);
      return 0;
  }
  ```

- **新元素简单分析**

  - 用**数组**储存**字符串**。在该程序中，用户**输入的名**被储存在**数组**中，该数组占用内存中**40 个连续的字节**，每个字节储存一个字符值
  - 使用`%s`**转换说明**来**处理字符串**的输入和输出。注意，在`scanf`中，`name`**没有**`&`**前缀**，而`weight`有(稍后解释，`&weight`和`name`都是**地址**)
  - 用 C**预处理器**把**字符常量**`DENSITY`定义为 62.4
  - 用 C 函数`strlen()`获取字符串的长度

##### **字符串简介**

> 1、**字符串**是**一个或多个字符**的**序列**，如`"I came from America"`  
> 2、**双引号**`"`不是字符串的一部分，仅是**告知编译器**它**括起来的是字符串**，就如**单引号**`'`用于标识单个字符一样

##### **char 类型数组与 null 字符**

> 1、C 语言**没有**专门用于**存储字符串**的变量类型，字符都被储存在`char`**类型数组**中。**数组**由**连续的存储单元**组成，字符串的**字符**被储存在**相邻的存储单元**中，每个单元储存一个字符  
> 2、数组**末尾位置**有一个**空字符**(**\0**)，C 语言用**空字符**(**null**)标记**字符串结束**。这意味着**数组容量**必须**比存储字符数多 1**  
> 3、**数组**是**同类型数据元素**的**有序序列**，**方括号**`[]`表示这是一个数组  
> 4、使用`%s`来转换**打印**一个**字符串**  
> 5、**字符串**与**字符**`char`不是同一种类型，因为**字符串**最后有**空字符标识**，而`char`**只存储该字符**  
> 6、使用`strlen()`函数可以得到**字符串的字符长度**，且`strlen()`并**不会计入空字符**

##### **常量与 C 预处理器**

- **为什么要使用常量**

  > 1、使用常量名比数字**表达的信息更多**，如`area = PI * d`与`area = 3.14 * d`相比**更加直观**  
  > 2、对于程序中**多次使用同一个常量时**，如果常量的值需要**修改**，**只需要修改常量值**即可

- **如何创建符号常量**

  - 可以**定义变量**，将**其值**定义为**所需的值**，但这样程序可能会**无意间改变它的值**
  - 使用**C 预处理器**定义，格式为`#define 常量名 值`，**编译程序时**，所有的**常量名**都会**被替换**为它们的值
    - 定义常量时，**习惯上**建议**全用大写**，以此**告知他人**这是一个常量，提高程序可读性；此外也有**小众习惯**使用`c_变量名`或`k_变量名`表示常量
    - **注意**：`define`常量名后的内容用于替换符号常量，不要将`#define NUM 20`写成`#define NUM = 20`，这样定义的**WORD**值为`=20`而非`20`
  - **C90**标准新增限定词`const`，表示**只读**，也可用此**作为**常量使用(其只表明**只读变量**)，如`const float PI=3.14`

- **明示常量**

  - C 头文件`limits.h`与`float.h`分别提供与**整数与浮点数**类型**大小限制**相关的说明，如`limits.h`中有类似以下代码：
    ```c
    #define INT_MAX +32767
    #define INT_MIN -32768
    ```
  - 这些**明示常量**代表`int`类型可表示的**最大值和最小值**，**该头文件**会为这些明示常量提供**不同的值**，如果系统使用**32 位的 int**且程序包含`limits.h`头文件，则可以使用`printf()`与`%d`转换输出**该常量 32 位 int 的值**
  - 如果系统使用**4 字节的 int**，**该头文件**将提供**符合 4 字节的对应值**
  - 下为`limits.h`中的一些明示常量：

    |  明示常量  | 含义                            |
    | :--------: | ------------------------------- |
    |  CHAR_BIT  | char 类型的位数                 |
    |  CHAR_MAX  | char 类型的最大值               |
    |  CHAR_MIN  | char 类型的最小值               |
    | SCHAR_MAX  | signed char 类型最大值          |
    | SCHAR_MIN  | signed char 类型最小值          |
    | UCHAR_MAX  | unsigned char 类型的最大值      |
    |  SHRT_MAX  | short 类型的最大值              |
    | USHRT_MAX  | unsigned short 类型的最大值     |
    |  INT_MAX   | int 类型的最大值                |
    |  UINT_MAX  | unsigned int 类型的最大值       |
    |  LONG_MAX  | long 类型的最大值               |
    | ULONG_MAX  | unsigned long 类型的最大值      |
    | LLONG_MAX  | long long 类型的最大值          |
    | ULLONG_MAX | unsigned long long 类型的最大值 |

  - 相似的，`float.h`头文件下也有一些明示常量：

    |    明示常量    | 含义                                                |
    | :------------: | --------------------------------------------------- |
    |  FLT_MANT_DIG  | float 类型的尾数位数                                |
    |    FLT_DIG     | float 类型的最小有效数字位数(十进制)                |
    | FLT_MIN_10_EXP | 带全部有效数字的 float 类型的最小负指数(以 10 为底) |
    | FLT_MAX_10_EXP | float 类型的最大正指数(以 10 为底)                  |
    |    FLT_MIN     | 保留全部精度的 float 类型最小正数                   |
    |    FLT_MAX     | float 类型的最大正数                                |
    |  FLT_EPSILON   | 1.00 和比 1.00 大的最小 float 类型值之间的差值      |

##### **printf()函数**

- 请求`printf()`打印数据的**指令**要与待打印**数据类型**相匹配。例如，**打印整数**使用`%d`，**打印字符**使用`%c`。这些符号称为**转换说明**，它们指定如何把数据转换成**可显示的形式**。

- **ANSI C**标准为`printf()`提供的**转换说明**

  | 转换说明 | 输出                                                                    |
  | :------: | ----------------------------------------------------------------------- |
  |    %a    | 浮点数、十六进制数和 p 计数法                                           |
  |    %A    | 浮点数、十六进制数和 p 计数法                                           |
  |    %c    | 单个字符                                                                |
  |    %d    | 有符号十进制整数                                                        |
  |    %e    | 浮点数，e 计数法                                                        |
  |    %E    | 浮点数，e 计数法                                                        |
  |    %f    | 浮点数，十进制计数法                                                    |
  |    %g    | 根据值的不同，自动选择%f 或%e。%e 格式用于指数小于-4 或者大于等于精度时 |
  |    %G    | 根据值的不同，自动选择%f 或%E。%E 格式用于指数小于-4 或者大于等于精度时 |
  |    %i    | 有符号十进制整数(与%d 相同)                                             |
  |    %o    | 无符号八进制整数                                                        |
  |    %p    | 指针                                                                    |
  |    %s    | 字符串                                                                  |
  |    %u    | 无符号十进制整数                                                        |
  |    %x    | 无符号十六进制整数，使用十六进制数 0f                                   |
  |    %X    | 无符号十六进制整数，使用十六进制数 0F                                   |
  |    %%    | 打印一个百分号                                                          |

- `prinft()`的转换说明**修饰符**，在`%`与**转换字符**之间插入**修饰符**可修饰基本转换说明

  | 修饰符 | 含义                                                                                                                                                                                                                                                                                                                                  |
  | :----: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  |  标记  | 本表格下一张表格描述了 5 种标记(-、+、空格、#、0)，可以不使用标记或使用多个标记，如`%-10d`                                                                                                                                                                                                                                            |
  |  数字  | 最小字段宽度，如果该字段不能容纳待打印内容则会使用更宽的字段，如`%4d`                                                                                                                                                                                                                                                                 |
  | .数字  | 精度。对于`%e`和`%f`转换，表示小数点右边数字位数 ； 对于`%g`转换，表示有效数字的最大位数 ； 对于`%s`转换，表示待打印字符最大数量 ； 对于**整型**转换，表示待打印数字的最小位数。如有必要，使用前导 0 达到这个位数，只使用`.`表示其后跟随一个 0，所以`%.f`与`%.0f`相同。如`%5.2f`表示打印一个字段宽度为 5，小数点后有 2 位数字的浮点数 |
  |   h    | 和整型转换说明一起使用，表示 short int 或 unsigned short int 类型的值，如`%hu`、`%hx`、`%6.4hd`                                                                                                                                                                                                                                       |
  |   hh   | 和整型转换说明一起使用，表示 signed char 或 unsigned char 类型的值，如`%hhu`、`%hhx`、`%6.4hhd`                                                                                                                                                                                                                                       |
  |   j    | 和整型转换说明一起使用，表示 intmax_t 或 uintmax_t 的值，这些类型定义在`stdint.h`中                                                                                                                                                                                                                                                   |
  |   l    | 和整型转换说明一起使用，表示 long int 或 unsigned long int 类型的值                                                                                                                                                                                                                                                                   |
  |   ll   | 和整型转换说明一起使用，表示 long long int 或 unsigned long long int 类型的值                                                                                                                                                                                                                                                         |
  |   L    | 和浮点转换说明一起使用，表示 long double 的值                                                                                                                                                                                                                                                                                         |
  |   t    | 和整型转换说明一起使用，表示 ptrdiff_t 类型的值，ptrdiff_t 是两个指针差值的类型(C99)                                                                                                                                                                                                                                                  |
  |   z    | 和整型转换说明一起使用，表示 size_t 类型的值，size_t 是 sizeof 返回的类型(C99)                                                                                                                                                                                                                                                        |

  > 注：`%u`标记**不能把数字和符号分开**，会报错!!

- `printf()`中的**标记**

  | 标记 | 含义                                                                                                                                                                                                     |
  | :--: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  |  -   | 待打印项左对齐，即从字段左侧开始打印该项，如`%-20s`                                                                                                                                                      |
  |  +   | 有符号值若为正，则在值前面显示加号(正号)，若为负则显示减号(负号)，如`%+6.2f`                                                                                                                             |
  | 空格 | 有符号值若为正，则在值前面显示前导空格(不显示任何符号)，若为负则显示减号(负号)覆盖前导空格，如`% 6.2f`                                                                                                   |
  |  #   | 把结果转换成另一种形式。如果是`%o`格式，则从 0 开始 ； 如果是`%x`格式，则从 0x 开始 ； 如果是**浮点**格式，`#`则保证了即使后面没有任何数字也打印一个小数点 ； 如果是`%g`格式，`#`防止结果后面的 0 被删除 |
  |  0   | 对于数值格式，使用前导 0 代替空格填充字段宽度 ； 对于整数格式，如果出现-标记或指定精度，则忽略该标记                                                                                                     |

##### **参数传递**

- **参数传递机制**因实现而异，下面以**本机系统**中的**本程序**分析参数传递。该调用告诉计算机把**变量 n1、n2、n3、n4**的值传递给程序，是一种**常见的传参方式**

  ```c
  #include <stdio.h>
  int main(void)
  {
      float n1 = 3.0;
      double n2 = 3.0;
      long n3 = 2000000000;
      long n4 = 1234567890;
      printf("%ld  %ld  %ld  %ld", n1, n2, n3, n4);
      return 0;
  }
  ```

  > 1、程序把**传入的值**放入被称为**栈**的**内存区域**，计算机根据**变量类型**(**不是转换说明**)把值放入**栈**中。  
  > 2、因此，**n1**被储存在**栈**中，**占 8 字节**(**float 被转换成 double 类型**)。同样，**n2**在**栈**中也占**8 字节**，而**n3、n4**分别占**4 字节**  
  > 3、然后，控制转到`printf()`，其根据**转换说明**从**栈**中读取值。`%ld`转换说明表明**应读取 4 字节**，所以`printf()`读取**前 4 字节**作为**第 1 个值**。这是**n1 前半部分**，将被解释成**long 类型整数**，根据下一个转换说明，`printf()`**再读取 4 字节**，这是**n1 后半部分**，将被解释为**第 2 个 long 类型整数**  
  > 4、类似的，继续读取**第 3、4 个**`%ld`，读取为**n2 的前、后半部分**，并解释成**两个 long 类型整数**  
  > 5、因此，对于**n3、n4**虽然用对了转换说明，但还是**读错了字节**

  ![](https://s2.loli.net/2022/05/25/jvdeNSciuAJbRaY.png)

##### **scanf()函数**

- `scanf()`是最通用的**输入函数**，因为它可以读取**不同格式的数据**，其将输入的**字符串**转换成**整数**、**浮点数**、**字符**或**字符串**

- `scanf()`使用**指向变量的指针**，而`printf()`使用**变量、常量、表达式**

- `scanf()`的**多个输入**

  > 1、可以通过`scanf("%d%d",&n,&m)`的格式**输入多个数据**  
  > 2、`scanf()`函数允许把**普通字符**放在**格式字符串**中，**除空格外**的字符必须与输入字符串**严格匹配**  
  > 3、如`scanf("%d,%d",&n,&m)`，用户必须输入**两个整数**，并以**逗号分隔**  
  > 4、除了`%c`，其他转换说明都会**自动跳过待输入值前面的所有空白**

- `scanf()`的**返回值**

  > `scanf()`函数返回**成功读取的项数**  
  > 如果**没有成功读取**任何项，且需要读取**一个数字**而用户输入一个**数值字符串**，其便返回**0**  
  > 当`scanf()`检测到“**文件结尾**”时，会返回**EOF**。这是`stdio.h`中定义的特殊值，通常会用`#define`将其定义为-1

- **ANSI C**标准为`scanf()`准备的**转换说明**和转换说明**修饰符**

  - `scanf`的**转换说明**与**修饰符**与`printf`的基本一致，但过程上从**转换输出**变成了**解释输入**，具体使用方法参考`printf`的表格

---

#### **运算符、表达式和语句**

---

<div class="success">

> **章节概要**：`while`循环简述；运算符；赋值术语；`sizeof`运算符和`size_t`类型；表达式、语句和块；语句术语；类型转换；强制类型转换；带参数的函数；形参实参

</div>

##### **while 循环简述**

- **示例程序**

  ```c
  #include <stdio.h>
  #define ADJUST 6.37
  int main(void)
  {
      const double SCALE = 0.333;
      double shoe, foot;
      printf("Shoe size (men's)   foot length\n");
      shoe = 3.0;
      while (shoe < 10.5)
      {
          foot = SCALE * shoe + ADJUST;
          printf("%10.1f %15.2f inches\n", shoe, foot);
          shoe = shoe +1;
      }
      printf("If the shoe fits , wear it.\n");
      return 0;
  }
  ```

- **while 循环**

  > 1、当**条件语句**为**真**时，执行**循环体**。**圆括号**内为**关系表达式**，**花括号**内为**循环体**  
  > 2、该程序中，程序判断`shoe < 18.5`**是否为真**，执行**循环体**内的代码，到达**花括号**时**再次判断表达式**，为**真**则**继续执行**，当**条件语句**为**假**时，**结束循环**

##### **运算符**

- **赋值运算符: =**

  > 1、C 语言中，**等号**`=`意为**赋值**而非**相等**。**赋值运算符**将**右侧的值赋给左侧**  
  > 2、当**赋值运算符**连用时，如`a=b=c=10`，仍按照**从右向左**方式**链式赋值**，即`c=10`，`b=c`，`a=b`

  - **几个术语：数据对象、左值、右值、项**

    > **数据对象**：赋值表达式语句的目的是把**值**储存到**内存位置**上，用于储存**值**的**数据存储区域**统称为**数据对象**  
    > **左值**：是 C 语言的术语，用于标识**特定数据对象**的**名称**或**表达式**。因此，**对象**指的是**实际的数据储存**，而**左值**是用于**标识**或**定位**储存**位置**的**标签**  
    > **右值**：指的是**赋值**给**可修改左值**的**量**，且**本身不是左值**  
    > **项**：学习名称时，被称为**项**的就是**运算对象**(如，赋值运算符左侧的项)。**运算对象**是**运算符**操作的对象

- **基本算术运算符**

  > 1、**加法运算符**`+`、**减法运算符**`-`、**乘法运算符**`*`、**除法运算符**`/`  
  > 2、**加和减**都被称为**二元运算符**  
  > 3、C 语言中的**除法**，若变量类型为**整数**，则除法的**商**的**小数部分**会**被舍弃**

- **符号运算符: +和-**

  > 1、`+`**和**`-`还可以做**符号运算符**，用作**正负号**  
  > 2、用作**正负号**时，为**一元运算符**

- **取模(余)运算符**

  > 1、用于**整数运算**，得到相除的**余数**，如`9 % 2 = 1`  
  > 2、**负数求模**，**C99**后，若**第一个运算对象**为**负数**，那么取模的结果为**负数**，反之亦然。如`11 % -5 = 1`，`-11 % 5 = -1`，`-11 % -5 = -1`

- **递增/减运算符: ++和\-\-**

  > 1、下文以`++`为例  
  > 2、两种形式：`++`出现在**变量前**，为**前缀模式**；`++`出现在**变量后**，为**后缀模式**  
  > 3、该**运算符作用**为变量**自加一**，如`a++`意为`a = a + 1`  
  > 4、当**单独使用**递增运算符时，使用哪种形式都没关系  
  > 5、当使用**较为复杂**时，**则会不同**。如`q = 2*++a;`，意为**a 递增 1，后 2\*a，再将结果赋给 q**；而`q = 2*a++;`，意为**2\*a，后将结果赋给 q，再 a 递增 1**  
  > 6、由于**前后缀模式**的以上特性会对代码**产生不同的影响**，因此最好**单独使用**(如需复合使用时，可以先单独自增再使用)

- **sizeof 运算符和 size_t 类型**

  > 1、第 3 章已介绍，`sizeof`运算符用于以**字节**为单位返回**运算对象的大小**  
  > 2、C 语言规定，`sizeof`返回`size_t`类型数值，这是一个**无符号整数类型**，其为**语言定义**的**标准类型**  
  > 3、**C99**后使用`%zd`用于转换显示`size_t`类型，如不支持可以使用`%u`或`%lu`代替

##### **表达式、语句和块**

- **表达式**

  > 1、**表达式**由**运算符**和**运算对象**组成。**最简单的表达式**是**单个运算对象**，以此为基础可以建立**复杂的表达式**  
  > 2、**运算对象**可以是**常量**、**变量**或**二者的组合**  
  > 3、每个表达式**都有一个值**，如`q=5*2`作为一个整体的**值为 10**；表达式`q>3`的值为**布尔值**，为**true**或**false**，即值为 1 或 0

- **语句**

  > 1、**语句**是 C 程序的**基本构建块**，**一条语句**相当于**一条完整的计算机指令**，C 中大部分语句都以**分号**`;`**结尾**  
  > 2、最简单的语句为**空语句**，只有一个分号构成；C 把**末尾加上一个分号**的**表达式**也**看做语句**，因此`8;`，`3+4;`这些语句也没问题，只是在程序中**什么都不做**

  - **副作用、序列点、完整表达式**

    > 1、**副作用**：副作用是对**数据对象**或**文件**的**修改**。例如语句`states=50;`，其**副作用**为**修改**变量 states 的值为 50。这似乎是**主要目的**，而在**C 语言的角度**看，**主要目的**是**对表达式求值**，如**表达式**`4+6`求值得`10`，给出**表达式**`states=50`求值得`50`  
    > 2、**序列点**：是**程序执行**的点，在该点上，**所有的副作用**都在**进入下一步之前**发生。**语句**中的**分号**标记了一个序列点，另外，任何**完整表达式**的结束也是一个序列点  
    > 3、**完整表达式**：指这个表达式**不是**另一个**更大表达式**的**子表达式**

- **复合语句(块)**

  > **复合语句**：是用**花括号**括起来的**一条或多条语句**，**复合语句**也称为**块**

##### **类型转换**

- 通常，在**语句**和**表达式**中，应使用**类型相同**的变量和常量。但是，如果使用**混合类型**，C 会采用一套规则进行**自动类型转换**，虽然这很便利，但有一定危险性，尤其是在无意间混合使用类型的情况下

- **基本的类型转换规则**

  > 1、当类型转换出现在**表达式**时，无论是`unsigned`还是`signed`的`char`和`short`都会被自动转换成`int`，如有必要会被自动转换成`unsigned int`(如果`short`和`int`**大小相同**，`unsigned short`就比`int`大，此时`unsigned short`会被转换成`unsigned int`)。由于都是**较小类型**转换为**较大类型**，所以这些转换被称为**升级**  
  > 2、涉及**两种类型**的**运算**，两个值会被**分别转换**成两种类型的**更高级别**  
  > 3、类型的**级别从高至低**依次是：`long double`、`double`、`float`、`unsigned long long`、`long long`、`unsigned long`、`long`、`unsigned int` 、`int`。**例外**的情况是，当`long`和`int`**大小相同时**，`unsigned int`级别比`long`的级别高。之所以`short`和`char`没有列出，是因为它们已经**被升级**成了`int`或`unsigned int`  
  > 4、在**赋值表达式语句**中，计算的**最终结果**会被转换成**被赋值变量**的类型，因此该过程可能导致类型**升级或降级**  
  > 5、当作为**函数参数传递**时，`char`和`short`被转换成`int`，`float`被转换成`double`。第九章将介绍，函数原型会覆盖自动升级

- **强制类型转换**

  - 通常，应该避免**自动类型转换**，尤其是**类型降级**，但如果能小心使用，类型转换也很方便
  - 当需要进行**精确的类型转换**，或者在程序中**表明类型转换的意图**，此时要用到**强制类型转换**
  - **强制类型转换**:在某个量**前面**放置用**圆括号**`()`括起来的**类型名**，该**类型名**即是希望转换成的**目标类型**。**圆括号**和它括起来的**类型名**构成了**强制类型转换运算符**，其通用形式为`(type)`，例子为`score = (int)1.6 + (int)1.7`

##### **带参数的函数**

- **示例程序**

  ```c
  #include <stdio.h>
  void pound(int n)           // 定义函数
  {
      while (n-- > 0)
      {
          printf("#");
      }
      printf("\n");
  }

  int main(void)
  {
      int times = 5;
      char ch = '!';
      float f = 6.0;
      pound(times);
      pound(ch);
      pound(f);
      return 0;
  }
  ```

- **参数-形参、实参**

  - 首先，看**函数头**`void pound(int n)`，如果函数**不接受任何参数**，那么**圆括号中**应写上`void`。由于该函数接受一个`int`类型的**参数**，所以其中包含一个`int`类型的**变量 n**的声明。参数名应遵循 C 语言的**命名规则**
  - 声明参数就创建了被称为**形式参数**的**变量**(简称**形参**)，该例中，形式参数是 int 类型的**变量 n**；像`pound(10)`这样的**函数调用**会把 **10** 赋给 **n** ，我们称函数调用**传递的值**为**实际参数**(简称**实参**)
  - 函数调用`pound(10)`把**实参 10**传递给**函数**，函数将 **10** 赋给**形参**
  - **变量名**是函数**私有的**，即在**函数中定义**的变量名**不会**和**别处的相同名称**发生冲突

- **函数调用**

  - 现在，来学习**函数调用**，如第一次调用`pound(times)`，**times**的值**5**被赋给**n**，因此函数打印了**5 个井号和一个换行符**
  - 第二次调用`pound(ch)`，此时**ch**是`char`类型变量，被初始化为`!`，其**ASCII 码**为**33**。由于函数形参类型为`int`，与`char`不匹配，所以程序开头的**函数原型**发挥了作用；**原型**即**函数声明**，描述函数**返回值**和**参数**，`pound`原型说明了两点：
    > 1、函数**没有返回值**(**函数名**前关键字为`void`)  
    > 2、函数有一个`int`类型的**形参**
  - 函数原型告诉编译器，函数**接受一个**`int`类型的**参数**，当编译器执行到`pound(n)`时，参数**ch**被自动转换成`int`类型，于是从**1 字节的 33**变成了**4 字节的 33**。于此类型，第三次调用`pound(f)`也使得`float`类型**转换成合适的**`int`**类型**

---

#### **C 控制语句:循环**

---

<div class="success">

> **章节概要**：再探`while`循环；`while`循环语句；迭代；关系运算符与关系表达式；真(true)与假(false)；`bool`布尔变量；`for`循环；`for`的几种使用示例；复合赋值运算符；出口条件循环`do-while`；循环嵌套；数组简介；函数返回值的使用

</div>

##### **再探 while 循环**

- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      long num;
      long sum = 0L;
      int status;
      printf("Please enter an integer to be summed");
      printf("(q to quit):");
      status = scanf("%ld", &num);
      while (status == 1)
      {
          sum = sum + num;
          printf("Please enter next integer (q to quit):");
          status = scanf("%ld", &num);
      }
      printf("Those integer sum to %ld.\n", sum);
      return 0;
  }
  ```

- **新元素分析**

  - **sum**初始值为`0L`，为`long`类型的`0`，而非`int`类型的`0`
  - `==`为**相等运算符**，用于判断**前后值是否相等**，不要与`=`**赋值运算符**混淆
  - `scanf()`函数的**返回值**，返回**成功读取项的数量**，因此此处读取**1 个整数**，则**成功后**返回**1**

##### **while 循环语句**

- **while 循环语句格式**

  ```c
  while(关系表达式){
      循环体;
  }
  ```

- **迭代**:在循环的**关系表达式**为**假(0)**之前，循环的**判断和执行**一直**重复进行**，**每一次循环**都被称为一次**迭代**

- **循环条件**

  - 在**构建循环**时，必须让**测试表达式**的值**有变化**，表达式最终要为**假**(**0**)，否则循环就不会停止
  - 可以使用`while(1)`来构建简单的**死循环**，之后会将到如何**破除循环**
  - 注意**循环终止**的时间，只有**大括号内的语句**会**循环执行**，注意哪些语句需要循环执行，哪些不需要

##### **关系运算符与关系表达式**

- **关系运算符**

  > `==`：**相等运算符**，用于判断**前后值是否相等**，不要与`=`**赋值运算符**混淆  
  > `!=`：**不等运算符**，用于判断**前后值是否不相等**  
  > `<`：**小于运算符**，用于判断**前值是否小于后值**  
  > `>`：**大于运算符**，用于判断**前值是否大于后值**  
  > `<=`：**小于等于运算符**，用于判断**前值是否小于等于后值**  
  > `>=`：**大于等于运算符**，用于判断**前值是否大于等于后值**

- **真(true)与假(false)**

  > 1、**关系表达式**会产生**真(true)**和**假(false)**的值，**真(true)**值通过打印会得到为**1**，**假(false)**值通过打印会得到为**0**  
  > 2、因此`while`循环**判断**的实际为**表达式的真假值**  
  > 3、而在 C 语言中，一般所有**非 0 的值**都可以被识别为**真(true)**，只有**0**被识别为**假(false)**

- **\_Bool 布尔变量**

  > 1、**C99**新增了`_Bool`**布尔**类型变量，其只能储存**真(true)**和**假(false)**，所有其他非零数值都会被转换为**真(true)**  
  > 2、`stdbool.h`头文件让`bool`成为了`_Bool`的别名，还把**true**和**false**分别定义为**1**和**0**的**符号常量**  
  > 3、且使用该头文件的代码可以与`C++`**兼容**，因为`C++`把`bool`、`true`、`false`定义为**关键字**

##### **for 循环**

- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      const int NUMBER = 22;
      int count;
      for (count = 1; count <= NUMBER; count++)
      {
          printf("Be my Valentine\n");
      }
      return 0;
  }
  ```

- **for 循环格式**

  ```c
  for(初始化;测试条件;执行更新){
      循环体
  }
  ```

  > 1、`for`后面的括号中有**三个表达式**，分别用**两个分号**`;`隔开  
  > 2、**第 1 个**表达式是**初始化**，只会在`for`**循环开始时**执行**一次**  
  > 3、**第 2 个**表达式是**测试条件**，**测试条件**为**真(true)**时**执行**循环体**，**测试条件**为**假(false)**时**结束**循环**  
  > 4、**第 3 个**表达式是**执行更新**，**每次循环结束时求值**

- **for 的灵活性**

  - `for`循环十分灵活，可以利用**三个表达式**完成**几乎所有**需要的**条件判断**，使用`for`循环能更轻松清楚地完成**遍历**
  - **逗号运算符**`,`使得**循环头**可以包含**更多表达式**，如`for(i=0,a=10; i<a; i=i+2,a++)`
  - `for`循环的其他几种妙用

    ```c
    #include <stdio.h>
    int main(void)
    {
        //输出20内平方表
        printf("数字        平方\n");
        for (int i = 1; i <= 20; i++)
        {
            printf("%-11d %-11d\n", i, i * i);
        }
        return 0;
    }
    ```

    ```c
    #include <stdio.h>
    int main(void)
    {
        //输出ASCII码表
        printf("字符        ASCII码\n");
        for (char i = 'A'; i <= 'z'; i++)
        {
            printf("%-11c %-11d\n", i, i);
        }
        return 0;
    }
    ```

    ```c
    #include <stdio.h>
    int main(void)
    {
        //输出20内的、平方小于350的偶数
        //注: &&为“与”，表示两者皆满足；i+=2同i=i+2
        for (int i = 0; i <= 20 && i * i < 350; i += 2)
        {
            printf("%d\n", i);
        }
        return 0;
    }
    ```

##### **复合赋值运算符**

- **复合赋值运算符**：`+=`、`-=`、`*=`、`/=`、`%=`

- **符号赋值运算符**：`+=`表示**加法赋值**，如`a+=2`意义等同于`a=a+2`，其余以此类推

##### **出口条件循环 do-while**

- 是`while`循环的一种**变种**，`while`为**入口处判断**，`do-while`为**出口处判断**
- 特点为**第一次执行**，无论如何`do-while`的**循环体至少执行一次**，出口处再**判断是否下次循环**。如下程序即使**count 初始值大于 22**，也会执行一次**do 内循环体**
- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int count=1;
      do
      {
          printf("Be my Valentine\n");
          count++;
      } while (count < 22);
      return 0;
  }
  ```

##### **循环嵌套**

- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      //输出乘法表
      for (int i = 1; i <= 9; i++)
      {
          for (int j = 1; j <= i; j++)
          {
              printf("%d*%d=%-2d  ", j, i, i*j);
          }
          printf("\n");
      }
      return 0;
  }
  ```

- **循环嵌套**

  > 1、**循环嵌套**指在**循环内**包含**另一个循环**，执行顺序为**外层循环**过程中执行多次**内层循环**，两个循环的**大括号**分别**标识自己的循环体部分**  
  > 2、如上述示例程序**乘法表**，通过最内层`printf`能得知，使用**j**表示乘法表**第一个数字**，使用**i**表示**第二个数字**，使用**i\*j**表示**乘法的积**  
  > 3、通过`j<=i`的**循环条件**防止出现`2*3`后再次出现`3*2`**重复**  
  > 4、建议自己运行一次程序，感受循环的顺序，也可以改变几个数值，看看程序的变化

##### **数组简介**

- 在许多程序中，数组很重要。**数组**可以作为一种**储存多个相关元素**的**便利方式**，将在第十章详细介绍

- **数组**

  > 1、数组是**按顺序存储**的一系列**类型相同**的值，如 10 个`char`类型数值或 10 个`int`类型数值  
  > 2、整个数组有一个**数组名**，通过**整数下标**访问数组中**单独的项**或**元素**

- **数组声明与使用**

  > **数组声明**：示例`int a[15]`，表示声明一个**内涵 15 个元素**的整数数组  
  > **数组使用**：通过**下标**访问**指定元素**。数组的**第一个元素**为`a[0]`，**第二个元素**为`a[1]`，以此类推。实际上**数组元素**的使用与**同类型变量**相同  
  > **陷阱**：考虑到 C 执行速度，C 编译器**不会检查**数组**下标是否正常**，注意数组元素**不要超出定义的范围**  
  > **下标**：用于**标识数组元素的数字**叫做**下标**、**索引**或**偏移量**。下标**必须是整数**且要**从 0 开始计数**

- **for 循环中使用数组**

  - `for`**循环**的**数组使用**，可以通过利用**循环变量**的变化来**切换数组的元素**，示例如下：

    ```c
    #include <stdio.h>
    int main(void)
    {
        int a[10];
        //循环输入
        for (int i = 0; i < 10; i++)
        {
            scanf("%d", &a[i]);
        }
        //循环输出
        for (int i = 0; i < 10; i++)
        {
            printf("%-5d  ", a[i]);
        }
        return 0;
    }
    ```

##### **函数返回值的使用**

- 对于**有返回值的函数**，函数最后的`return`**语句**表示函数的**返回值**，即执行完函数后，函数**返回的值**

- **编写**一个有返回值的函数，需要注意以下几点：

  > 1、定义函数时，**确定函数的返回类型**  
  > 2、使用`return`表明待返回的值

- **示例程序**

  ```c
  #include <stdio.h>

  // double 函数名 表明函数返回一个double类型的值
  double power(double n, int p)
  {
      double pow = 1;
      for (int i = 1; i <= p; i++)
      {
          pow *= n;
      }
      // 返回pow的值
      return pow;
  }

  int main(void)
  {
      // a^b
      double a;
      int b;
      printf("输入底数:");
      scanf("%lf", &a);
      printf("输入指数:");
      scanf("%d", &b);
      // 调用函数
      printf("乘方结果:%lf", power(a, b));
      return 0;
  }
  ```

---

#### **C 控制语句:分支和跳转**

---

<div class="success">

> **章节概要**：`if`语句；`if-else` 语句与 `else-if` 语句；`if` 与 `else` 的配对和嵌套 `if`；`getchar()`与`putchar()`函数；`ctype.h`系列的字符函数；逻辑运算符；备选拼写：`iso646.h`头文件；条件(三目)运算符；循环辅助：`continue`和`break`；`switch` 语句；`goto` 语句

</div>

##### **if 语句**

- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int a, b;
      scanf("%d%d", &a, &b);
      if (a > b)
      {
          printf("Sure,A>B!\n");
      }
      printf("Over!");
      return 0;
  }
  ```

- **if 语句**

  > 1、`if`**语句**被称为**分支语句**或**选择语句**，因为它相当于一个**交叉点**，程序要在两条分支中**选择一条**执行  
  > 2、程序如果对**分支表达式**求值为**真**，则执行**执行语句**，否则**跳过**执行语句  
  > 3、`if`**语句**的通用形式如下

  ```c
  if (分支表达式){
      执行语句;
  }
  ```

##### **if-else 语句与 else-if 语句**

- **if-else 语句**

  > 1、简单的`if`**语句**可以让程序选择**执行一条语句或跳过**，而`if-else`**语句**可以在**两条语句之间做选择**  
  > 2、程序如果对**分支表达式**求值为**真**，则执行**执行语句 1**，否则执行**执行语句 2**  
  > 3、`if-else`**语句**的通用形式如下

  ```c
  if (分支表达式){
      执行语句1;
  }
  else{
      执行语句2;
  }
  ```

- **else-if 语句**

  > 1、`else-if`**语句**为**多重选择**语句，可以在**多个分支之间做选择**  
  > 2、程序会根据表达式是否为真**逐步判断**，特别注意，如果**第一个表达式为真**，则**不会继续向下执行**  
  > 3、`else-if`**语句**的通用形式如下

  ```c
  if (分支表达式1){
      执行语句1;
  }
  else if (分支表达式2){
      执行语句2;
  }
  else{
      执行语句3;
  }
  ```

##### **if 与 else 的配对和嵌套 if**

- 当一个程序有**多个**`if`和`else`，**如果没有花括号**，`else`将与**离它最近**的`if`配对，除非最近的 if 被花括号括起来  
  ![](https://s2.loli.net/2022/06/13/cyX9MLRs4nvfZ3x.png)

- 有关`if`的嵌套，与`for`的嵌套基本雷同，只需要注意**不同嵌套的花括号包括的范围**即可

##### **getchar()与 putchar()函数**

- **getchar()与 putchar()的使用**

  > 1、`getchar()`**函数**用于从**标准输入流**中**读取一个字符**，并将其存储在变量中  
  > 2、如把字符**储存进**变量**ch**，则写为`ch = getchar()`，其等效于`scanf("%c", &ch)`  
  > 3、`putchar()`**函数**用于**打印它的参数**  
  > 4、如打印**ch**的值，则写为`putchar(ch)`，其等效于`printf("%c",ch)`  
  > 5、由于这些函数**只处理字符**，所以比`scanf`与`printf`**更快更轻量**，而且**不需要转换说明**

- **探索如何工作的程序示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      char ch;
      ch = getchar();    // 读取第一个字符
      while (ch != '\n') // 当不为换行符时循环，即一行字符未结束时
      {
          if (ch == ' ') // 留下空格不变
          {
              putchar(ch);
          }
          else
          {
              putchar(ch + 1); //其他字符改变+1
          }
          ch = getchar(); //获取下一个字符
      }
      putchar(ch); //打印换行符
      return 0;
  }
  ```

  - 该程序**可以进行优化**，将**如下形式的循环**替换为**后者**

    ```c
    ch = getchar();
    while (ch != '\n'){
        ...
        ch = getchar();
    }
    ```

    ```c
    while ( (ch=getchar()) != '\n'){
        ...
    }
    ```

  - 这样的写法体现了**C 特有的编程风格**——**把两个行为合并成一个表达式**
  - 程序中的`putchar(ch+1);`语句，再次演示了**字符**实际上是**作为整数储存**的

##### **ctype.h 系列的字符函数**

- C 有一系列专门用于**处理字符**的**函数**，`ctype.h`**头文件**包含了这些**函数**的原型。这些函数**接受一个字符作为参数**，如果该字符**属于某特殊的类别**，则返回**true**，否则返回**false**

- `ctype.h`的**字符测试函数**

  |   函数名   | 如果是下列参数，返回值为 true                                          |
  | :--------: | ---------------------------------------------------------------------- |
  | isalnum()  | 字母或数字                                                             |
  | isalpha()  | 字母                                                                   |
  | isblank()  | 标准的空白字符(空格、换行、水平制表符)或其他本地指定为空白的字符       |
  | iscntrl()  | 控制字符，如`Ctrl+B`                                                   |
  | isdigit()  | 数字                                                                   |
  | isxdigit() | 十六进制数字符                                                         |
  | isgraph()  | 除空格以外的任意可打印字符                                             |
  | islower()  | 小写字母                                                               |
  | isupper()  | 大写字母                                                               |
  | isprint()  | 可打印字符                                                             |
  | ispunct()  | 标点符号(除空格和字母数字以外的任何可打印字符)                         |
  | isspace()  | 空白符(空格、换行、换页、回车、垂直或水平制表符、其他本地定义的空白符) |

- `ctype.h`的**字符映射函数**

  |  函数名   | 行为                                                 |
  | :-------: | ---------------------------------------------------- |
  | tolower() | 如果参数是大写字符，则函数返回小写，否则返回原始参数 |
  | toupper() | 如果参数是小写字符，则函数返回大写，否则返回原始参数 |

##### **逻辑运算符**

- C 语言的`if`和`while`语句通常需要使用**关系表达式**作为测试条件。有时需要**多个关系表达式组合**，来判断**多个条件的逻辑关系**，**逻辑运算符**便可满足这一需求

- **3 种逻辑运算符**

  > 1、`&&`**逻辑与**：如果连接的两个表达式**都为 true**，则**返回 true**  
  > 2、`||`**逻辑或**：如果连接的两个表达式**至少有一个为 true**，则**返回 true**  
  > 3、`!`**逻辑非**：如果表达式为 **true**，则**返回 false**；如果表达式为 **false**，则**返回 true**

- **逻辑运算符优先级**

  > 1、`!`优先级**最高**、`&&`优先级**次之**、`||`优先级**最低**  
  > 2、`!`的优先级**仅次于圆括号**，比乘法运算符还高。`&&`、`||`的优先级都**比关系运算符低**，**比赋值运算符高**  
  > 3、因此，表达式`a>b && b>c || b>d`相当于`((a>b) && (b>c)) || (b>d)`

- **备选拼写：iso646.h 头文件**
  - 由于 C 使用**标准美式键盘**开发，部分键盘并**没有美式键盘的符号**。使用`iso646.h`**头文件**，可以使用`and`、`or`、`not`分别代替`&&`、`||`、`!`

##### **条件(三目)运算符**

- C 提供**条件(三目)运算符**作为表达`if-else`的一种便捷方式，常用于为一个变量**判断赋值或输出的值**时使用

- **三目运算符的使用**
  - **基本语法**：`测试条件 ? 结果true执行表达式 : 结果false执行表达式`
  - 例如`a = (num<0) ? -y : y;`等效于如下语句：
    ```c
    if (num < 0) {
        a = -y;
    } else {
        a = y;
    }
    ```
  - **三目运算符**也可以**嵌套使用**，使用**小括号表明不同层级部分**

##### **循环辅助：continue 和 break**

- **语句功能**

  > `continue`**语句**：在**循环过程**中，如果执行到`continue`语句，则会从`continue`执行处**跳过本层本次循环**的剩余内容，**继续执行下一次循环**  
  > `break`**语句**：在**循环过程**中，如果执行到`break`语句，则会从`break`执行处**终止本层循环**且**跳过未执行内容**，**不再进行下一次本层循环**

- **语句优势**
  > 1、可以**更加灵活**的控制循环的执行  
  > 2、能够**减少不必要的**`if-else`**层级缩进**，提高代码的**可读性**  
  > 3、使代码语句**结构更清晰紧凑**

##### **switch 语句**

- 使用**条件运算符**和`if-else`语句很容易编写**二选一**的程序，然而有时程序需要从**多个选项中选择**，尽管可以使用`else if`实现，但大多情况下`switch`**更加方便**

- **基本语法**

  ```c
  switch (表达式){
      case 表达式的可能值1:
          语句;
          break;
      case 表达式的可能值2:
          语句;
          break;
      ...
      default:
          语句;
          break;
  }
  ```

- **注意事项**

  > 1、`break`语句使程序离开`switch`语句，**直接执行**`switch`后的**下一条语句**，如果**没有**`break`，则会**按顺序**将**条件成立处**向后**所有**`case`内语句执行完毕，直到`default`语句后退出  
  > 2、C 语言的`case`一般都**指定一个值**，**不能使用一个范围**  
  > 3、关于`switch`不使用`break`会**向后执行**的特性，可以在特定的地方设定`break`，来利用这个特性，如下设计统计字母出现次数的程序

  ```c
  #include <stdio.h>
  int main(void)
  {
      char ch;                              // 输入字母
      int a_ct, b_ct, c_ct, d_ct, e_ct;     // 统计abcde的次数
      a_ct = b_ct = c_ct = d_ct = e_ct = 0; // 初始化为0
      printf("enter some text;enter # to quit");
      while ((ch = getchar()) != '#')
      {
          switch (ch)
          {
          case 'a': // 检测a时执行，并会向下执行'A'的语句
          case 'A': // 不论大写小写a，都会执行语句计入统计
              a_ct++;
              break; // break终止继续执行
          // 以此类推，此处省略bcde的case
          }
      }
      printf("A   B   C   D   E\n");
      printf("%-4d%-4d%-4d%-4d%-4d", a_ct, b_ct, c_ct, d_ct, e_ct);
      return 0;
  }
  ```

- **swith 与 if-else**

  > 1、通常而言，`switch`能干的`if-else`**都能实现**，但`switch`的运行**速度更快**  
  > 2、当需要判断**一个范围**或**浮点变量或表达式**时，`switch`**无法实现**  
  > 3、`switch`通常只是`if-else`的**优化**，对比之下，仍是`if-else`**泛用性更强**

##### **goto 语句**

- 早期版本的**BASIC**和**FORTRAN**所依赖的`goto`语句，在 C 中**仍然可用**，但**非常不建议**使用，即使没有`goto`语句 C 语言也仍能运行良好，且**逻辑更加清晰**

- **基本语法**

  ```c
  语句标签(如:part1):语句

  goto 语句标签;
  ```

---

#### **字符输入输出与输入验证**

---

<div class="success">

> **章节概要**：单字符 I/O:`getchar`与`putchar`；缓冲区；完全缓冲 I/O 与行缓冲 I/O；结束键盘输入(C 处理文件的方式)；文件；流；检测文件结尾；C 语言的`EOF`；重定向和文件；UNIX、Linux 和 DOS 重定向(流的输送)、重定向注意事项；创建更友好的用户界面；处理缓冲输入的换行符；处理混合数值字符输入的错误；输入验证

</div>

##### **单字符 I/O:getchar 与 putchar**

- 在第七章中提到过，`getchar()`和`putchar()`每次**只处理一个字符**。可能这种方法过于笨拙，但这种方法**很适合计算机**。而且，这是绝大多数**文本处理程序**所用的**核心方法**

- 详细用法请参照**前一章**

- 为何输入的字符能直接**显示在屏幕**上？如果用一个**特殊字符**(如`#`)来**结束输入**，就无法**在文本中使用**这个字符。是否有**更好的办法**结束输入？首先要了解**C 程序如何处理键盘输入**，尤其是**缓冲**和**标准输入文件**的概念

##### **缓冲区**

- **缓冲输入与缓冲区**

  > **缓冲输入**：对于**程序输入**，大部分系统在用户按下`Enter`之前**不会重复打印**刚输入的字符，即在**重复输入字符**时，不会在终端出现`H(输入)H(输入后处理输出的字符)e(第二格输入的字符)elllloo`这样的情况。这种**输入形式**称为**缓冲输入**  
  > **缓冲区**：用户**输入的字符**会先被**收集并储存**在一个被称为**缓冲区**的**临时储存区**，按下`Enter`时，程序才可使用用户输入的字符

  ![](https://s2.loli.net/2022/06/15/gP38vdLms4abNn1.png)

- **为什么要有缓冲区**

  > 1、把**若干字符**作为**一个块**传输比**逐个发送**这些字符**节约时间**  
  > 2、如果用户**打错字符**，可以**直接通过键盘修正**，当最后按下`Enter`时，传输的是**正确的输入**  
  > 3、虽然缓冲输入**好处很多**，但某些**交互式程序**也需要**无缓冲输入**，比如在**游戏中**，希望**按下一个按键**就**立刻执行**相应的指令。因此缓冲输入和无缓冲输入**都有用武之地**

- **完全缓冲 I/O 与行缓冲 I/O**

  > **完全缓冲输入**：指当**缓冲区被填满**时才**刷新缓冲区**(内容被发送至目的地)，通常出现在**文件输入**中。**缓冲区大小**取决于**系统**，常见**512 字节**和**4096 字节**  
  > **行缓冲输入**：指在**出现换行**时**刷新缓冲区**。**键盘输入**通常是**行缓冲输入**，所以在按下`Enter`时才**刷新缓冲区**

- **使用缓冲输入还是无缓冲输入**

  > 1、**ANSI C**和**后续的 C 标准**都规定**输入是缓冲的**，不过最初 K&R 把这个**决定权**交给了**编译器的编写者**  
  > 2、**ANSI C**决定把**缓冲输入**作为**标准输入**的原因是：一些计算机**不允许无缓冲输入**  
  > 3、**ANSI C**没有提供**调用无缓冲输入**的**标准方式**，这意味着能否进行无缓冲输入**取决于计算机系统**

##### **结束键盘输入(C 处理文件的方式)**

- **文件、流和键盘输入**

  - **文件**

    > 1、**文件**是**储存器**中**储存信息的区域**。通常，文件都**保存**在某种**永久储存器**中(如硬盘、U 盘、DVD 等)。  
    > 2、毫无疑问，文件对于计算机系统**相当重要**。例如你编写的**C 程序**就保存在**文件**中，用来**编译 C 程序**的**程序**也保存在**文件**中  
    > 3、某些程序需要**访问指定的文件**。当**编译**储存在名为`echo.c`**文件**中的**程序**时，编译器**打开**`echo.c`文件并**读取**其中的内容，当编译器**处理完后**，会**关闭**该文件  
    > 4、其他程序，例如**文字处理器**，不仅要**打开**、**读取**、**关闭**文件，还要把数据**写入**文件

  - **C 语言与文件**

    > 1、C 是一门强大、灵活的语言，有许多用于**打开**、**读取**、**写入**、**关闭**文件的**库函数**  
    > 2、从**较低层面**上，C 可以使用**主机操作系统**的**基本文件工具**直接处理文件，这些直接**调用操作系统**的**函数**被称为**底层 I/O**。但计算机系统**各不相同**，所以**不可能**为普通的**底层 I/O**函数创建**标准库**  
    > 3、从**较高层面**上，C 还可以通过**标准 I/O 包**来处理文件。这涉及**创建**用于处理文件的**标准模型**和一套**标准 I/O 函数**。这一层面上，具体的**C 实现**负责**处理不同系统的差异**，以便用户使用**统一**的界面

  - **流(stream)**

    > 1、从**概念上**看，C 程序**处理**的是**流**，而**不是直接处理文件**  
    > 2、**流**是一个**实际输入或输出**映射的**理想化数据流**。这意味着**不同属性**和**不同种类**的输入，由**属性更统一**的**流**来表示  
    > 3、于是，**打开文件的过程**就是把**流**与**文件**关联，而且**读写**都通过**流**来完成

- **文件结尾**

  - **操作系统检测文件结尾**

    > 1、计算机**操作系统**要以某种方式**判断文件的开始和结束**，其中**一种方法**是，在**文件末尾**放一个**特殊的字符**标记文件结尾  
    > 2、**CP/M**，**IBM-DOS**，**MS-DOS**的文本文件曾经都**用过这种方法**。如今这些操作系统可以使用**内嵌的**`Ctrl+Z`字符来标记文件结尾  
    > 3、这**曾经是**操作系统使用的**唯一标记**，不过现在有一些**其他选择**，如**记录文件的大小**。所以现代的文本文件**不一定有**嵌入的`Ctrl+Z`，但如果有，**操作系统**会**将其视为**一个**文件结尾的标记**，如后附图  
    > 4、操作系统使用的**另一种方法**是**储存文件大小的信息**。如果文件有**3000 字节**，那么**读到 3000 字节**时便**达到文件的末尾**  
    > 5、**MS-DOS**及其相关系统使用这种方法**处理二进制文件**，因为用这种方法可以在文件中**储存所有的字符**。新版的**DOS**也使用这种方式**处理文本文件**。**UNIX**使用这种方式**处理所有的文件**

    ![](https://s2.loli.net/2022/06/16/ANt5CdYcEu94Og1.png)

  - **C 语言检测文件结尾**

    > 1、在 C 语言中，用`getchar()`读取文件**检测到文件结尾**时，会返回**特殊值**`EOF`(End Of Line 缩写)。`scanf()`检测到文件结尾时也返回`EOF`  
    > 2、通常，`EOF`被定义在`stdio.h`**文件中**：`#define EOF (-1)`

  - **关于 EOF**

    > 1、为什么是**选用-1**？因为`getchar()`函数的**返回值**介于**0~127**，这些值对应**标准字符集**。但是如果系统能识别**拓展字符集**，则**返回值**可能在**0~255**。但无论哪种情况，-1**都不对应任何字符**，所以选用-1 标记文章结尾  
    > 2、某些系统也许把`EOF`**定义为-1 以外的值**，但是**定义的值**一定与**输入字符**所产生的**返回值**会**不同**。如果包含`stdio.h`文件，并使用`EOF`符号，就**不必担心**值不同的问题。这里关键要理解`EOF`**是一个值**，标志着**检测到文件结尾**，**并不是**在文件中**找得到的符号**  
    > 3、如何在**程序中使用**？把`getchar()`的**返回值**和`EOF`比较，如果**不同**则**没有到达文件结尾**，即如下：`while((ch = getchar()) != EOF)`

  - **键盘模拟文件结尾条件**

    ```c
    #include <stdio.h>
    int main(void)
    {
        int ch;
        while ((ch = getchar()) != EOF)
        {
            putchar(ch);
        }
        return 0;
    }
    ```

    > 1、不用定义`EOF`，因为`stdio.h`已经**定义过了**  
    > 2、不用担心`EOF`的**实际值**，因为`EOF`在`stdio.h`中用`#define`预处理指令定义，**可直接使用**  
    > 3、变量**ch**的类型从`char`变成了`int`，因为`char`的变量只能表示**0~255**的**无符号**整数，但`EOF`的**值是-1**。还好`getchar()`函数**实际返回值类型**是`int`，所以它可以读取`EOF`字符。如果实现使用**有符号**的`char`类型，也可以把**ch**声明为`char`，但最好还是用**更通用**的形式  
    > 4、由于`getchar()`**返回类型**是`int`，如果把`getchar()`的**返回值**赋给`char`变量，一些编译器可能会**警告甚至丢失数据**  
    > 5、**ch**是**整数**不会影响`putchar()`，该函数仍然会**打印等价字符**  
    > 6、使用该程序进行**键盘输入**，要设法输入`EOF`字符，不能只输入**字符 EOF**，也不能只输入**数值-1**(会被当做一个连字符和一个数字 1)。正确的方法是**找出当前系统的要求**，如大多数**UNIX**和**Linux**系统中在**一行开始**使用`Ctrl+Z`会**传输文件结尾信号**，而**Windows**系统中在**一行开始**使用`Ctrl+Z`会**传输文件结尾信号**，所以在程序中需要**设立不同的提示语**提醒用户

##### **重定向和文件**

- 默认情况下，C 程序使用**标准 I/O**包查找**标准输入**作为**输入源**，这就是前面介绍过的**stdin 流**，它是把数据**读入计算机**的常用方式

- **程序使用文件的两种方式**

  > 1、显式使用**特定的函数**打开、关闭、读取、写入文件，将在第 13 章介绍  
  > 2、设计能与键盘和屏幕互动的程序，通过不同的渠道**重定向**输入至文件和从文件输出，下面主要介绍此类**重定向**

- **UNIX、Linux 和 DOS 重定向**

  - UNIX(运行命令行模式)、Linux(ditto)和 Windows 命令行(注意使用**cmd**而不是**终端**)提示都能**重定向输入输出**。**重定向输入**让程序**使用文件**而不是键盘输入，**重定向输出**让程序**输出至文件**而不是屏幕

  - **重定向输入**

    > 1、假设已经编译了**echo.c**程序，并生成了一个名为**echo**的**可执行文件**(Windows 中为**echo.exe**，**注意后续命令注意使用带有文件后缀的名字**)。想要**运行**该程序，在**命令行**的**对应目录**中输入可执行文件名：`./echo`，**Windows**下输入`echo.exe`，即可执行可运行文件  
    > 2、现在，假设要用该程序处理**名为 passage**的**文本文件**(.txt)，文件中储存的是**可识别的字符**。此处由于操作对象是**字符**，所以使用文本文件。使用此命令代替上面的命令：`./echo < passage`，**Windows**下输入`echo.exe < passage.txt`  
    > 3、`<`符号是 UNIX 和 DOS/Windows 的**重定向运算符**。该运算符使**passage 文件**与**stdin 流**相关联，把文件中的内容**导入 echo 可执行程序**

  - **重定向输出**

    > 1、类似的，假设要用**echo 可执行程序**把**程序输出**的内容**发送到名为 passage 的新文件**，便可以使用`./echo > passage`，**Windows** 下输入`echo.exe > passage.txt`  
    > 2、`>`符号是第二个**重定向运算符**，创建了一个名为**passage 的新文件**，然后把 echo 的**输出写入该文件**。通常会**擦除该文件的内容**，然后**替换新的内容**，在下一行开始处按下`Ctrl+D`(UNIX)或`Ctrl+Z`(DOS)即可**结束该程序**

  - **组合重定向**

    > 1、现在假设你希望制作一份**mywords 文件**的**副本**，并**命名为 savewords**，输入`./echo < mywords > savewords`，Windows 下输入`echo.exe < mywords.txt > savewords.txt`  
    > 2、下面的命令**也起作用**，因为**命令**与**重定向运算符的顺序无关**，如：`./echo > savewords < mywords`  
    > 3、在一条命令中，输入文件名和输出文件名**不能相同**，如：`./echo < mywords > mywords <==错误`，原因是`> mywords`在输入之前已导致**原 mywords 长度被截断为 0**

  - **其他重定向注意事项**

    > 1、重定向运算符连接**一个可执行程序**和**一个数据文件**，**不能直接连接两个可执行文件或连接两个数据文件**  
    > 2、使用重定向运算符**不能读取多个文件的输入**，也**不能把输出定向至多个文件**  
    > 3、文件名和运算符之间**空格不是必须的**，且**有些系统不能使用空格**  
    > 4、UNIX、Linux 或 Windows/DOS 还有`>>`运算符，该运算符可以**把数据添加到现有文件的末尾**且**不覆盖原内容**，而`|`运算符能**把一个文件的输出连接到另一个文件的输入**

##### **创建更友好的用户界面**

- **使用缓冲输入**

  - **示例程序(待优化程序)**

    ```c
    #include <stdio.h>
    int main(void)
    {
        int guess = 1;
        printf("在1-100想一个数，输入y或n表示当前显示的数是否是你想的数\n");
        printf("数字是1吗\n");
        while (getchar() != 'y')
        {
            printf("那么，是%d吗\n", ++guess);
        }
        printf("好的，这便是你想的数字");
        return 0;
    }
    ```

  - 该示例程序有**以下问题**，对于用户的体验有影响

    > 1、**缓冲输入**要求用户按下`Enter`发送，这一动作也**传递了换行符**，程序必须**妥善处理**这个**换行符**  
    > 2、**用户的输入**可能并不会按照**人为约定**只输入**y 或 n**，仍有**其他输入**的可能，也需要**对应进行处理**

- **处理缓冲输入的换行符**

  - 该程序每次**输入 n 时**，程序便打印了**两条消息**。这是由于程序**读取 n**作为用户**否定了数字 1**，另外**读取了一个换行符**作为用户**否定了数字 2**。此外**输入 no**，会打印三条语句，程序**将 n 和 o 分别当做了一次响应**，外加**换行符的一次响应**
  - **优化 1**：跳过剩余输入

    > 1、使用`while`循环，**循环丢弃**输入行最后**剩余的内容**，包括换行符  
    > 2、这种方法还能把**no**、**no way**都视为简单的**n**(因为只使用第一个字符，其余字符被丢弃)

    ```c
    while(getchar() != 'y')
    {
        printf("那么，是%d吗\n", ++guess);
        while(getchar() != '\n')
        {
            continue; //跳过剩余输入行
        }
    }
    ```

  - **优化 2**：使用变量储存响应以进行判断

    > 1、上述**方法 1**虽然解决了换行符的问题，但程序仍会将**f**视为**n**  
    > 2、可以添加一个**char**类型变量**储存响应**，再用`if`判断**筛选其他响应**

    ```c
    char response;
    while((response = getchar()) != 'y')
    {
        if (response == 'n')
        {
            printf("那么，是%d吗\n", ++guess);
        }
        else
        {
            printf("未知输入\n");
        }
        while(getchar() != '\n')
        {
            continue; //跳过剩余输入行
        }
    }
    ```

- **混合数值和字符输入**

  - **示例程序(待优化程序)**

    ```c
    #include <stdio.h>
    void display(char cr, int lines, int width)
    {
        // 该函数用于输出
        int row, col;
        for (row = 1; row <= lines; row++)
        {
            for (col = 1; col <= width; col++)
            {
                putchar(cr);
            }
            printf("\n");
        }
    }

    int main(void)
    {
        int ch, rows, cols;
        printf("输入要打印的字符、行数、每行个数\n");
        while ((ch = getchar()) != '\n')
        {
            scanf("%d%d", &rows, &cols);
            display(ch, rows, cols);
            printf("输入另一组数据继续，输入换行退出\n");
        }
        printf("Bye!");
        return 0;
    }
    ```

  - 该示例程序有**以下问题**，对于用户的体验有影响

    > 1、`getchar()`与`scanf()`各自使用都能完成各自的任务，但尽可能**不要将它们混用**。`getchar()`读取每个字符，**包括空格换行制表符**，`scanf()`会**跳过空格换行制表符**，上述程序便因此出错  
    > 2、当程序**输出完第一组**数据，就**直接退出**了，无法输入第二组数据  
    > 3、在**第一次输入**的最后一个数字后的**换行符**，`scanf()`将其**留在了输入队列里**，而`getchar()`不会跳过换行符。所以进入**下一次迭代**时，`getchar()`便**读取了该换行符**，将其赋给**ch**

- **处理混合数值字符输入的错误**

  - **优化**：跳过**一轮输入结束**与**下一轮输出开始**之间所有的**换行符和空格**

    ```c
    /*修改主函数的while循环*/
    while ((ch = getchar()) != '\n')
    {
        if((scanf("%d%d", &rows, &cols)) != 2)
        {
            break;
        }
        display(ch, rows, cols);
        while(getchar() != '\n')
        {
            continue;
        }
        printf("输入另一组数据继续，输入换行退出\n");
    }
    ```

##### **输入验证**

- 在**实际应用**中，用户不一定会按照**程序的指令**行事，**用户的输入**和**程序期望**的输入**不匹配**时常发生。因此需要**输入验证**，**预料**一些可能的**输入错误**，并提前编写**处理错误**的程序

- 假设编写了一个**处理非负整数**的循环，提前推演**可能出现的错误**，便可以按如下方式处理：

  - 防止出现**负数**，使用**关系表达式**排除此种情况：

    ```c
    long n;
    scanf("%ld", &n); // 获取第一个值
    while (n >= 0)  // 判断是否为非负数
    {
        // 处理n(此处省略处理语句)
        scanf("%ld", &n);   // 继续获取下一个值
    }
    ```

  - 防止输入**错误类型**的值，判断`scanf()`**返回值**排除，并结合上处错误改进：

    ```c
    long n;
    while (scanf("%ld", &n)==1 && n>=0)
    {
        // 处理n(此处省略处理语句)
    }
    ```

  - 对于上处程序，当用户输入**错误的值**，会直接**结束程序**。此外还可以**提示用户**再次**输入正确的值**，但这种情况下，需要**处理有问题的输入**。因为`scanf()`的**错误输入**仍会**留在输入队列**，可以使用`getchar()`函数**逐字读取输入**，还可以将其**结合在一个函数内**，按如下改进：

    ```c
    long get_long(void)
    {
        long input;
        char ch;
        while (scanf("%ld", &input) != 1)
        {
            while ((ch = getchar()) != '\n')
            {
                putchar(); // 处理错误的输入
            }
            printf("输入有误，请重新输入\n");
        }
        return input;
    }
    ```

---

#### **函数**

---

<div class="success">

> **章节概要**：复习函数；函数概述；函数创建与使用；函数参数与返回值；ANSI C 函数原型；旧式声明问题及解决；递归；递归演示；递归的基本原理；尾递归；递归和倒序计算；递归的优缺点；编译多源代码文件的程序;使用(自建)头文件；查找地址：&运算符；更改主调函数中的变量；指针简介；指针基本概念；间接运算符：\*；声明指针；使用指针在函数间通信

</div>

##### **复习函数**

- **函数概述**

  - **函数**：完成**特定任务**的**独立程序代码单元**。**语法规则**定义了函数的**结构**和**使用方式**

  - **功能**

    > 1、**执行某些动作**：如`printf()`把数据**打印**到屏幕  
    > 2、**找出一个值供程序使用**：如`strlen()`把**指定字符串**的**长度**返回给程序

  - **优点**

    > 1、可以省去编写**重复代码**的苦差  
    > 2、让程序更加**模块化**  
    > 3、提高代码的**可读性**  
    > 4、方便后期**修改**、**完善**

- **函数创建与使用**

  - **示例程序**

    ```c
    /*定义并使用starbar函数打印40个星号*/
    #include <stdio.h>

    void starbar(void); // 函数原型

    int main() // 主函数
    {
        starbar();  // 调用函数
        printf("hello world\n");
        starbar();
        return 0;
    }

    void starbar(void)  // 定义函数
    {
        for (int i=1;i<=40;i++){
            putchar('*');
        }
        putchar('\n');
    }
    ```

  - **函数基础**

    - 基本术语

      > 1、**函数原型**：告诉**编译器**函数`starbar()`的**相关信息**。其指明了函数的**返回值类型**和函数接收的**参数类型**，这些**信息**称为函数的**签名**  
      > 2、**函数调用**：表明在此**执行函数**  
      > 3、**函数定义**：指定**函数**具体要**做什么工作**  
      > 4、**补充**：**函数原型**与**函数定义**可以在**同一步**完成，即函数原型`void starbar(void)`后可以**直接跟花括号**进行**定义**。此外**函数原型**可以置于`main()`**主函数**内**声明变量处**

    - 函数类型

      > 1、**函数**和**变量**一样有**多种类型**，任何程序在**使用函数前**都要**声明函数类型**  
      > 2、`void starbar(void);`中第一个**void**表明函数**返回类型**是**void**，即**没有返回值**；**starbar**为**函数名**；第二个**void**表明函数**没有参数**；**分号**表明**仅在声明函数**，**不是在定义函数**  
      > 3、因此，**函数名前**的**类型**仅表明函数**返回值类型**，而**不是参数类型**

    - 函数的跨文件调用

      > 1、程序把`starbar()`和`main()`放在**一个文件**中，也可以将它们**分别**放在**两个文件**下  
      > 2、把函数都**放在一个文件**中的**单文件形式**比较**容易编译**，而**使用多个文件**方便在**不同程序**中使用**同一个函数**  
      > 3、如果把**函数**放在**单独的文件**中，要把`#define`和`include`指令也放入该文件，稍后会讨论如何**跨文件调用函数**

- **函数参数与返回值**

  - **示例程序**

    ```c
    #include <stdio.h>

    int plus_multiply(int num1, int num2, int num3)
    {
        int result;
        result = (num1 + num2) * num3;
        return result;
    }

    int main(void)
    {
        int a, b, c;
        printf("计算(a+b)*c的结果，请分别输入a,b,c的值：\n");
        scanf("%d%d%d", &a, &b, &c);
        printf("%d", plus_multiply(a, b, c));
        return 0;
    }
    ```

  - **形参与实参**

    > 1、**形式参数**：**函数定义**的**函数头**中声明的**变量**，称为**形参**  
    > 2、**实际参数**：出现在**函数调用**的**圆括号**内的**表达式**，称为**实参**

  - **函数参数的定义与使用**

    > 1、在**函数原型**的**圆括号**里，写入需要**传入的参数**的**类型**，以及**参数名**，即**定义形参**。语法为`void def (类型 形参1, 类型 形参2, ...)`，实例如`void def (int a, float b)`  
    > 2、**使用形参**，需要先**传入实参**。在调用函数时，**按顺序**传入**指定类型**的值(即**实参**)，此外也可以**分别定义**形参的值，如`def (b=实参1, a=实参2)`，便可将**实参的值**传入函数的**形参**

  - **返回值**

    > 1、如果说**参数**是方便**值**从**主调函数**前往**被调函数**，那**返回值**便是方便**值**从**被调函数**前往**主调函数**。函数中为`return`语句后的值  
    > 2、返回值的**类型**即为**函数原型**中定义的**函数类型**

##### **ANSI C 函数原型**

- **旧式声明**

  > 1、在**ANSI C**标准**之前**，声明函数的方案**有缺陷**，因为只需要声明**函数类型**，不用声明**任何参数**  
  > 2、如`int imin()`这个**函数声明**，只需要告知编译器`init()`**返回 int 类型的值**  
  > 3、然而，以上**函数声明**并未给出`imin()`函数的**参数个数和类型**。因此，如果**调用**`imin()`时使用的参数**个数不对**或**类型不匹配**，编译器根本**不会察觉**

- **问题所在**

  - **示例程序**

    ```c
    #include <stdio.h>

    int imax(); // 旧式声明

    int main(void)
    {
        printf("%d和%d的最大值是%d\n", 3, 5, imax(3));
        printf("%d和%d的最大值是%d\n", 3, 5, imax(3.0, 5.0));
        return 0;
    }

    int imax(n, m)
    int n, m;
    {
        return (n > m ? n : m);
    }
    ```

    ```
    3和5的最大值是1606416656
    3和5的最大值是3886
    ```

  - **问题分析**

    > 1、由于不同系统的**内部机制不同**，所以出现问题的**具体情况也不同**，下面介绍**PC**和**VAX**的情况  
    > 2、**主调函数**把它的**参数**储存在被称为**栈**的**临时储存区**，**被调函数**从**栈**中**读取**这些参数，而这两个过程**并未互相协调**  
    > 3、**主调函数**根据函数调用中的**实际参数**决定**传递的类型**，**被调函数**根据它的**形式参数**来**读取**值。因此，函数调用`imax(3)`把**一个整数**放在**栈**中，当函数**开始执行时**，它从**栈**中**读取两个整数**，而**实际**只存放了**一个**待读取的整数，所以读取的**第二个值**是当时**恰好在栈中**的**其他值**  
    > 4、**第二次**使用`imax()`函数时，它传递的是**float**类型的值。这次把两个**double**类型的值放在**栈**中(当 float 作为参数传递会被升级成 double)。**两个 double**的值就是**两个 64 位**的值，所以弓**128 位**的数据被存放在**栈**中。当`imax()`读取**两个 int**值时，即**读取前 64 位**，于是**出现错误**

- **解决方案**

  - 针对**参数不匹配**的问题，**ANSI C**标准要求在**声明函数**时还要声明**变量的类型**，即使用**函数原型**来声明函数的返回类型、参数数量、参数类型
  - 未标明`imax()`函数有两个**int**类型的**参数**，可以使用**下面两种函数原型**来声明

    ```c
    int imax(int, int);
    int imax(int a, int b);
    ```

  - **第一种**形式使用以**逗号分隔**的类型列表，**第二种**形式在类型后面**添加了变量名**。注意，这里的**变量名**是**假名**，**不必**与函数定义的**形式参数**名**一致**

##### **递归**

- **递归**：C 函数允许**调用它自己**，这种调用称为**递归**。递归有时难以捉摸，有时却很方便实用

- **递归演示**

  - **示例程序**

    ```c
    #include <stdio.h>

    void up_and_down(int n)
    {
        printf("Level %d: n location %p\n", n, &n); // #1
        if (n < 4)
        {
            up_and_down(n + 1);
        }
        printf("Level %d: n location %p\n", n, &n); // #2
    }

    int main(void)
    {
        up_and_down(1); // 调用递归函数
        return 0;
    }
    ```

    ```
    Level 1: n location 000000000061FE00
    Level 2: n location 000000000061FDD0
    Level 3: n location 000000000061FDA0
    Level 4: n location 000000000061FD70
    Level 4: n location 000000000061FD70
    Level 3: n location 000000000061FDA0
    Level 2: n location 000000000061FDD0
    Level 1: n location 000000000061FE00
    ```

  - **程序分析**

    > 1、`main()`函数**调用**`up_and_down()`，称为**第 1 级递归**，然后`up_and_down()`**调用自己**，这次调用称为**第 2 级递归**，第 2 级**再次调用**，称为**第 3 级递归**，以此类推  
    > 2、`%p`、`&`用于显示变量的**内存地址**，稍后解释  
    > 3、首先，`main()`函数调用带**参数 1**的`up_and_down()`函数，此时**n=1**，**语句#1**打印**Level 1**，由于**n<4**，执行调用**实际参数**为**n+1(即 2)**的`up_and_down()`(**第 2 级**)  
    > 4、**第 2 级**中**n=2**，所以**语句#1**打印**Level 2**，以此类推继续**递归调用**  
    > 5、当执行到**第 4 级**时**n=4**，`if`语句**n<4**为**false**，所以跳过执行**不再调用**自己，**第 4 级**继续执行**语句#2**，打印**Level 4**  
    > 6、此时**第 4 级**调用结束，控制返回它的**主调函数**(**即第 3 级**)，**第 3 级**继续执行**语句#2**，打印**Level 3**，以此类推，直到**第 1 级**返回`main()`函数  
    > 7、注意，每级递归的**变量 n**都属于每级递归**私有**，这点从**程序输出的地址**可以得出

- **递归的基本原理**

  > 1、**每级递归调用**都有**自己的变量**。也就是说，**第 1 级的 n**和**第 2 级的 n**是**完全不同**的  
  > 2、**每次函数调用**都会**返回一次**。当函数执行完毕，**控制权**将返回到**上一级递归**，程序必须**按顺序逐级返回递归**  
  > 3、递归函数中位于**递归调用之前**的语句，均按**被调函数的顺序**执行。例如上例按序**Level 1**、**Level 2**、**Level 3**、**Level 4**  
  > 4、递归函数中位于**递归调用之后**的语句，均按**被调函数相反的顺序**执行。例如上例按序**Level 4**、**Level 3**、**Level 2**、**Level 1**  
  > 5、虽然**每级递归**都有**自己的变量**，但是并**没有拷贝函数的代码**。程序**按顺序执行**函数中的代码，**递归调用**相当于又**从头开始按序执行**函数的代码。除了为每次递归调用**创建变量**外，**递归调用**非常类似一个**循环语句**  
  > 6、递归函数**必须包含**能让递归**调用停止**的语句。通常都使用`if`**语句**或其他等价的**测试条件**在**函数形参**等于**某特定值**时终止递归。因此，**每次递归**调用的**形参**都要使用**不同的值**

  ![](https://s2.loli.net/2022/07/01/VTa7kZndFOlJopy.png)

- **尾递归**

  - **尾递归**：把**递归调用**置于**函数末尾**。是**最简单的**递归形式，因为它**相当于循环**

  - **阶乘计算示例**(5 的阶乘：1\*2\*3\*4\*5；0 的阶乘=1)

  ```c
  #include <stdio.h>

  long fact(int n) // 直接使用for循环的函数
  {
      long ans;
      for (ans = 1; n > 1; n--) // 此处顺带初始化ans为1
      {
          ans *= n;
      }
      return ans;
  }

  long rfact(int n) // 使用递归的函数
  {
      long ans;
      if (n > 0)
      {
          ans = n * rfact(n - 1);
      }
      else
      {
          ans = 1;
      }
      return ans;
  }

  int main(void)
  {
      int num;
      do
      {
          printf("请输入一个0~12之间的整数：\n");
          scanf("%d", &num);
      } while (num < 0 || num > 12);
      printf("循环得到的结果：%ld\n", fact(num));
      printf("递归得到的结果：%ld\n", rfact(num));
      return 0;
  }
  ```

- **递归和倒序计算**

  - **递归**在**处理倒序**时非常方便，**比循环更便捷**

  - **示例程序：打印整数二进制**

    ```c
    #include <stdio.h>

    // 递归函数
    void to_binary(unsigned long n)
    {
        int r;
        r = n % 2;
        if (n >= 2)
            to_binary(n / 2);
        putchar(r == 0 ? '0' : '1');
    }

    int main(void)
    {
        unsigned long number;
        printf("输入整数：\n");
        scanf("%lu", &number);
        to_binary(number);
        return 0;
    }
    ```

- **递归的优缺点**

  > 1、递归既有优点也有缺点  
  > 2、**优点**是递归对于**某些编程问题**提供了**最简单的解决方案**  
  > 3、**缺点**是一些**递归算法**会**快速消耗**计算机的**内存资源**，此外**不便于阅读和维护**

##### **编译多源代码文件的程序**

- 使用**多个函数**最简单的方法是把它们都放在**同一个文件**中，然后像编译**只有一个函数的文件**那样编译该文件即可。其他方法**因操作系统而异**，下面举例说明

- **UNIX**

  > 1、假定**UNIX 系统**中安装了**UNIX C 编译器 cc**，假设**file1.c**和**file2.c**是两个内涵 C 函数的文件  
  > 2、使用`cc file1.c file2.c`可以将**两个文件**编译成**一个**名为**a.out**的可执行文件，并**生成**两个名为**file1.o**和**file2.o**的目标文件  
  > 3、如果后来改动了**file1.c**而没有改动**file2.c**，可以使用`cc file1.c file2.o`来编译(如果**file2.o**文件还存在)

- **Linux**

  > 1、假定**Linux 系统**中安装了**GNU C 编译器 GCC**，假设**file1.c**和**file2.c**是两个内涵 C 函数的文件  
  > 2、使用`gcc file1.c file2.c`可以将**两个文件**编译成**一个**名为**a.out**的可执行文件，并**生成**两个名为**file1.o**和**file2.o**的目标文件  
  > 3、如果后来改动了**file1.c**而没有改动**file2.c**，可以使用`cc file1.c file2.o`来编译(如果**file2.o**文件还存在)

- **DOS 命令行编译器**

  > 1、绝大多数**DOS 命令行编译器**的工作原理和**UNIX 的 cc 命令类似**，只不过使用**不同名称**而已  
  > 2、一个**区别**是，对象文件的**拓展名**是`.obj`而不是`.o`

- **Windows 和 Mac 的 IDE 编译器**

  > 1、**Windows**和**Mac**使用的**集成开发环境 IDE**的编译器是**面向项目**的，这种 IDE 的编译器要**创建项目**来**运行单文件程序**  
  > 2、对于**多文件**程序，需要使用相应的**菜单命令**，把源代码加入一个项目中。要确保**所有源代码文件**都在**项目列表**中列出

- **使用头文件**

  > 1、如果把`main()`放在**第一个文件中**，**函数定义**放在**第二个文件中**，那么**第一个文件**仍然要使用**函数原型**  
  > 2、而把**函数原型**放在**头文件**中，就**不用**每次使用函数文件都**写出函数的原型**  
  > 3、此外，我们常常使用**C 预处理器**(`#define`)定义**符号常量**，也可以将其**写入头文件**，使用时只需要**包含**(`#include`)**该头文件**即可。这样更有利于**维护修改**，也利于对**常量的管理**  
  > 4、因此，将**函数原型**和**字符常量**放在**头文件**，是一个十分良好的**编程习惯**  
  > 5、`#include "xxx.h"`命令可以引入**自定义的头文件**，使用**双引号**`""`，且引号内如果是**同目录**可以**直接写文件名**，不同目录也可以使用**相对路径**和**绝对路径**

  - **如下案例**，编写一个模拟酒店收费管理的程序，注意**标注的文件名**来区分文件，请使用**多源代码文件**编译方法**编译文件**(程序运行仍会从`usehotel.c`的`main()`**主函数**开始)

    ```c
    /* hotel.h */
    #define QUIT 5
    #define HOTEL1 180.00
    #define HOTEL2 225.00
    #define HOTEL3 225.00
    #define HOTEL4 355.00
    #define DISCOUNT 0.95
    #define STARS "**************************************************"

    // 显示选择列表
    int menu(void);

    // 返回预定天数
    int getnights(void);

    // 计算费用并显示结果
    void showprice(double rate, int nights);
    ```

    ```c
    /* hotel.c */
    #include <stdio.h>
    #include "hotel.h"
    int menu(void)
    {
        int code, status;
        printf("\n%s\n", STARS);
        printf("enter the number to desired hotel:\n");
        printf("1) XXX Hotel1            2) XXX Hotel2\n");
        printf("3) XXX Hotel3            4) XXX Hotel4\n");
        printf("5) Quit\n");
        printf("%s\n", STARS);
        while ((status = scanf("%d", &code)) != 1 || (code < 1 || code > 5))
        {
            if (status != 1)
                scanf("%*s"); //处理非整数输入
            printf("Enter an integer from 1 to 5:\n");
        }
        return code;
    }

    int getnights(void)
    {
        int nights;
        printf("How many nights are you needed?\n");
        while (scanf("%d", &nights) != 1)
        {
            scanf("%*s"); //处理非整数输入
            printf("Enter an integer, such as 2\n");
        }
        return nights;
    }

    void showprice(double rate, int nights)
    {
        int n;
        double total = 0.0;
        double factor = 1.0;
        for (n = 1; n <= nights; n++, factor *= DISCOUNT)
            total += rate * factor;
        printf("The total cost will be &%0.2f.\n", total);
    }
    ```

    ```c
    /* usehotel.c */
    #include <stdio.h>
    #include "hotel.h"
    int main(void)
    {
        int nights;
        double hotel_rate;
        int code;
        while ((code = menu()) != QUIT)
        {
            switch (code)
            {
                case 1:
                    hotel_rate = HOTEL1;
                    break;
                case 2:
                    hotel_rate = HOTEL2;
                    break;
                case 3:
                    hotel_rate = HOTEL3;
                    break;
                case 4:
                    hotel_rate = HOTEL4;
                    break;
                default:
                    printf("Oops!\n");
                    break;
            }
            nights = getnights();
            showprice(hotel_rate,nights);
        }
        printf("Thank you and goodbye\n");
        return 0;
    }
    ```

  - 此外，**函数**也可以**直接定义**在头文件内，因此上述程序写为**单源代码文件**的方式可以**精简如下**：

    ```c
    /* hotel.h */
    #include <stdio.h> // 注意引入头文件
    #define QUIT 5
    #define HOTEL1 180.00
    #define HOTEL2 225.00
    #define HOTEL3 225.00
    #define HOTEL4 355.00
    #define DISCOUNT 0.95
    #define STARS "**************************************************"

    // 显示选择列表
    int menu(void)
    {
        int code, status;
        printf("\n%s\n", STARS);
        printf("enter the number to desired hotel:\n");
        printf("1) XXX Hotel1            2) XXX Hotel2\n");
        printf("3) XXX Hotel3            4) XXX Hotel4\n");
        printf("5) Quit\n");
        printf("%s\n", STARS);
        while ((status = scanf("%d", &code)) != 1 || (code < 1 || code > 5))
        {
            if (status != 1)
                scanf("%*s"); //处理非整数输入
            printf("Enter an integer from 1 to 5:\n");
        }
        return code;
    }

    // 返回预定天数
    int getnights(void)
    {
        int nights;
        printf("How many nights are you needed?\n");
        while (scanf("%d", &nights) != 1)
        {
            scanf("%*s"); //处理非整数输入
            printf("Enter an integer, such as 2\n");
        }
        return nights;
    }

    // 计算费用并显示结果
    void showprice(double rate, int nights)
    {
        int n;
        double total = 0.0;
        double factor = 1.0;
        for (n = 1; n <= nights; n++, factor *= DISCOUNT)
            total += rate * factor;
        printf("The total cost will be &%0.2f.\n", total);
    }
    ```

    ```c
    /* usehotel.c */
    同上例文件，写法不变
    此外由于hotel.h中引入了stdio.h，而本文件又调用了hotel.h，所以可以不再调用stdio.h，即删除本文件的#include <stdio.h>
    ```

##### **查找地址：&运算符**

- **指针**是 C 语言中**最重要的**(有时也是**最复杂的**)概念之一，用于**存储变量的地址**。前面使用的`scanf()`函数中就**使用地址作为参数**

- 如果**主调函数**不使用`return`**返回**的值，则必须通过**地址**才能**修改**主调函数中的值

- **一元**`&`**运算符**的用法

  - **一元**`&`**运算符**给出变量的**储存地址**，如果`pooh`是变量名，那么`&pooh`是变量的地址。可以把地址看做是**变量在内存中的位置**

  - **PC 地址**通常使用**十六进制**表示，`%p`是输出地址的**转换说明**

  - **示例程序**：查看不同函数中同名变量分别储存在什么位置

    ```c
    #include <stdio.h>

    void mikado(int bah)
    {
        int pooh = 10;
        printf("In mikado(), pooh= %d and &pooh= %p\n", pooh, &pooh);
        printf("In mikado(), bah= %d and &bah= %p\n", bah, &bah);
    }

    int main(void)
    {
        int pooh = 2, bah = 5;
        printf("In main(), pooh= %d and &pooh= %p\n", pooh, &pooh);
        printf("In main(), bah= %d and &bah= %p\n", bah, &bah);
        mikado(pooh);
        return 0;
    }
    ```

    ```
    In main(), pooh= 2 and &pooh= 000000000061FE1C
    In main(), bah= 5 and &bah= 000000000061FE18
    In mikado(), pooh= 10 and &pooh= 000000000061FDDC
    In mikado(), bah= 2 and &bah= 000000000061FDF0
    ```

  - **输出解析**

    > 1、两个**pooh**地址不同，两个**bah**的地址也不同，因此证实**计算机**把它们看做**4 个独立的变量**  
    > 2、函数调用`mikado(pooh)`把**实参 pooh=2**传递给了**形参 bah**。注意这种传递**只传递了值**，涉及的**两个变量并未改变**  
    > 3、注意**第 2 点**并非在**所有语言**都成立。如**FORTRAN**中，**子例程**会影响**主调例程**的**原始变量**。子例程**变量名**可能与原始变量**不同**，但它们的**地址相同**。但在 C 中不是这样，每个**C 函数**都有**自己的变量**，这样可以防止**原始变量**被**被调函数**的副作用**意外修改**，但也带来了**一些麻烦**

##### **更改主调函数中的变量**

- 有时需要在**一个函数**中改变**其他函数的变量**，则需要**使用指针**

- **程序示例**(**错误的方式**使用**函数**交换两个变量的**值**)

  ```c
  #include <stdio.h>

  void change(int u, int v)
  {
      int temp;
      temp = u;
      u = v;
      v = temp;
      printf("u:%d    v:%d\n",u,v);
  }

  int main(void)
  {
      int x = 5, y = 10;
      printf("before: %d %d\n", x, y);
      change(x, y);
      printf("after: %d %d\n", x, y);
      return 0;
  }
  ```

- **问题解析**

  > 1、但显然该程序`main()`中**x**和**y**的值**并未交换**，而交换函数`change()`内的**u**和**v**的值是**交换**的。问题出现在把**结果传回**`main()`时。  
  > 2、`change()`的变量并不是`main()`的变量，因此交换的**值**并不会**影响**`main()`中的**值**。  
  > 3、能否使用`return`**将值传回**`main()`？当然可以，但`return`只能把**被调函数**中的**一个值**传回，但现在**要传回两个值**，因此需要**使用指针**

##### **指针简介**

- **基本概念**

  - **指针**：一个**值**为**内存地址**的**变量**(或数据对象)。正如**char**类型变量**值是字符**，**int**类型变量**值是整数**，**指针**变量的**值是地址**

  - 假设一个**指针变量名**是**ptr**，则可以编写`ptr = &pooh`这条语句

    > 1、对于这条语句，我们说**ptr 指向 pooh**  
    > 2、**指针 ptr**和**地址 &pooh**的**区别**是，**指针 ptr**是**变量**，**地址 &pooh**是**常量**。或者说，**指针 ptr**是**可修改**的**左值**，**地址 &pooh**是**右值**  
    > 3、我们当然还可以**把 ptr 指向别处**，如`ptr = &bah`，现在**ptr 指向 bah**，**值**为**bah 的地址**

  - 要创建**指针变量**，要先**声明**指针变量的**类型**。假设想把**ptr**声明为**储存 int 类型变量地址**的指针，就要使用下面介绍的**新运算符**

- **间接运算符：**`*`

  > 1、假设已知`ptr = &bah;`，即**ptr 指向 bah**  
  > 2、使用**间接运算符**`*`，可以找出**储存在 bah 中**的**值**，语句为：`val = *ptr;`，意为**找出 ptr 指向的值**  
  > 3、该运算符有时也称为**解引用运算符**。但注意不要将其与**二元乘法运算符**混淆，虽然符号相同，但**语法功能不同**  
  > 4、将语句`ptr = &bah`和`val = *ptr`**放在一起**，其**功能作用**相当于此**赋值语句**：`val = bah;`  
  > 5、由此可见，使用**地址**和**间接运算符**可以**间接完成**上面赋值语句的功能，这也是其名称的由来

- **声明指针**

  - **声明指针变量示例**

    ```c
    int * pi;               // 指向int类型变量的指针
    char * pc;              // 指向char类型变量的指针
    float * pf, * pg;       // 指向float类型变量的指针
    ```

  - **声明解析**

    > 1、**类型说明符**表明了指针**所指向对象**的**类型**，**星号**表明**声明的变量**是一个**指针**  
    > 2、`*`和**指针名**之间的**空格可有可无**，通常在**声明时使用**空格，在**解引用时省略**空格  
    > 3、**pc 指向的值**(即\*pc)是`char`类型，而**pc 本身的类型**描述为"**指向 char 类型的指针**"  
    > 4、在大部分系统内部，该**地址**由一个**无符号整数**表示。但**不要**把**指针**认为是**整数类型**，为此，**ANSI C**专门为指针提供了`%p`的**格式转换说明**

    ![](https://s2.loli.net/2022/07/05/DgmC9sXaTE2ibY8.png)

- **使用指针在函数间通信**

  - 在上节**改变主调函数中的变量**中的程序，通过**函数**调换两个变量的值不能成功，在此可以**通过指针实现**

  - **示例程序**

    ```c
    #include <stdio.h>

    void change(int *u, int *v)
    {
        int temp;
        temp = *u;
        *u = *v;
        *v = temp;
    }

    int main(void)
    {
        int x = 5, y = 10;
        printf("before: %d %d\n", x, y);
        change(&x, &y);
        printf("after: %d %d\n", x, y);
        return 0;
    }
    ```

  - **程序解析**

    > 1、该函数传递的不是**x 和 y**的**值**，而是他们的**地址**。这意味着出现在`change()`**原型和定义**中的**形参 u 和 v**将**地址**作为它们的**值**。因此应把他们声明为**指针**。由于**x 和 y**是**整数**，所以**u 和 v**是**指向整数的指针**  
    > 2、在**函数体**中声明了一个交换值时必需的**临时变量 temp**，通过`temp = *u;`把**x 的值**存储在**temp**中  
    > 3、注意，**u 的值**是`&x`，这意味着可以用`*u`表示**x 的值**，这正是我们需要的。不要写成`temp = u;`，该语句意为把**x 的地址**赋给**temp**(u 的值就是 x 的地址)，而**不是 x 的值**  
    > 4、于是，通过这种形式进行交换，就可以做到**修改主调函数的值**的需求了

---

#### **数组与指针**

---

<div class="success">

> **章节概要**：数组；数组复习；初始化数组；只读数组；指定初始化器；指定初始化器的特性；数组元素赋值；数组边界；多维数组；二维数组；二维数组的声明；其他多维数组；指针和数组；指针处理数组；函数、数组与指针(声明数组形参)；使用指针形参；指针操作；不要解引用未初始化的指针；保护数组中的数据；对形参使用`const`；其他`const`内容；指针和多维数组；通过指针表示二维数组的值；数组指针与指针、多维数组深入；指向多维数组的指针；指针的兼容性；`C const`和`C++ const`；函数和多维数组指针；变长数组(VLA)；复合字面量

</div>

##### **数组**

- **数组复习**

  - **声明示例**

    ```c
    int main(void)
    {
        float candy[365];       // 内含365个float类型元素的数组
        char code[12];          // 内含12个char类型元素的数组
        int states[50];         // 内含50个int类型元素的数组
        ...
    }
    ```

  - **数组使用规则**

    > 1、前面介绍过，**数组**由**数据类型相同**的**一系列元素**组成。需要使用**数组**时，通过**声明数组**告诉**编译器**数组内含有**多少元素**和**元素类型**。**编译器**根据这些**信息**正确的**创建数组**  
    > 2、**普通变量**可以使用的**类型**，**数组元素都可以用**  
    > 3、**方括号**`[]`表示**candy**、**code**、**states**都是**数组**，方括号中的**数字**表示数组中的**元素个数**  
    > 4、要**访问**数组中的**元素**，通过使用数组**下标数**(也称为**索引**)**表示**数组中的各个**元素**。数组**元素编号**从**0**开始，所以`candy[0]`表示**candy**的**第 1 个元素**，`candy[364]`表示**第 365 个元素**，即**最后一个元素**

- **初始化数组**

  - **数组**通常被用来储存程序**需要的数据**。例如，一个内涵**12 个整数元素**的数组可以**储存 12 个月的天数**。这种情况下，在程序**一开始**就**初始化数组**比较好

  - **初始化数组的方法**

    - 只**存储单个值**的**变量**有时也称为**标量变量**，我们已经**很熟悉**如何**初始化**这种变量(代码中**PI**已被定义为**宏**)：

      ```c
      int fix = 1;
      float flax = PI * 2;
      ```

    - 而 C 使用**新的语法**来**初始化数组**：

      ```c
      int power[8] = {1, 2, 4, 6, 8, 16, 32, 64};       // ANSI C开始支持这种初始化
      ```

    - **语法解析**

      > 1、如上所示，用以**逗号分隔**的**值列表**(用**花括号**括起来)来**初始化数组**，**各值之间**用**逗号分隔**(逗号和值之间可以使用空格)  
      > 2、根据上面的**初始化**，把**1**赋给数组**首元素 power[0]**，**2**赋给**power[1]**，**按序**以此类推(注意 64 赋给的末元素是 power[7])  
      > 3、不支持**ANSI C**的编译器会把这种**初始化**识别为错误，在**数组声明前**加上关键字`static`即可解决(12 章将讨论此关键字)

  - **使用 const 声明数组**

    > 1、有时需要把**数组**设置为**只读**，这样**只能**从数组中**检索值**，不能把**新值写入**  
    > 2、要**创建只读数组**，应该用`const`声明和初始化数组，即`const int days[12] = {..., ..., ...}`  
    > 3、这样修改后，程序在**运行过程中**就**不能修改数组的内容**。一旦声明为`const`，便**不能**再给它**赋值**

  - **自动适配数组大小**

    ```c
    #include <stdio.h>
    int main(void)
    {
        const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31};
        for (int index = 0; index < sizeof(days) / sizeof(days[0]); index++)
        {
            printf("Month %2d has %d days.\n", index + 1, days[index]);
        }
        return 0;
    }
    ```

  - **注意事项**

    > 1、 使用数组前**必须先初始化**。与普通变量类似，在使用**数组元素**前**必须**先给它们**赋初值**，否则**编译器**使用的值是**内存相应位置上的现有值**(即都是**垃圾值**，会干扰程序运行)。只要**初始化**至少**1 个元素**的值，其余**未初始化**的值也会被**初始化为 0**  
    > 2、如果**初始化数组**时**省略**方括号中的**数字**，**编译器**会根据**初始化列表**中的**项数**来确定**数组大小**(如上"自动适配数组大小")  
    > 3、使用`sizeof()`计算**数组大小**(**字节**)时，`sizeof(days)`是**整个数组**的大小，`sizeof(days[0])`是数组中**一个元素**的大小

- **指定初始化器**

  - **C99**新增加了一个**新特性**：**指定初始化器**。利用该特性可以**初始化指定的数组元素**。例如只初始化**最后一个元素**

    > 1、传统 C 初始化：`int arr[6] = {0,0,0,0,0,212};`  
    > 2、**C99**规定，可以在**初始化列表**中使用带**方括号**的**下标**指明**待初始化的元素**：`int arr[6] = { [5] = 212 };`

  - **复杂示例**

    ```c
    #include <stdio.h>
    int main(void)
    {
        int arr[12] = {31, 28, [4] = 31, 30, 31, [1] = 29};
        for (int i = 0; i < 12; i++)
        {
            printf("index:%-3d    value:%d\n", i, arr[i]);
        }
        return 0;
    }
    ```

    ```
    index:0      value:31
    index:1      value:29
    index:2      value:0
    index:3      value:0
    index:4      value:31
    index:5      value:30
    index:6      value:31
    index:7      value:0
    index:8      value:0
    index:9      value:0
    index:10     value:0
    index:11     value:0
    ```

  - **特性解析**

    > 1、以上输出揭示了**指定初始化器**的**两个重要特性**  
    > 2、如果**指定初始化器**后面有**更多值**，如该例`[4] = 31,30,31`，那么**后面的值**将被用于**初始化指定元素后面的元素**(即 arr[5]和 arr[6]被初始化为 30 和 31)  
    > 3、如果**再次初始化**指定元素，那么**最后的初始化**将会**取代之前的初始化**(如 arr[1]先被初始化为 28，后被指定初始化`[1] = 29`初始化为 29)  
    > 4、如果未指定元素大小，如`int arr[] = {1, [6]=4, 9, 10};`，编译器将会把**数组大小**设置为**足够装得下初始化**的值(即该例下标应为 0~8，共 9 个元素)

- **数组元素赋值**

  - **示例程序**

    ```c
    #include <stdio.h>
    int main(void)
    {
        int arr[50];
        for (int i = 0; i < 50; i++)
        {
            arr[i] = i*2;
        }
        arr[6] = 10;
        return 0;
    }
    ```

  - **示例解析**

    > 1、声明**数组**后，可以借助**数组下标**给数组元素**赋值**，如已定义`int arr[20];`则可使用`arr[6] = 10;`来赋值对应元素  
    > 2、注意**多个元素**赋值应通过**循环遍历依次赋值**。C**不允许**把**数组**作为一个单元**赋给另一个数组**，**初始化外**也**不允许**使用**花括号列表**赋值

- **数组边界**

  > 1、在**使用数组**时，要防止数组**下标越界**，必须确保**下标**是**有效的值**  
  > 2、假设有`int doofi[20];`的**声明**，则使用时数组**下标**应在**0~19 的范围内**  
  > 3、编译器**不会检查**这种错误，但是一些编译器会**发出警告**，然后**继续编译**程序  
  > 4、在 C 标准中，使用**越界下标**的结果是**未定义**的。这意味着程序可能**看上去可以运行**，但是运行**结果很奇怪**，或**异常终止**  
  > 5、C 语言为什么会允许这种事发生？这要归功于**C 信任程序员**的原则。编译器没必要**捕获所有**的**下标错误**，这会**降低运行速度**；C 相信程序员能**编写正确的代码**，**不检查边界**，这样程序**运行速度更快**

##### **多维数组**

- **概念引入与分析**

  > 1、假如需要记录**5 年内每个月**的降水量，应该如何更方便的储存数据？  
  > 2、第一种方案，创建**60 个变量**，分别储存每个月的数据。但显然**十分麻烦**  
  > 3、第二种方案，使用**内涵 60 个元素的数组**，**每个元素**恰好表示**每月的数据**。这种更加可行，但**无法分辨年份**  
  > 4、第三种方案，创建**5 个分别内涵 12 个元素的数组**，以此分辨年份。但这种方案也**很麻烦**，且**不能满足更多年份**的需求  
  > 5、第四种方案，使用**二维数组**，下面介绍此种方案

- **二维数组**

  - 结合上例，可以将**二维数组**理解为**数组的数组**。**主数组**有**5 个元素**(表示 5 年)，这 5 个元素**每个元素**都是**内涵 12 个元素的数组**(表示每年 12 个月)

- **二维数组的声明**

  > 1、使用`float rain[5][12]`**声明**符合本需求的**二维数组**  
  > 2、分开来看，`rain[5]`表示数组**rain 有 5 个元素**，至于**每个元素**的情况，要看**声明的其余部分**  
  > 3、`float`和`[12]`说明**每个元素的类型**是**float[12]**。即**rain 的每个元素**本身都是一个**内含 12 个 float 类型值**的**数组**

  ![](https://s2.loli.net/2022/07/08/b9JKzUBwAcMarDi.png)

- **示例程序(十分重要，请理解代码，教程夹杂在代码中)**

  ```c
  #include <stdio.h>

  #define MONTHS 12
  #define YEARS 5
  #define LINE "========================================================="

  int main(void)
  {
      // 声明二维数组并初始化(这样初始化换行为了方便查看，也可以按规定格式写在一行)
      float rain[YEARS][MONTHS] = {
          {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6},
          {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3},
          {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4},
          {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2},
          {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}};
      int year, month;
      float subtot, total;

      /* 输出年总降水与年均降水 */
      printf("%s\n", LINE);
      printf("年份               降水量(英尺)\n");
      // year遍历年份，total计算所有年份(5年)总降水量
      for (year = 0, total = 0; year < YEARS; year++)
      {
          // month遍历月份，subtot计算每年总降水量
          for (month = 0, subtot = 0; month < MONTHS; month++)
          {
              subtot += rain[year][month];
          }
          printf("%4d %20.1f\n", 2018 + year, subtot);
          total += subtot;
      }
      printf("年均降水：%.1f\n", total / YEARS);
      printf("%s\n", LINE);

      /* 输出降水详情 */
      printf("     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n");
      for (year = 0; year < YEARS; year++)
      {
          printf("%d ", 2018 + year);
          for (month = 0; month < MONTHS; month++)
          {
              printf("%.1f ", rain[year][month]);
          }
          printf("\n");
      }
      printf("%s", LINE);
      return 0;
  }
  ```

  ```
  =========================================================
  年份               降水量(英尺)
  2018                 32.4
  2019                 37.9
  2020                 49.8
  2021                 44.0
  2022                 32.9
  年均降水：39.4
  =========================================================
       Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
  2018 4.3 4.3 4.3 3.0 2.0 1.2 0.2 0.2 0.4 2.4 3.5 6.6
  2019 8.5 8.2 1.2 1.6 2.4 0.0 5.2 0.9 0.3 0.9 1.4 7.3
  2020 9.1 8.5 6.7 4.3 2.1 0.8 0.2 0.2 1.1 2.3 6.1 8.4
  2021 7.2 9.9 8.4 3.3 1.2 0.8 0.4 0.0 0.6 1.7 4.3 6.2
  2022 7.6 5.6 3.8 2.8 3.8 0.2 0.0 0.0 0.0 1.3 2.6 5.2
  =========================================================
  ```

- **其他多维数组**

  - 前面讨论的**二维数组**相关内容都**适用**于**三维数组**或**更多维的数组**。例如可以通过`int box[10][20][30];`**声明一个三维数组**
  - 同样面对**更多维的数组**，需要**更多的循环嵌套**来**遍历**，理解好**每层循环**所**控制的元素**，才能够**准确地操控数组**
  - 实际使用中，更多维的数组**出现概率不高**，通常只需要**二维数组**就能完成**大多数需求**

##### **指针和数组**

- 第 9 章介绍过指针，指针提供一种**以符号形式使用地址**的方法。因为计算机的**硬件指令**非常**依赖地址**，指针在某种程度上把程序员想要**传达的指令**以**更接近机器**的方式表达，因此**使用指针**的程序**很有效率**。

- **指针处理数组**

  - **引入**

    > 1、**指针**能有效地**处理数组**，**数组表示法**其实是在**变相地使用指针**  
    > 2、举个简单的例子，**数组名**是数组的**首元素地址**，即`arr == &arr[0]`成立  
    > 3、两者都是**常量**，运行过程中**不会改变**。但是可以将它们**赋值**给**指针变量**，然后可以**修改指针变量的值**

  - **示例程序**

    ```c
      #include <stdio.h>
      #define SIZE 4

      int main(void)
      {
          short dates[SIZE];
          short *pti;
          double bills[SIZE];
          double *ptf;
          pti = dates; // 把数组地址赋给指针，数组名是数组首元素地址
          ptf = bills;
          printf("%23s %15s\n", "short", "double");
          for (int index = 0; index < SIZE; index++)
              printf("pointers + %d: %10p %10p\n", index, pti + index, ptf + index);
          return 0;
      }
    ```

    ```
                        short          double
      pointers + 0: 000000000061FE00 000000000061FDE0
      pointers + 1: 000000000061FE02 000000000061FDE8
      pointers + 2: 000000000061FE04 000000000061FDF0
      pointers + 3: 000000000061FE06 000000000061FDF8
    ```

  - **程序解析**

    > 1、第 2 行起打印**两个数组的地址**，下一行打印的是**指针+1 后的地址**。地址为**十六进制**，因此**DF**比**DE**大  
    > 2、系统中，地址**按字节编址**。**short**占**2 字节**，**double**占**8 字节**。在 C 中，**地址+1**指的是增加一个**存储单元**。对**数组**而言，这意味着**地址+1 后**是**下一个元素的地址**，而不是**下一个字节的地址**  
    > 3、这便是为何必须**声明指针所指向的对象类型**的原因之一。只知道**地址**不够，还需要知道**储存对象**需要**多少字节**，否则指针**无法正确取回**地址上的**值**

    ![](https://s2.loli.net/2022/07/14/96IxhpwnslqozLK.png)

  - **特性总结补充**

    > 1、**指针的值**是**它所指向对象的地址**。地址的表示方式依赖于计算机内部的硬件，大部分都是**按字节编址**，即内存中**每个字节**都**按顺序编号**。一个**较大对象**(如 double 的 8 字节)的地址通常是**第一个字节的地址**  
    > 2、在指针前面使用`*`**运算符**可以得到该指针**所指向对象的值**  
    > 3、**指针+1**，指针的值**递增**它**所指向类型的大小**(字节为单位)

##### **函数、数组与指针(声明数组形参)**

- **引入**

  > 1、假设要编写一个**处理数组的函数**，该函数**返回数组中所有元素之和**  
  > 2、此时注意，由于**数组名**是数组**首元素地址**，所以**实参**是一个**存储对应类型值的地址**而不是**数值**，因此**传参时**应把它赋给一个**指针形式参数**，即**形参**应为**指向对应类型的指针**  
  > 3、此时**函数**获得了该数组**首元素的地址**，且知道需要找出的**值的数据类型**，但并未获得**数组元素个数**，有两种方法：一种方式可以在函数中需要时直接**人为写入数组元素个数**(比如`for`遍历时的条件直接写入元素个数)来告知此信息，但这样**不利于维护**；另一种方式是**创建形参**，将**元素个数**也**传入函数**中

- **示例程序**

  ```c
  #include <stdio.h>
  #define SIZE 10

  // 此处也可写为：
  // int def(int * ar, int n)
  int def(int ar[], int n)
  {
      int sum = 0;
      for (int i = 0; i < n; i++)
          sum += ar[i];
      printf("ar的大小是 %zd bytes\n", sizeof(ar));
      return sum;
  }

  int main(void)
  {
      int arr[SIZE] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20};
      long answer;
      answer = def(arr, SIZE);
      printf("数值相加为 %d\n", answer);
      printf("arr的大小是 %zd bytes\n", sizeof(arr));
      return 0;
  }
  ```

  ```
  ar的大小是 8 bytes
  数值相加为 190
  arr的大小是 40 bytes
  ```

- **程序解析**

  > 1、函数**第 1 个形参**告诉函数**数组地址**与**数据类型**，**第 2 个形参**告诉函数数组的**元素个数**  
  > 2、只有在**函数原型**或**函数定义头**时，才可以用`int ar[]`代替`int * ar`(某些编译器可能对于前者会报警报 warning)。在这种情况下，`int * ar`与`int ar[]`都表示**ar**是一个**指向 int 的指针**，但是`int ar[]`只能用于**声明形参**。`int ar[]`提醒读者，不仅是一个**int 类型值**，还是一个**int 类型数组的元素**  
  > 3、**arr**大小是**40 字节**，因为其**内含 10 个 int 类型值**。**ar**只有**8 字节**，因为其是指向**arr**数组首元素的**指针**，**我们的系统**使用**8 字节存储地址**(其他系统可能不同)，所以**指针变量大小**是**8 字节**

- **声明数组形参**

  - 因为**数组名**是该数组**首元素的地址**，作为**实参**的**数组名**要求**形参**是一个**与之相配的指针**。只有这种情况下，C 才会把`int ar[]`和`int * ar`解释成一样

  - 注意上方**示例程序**的**函数原型**与**函数定义**写在一起，因此对于下方的解释，应按照**函数定义**标准，而非**函数原型**标准

  - 由于**函数原型**可以**省略参数名**，所以**下面 4 种原型等价**：

    ```c
    int def(int * ar, int n);
    int def(int *, int);
    int def(int ar[], int n);
    int def(int [], int);
    ```

  - **函数定义**中**不能省略参数名**，因此只有**下面 2 种的定义等价**：

    ```c
    int def(int * ar, int n){
        // 省略函数内代码
    }

    int def(int ar[], int n){
        // 省略函数内代码
    }
    ```

##### **使用指针形参**

- 函数要**处理数组**必须知道何时**开始**、何时**结束**。上节已展示一种方式**标识函数开始与元素个数**，而这并非唯一途径。第二种方式是**传递两个指针**，一个表明**数组开始处**，一个表明**数组结束处**

- **程序示例**

  ```c
  #include <stdio.h>
  #define SIZE 10

  int def(int *start, int *end)
  {
      int sum = 0;
      while (start < end)
      {
          sum += *start;
          start++;
      }
      return sum;
  }

  int main(void)
  {
      int arr[SIZE] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20};
      long answer;
      answer = def(arr, arr + SIZE);
      printf("数值相加为 %d", answer);
      return 0;
  }
  ```

- **程序解析**

  > 1、指针**start**开始指向**arr**数组的首元素地址，所以赋值表达式`sum += *start`把**首元素的值**加给**sum**(前面讲过`*指针变量`表示获取对应地址的**值**)  
  > 2、表达式`start++`**递增**指针变量**start**，使其指向数组**下一个元素**(前面讲过**指针递增 1**相当于**递增对应类型的大小**，此处即为**递增 int 类型的大小**)  
  > 3、程序的`while`循环，使用**第二个指针 end**来设定范围，告知函数**数组的大小**  
  > 4、`while`循环的条件使用了**小于**，即循环处理的**最后一个元素**是**end**所指向位置的**前一个元素**。这是由于**end**(`arr + SIZE`)指向的位置实际是**数组最后一个元素**(arr[9])的**后面**(并不存在的 arr[10])，本机测试时`arr[9]`地址尾缀**fe14**，**end**尾缀**fe18**。C 保证在给数组**分配空间**时，**指向**数组**后面第一个位置**的指针仍是**有效的指针**  
  > 5、因此结合**第 4 条**，如果按照**常规逻辑**，**end**应被传入`arr + SIZE -1`以正确**指向最后的元素**`arr[9]`。只是这种写法既不简洁也不好记，于是使用了上面的写法

##### **指针操作**

- 可以对指针进行哪些操作？C 提供一些基本的**指针操作**，下面的程序演示一些不同的操作

- **程序示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int urn[5] = {100, 200, 300, 400, 500};
      int *ptr1, *ptr2, *ptr3;

      ptr1 = urn;     // 把一个地址赋给指针
      ptr2 = &urn[2]; // 把第一个地址赋给指针

      // 1.解引用指针，以及获得指针的地址
      printf("1. ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);

      // 2.指针加法
      ptr3 = ptr1 + 4;
      printf("2. ptr1+4 = %p, *(ptr1+4) = %d\n", ptr1 + 4, *(ptr1 + 4));

      // 3.指针递增
      ptr1++;
      printf("3. ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);

      // 4.指针递减
      ptr2--;
      printf("4. ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);

      --ptr1; // 恢复初始值
      ++ptr2; // 恢复初始值

      // 5.指针减另一个指针
      printf("5. ptr2 = %p, ptr1 = %p, ptr2-ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);

      // 6.指针减一个整数
      printf("6 .ptr3 = %p, ptr3-2 = %p\n", ptr3, ptr3 - 2);

      return 0;
  }
  ```

  ```
  1. ptr1 = 000000000061FE00, *ptr1 = 100, &ptr1 = 000000000061FDF8
  2. ptr1+4 = 000000000061FE10, *(ptr1+4) = 500
  3. ptr1 = 000000000061FE04, *ptr1 = 200, &ptr1 = 000000000061FDF8
  4. ptr2 = 000000000061FE04, *ptr2 = 200, &ptr2 = 000000000061FDF0
  5. ptr2 = 000000000061FE08, ptr1 = 000000000061FE00, ptr2-ptr1 = 2
  6. ptr3 = 000000000061FE10, ptr3-2 = 000000000061FE08
  ```

- **指针变量的基本操作**

  - **赋值**

    > 1、可以把**地址**赋给**指针**。例如，用**数组名**、**带地址运算符的变量名**(&a)、**另一个指针**等进行赋值  
    > 2、该例中，urn 数组的**首地址**赋给**ptr1**，其地址编号尾号**FE00**，变量**ptr2**获得数组 urn 的**第 3 个元素的地址**，即`urn[2]`的地址

  - **解引用**

    > 1、`*`**运算符**给出指针**指向地址**上**储存的值**  
    > 2、因此，**\*ptr**的初值是**100**，该值储存在编号尾号**FE00**的**地址**上

  - **取址**

    > 1、和所有变量一样，**指针变量**也有自己的**地址**和**值**。对指针而言，`&`**运算符**给出**指针本身**的**地址**  
    > 2、该例中，**ptr1**储存在内存编号尾号**FDF8**的地址上，其**值**为编号尾号**FE00**的地址(即 urn 的地址)  
    > 3、因此，`&ptr1`是指向**ptr1**的指针，**ptr1**是指向`urn[0]`的指针

  - **指针和整数相加**

    > 1、可以使用`+`**运算符**把**指针和整数相加**，或者**整数和指针相加**  
    > 2、无论哪种情况，**整数**都会和指针**所指向类型的大小**(字节为单位)**相乘**，再与初始地址相加  
    > 3、因此`ptr1 + 4`与`&urn[4]`等价。如果结果**超出数组范围**，计算结果是**未定义的**，除非**超出数组末尾第一个位置**(前面讲过，C 保证该指针有效)

  - **指针减去一个整数**

    > 1、可以使用`-`**运算符**从一个**指针**减去一个**整数**。**指针**必须是**第 1 个运算对象**，**整数**是**第 2 个运算对象**  
    > 2、其**运算规则**与**指针+整数**相同

  - **递增指针**

    > 1、**递增**指向**数组的元素**的**指针**可以让该指针**移动**到数组**下一元素**  
    > 2、因此，`ptr1++`相当于**把 ptr1 的值+4**(因为本系统 int 为 4 字节)，**ptr1**指向`urn[1]`  
    > 3、注意程序中还输出了**ptr1 的地址**，其并**未发生变化**。，因为指针变量也是变量，变量**不会**因为**值发生变化**就**移动位置**

  - **递减指针**

    > 1、当然，除了递增指针，还可以**递减指针**  
    > 2、其**使用方法**与**递增指针**相同

  - **指针求差**

    > 1、可以计算**两个指针**的**差值**。通常，求差的两个指针分别指向**同一个数组的不同元素**，通过计算求出**两元素之间的距离**。**差值的单位**与**数组类型单位**相同  
    > 2、该例中，`ptr2 - ptr1 = 2`意为这两个指针所指向的**两个元素**相隔**2 个 int**，而**不是 2 字节**  
    > 3、只要两个指针都指向**相同的数组**，C 都能保证**运算有效**。如果指向**不同数组**，求差运算可能会**得出一个值**，或者导致**运行时错误**

  - **比较**

    > 1、使用**关系运算符**可以**比较两个指针的值**，前提是它们**指向相同类型的对象**

- **不要解引用未初始化的指针**

  - **注意事项**：千万**不要**解引用**未初始化**的指针，如下：

    ```c
    int *pt;    // 未初始化的指针
    *pt = 5;    // 严重的错误
    ```

  - **原因说明**

    > 1、为何不行？**第 2 行**的意思是**把 5 存储在 pt 指向的位置**。但**pt 未初始化**，其**值**是一个**随机值**，所以不知道 5 将**存储在何处**  
    > 2、这可能不会出什么错，也可能会**擦写数据或代码**，或者**导致程序崩溃**  
    > 3、**创建**一个**指针**时，系统只分配了**储存指针本身**的内存，并未分配**存储数据**的内存。因此**使用指针**前，必须先用**已分配**的地址**初始化**它

##### **保护数组中的数据**

- **引入**

  > 1、编写一个**处理基本类型**的**函数**时，需要选择是传递**值**还是**指针**。通常都是传递**数值**，只有程序需要在函数内**改变该值**时，才会传递**指针**  
  > 2、对于**数组**别无选择，**必须**传递**指针**。因为这样**效率更高**，如果**按值传递**，则必须分配足够空间将值**拷贝**到**新数组**中  
  > 3、C 通常**按值传递**数据，这样可以保证**数据**的**完整性**，使用的是原始数据的**副本**而非原始数据**本身**，这样便可以**保护原数据**。但对于数组，我们需要一种方式来保护数组中的数据

- **对形参使用 const**

  > 1、如果函数的意图不是**修改**数组中的**数据内容**，那么**函数原型**和**函数定义**可以使用**只读**——`const`**关键字**  
  > 2、`const`告诉编译器，函数**不能修改**指针**指向的数组**的内容。如若使用`arr[i]++`这样的表达式会**生成错误信息**  
  > 3、函数声明例如`void def(const int ar[])`，这样便可以**保护数组的数据**

- **其他 const 内容**

  - **其他 const 的使用**

    > 1、之前我们使用`const`**创建**过**变量**。虽然使用`#define`也能**创建符号常量**，但`const`更为灵活，可以创建`const`数组、`const`指针和指向`const`的指针。  
    > 2、下面举例(**默认已声明**`int arr[5];`)  
    > 3、如指向`const`的**指针**：`const int *ptr = arr;`，将**不允许通过 ptr 修改**指向数据的值。但注意**arr**并未被声明为`const`，所以仍可**通过 arr 修改**元素的值：`arr[0] = 10;`。此外也可以**让 ptr 指向别处**：`ptr++; // 指向arr[1]`  
    > 4、此外可以声明并初始化一个**不能指向别处**的`const`**指针**，特别注意`const`**的位置**：`int * const ptr = arr;`。**可以**用这种指针**修改指向的值**，但**不能更改**它**指向的地址**  
    > 5、如果创建指针时**使用两次**`const`，这样便既**不能修改指向地址的数据**也**不能修改指向的地址**：`const int * const ptr = arr;`

  - **其他 const 的规则**

    > 1、把`const`或**非**`const`数据的**地址**初始化为**指向**`const`**的指针**是**合法的**，但`const`数据的**地址**只能赋给**指向**`const`**的指针**，赋值给**普通指针**是**非法的**  
    > 2、这个规则非常合理，否则通过**普通指针**就能**修改**`const`数组的**数据**  
    > 3、因此，对函数的**形参**使用`const`不仅能**保护数据**，还能让函数**处理**`const`**数组**

    ```c
    int arr[5] = {};
    const int locked[5] = {};
    const int *ptr1;
    int *ptr2;

    ptr1 = arr;       // 有效(指向非const数据的地址)
    ptr1 = locked;    // 有效(只是不能通过ptr1改变指向的值，但可以更改ptr1指向的对象。指向const数据的地址)
    ptr1 = &arr[3];   // 有效(指向非const数据的地址)
    ptr2 = arr;       // 有效(普通指针指向普通地址)
    ptr2 = locked;    // 无效(普通指针不能指向const数据的地址，只能通过指向const的指针指向此数据)
    ```

##### **指针和多维数组**

- **引入**

  - 假设有`int arr[4][2];`的声明。**数组名 arr**是该数组的**首元素地址**。在本例中，**arr**的**首元素**是一个**内含两个 int 值**的**数组**(由 arr 声明时第二维为`[2]`表明)，所以**arr**是**这个数组**(即内含两个 int 值的数组)的**地址**

- **从指针属性进一步分析(可结合下方辅助理解示例来理解)**

  > 1、因为**arr**是**首元素地址**(即第一维首元素`arr[0]`的地址)，所以在地址上`arr = &arr[0]`，其值**相同**。而`arr[0]`本身是一个**内含两个整数**的**数组**，所以`arr[0]`的值和它的**首元素**(一个整数)**地址**(即`&arr[0][0]`)**相同**，即在地址上`arr[0] = &arr[0][0]`(此处可以像第一维一样，假设将二维数组的`arr[0]`看做一维的**arr**，将二维数组的`arr[0]`的元素`arr[0][0]`和`arr[0][1]`分别看做一维的`arr[0]`和`arr[1]`，方便理解)  
  > 2、简而言之，**arr**是一个**占用两个 int 大小对象**的**地址**(因为其一个元素(`arr[0]`)内含两个 int 值)，而`arr[0]`是一个**占用一个 int 大小对象**的**地址**。但由于内含两个整数的**数组**(`arr[0]`)和这个**整数**(`arr[0][0]`)**起始于同一个地址**，所以**arr**和`arr[0]`**地址相同**。综上，在地址上`arr = arr[0] = &arr[0] = &arr[0][0]`，因为都**指向整个二维数组的起始地址**(即最根本的第一个数值的位置`arr[0][0]`)  
  > 3、**给指针或地址+1**,其值会增加**对应类型大小**的数值。在这方面，**arr**和`arr[0]`不同，因为如上所言**arr**指向的对象**占两个 int 大小**，而`arr[0]`指向对象**占一个 int 大小**。因此`arr + 1`和`arr[0] + 1`的值不同  
  > 4、**解引用**(使用`*`符)指针或通过**数组下标**`[]`，可以**得到**引用对象的**值**。因为`arr[0]`作为**数组名**是**数组首元素**(即`arr[0][0]`)的**地址**，所以**解引用**`*(arr[0])`**得到**的是存储在`arr[0][0]`上的**值**。与此类似，**arr**作为**数组名**代表**首元素**(即`arr[0]`)的**地址**，但`arr[0]`本身还是一个**地址**，其地址是`&arr[0][0]`，所以**解引用**`*arr`就是`&arr[0][0]`(注意这里**解引用后**`*arr`的值就是**地址**，而**不是数值**)，此时**再次解引用**`**arr`就相当于`*&arr[0][0]`，即**取得**`arr[0][0]`指向的**值**  
  > 5、简而言之，**arr**作为数组名(首元素地址)，是**地址的地址**，必须**解引用两次**才能**获得原始值**。此处**地址的地址**或者**指针的指针**就是**双重间接**的例子

- **针对上述 1、2 条的辅助理解示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int arr[4][2];
      printf("%p\n", arr);        // 数组名为首元素地址，起始首元素为arr[0]，即指向&arr[0]
      printf("%p\n", &arr[0]);    // 与上者相等
      printf("%p\n", arr[0]);     // 数组名为首元素地址，起始首元素为arr[0][0]，即指向&arr[0][0]
      printf("%p\n", &arr[0][0]); // 与上者相等
      printf("%p\n", &arr[0][1]); // 从第二维递增一个下标，证明arr[0]是一个占用一个 int 大小对象的地址
      printf("%p\n", &arr[1]);    // 从第一维递增一个下标，证明arr是一个占用两个 int 大小对象的地址
      return 0;
  }
  ```

  ```
  000000000061FE00
  000000000061FE00
  000000000061FE00
  000000000061FE00
  000000000061FE04
  000000000061FE08
  ```

- **针对上述 3、4、5 条的辅助理解示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int arr[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
      printf("%p\n", arr);
      printf("%p\n", arr + 1); // 增加对应元素类型的大小(两个int类型大小)
      printf("%p\n", arr[0]);
      printf("%p\n", arr[0] + 1); // 增加对应元素类型的大小(一个int类型大小)
      printf("=================\n", arr[0]);
      printf("%d\n", arr[0][0]); // 直接通过数组下标获取值
      printf("%d\n", *arr[0]);   // 解引用arr[0]
      printf("%p\n", *arr);      // 解引用一次arr，其值仍为地址，即arr[0][0]的地址
      printf("%d\n", **arr);     // 解引用两次，获得指向的值
      return 0;
  }
  ```

  ```
  000000000061FE00
  000000000061FE08
  000000000061FE00
  000000000061FE04
  =================
  2
  2
  000000000061FE00
  2
  ```

- **通过指针表示二维数组的值**

  - 前面我们了解过，对于`int arr[4][2]`该例：`arr + 1`，其值+8(两个 int)，而`arr[0] + 1`，其值+4(一个 int)
  - 但要注意，与`arr[2][1]`**数值等价**的指针表示法是`*(*(arr+2) + 1)`，理解如下

    | 表达式            | 相对上一步的含义                                                                                             |
    | ----------------- | ------------------------------------------------------------------------------------------------------------ |
    | arr               | 二维数组首元素地址，(每个元素都是内含两个 int 的一维数组)，即第一维首元素`arr[0]`的地址                      |
    | arr +2            | 二维数组第 3 个元素的地址，即第一维从第一个元素`arr[0]`变为第三个元素`arr[2]`，值为其地址                    |
    | \*(arr+2)         | 二维数组第 3 个元素的首元素地址，即第二维首元素`arr[2][0]`的地址                                             |
    | \*(arr+2) + 1     | 二维数组第 3 个元素的第 2 个元素的地址，即第二维从第一个元素`arr[2][0]`变为第二个元素`arr[2][1]`，值为其地址 |
    | \*(\*(arr+2) + 1) | 解引用该地址，取得`arr[2][1]`的值                                                                            |

  - 图片演示**指针表示法**

    ![](https://s2.loli.net/2022/07/21/8KCGwA3Y1lc9qWm.png)

  - 以上分析并**不是为了**说明用**指针表示法**来**代替**常用的**数组表示法**(即下标直接引用)，而是表述程序恰巧使用一个**指向二维数组的指针**，而且要通过该指针**获取值**，最好用简单的**数组表示法**

##### **数组指针与指针、多维数组深入**

- **指向多维数组的指针**

  - 如何声明一个**指针变量 pz**指向一个**二维数组**(如`int arr[4][2]`的第一层的**arr**或`arr[1]`)？

  - **声明方法**

    > 1、对于声明指向**arr**和`arr[1]`这样的数组，只声明为**指向 int 类型**还**不够**，因为这种指针指向**一个 int 类型的值**，但需要指向的**元素**为**内含两个 int 类型的值的数组**  
    > 2、因此应按照`int (*pz)[2]`**这种格式**声明，这种声明的**pz**便指向一个**内含两个 int 类型的值的数组**，将其声明为**指向数组的指针**。为什么使用**圆括号**`()`，因为`[]`的优先级高于`*`，考虑下条声明  
    > 3、对于`int *pax[2]`这条声明。按照优先级**pax**先与`[2]`结合成为一个**内含两个元素的数组**，然后`*`表示**pax 数组**内含**两个指针**。因此这条代码声明了**两个指向 int 的指针**  
    > 4、补充解释，`int (*pz)[2]`的**pz**是一个**储存一个地址**的指针，其储存的地址指向**内含两个 int 类型的值的数组**；而`int *pax[2]`的**pax**是一个**储存两个地址**的**指针数组**，其储存的地址指向**一个 int 类型的值**

  - **辅助理解示例**

    ```c
    #include <stdio.h>
    int main(void)
    {
        int arr[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
        int(*pz)[2];
        pz = arr; // 指向&arr[0]，其为内含两个int类型值的数组

        printf("%p\n", &arr[0]);
        printf("%p\n", pz);
        printf("%p\n", pz + 1);     // +1直接增加了两个int类型值的大小
        printf("%p\n", &arr[1]);    // 证明了pz+1 相当于从arr[0]指向了arr[1]
        printf("%p\n", pz[0]);      // 因为pz指向arr[0]，所以相当于&arr[0][0] (具体还需结合下方“数组指针的[]使用来理解”)
        printf("%p\n", pz[0] + 1);  // 相当于从arr[0][0] +1后指向arr[0][1]，所以增加了一个int类型值的大小
        printf("%p\n", &arr[0][1]); // 证明了pz[0]+1 指向 arr[0][1]
        printf("%p\n", *pz);        // 使用 * 解运算pz，相当于解运算arr[0]，即 *arr[0]，arr[0]指向其首元素地址，于是便得到 &arr[0][0]
        printf("%p\n", *pz + 1);    // 相当于arr[0][0] +1后指向arr[0][1]，增加一个int类型值大小
        printf("=================\n");
        printf("%d\n", *pz[0]);           // pz[0]即指向 &arr[0][0]，解运算得到arr[0][0]的值
        printf("%d\n", **pz);             // 第一次解运算 *pz得到指向arr[0][0]的地址 &arr[0][0]，解运算得到值
        printf("%d\n", pz[2][1]);         // 关于数组指针加[]的事宜，下方将详细讨论
        printf("%d\n", *(*(pz + 2) + 1)); // 按前节方法解释，相当于得到arr[3][1]的值
        return 0;
    }
    ```

    ```
    000000000061FDF0
    000000000061FDF0
    000000000061FDF8
    000000000061FDF8
    000000000061FDF0
    000000000061FDF4
    000000000061FDF4
    000000000061FDF0
    000000000061FDF4
    =================
    2
    2
    3
    3
    ```

  - **数组指针的[]使用**

    > 1、如前所述，虽然**pz 是一个指针**，不是数组名，但仍可以使用`pz[2][1]`这种写法  
    > 2、可以用**数组表示法**或**指针表示法**表示**一个数组元素**，既可以使用**数组名**，也可以使用**指针名**
    > 3、三者的**等价关系如下陈述**。需要注意数组名`[m][n]`调用到的数值与`arr[m][n]`的值是对应的，**pz 调用时**，如果 pz**不指向数组首元素地址**，则**对应的值**是`arr[指向元素 + m][指向元素 + n]`

    ```c
    arr[m][n] == *(*(arr+m) + n)
    pz[m][n] == *(*(pz+m) + n)
    ```

- **指针的兼容性**

  - **指针**之间的**赋值**比**数值类型**之间的**赋值**要**严格**。例如，不用类型转换就可以把**int 类型值**赋给**double 类型变量**，但**两个类型的指针**就**不能这样做**，如下两例：

    ```c
    int n=5;
    double x;
    int *pl = &n;
    double *pd = &x;
    /*-------------------------------*/
    x = n;      // 数值类型，隐式类型转换
    pd = pl;    // 指针，编译时错误
    ```

    ```c
    int *pt;
    int (*pa)[3];
    int arr1[2][3];
    int arr2[3][2];
    int **p2;             // 一个指向指针的指针
    /*--------------------------------*/
    pt = &arr1[0][0];     // 都是指向int的指针
    pt = arr1[0];         // 数组名是首元素地址，都是指向int的指针
    pt = arr1;            // 无效，首元素地址指向&arr[0]，是一个指向三个int类型值的数组
    pa = arr1;            // 相当于&arr[0]，都是指向内含三个int类型元素数组的指针
    pa = arr2;            // 无效，arr2为指向两个int类型值的数组
    pa = &pt;             // 都是指向int *的指针，&pt为指向指针pt的地址
    *p2 = arr2[0];        // 都是指向int的指针，p2此处进行了一次解运算，指向int类型而非指向指针
    p2 = arr2;            // 无效，p2为指向指针的指针
    ```

  - **多重解引用**注意事项：

    - **示例程序**

      ```c
      int x=20;
      const int y=23;
      int *p1 = &x;
      const int *p2 = &y;
      const int **pp2;
      p1 = p2;        // 不安全，把const指针赋给非const指针
      p2 = p1;        // 有效，把非const指针赋给const指针
      pp2 = &p1;      // 不安全，嵌套指针类型赋值
      ```

    - **示例解析**

      > 1、前面提到过，把`const`**指针**赋给**非**`const`**指针**是**不安全**的，因为这样可以**使用新的指针改变**`const`**指针指向的数据**。**编译器**在编译时，可能会给出警告，执行这样的代码是**未定义的**  
      > 2、但把**非**`const`**指针**赋给`const`**指针**没问题，前提是**只进行一级解引用**。但当进行**两级解引用**时，这样的赋值**也不安全**，如下描述

    - **非 const 赋值 const 时的两级解引用**

      ```c
      const int **pp2;
      int *p1;
      const int n=13;
      pp2 = &p1;        // 允许，但是这会导致const限定符失效(根据第一行代码，不能通过**pp2修改它所指向的内容)
      *pp2 = &n;        // 有效，两者都声明为const，但是这将导致p1指向n(*pp2已被修改)
      *p1 = 10;         // 有效，但是这将改变n的值(但是根据第三行代码，不能修改n的值)
      ```

    - **示例解析**

      > 1、发生了什么？如前所示，标准**规定了**通过**非**`const`**指针**更改`const`**数据**是**未定义的**  
      > 2、例如使用**gcc**编译包含以上代码的程序，导致**n**最终值为**13**(未更改)。但是在**相同系统下**使用**clang**来编译，**n**最终的值是**10**(已更改)。两个编译器都给出**指针类型不兼容**的**警告**  
      > 3、当然您可以忽略这些警告，但最好**不要相信程序运行的结果**，因为这些结果都是**未定义的**

- **C const 和 C++ const**

  > 1、C 和 C++中`const`**用法很相似**，但并不完全相同  
  > 2、区别之一是，C++允许**声明数组大小**时**使用**`const`**整数**，而 C**不允许**  
  > 3、区别之二是，C++的**指针赋值检查更严格**。C++**不允许**把`const`**指针**赋给**非**`const`**指针**，而 C 允许。如下例，但如果**通过 p1 更改 y**，其行为是未定义的

  ```c
  const int y;
  const int *p2 = &y;
  int *p1;
  p1 = p2;    // C++不允许这样做，C可能只发出警告
  ```

- **函数和多维数组指针**

  - **示例程序**

    ```c
    #include <stdio.h>

    #define ROWS 3
    #define COLS 4

    void sum_rows(int ar[][COLS], int rows)
    {
        int r, c, tot;
        for (r = 0; r < rows; r++)
        {
            tot = 0;
            for (c = 0; c < COLS; c++)
                tot += ar[r][c];
            printf("row %d: sum = %d\n", r, tot);
        }
    }

    void sum_cols(int ar[][COLS], int rows)
    {
        int r, c, tot;
        for (c = 0; c < COLS; c++)
        {
            tot = 0;
            for (r = 0; r < rows; r++)
                tot += ar[r][c];
            printf("col %d: sum = %d\n", c, tot);
        }
    }

    int sum2d(int ar[][COLS], int rows)
    {
        int r, c, tot = 0;
        for (r = 0; r < rows; r++)
            for (c = 0; c < COLS; c++)
                tot += ar[r][c];
        return tot;
    }

    int main(void)
    {
        int junk[ROWS][COLS] = {{2, 4, 6, 8}, {3, 5, 7, 9}, {12, 10, 8, 6}};
        sum_rows(junk, ROWS);
        sum_cols(junk, ROWS);
        printf("Sum of all elements = %d\n", sum2d(junk, ROWS));
        return 0;
    }
    ```

    ```
    row 0: sum = 20
    row 1: sum = 24
    row 2: sum = 36
    col 0: sum = 17
    col 1: sum = 19
    col 2: sum = 21
    col 3: sum = 23
    Sum of all elements = 80
    ```

  - **程序解析**

    > 1、在**函数声明**中`int ar[][COLS]`，第 1 个**方括号**`[]`是空的，空的方括号**表明 ar 是一个指针**。所以该语句等效于`int (*ar)[COLS]`，如前面**数组指针**提到的，后面的`COLS`用于告知指针指向的**元素**(子数组)内含多少个**对应数据类型**的**大小**  
    > 2、该程序把**数组名 junk**(即首元素地址，即**子数组**)和**符号常量 ROWS**作为参数**传递给函数**。由于`int ar[][COLS]`的声明，每个函数都把**ar**视为**内含数组元素**的**数组**  
    > 3、注意，**ar**和`main`中的**junk**都使用**数组表示法**。因为 ar 和 junk**类型相同**，都是指向**内含 4 个 int 值的数组的指针**  
    > 4、一般而言，声明一个**指向 N 维数组**的指针时，**只能省略最左边**的方括号中的值，因为其只用于**表明这是一个指针**，其他方括号则用于描述**指针指向**的**数据对象的类型**(内含多少个对应什么数据类型的大小)

##### **变长数组(VLA)**

- **引入**

  ```c
  /*如上节的函数示例*/
  int sum2d(int ar[][COLS], int rows)
  {
      int r, c, tot = 0;
      for (r = 0; r < rows; r++)
          for (c = 0; c < COLS; c++)
              tot += ar[r][c];
      return tot;
  }
  ```

  > 1、为什么**使用函数**操作**二维数组**时，只将**行数**(**ROWS**)作为函数的**形参**，而**列数**(**COLS**)**内置**在函数体内？  
  > 2、我们可以使用`sum2d()`函数对`int arr1[5][4]`、`int arr2[100][4]`、`int arr3[2][4]`等数组**求各元素之和**，是因为这些数组的**列数固定为 4**，**行数**被**传递**给**形参 rows**，**rows**是一个**变量**。但如果要对`int arr4[6][5]`计算，则**不能使用这个函数**，必须新建一个**COLS 为 5**的函数，因为**C 规定**，数组的维数**必须是常量**，**不能用变量代替**  
  > 3、要创建一个能**处理任意大小**二维数组的函数，比较繁琐(必须把数组**作为一位数组传递**，然后让**函数计算每行的开始处**)。鉴于此，**C99**新增了**变长数组**，允许使用**变量**表示**数组的维度**

- **变长数组**

  - **声明示例**

    ```c
    int quarters = 4;
    int regions = 5;
    double arr[regions][quarters];      // 一个变长数组
    ```

  - **变长数组的特性**

    > 1、**变长数组**有一些**限制**：变长数组**必须**是**自动储存类别**，这意味着无论在**函数中声明**还是作为**函数形参声明**都**不能使用**`static`或`extern`**储存类别说明符**(第 12 章介绍)。而且**不能在声明中初始化**它们  
    > 2、变长数组**不能改变大小**：**变长数组**的“**变**”不是指可以**修改**已创建数组的**大小**。**一旦创建**了变长数组，**其大小保持不变**。这里的“**变**”指的是在**创建数组时**，可以**使用变量指定数组的维度**  
    > 3、由于**变长数组**是 C 语言的**新特性**，目前**完全支持**这一特性的**编译器**不多

  - **示例程序(程序要求编译器支持变长数组)**

    ```c
    #include <stdio.h>

    #define ROWS 3
    #define COLS 4

    // 带变长数组形参的函数
    int sum2d(int rows, int cols, int ar[rows][cols])
    {
        int r, c, tot = 0;
        for (r = 0; r < rows; r++)
            for (c = 0; c < cols; c++)
                tot += ar[r][c];
        return tot;
    }

    int main(void)
    {
        int i, j;
        int rs = 3, cs = 10;
        int junk[ROWS][COLS] = {{2, 4, 6, 8}, {3, 5, 7, 9}, {12, 10, 8, 6}};                // 3*4数组
        int morejunk[ROWS - 1][COLS + 2] = {{20, 30, 40, 50, 60, 70}, {5, 6, 7, 8, 9, 10}}; // 2*6数组
        int varr[rs][cs];                                                                   // 3*10变长数组
        // 为变长数组赋值
        for (i = 0; i < rs; i++)
            for (j = 0; j < cs; j++)
                varr[i][j] = i * j + i;

        printf("3*4 array: sum = %d\n", sum2d(ROWS, COLS, junk));
        printf("2*6 array: sum = %d\n", sum2d(ROWS - 1, COLS + 2, morejunk));
        printf("3*10 VLA: sum = %d\n", sum2d(rs, cs, varr));
        return 0;
    }
    ```

    ```
    3*4 array: sum = 80
    2*6 array: sum = 315
    3*10 VLA: sum = 165
    ```

  - **示例解析**

    > 1、声明一个带**二维变长数组参数**的函数，需要注意**前两个形参**`rows`和`cols`用作**第三个形参**二维数组`ar[rows][cols]`的**两个维度**。**参数数组 ar**的声明需要**使用前两个参数**，因此**必须先声明**前两个参数，使用`int sum2d(int ar[rows][cols], int rows, int cols)`这种**无效的顺序**声明函数原型是**错误的**  
    > 2、体面提到过 C 标准规定，可以省略**函数原型**中的**形参名**，但这种情况下必须用**星号**`*`**代替省略的维度**：`int sum2d(int, int, int ar[*][*])`。(注意是**函数原型**不是**函数定义**，如果是**函数定义**仍必须**完整写出**类型、变量名等信息)  
    > 3、需要注意的是，在**函数定义**时的形参列表中**声明的变长数组**，**并非实际创建数组**。和传统的语法类似，**变长数组名**实际上**是一个指针**。这说明函数实际上还是在**原始数组**中处理数组，因此**可以更改传入的数据**  
    > 4、变长数组还允许**动态内存分配**，这说明可以在**程序运行时指定数组的大小**。**普通数组**都是**静态内存分配**，即在**编译时确定数组大小**(12 章将详细讨论)

##### **复合字面量**

- **引入**

  > 1、假设给带**int 类型形参**的函数**传递**一个值，应传递**int 类型的变量**，但也可以传递**int 类型的常量**，比如**5**  
  > 2、C99 之前，对于**带数组形参的函数**，可以传递数组，但没有等价的**数组常量**，于是 C99 新增了**复合字面量**  
  > 3、**字面量**是除**符号常量**以外的**常量**。如：**5**是**int**的字面量；**81.3**是**double**的字面量；**Y**是**char**的字面量；**hello**是字符串字面量  
  > 4、于是，C99 认为如果有**代表数组**和**结构内容**的**复合字面量**，会更方便

- **复合字面量**

  > 1、对于数组，**复合字面量**类似数组**初始化列表**(实际可以看做**常量数组**，类似我们给普通变量赋值时写的**5**、**81.3**这样的**字面量常量**)，前面是用**括号**`()`括起来的**类型名**。如`(int [2]){10,20};`，括号内的`int [2]`便是复合字面量的**类型名**  
  > 2、初始化**有数组名的数组**时可以**省略数组大小**，**复合字面量**也可以**省略大小**，**编译器**会**自动计算**数组当前**元素个数**：`(int []){50,20,90}`  
  > 3、因为**复合字面量**是**匿名**的，所以**不能先创建再使用**，必须在**创建的同时使用**它。使用**指针记录地址**就是一种用法，即如果有`int *pt;`，则可以通过`pt = (int [2]){10,20};`让**pt**指针**记录地址**，后通过**pt**使用这个**常量数组**(匿名只是无法通过名称调用，但仍储存在固定的内存地址上，因此可以使用指针调用)。**复合字面量**的**类型名**也代表**首元素地址**，因此和数组规则相同，`*pt`是**10**，`pt[1]`是**20**  
  > 4、还可以把**复合字面量**作为**实参**传给带有**匹配形参**的**函数**。这也是复合字面量的**典型用法**，其好处是把信息**传入函数**前**不必先创建数组**  
  > 5、注意，**复合字面量**是提供**只临时需要**的值的**一种手段**。**复合字面量**具有**块作用域**(12 章详细介绍)，一旦**离开**定义复合字面量的**块**，程序无法保证该字面量**是否存在**。也就是说，复合字面量定义在**最内层的花括号内**

- **综合应用示例**

  ```c
  #include <stdio.h>

  #define COLS 4

  // 计算一维数组各元素的和
  int sum(const int ar[], int n)
  {
      int i, total = 0;
      for (i = 0; i < n; i++)
          total += ar[i];
      return total;
  }

  // 计算二维数组各元素的和
  int sum2d(const int ar[][COLS], int rows)
  {
      int r, c, tot = 0;
      for (r = 0; r < rows; r++)
          for (c = 0; c < COLS; c++)
              tot += ar[r][c];
      return tot;
  }

  int main(void)
  {
      int total1, total2, total3;
      int *pt1;
      int(*pt2)[COLS];
      // 使用指针记录匿名的复合字面量的地址，以后续调用
      pt1 = (int[2]){10, 20};
      pt2 = (int[2][COLS]){{1, 2, 3, -9}, {4, 5, 6, -8}};

      total1 = sum(pt1, 2);
      total2 = sum2d(pt2, 2);
      // 将复合字面量作为实参传入函数形参
      total3 = sum((int[]){4, 4, 4, 5, 5, 5}, 6);
      printf("total1 = %d\n", total1);
      printf("total2 = %d\n", total2);
      printf("total3 = %d\n", total3);
      return 0;
  }
  ```

---

#### **字符串和字符串函数**

---

<div class="success">

> **章节概要**：表示字符串和字符串 I/O；在程序中定义字符串；数组表示法与指针表示法；字符串数组；字符串输入；分配空间；`gets()`函数；`fgets()`函数；`gets_s()`函数；`scanf()`函数；字符串输出；`puts()`函数；`fputs()`函数；`printf()`函数；自定义输入/输出函数；字符串函数；`strlen()`函数；`strcat()`函数；`strncat()`函数；`strcmp()`函数；`strncmp()`函数；`strcpy()`函数；`strncpy()`函数；其他字符串函数；`ctype.h`字符函数和字符串；字符串示例：字符串排序；排序指针而非字符串；选择排序算法；命令行参数；字符串转换为数字；`atoi()`与其类别函数；`strtol()`与其类别函数

</div>

##### **表示字符串和字符串 I/O**

- 第四章介绍过，**字符串**是以**空字符**(`\0`)结尾的**char 类型数组**。因此，可以把上一章学到的**数组和指针**的知识应用于**字符串**

- **在程序中定义字符串**

  - **字符串字面量**(**字符串常量**)

    > 1、用**双引号**`""`括起来的内容称为**字符串字面量**，也叫做**字符串常量**。双引号中的**字符**和编译器**自动加入末尾**的`\0`字符，都作为字符串**储存在内存中**  
    > 2、从**ANSI C**起如果**字符串字面量**之间**没有间隔**，或者用**空白字符分隔**，C 会将其视为**串联起来的**字符串字面量。如`char word[50] = "hello,"" how are" " you?"`等价于`char word[50] = "hello, how are you?"`。如果要在**字符串内部**使用**双引号**，则必须通过**反斜杠**`\`进行**转义**。如`printf("\"Hello\", Jimmy said");`  
    > 3、**字符串常量**属于**静态存储类别**，这说明如果在**函数中使用**字符串，该字符串**只会被储存一次**，并在**整个程序的生命周期内存在**，即使函数**被调用多次**  
    > 4、用**双引号括起来的内容**被视为指向**该字符串存储位置**的**指针**(该字符串**首字符地址**)，这类似于把**数组名**作为指向**该数组位置**的**指针**  
    > 5、因此，如果使用`printf()`打印`"hello"`，使用`%s`将打印**整个字符串**，使用`%p`将打印该字符串**首字符地址**。既然整个字符串表示**首字符地址**，那么使用`%c`输出解引用的`*"hello"`，结果便是**首字符 h**而**不是整个字符串**

  - **字符串数组和初始化**

    > 1、**定义字符串数组**时，必须让编译器知道**需要多少空间**  
    > 2、**声明示例**：`const char word[10] = "hello"`，其中`const`表明不会更改这个字符串(可省略)。这种形式初始化比**标准的数组初始化**简单的多：`const char word[10] = {'h', 'e', 'l', 'l', 'o', '\0'}`，注意最后的**空字符**，如果没有这个空字符，这就**不是**一个**字符串**，而是一个**字符数组**  
    > 3、在**指定数组大小**时，要确保数组的**元素个数**要**至少**比字符串长度**多 1**(为了容纳空字符)。所有**未被使用的元素**都会被自动**初始化为 0**(这里的 0 是 char 形式的空字符，不是数字字符 0)  
    > 4、通常，让**编译器**确定**数组大小**很方便。对于**字符串**(字符数组)也一样，省略数组**初始化声明**中的**大小**，编译器会**自动计算**数组的大小  
    > 5、**字符数组名**和其他**数组名**一样，是该数组**首元素的地址**

  - **数组表示法与指针表示法**

    - 前面介绍的声明为**数组表示法**，如`const char arr[] = "hello";`(`const`可省略)，此外还可以用**指针表示法**创建字符串，如`const char * pt = "hello";`(`const`不可省略)

    - **pt**和**arr**都是该字符串的**地址**，且**字符串本身**决定预留的**存储空间**，尽管如此，这两种形式**并不完全相同**

    - **数组表示法**

      > 1、**数组形式**(`arr[]`)在计算机的**内存中**分配为一个**内含 6 个元素**的数组(预留出空字符)，每个元素被**初始化**为字符串字面量**对应的字符**  
      > 2、通常**字符串**都作为**可执行文件**的一部分存储在**数据段**中，当把程序**载入内存**时，也载入了**字符串**。字符串存储在**静态存储区**中，但是程序在**开始运行时**才会为数组**分配内存**，此时才**将字符串拷贝到数组**中。这时字符串有**两个副本**，一个是**静态内存**中的**字符串字面量**，另一个是**arr 数组**中的**字符串**  
      > 3、随后，编译器将**数组名 arr**识别为数组的**首元素地址**的别名。在**数组形式**中，**arr**是**地址常量**，**不能更改 arr**，否则更改意味着**改变了**数组的**存储位置**。所以**可以进行**类似`arr+1`这样的操作，标识数组的**下一个元素**，但**不能进行**类似`++arr`这样的操作，**递增运算符**只可以用于**可修改的左值**，**不能用于常量**

    - **指针表示法**

      > 1、**指针形式**(`*pt`)也使得**编译器**为**字符串**在**静态存储区**预留 6 个元素的空间。另外**一旦开始执行**程序，他会为**指针变量 pt**留出一个储存位置，并把**字符串的地址**存储在**指针变量**中  
      > 2、该指针变量**最初指向**该**字符串首字母**，但是它的值**可以改变**。因此可以使用**递增运算符**，如`++pt;`将指向**第二个字符**(即 e)  
      > 3、**字符串字面量**被视为`const`**数据**，由于**pt 指向这个数据**，所以应该把**pt**声明为**指向**`const`**数据**的**指针**。这意味着**不能用 pt 改变**它所**指向的数据**，但**可以改变 pt 的值**(即指向的地址)  
      > 4、如果把一个字符串**拷贝**给一个**数组**(即使用数组表示法)，则可以**随意改变数据**，除非把数组**声明**为`const`

  - **字符串数组**

    - 创建一个**字符串数组**通常很方便，可以通过**数组下标**访问多个**不同的**字符串

    - **字符串数组-数组表示法**

      ```c
      const words[5][40] = {
          "Hello, my name is Lisa.",
          "I'm 16 years old.",
          "How about you?"
      };
      ```

    - **字符串数组-指针表示法**

      ```c
      const *words[5] = {
          "Hello, my name is Lisa.",
          "I'm 16 years old.",
          "How about you?"
      };
      ```

##### **字符串输入**

- 想把一个**字符串**读入程序，首先必须**预留**储存该字符串的**空间**，然后用**输入函数**获取该**字符串**

- **分配空间**

  - 第一件事便是**分配空间**，以**储存**后续读入的**字符串**。这意味着要为字符串**分配足够的空间**，**不要指望**计算机在读取时**顺便计算**它的长度，再分配空间(计算机不会这样做)

  - **错误示例**

    ```c
    char *name;
    scanf("%s",name);
    ```

    > 1、虽然**可能通过编译**(大概率会报**警报**)，但在读取**name**时，**name**很可能会**擦写**程序中的**数据或代码**，导致程序**异常终止**  
    > 2、因为`scanf()`要把信息**拷贝**到参数的**指定地址**，而**name**是个**未初始化的指针**，所以可能指向**任何地方**

  - **正确分配空间**

    > 1、**最简单**的方法是，在**声明时显式指明数组的大小**：`char name[81];`  
    > 2、还有一种方法是使用**C 库函数**来**分配内存**，第 12 章介绍

- **gets()函数**

  - `gets()`**的使用**

    ```c
    char word[81];
    gets(word);
    puts(word);
    ```

    > 1、在**读取字符**时，`scanf()`配合`%s`只能读取**一个单词**(遇到空格就停止)，但程序经常要读取**一整行输入**  
    > 2、`gets()`函数就用于**读取整行输入**，直至**遇到换行符**。然后**丢弃换行符**，**储存其他字符**，并在这些字符**末尾添加一个空字符**使其成为一个**字符串**  
    > 3、`gets()`常常与`puts()`函数**配对使用**，该函数用于**显示字符串**，并在末尾**添加换行符**

  - `gets()`**的危险性**

    > 1、某些**编译器**对于使用`gets()`的程序**报出警告**，但并非全部编译器都会这样做。其他编译器可能在**编译过程中**给出警告，但不会引起你的注意  
    > 2、问题出现在`gets()`的**唯一参数**是**字符串名**(word)，它**无法检查**数组**是否装得下**输入行  
    > 3、如果输入的**字符串过长**，会导致**缓冲区溢出**，即多余的字符**超出了**指定的**目标空间**。如果这些**多余字符**只是占用了**尚未使用的内存**，就**不会立刻出现问题**；如果它们**擦写**掉了程序中的其他数据，会导致**程序异常终止**，或者还有**其他情况**  
    > 4、如果出现上述情况，会报出`Segmentation fault`(**分段错误**)，这条消息说明**该程序试图访问未分配的内存**。该函数的**不安全行为**造成了**安全隐患**，过去有些人通过**系统编程**，利用`gets()`插入和运行一些破坏系统安全的代码

  - `gets()`**被遗弃**

    > 1、由于`gets()`的**不安全性**，不久**C 社区**许多人都建议编程时**摒弃**`gets()`。制定**C99**标准的委员会将这些建议**放入了标准**，承认`gets()`的**大量问题**并建议不要再使用它  
    > 2、尽管如此，在标准中**保留**`gets()`也合情合理，因为**现有程序**中含有**大量使用该函数**的代码。而且只要使用得当，其的确是一个**很方便**的函数  
    > 3、好景不长，**C11**采取了更强硬的手段，直接从标准中**废除了**`gets()`函数。既然标准已经发布，那么**编译器**就必须**调整支持**。然而**实际使用**中，编译器为了**兼容以前的代码**，大部分仍**继续支持**`gets()`函数，但部分编译器已**按标准废除**`gets()`

- **fgets()函数**

  - `fgets()`函数可以作为`gets()`的替代品，其通过**第二个参数**限制**读入的字符数**来解决**溢出问题**。但该函数**设计用于处理文件输入**，一般情况可能不那么好用

  - `fgets()`**和**`gets()`**的区别**

    > 1、`fgets()`函数的**第二个参数**指定了读入字符的**最大数量**。如果**该参数值**为**n**，那么`fgets()`将读取**n-1**个字符，或者读到遇到的**第一个换行符**  
    > 2、如果`fgets()`读到一个**换行符**，会把它**保存在字符串**中。而`gets()`函数会**舍弃换行符**  
    > 3、`fgets()`的**第三个参数**指明**要读入的文件**。如果读入从**键盘输入**的数据，则以`stdin`(标准输入)**作为参数**，该**标识符**定义在`stdio.h`中

  - `fgets()`**的使用**

    ```c
    char word[14];
    fgets(word, 14, stdin);
    fputs(word, stdout);
    ```

    > 1、假设**输入 17 个字符**，该程序输出仅会**输出前 13 个字符**(`fgets`只读入**第二个参数-1**个字符)  
    > 2、假设**输入 6 个字符**，`fgets()`函数会将末尾的**换行符**也**储存起来**，如果使用`puts()`函数打印则会**附带一个换行符**，如果使用`fputs()`则不会  
    > 3、`fgets()`由于**储存换行符**的特性常常与`fputs()`**配对使用**。`fputs()`**第二个参数**指明它要**写入的文件**，如果要**显示在屏幕上**，则应使用`stdout`(标准输出)**作为参数**  
    > 4、`fgets()`函数返回**指向 char**的**指针**。如果一切顺利，该函数**返回地址**与传入的**第一个参数**相同。但是，如果函数**读到文件结尾**，它将返回一个**空指针**(null pointer)，该指针**保证不会指向有效数据**,在代码中可以**用数字 0 代替**，不过 C 语言中用宏`NULL`代替**更常见**

  - **示例程序**

    ```c
    #include <stdio.h>
    int main(void)
    {
        char word[10];
        puts("输入字符串(单独换行结束):");
        // fgets输入，返回值不等于空指针(文件结尾)且判断第一个字符不为换行符
        while (fgets(word, 10, stdin) != NULL && word[0] != '\n')
            fputs(word, stdout);
        puts("Done.");
        return 0;
    }
    ```

    ```
    by the way, the gets() function
    by the way, the gets() function
    hello, world
    hello, world
    how about you?
    how about you?

    Done.
    ```

  - **示例解析**

    > 1、虽然**word**的长度被设置为**10**(即实际读入 9 个字符)，但处理**更长的字符串**时貌似并**没有问题**，原理如下  
    > 2、之前提到过，程序的输入使用了**缓冲区**，所以输入**更长的字符串**被**储存在缓冲区**内**等待处理**。第一轮`while`迭代按`fgets()`函数要求**只读入 9 个字符**(即`by the wa`，储存为`by the wa\0`)，然后**处理**(即输出)该字符串，`fputs()`打印且**不换行**  
    > 3、随后进入**第二轮迭代**，从**缓冲区**中读取**剩余未读取的字符**`y, the ge`并存储，再次**输出**，由于`fputs()`的输出**未换行**，所以与上次输入**拼接在了一起**。以此类推

  - **特殊处理**(需要对应操作时可参考处理思路)

    - **处理换行符**(查找换行符，将其替换为空字符)

      ```c
      while (word[i] != '\n')   // 假设 \n 在 word 中，while循环检测跳过非换行符的部分
          i++;
      word[i] = '\0';           // 将换行符替换为空字符
      ```

    - **处理留在缓冲区中的多余字符**(丢弃多余字符)

      ```c
      while (getchar() != '\n') // 读取但不存储输入，包括\n
          continue;
      ```

- **gets_s()函数**

  - **C11**新增的`gets_s()`函数和`fgets()`类似，用一个参数**限制读入的字符数**，其语法为`gets_s(字符串名, 字符数)`，但由于是**可选标准**，所以**某些编译器可能不支持**

  - `gets_s`**与**`fgets()`**的区别**

    > 1、`gets_s`只从`stdin`**标准输入**中读取数据，所以**不需要第三个参数**  
    > 2、如果`gets_s`读到**换行符**，会**舍弃换行符**而不是储存它  
    > 3、如果`gets_s`读到**最大字符数**都**没有读到**换行符，将会执行以下几步。首先把**目标数组**的**首字符**设置为**空字符**，**读取并丢弃随后的输入**直至**换行符**或**文件结尾**，然后**返回空指针**。接着调用依赖实现的**处理函数**(或你选择的其他函数)，可能会**终止或退出**程序  
    > 4、第二个特性说明，只要**不超过最大值**，这两个函数**几乎完全一样**；第三个特性说明，要使用`gets_s`函数还需**进一步学习**

- **scanf()函数**

  - `scanf()`**与**`gets()`、`fgets()`**的区别**

    > 1、**最主要的区别**在于它们如何**确定字符串的末尾**。`scanf()`更像**获取单词**函数，而非**获取字符串**函数  
    > 2、如果**预留的储存区**装得下输入行，`gets()`和`fgets()`会读取**第一个换行符**前**所有的字符**  
    > 3、`scnaf()`有**两种方式**确定**输入结束**，无论哪种方式，都从**第一个非空白字符**作为**字符串开始**。如果使用`%s`**转换说明**，则以**下一个空白字符**作为**字符串结束**；如果指定了**字段宽度**，如`%10s`，那么将**读取 10 个字符**或**读到第一个空白符停止**

##### **字符串输出**

- **puts()函数**

  - `puts()`**的使用**

    ```c
    char word[81] = "hello world";
    puts(word);
    ```

    > 1、`puts()`函数很容易使用，只需要把**字符串地址**传递给它即可。`puts()`**只能**用来**打印字符串**  
    > 2、`puts()`在显示字符串时会**自动**在其末尾**添加一个换行符**  
    > 3、`puts()`如何知道**在哪停止**？其在检测到**空字符**(`\0`)时就**停止输出**，所以必须确保**有空字符**。**典型错误**为打印**字符数组**`char word[81] = {'h','e','l','l','o'}`，字符数组是**没有空字符**的

- **fputs()函数**

  - `fputs()`**与**`puts()`**的区别**

    > 1、`fputs()`与`puts()`就如同`fgets()`与`gets()`相似，**前者**是**后者**的**针对文件**定制的版本  
    > 2、`fputs()`函数的**第二个参数**指明**要写入数据的文件**，如果打印在屏幕上，可以用`stdout`(标准输出)**作为参数**  
    > 3、与`puts()`不同，`fputs()`**不会**在**末尾添加换行符**

- **printf()函数**

  - 和`puts()`等函数一样，`printf()`也把**字符串地址**作为参数。`printf()`输出**字符串**虽然用起来**不如**`puts()`**方便**，但其更加**全能**和**可控**

  - `printf()`**不会**在每个字符串**末尾添加换行符**，所以必须**人为指定**(使用`\n`)在哪里使用换行符

##### **自定义输入/输出函数**

- 不一定非要使用 C 库的**标准函数**，当然我们也可以自己通过`getchar()`和`putchar()`这两个**功能更简单的函数**写一个我们**自己需求的函数**

- **打印字符串，不添加\n**

  ```c
  #include <stdio.h>
  // 因为不需要改变字符串值，所以使用const保护数据
  void put1(const char *str)
  {
      while (*str != '\0')
          // str++指的是指针指向地址递增，而不是指向的数值递增
          putchar(*str++);
  }
  ```

- **一个能统计打印字符个数的 puts()函数**

  ```c
  #include <stdio.h>
  int put2(const char *str)
  {
      int count = 0;
      // 当str指向空字符时，*str值为0，即false，循环结束
      while (*str)
      {
          putchar(*str++);
          count++;
      }
      putchar('\n'); // puts额外添加的换行符，单独输出
  }
  ```

- **优化的 fgets()函数，读取整行输入并用空字符代替换行符(即不存储换行符)，或读取一部分输入舍弃其余部分(即越界部分不存储)**

  ```c
  #include <stdio.h>
  // 函数的返回值是字符串(char *s_gets)
  char *s_gets(char *str, int n)
  {
      char *ret_val; // 创建指针(同时也是存储字符串的变量)
      int i = 0;
      ret_val = fgets(str, n, stdin); // fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL
      if (ret_val)                    // 即，ret_val != NULL，判断是否读到文件结尾
      {
          while (str[i] != '\n' && str[i] != '\0') // 忽略跳过正常字符
              i++;
          if (str[i] == '\n') // 出现换行符替换为空字符，即不存储换行符
              str[i] = '\0';
          else                          // 否则就是读到了空字符
              while (getchar() != '\n') // 丢弃该输入行的其余字符
                  continue;
      }
      return ret_val;
  }
  ```

##### **字符串函数**

- C 库提供了多个**处理字符串**的**函数**，**ANSI C**把这些函数原型放在`string.h`**头文件**中(即**使用需要调用**`string.h`**头文件**)

- **strlen()函数**

  - `strlen()`函数用于**统计字符串有效字符的个数**(不含空字符)

  - **使用**`strlen()`**截断字符串**

    ```c
    #include <stdio.h>
    #include <string.h>           // 特别注意需要头文件

    void fit(char *str, int size)
    {
        if (strlen(str) > size)   // 判断字符串是否比截断位置长
            str[size] = '\0';     // 将第size+1位置的字符替换成空字符
    }
    ```

    > 1、由于`puts()`函数检测到**空字符停止输出**的特性，所以将第**size+1**位置替换为**空字符**，便可实现在此处**停止输出**  
    > 2、若**size**传入**40**，则意味着输出**显示 40 个字符**，因为`str[size]`的**size**作为**下标**，实际修改的是**第 41 位**的值  
    > 3、可以使用`puts(arr + (size+1))`(arr 代指主函数中原字符串名)**输出剩余字符**，但**被替换**为空字符的**字符**已被修改**无法输出**。`arr + (size+1)`实际就是**被替换字符**的**下一个字符**的**地址**，即**跳过**被修改的`\0`位置**向后输出**

- **strcat()函数**

  - `strcat()`函数用于**拼接字符串**

  - `strcat()`接收**两个字符串**作为**参数**。将**第二个字符串**的**备份**，**拼接**在**第一个字符串末尾**，并把拼接后的**新字符串**作为**第一个字符串**，**第二个字符串不变**

  - `strcat()`**返回第一个参数**，即**拼接后的第一个字符串的地址**

  - 注意：该函数无法检测**拼接第二个字符串后**，**第一个字符串是否越界**，需要小心使用

- **strncat()函数**

  - `strncat()`函数也用于**拼接字符串**，其为`strcat()`的**更优选**，可以**预防越界**

  - 相比`strcat()`，`strncat()`多了**第三个参数**用于**指定最大添加字符数**。其在**拼接时**，**拼接到指定大小**或**遇到空字符**时**停止**

- **strcmp()函数**

  - `strcmp()`函数用于**检测字符串的内容是否相等**

  - 一般程序中，**直接比对**两个字符串名，比对的是他们的**地址是否相同**，而非**值是否相同**，`strcmp()`便用于检测**值是否相同**。比如作为**循环条件判断**时`arr != "Quit"`就是**典型错误**，因为**比对地址**永远会得到**false**

  - `strcmp()`比较的是**字符串**，而不是**整个数组**。例如一个**数组**占用**40 字节**，但其仅储存**5 个字符+1 个空字符**共计**6 字节**。此时`strcmp()`函数只会比较该数组**第一个空字符前面**的部分。所以可以用`strcmp()`比较存储在**不同大小数组**中的**字符串**

  - `strcmp()`的**返回值**

    > 1、当**两个字符串**比对**完全相同**，则**返回 0**，**不同**则**返回非零值**  
    > 2、`strcmp()`按照顺序**依次比对字符**，如果比对字符(ASCII 码值)**前者比后者大**(C 和 A)，则**返回 1**；如果**后者比前者大**(A 和 C)，则**返回 -1**  
    > 3、**有些系统**对于上面的结果可能为**2 与 -2**，这些系统的**返回值**为两者的**ASCII 码值**的**差**。但无论如何，**正负**的**规律不变**  
    > 4、注意**ASCII 码**中**大写字母**与**小写字母**比对，**相差 32**，即**小写 = 大写 + 32**

- **strncmp()函数**

  - `strncmp()`函数也用于**检测字符串的内容是否相等**

  - `strncmp()`相比`strcmp()`多了**第三个参数**，用于**限定最大对比到第多少位**

  - `strncmp()`可以**限制只比对多少位**，例如需要查找**以 astro 开头**的单词，`strncmp(arr, "astro", 5)`则表示**只比对前五位**是不是**astro**。而`strcmp()`会**一直比对**，直至发现不同，这一过程可能会**持续到字符串末尾**，且比对**全部字符**

- **strcpy()函数**

  - `strcpy()`函数用于**拷贝字符串**

  - 前面提到过，如果**pts1**和**pts2**都是**指向字符串的指针**，那么`pts2 = pts1`这个语句**拷贝**的是**字符串的地址**而不是**字符串本身**

  - `strcpy()`函数接受**两个参数**`strcpy(str1, str2)`，其将**后者**(地址)指向的字符串**拷贝**至**前者**(地址)。**拷贝出来的**字符串(前者)被称为**目标字符串**，**最初的**字符串(后者)被称为**源字符串**。实际过程中，`strcpy()`函数先创建**源字符串**内容的**副本**，再让**目标字符串**指向该**副本**。如果其**第一个参数**是**数组**，**不必指向**数组的**开始**。须注意拷贝至的**目标字符串**需要保证有**足够空间**容纳**源字符串**副本

  - `strcpy()`的**返回类型**是**指向 char 的指针**，其**返回值**是**第一个参数的值**，即一个**字符地址**

- **strncpy()函数**

  - `strncpy()`函数也用于**拷贝字符串**

  - `strncpy()`相比`strcpy()`多了**第三个参数**，用于**指定可拷贝的最大字符数**

- **sprintf()函数**

  - `sprintf()`函数声明在`stdio.h`头文件中，其用于**将数据写入字符串**

  - `sprintf()`可以把**多个元素**组合成**一个字符串**，其接受的**第一个参数**是**目标字符串**的**地址**，其余参数和`printf()`**相同**，即**格式字符串**和**待写入项的列表**

  - 示例：`sprintf(str, "%s, %6.2f %s", "there are", prize, "yuan.");`

- **其他字符串函数**

  |                      函数                      | 作用                                                                                                                                    |
  | :--------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------- |
  |    char \*strchr(const char \*str, char c)     | 如果 str 字符串包含 c 字符，返回指向 str 中**首次**出现 c 字符位置的指针，如果未找到 c 字符，返回空指针(末尾的空字符也在查找范围内)     |
  |    char \*strrchr(const char \*str, char c)    | 如果 str 字符串包含 c 字符，返回指向 str 中**最后一次**出现 c 字符位置的指针，如果未找到 c 字符，返回空指针(末尾的空字符也在查找范围内) |
  | char \*strpbrk(const char *s1, const char *s2) | 如果 s1 字符串中包含 s2 字符串中的任意字符，返回指向 s1 字符串首位置的指针，否则返回空指针                                              |
  | char \*strstr(const char *s1, const char *s2)  | 该函数返回指向 s1 字符串中 s2 字符串出现的首位置，如果没有找到，返回空指针                                                              |

- **ctype.h 字符函数和字符串**

  - **第 7 章**中介绍了`ctype.h`系列**与字符相关**的**函数**，这些函数虽然**不能处理整个字符串**，但可以通过**自定义编写**，**处理**字符串中的**字符**

  - 例如可以自己编写`for`循环**遍历**字符串中的**字符**，然后对**这些字符**使用`ctype.h`中的**函数**来**实现一些功能**

##### **字符串示例：字符串排序**

- **示例程序**

  ```c
  #include <stdio.h>
  #include <string.h>

  #define SIZE 81 // 限制字符串长度
  #define LIM 20  //可读入最多行数
  #define HALT "" //空字符串停止输入

  // 字符串-指针-排序函数
  void stsrt(char *strings[], int num)
  {
      char *temp;
      int top, seek;
      // 选择排序
      for (top = 0; top < num - 1; top++)
          for (seek = top + 1; seek < num; seek++)
              if (strcmp(strings[top], strings[seek]) > 0)
              {
                  // 交换指针
                  temp = strings[top];
                  strings[top] = strings[seek];
                  strings[seek] = temp;
              }
  }

  // 前面“自定义函数”中提到过的自定义 s_gets()函数
  char *s_gets(char *str, int n)
  {
      char *ret_val; // 创建指针(同时也是存储字符串的变量)
      int i = 0;
      ret_val = fgets(str, n, stdin); // fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL
      if (ret_val)                    // 即，ret_val != NULL，判断是否读到文件结尾
      {
          while (str[i] != '\n' && str[i] != '\0') // 忽略跳过正常字符
              i++;
          if (str[i] == '\n') // 出现换行符替换为空字符，即不存储换行符
              str[i] = '\0';
          else                          // 否则就是读到了空字符
              while (getchar() != '\n') // 丢弃该输入行的其余字符
                  continue;
      }
      return ret_val;
  }

  int main(void)
  {
      char input[LIM][SIZE]; // 储存输入的数组
      char *ptstr[LIM];      // 内含指针变量的数组
      int ct = 0;            // 输入计数
      int k;                 //输出计数
      printf("最多输入%d行，我将会对它们排序，在一行开始处回车以停止输入\n", LIM);
      // 输入行数在范围内 && 输入数据正常 && 第一个字符不是空字符
      while (ct < LIM && s_gets(input[ct], SIZE) != NULL && input[ct][0] != '\0')
      {
          ptstr[ct] = input[ct]; //设置指针指向字符串
          ct++;
      }
      // 函数排序
      stsrt(ptstr, ct);
      printf("排序后：\n");
      for (k = 0; k < ct; k++)
          puts(ptstr[k]);
      return 0;
  }
  ```

  ```
  最多输入20行，我将会对它们排序，在一行开始处回车以停止输入
  O that I was where I would be,
  Then would I be where I an not;
  But there I an I must be,
  And where I would be I can not.

  排序后：
  And where I would be I can not.
  But there I an I must be,
  O that I was where I would be,
  Then would I be where I an not;
  ```

- **排序指针而非字符串**

  > 1、该程序的**巧妙之处**，在于**排序**的是**指向字符串的指针**，而**不是字符串本身**  
  > 2、最初，`ptrst[0]`**指针**被设置为`input[0]`，`ptrst[1]`**指针**被设置为`input[1]`，以此类推，这意味着**指针**`ptrst[i]`**指向数组**`input[i]`的**首字符**。每个`input[i]`都是**内含 81 个元素的数组**，每个`ptrst[i]`都是一个**单独的指针变量**  
  > 3、排序过程中，将`ptrst`**重新排列**，并**未改变**`input`。例如**按字母顺序**`input[1]`应在`input[0]`前面，程序便**交换它们的指针**(即`ptrst[0]`指向`input[1]`的开始，而`ptrst[1]`指向`input[0]`的开始)。这样做比`strcpy()`函数**交换字符串内容**要**简易快速**的多，且还保留了`input`的**原始顺序**

- **选择排序算法**

  > 1、上例中**排序函数**使用的**排序算法**为**选择排序**，具体通过**两层循环**处理以下操作(简称内层循环变量为 j，外层循环变量为 i)  
  > 2、**内层循环**负责**依次**把**每个未排序的元素**(第 j 个元素)与**所排序位置元素**(第 i 个元素)比较。如果**第 j 个元素**在**第 i 个元素**前面，则**交换两者**  
  > 3、**内层循环结束**时，**第 i 个元素**便是这一轮排序中的**最值**，然后**外层循环**将 i 加 1(比对下一位置)，继续**重复这一过程**

##### **命令行参数**

- **命令行简介**

  > 1、在**图形界面**普及之前都是用**命令行界面**，**UNIX**和**DOS**就是例子。**命令行**是在**命令行环境**中，用户为运行程序**输入命令的行**  
  > 2、假设一个文件中有一个名为**fuss**的**程序**，在**UNIX**环境中**运行该程序**的**命令行**是`$ fuss`，或者**Windows**命令提示模式下是`C> fuss`($ 和 C> 都是命令行自带的的行首标识)  
  > 3、**命令行参数**是同一行的**附加项**，比如`$ fuss -r Ginger`，一个**C 程序**可以**读取并使用**这些**附加项**

- **示例程序**

  ```c
  /*test.c*/
  #include <stdio.h>

  int main(int argc, char *argv[])
  {
      int count;
      printf("The command line has %d arguments:\n", argc - 1);
      for (count = 1; count < argc; count++)
          printf("%d: %s\n", count, argv[count]);
      printf("\n");
      return 0;
  }
  ```

- 编译后使用终端 cmd**运行命令行**及**输出结果**

  ```
  C> test.exe resistance is futile
  The command line has 3 arguments:
  1: resistance
  2: is
  3: futile
  ```

- **程序解析**

  > 1、C 编译器**允许**`main()`**没有参数**或者**有两个参数**(一些实现会允许更多参数，属于对标准的扩展)  
  > 2、`main()`有**两个参数**时，**第一个参数**表示命令行中**字符串数量**。过去，这个**int 类型**的**参数**称为**argc**(参数计数 argument count)  
  > 3、系统用**空格**表示一个**字符串的结束**和**下一个字符串的开始**。因此`test.exe resistance is futile`中**一共 4 个字符串**，其中**后 3 个**供`test.exe`使用  
  > 4、该程序把**命令行字符串**储存在**内存**中，并把每个字符串的**地址**存储在**指针数组**中，而**该数组的地址**则被存储在`main()`的**第二个参数**中。按照惯例，这个**指向指针**的**指针**称为**argv**(参数值 argument value)  
  > 5、如果系统允许，就把**程序本身的名称**赋给`argv[0]`，把随后的**第一个字符串**赋给`argv[1]`，以此类推。在我们的例子中，`argv[0]`指向**test.exe**，`argv[1]`指向**resistance**，`argv[2]`指向**is**，`argv[3]`指向**futile**  
  > 6、`main()`中的**形式参数**与其他**带形参的函数**相同，许多程序员用**不同的形式**声明**argv**。如`int main(int argc, char **argv)`，其中`**argv`与`*argv[]`**等价**，**argv**也是一个**指向指针的指针**

##### **字符串转换为数字**

- **引入**

  > 1、**数字**(如 213)既能以**字符串形式**('2','1','3','\0')**存储**，也能以**数值形式**(int 类型值 213)**存储**  
  > 2、C 进行**数值运算**要求用**数值形式**，但在屏幕上**显示数字**要求用**字符串形式**，因为屏幕显示的是**字符**。`printf()`和`sprintf()`函数通过**转换说明**将数字从**数值形式**转换成**字符串形式**，而`scanf()`可以把输入的**字符串**转换成**数值形式**  
  > 3、假设你编写的程序需要使用**数值命令形参**，但是**命令形参数**被读取为**字符串**。因此要使用**数值**必须先把**字符串转换成数字**。C 的`stdlib.h`中有一些函数专门用于处理这类问题

- **atoi()示例程序**

  ```c
  #include <stdio.h>
  #include <stdlib.h>

  int main(int argc, char *argv[])
  {
      int i, times;
      // 使用atoi()函数转换为数值比对
      if (argc < 2 || (times = atoi(argv[1])) < 1)
          printf("Usage:%s, positive-number\n", argv[0]);   // 提示语句
      else
          for (i = 0; i < times; i++)
              puts("Hello, good looking!");
      return 0;
  }
  ```

- **atoi()与其类别函数**

  > 1、`atoi()`函数用于将**字符串**转换为**int 数值形式**  
  > 2、`atoi()`函数能处理**字符串开头**的**数字部分**，例如`123`、`123hello`都会被**转换**成**123**。但如果**开头不是整数**，如`hello123`、`hello`这种字符串，在我们的**C 实现**中会**返回 0**，但**C 标准**规定这种行为是**未定义**的
  > 3、因此，使用有**错误检测功能**的`strtol()`函数(马上介绍)会**更安全**  
  > 4、除了`stoi()`外，`stdlib.h`还包含了其他一些**类似函数**的原型，如下表

  |  函数  | 作用                              |
  | :----: | --------------------------------- |
  | atoi() | 将字符串转换成 int 类型数值形式   |
  | atof() | 将字符串转换成 float 类型数值形式 |
  | atol() | 将字符串转换成 long 类型数值形式  |

- **strtol()示例程序**

  ```c
  #include <stdio.h>
  #include <stdlib.h>

  // 前面自定义函数提到的自定义s_gets()函数
  char *s_gets(char *str, int n)
  {
      char *ret_val; // 创建指针(同时也是存储字符串的变量)
      int i = 0;
      ret_val = fgets(str, n, stdin); // fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL
      if (ret_val)                    // 即，ret_val != NULL，判断是否读到文件结尾
      {
          while (str[i] != '\n' && str[i] != '\0') // 忽略跳过正常字符
              i++;
          if (str[i] == '\n') // 出现换行符替换为空字符，即不存储换行符
              str[i] = '\0';
          else                          // 否则就是读到了空字符
              while (getchar() != '\n') // 丢弃该输入行的其余字符
                  continue;
      }
      return ret_val;
  }

  int main(void)
  {
      char str[30];
      char *end;
      long value;
      s_gets(str, 30);

      value = strtol(str, &end, 10); // 十进制
      printf("10进制：%ld，终止于%s (%d)\n", value, end, *end);
      value = strtol(str, &end, 16); // 十六进制
      printf("16进制：%ld，终止于%s (%d)\n", value, end, *end);
      return 0;
  }
  ```

  ```
  10
  10进制：10，终止于 (0)
  16进制：16，终止于 (0)
  ```

  ```
  10atom
  10进制：10，终止于atom (97)
  16进制：266，终止于tom (116)
  ```

- **strtol()与其类别函数**

  > 1、`atrtol()`函数用于将**字符串**转换为**long 数值形式**  
  > 2、`strtol()`的**第一个参数**接受一个**指向待转换字符串**的**指针**；**第二个参数**接受一个**指针的地址**，该指针被**设置**为标识**输入数字结束字符**的**地址**；**第三个参数**接受一个**整数**，表示以**什么进制**读入数字  
  > 3、**示例中**，如果**end**指针**指向一个字符**，那么**解引用**`*end`就是一个字符。**第一次转换**读到**空字符**结束('1','0','\0')，此时**end**指向**空字符**，打印**end**会显示一个**空字符**，后面的`%d`输出的`*end`显示的是**空字符**的**ASCII 码**(即 0)  
  > 4、**第二次转换**，以**十进制**读入字符串，**end**的值是**字符'a'**的**地址**，所以打印**end**显示**字符串"atom"**；以**十六进制**读入，函数将**atom**的**字符 a**识别为合法的**十六进制数**，所以将十六进制数**10a**转换为**266**  
  > 5、该函数**最多可以支持**转换**三十六进制**，即**a~z**都可以**用作数字**  
  > 6、除了`strtol()`外，`stdlib.h`还包含了其他一些**类似函数**的原型，如下表

  |   函数    | 作用                                                               |
  | :-------: | ------------------------------------------------------------------ |
  | strtol()  | 将字符串转换成 long 类型数值形式                                   |
  | strtoul() | 将字符串转换成 unsigned long 类型数值形式                          |
  | strtod()  | 将字符串转换成 double 类型数值形式(只以十进制转换，只需要两个参数) |

---

#### **储存类别、链接和内存管理**

---

<div class="success">

> **章节概要**：储存类别(引入)；标识符、表达式与左值；作用域、链接与存储期；作用域；翻译单元和文件；链接；储存期；使块作用域变量具有静态存储期；C 的存储类别；自动变量；内层块与外层块变量同名隐藏；编译器对 C99 和 C11 的支持；寄存器变量；块作用域的静态变量；外部链接的静态变量；内部链接的静态变量；存储类别补充；多文件；储存类别说明符；储存类别和函数；存储类别的选择；随机数函数和静态变量;随机数实现原理；自动重置种子；分配内存：`malloc()`和`free()`；`calloc()`函数；ANSI C 类型限定符；`volatile`类型限定符；`restrict`类型限定符；`_Atomic`类型限定符

</div>

##### **储存类别(引入)**

- C 提供了多种**不同的模型**或**存储类别**在**内存**中存储**数据**。要理解这些**存储类别**，需要先复习一些**概念和术语**

- **概念术语复习**

  > 1、截至目前，所有的**示例程序**的**数据**都存储在**内存**中  
  > 2、从**硬件层面**来看，被存储的每个**值**都占用一定的**物理内存**，C 吧这样的**一块内存**称为**对象**。对象可以存储**一个或多个值**。一个对象可能并**未存储实际的值**，但当它**存储适当的值**时一定具有**相应的大小**(**面向对象编程**中对象指的是**类对象**，其定义包括**数据**和允许对数据进行的**操作**，但 C **不是面向对象**编程语言)  
  > 3、从**软件层面**来看，**程序**需要一种方法来**访问对象**。可以通过**声明变量**来完成，如`int entity = 3;`，该声明**创建**了一个名为**entity**的**标识符**。**标识符**是一个**名称**，这种情况下，**标识符**可以用来**指定**特定**对象的内容**，其遵循变量的**命名规则**，该例中，**标识符 entity**即是**软件**(即 C 程序)指定**硬件内存**中的对象的方式

- **标识符、表达式与左值**

  ```c
  int entity = 3;
  int *pt = &entity;
  int ranks[10];
  ```

  > 1、**变量名**不是**指定对象**的唯一途径  
  > 2、**pt**是一个**标识符**，它**指定**了一个**储存地址**的**对象**。但是，表达式`*pt`**不是标识符**，因为它**不是一个名称**，但它确实**指定**了一个**对象**，这种情况下，它与**entity**指定的**对象相同**  
  > 3、一般而言，那些**指定对象**的**表达式**被称为**左值**。所以**entity**既是**标识符**也是**左值**，`*pt`既是**表达式**也是**左值**  
  > 4、按照这个思路，`ranks + 2 * entity`既**不是标识符**(不是名称)也**不是左值**(不指定内存位置上的内容)。但是表达式`*(ranks + 2 * entity)`是一个**左值**，因为它**指定了特定内存位置的值**，即**ranks**的**第七个元素**  
  > 5、所有这些示例中，如果可以**使用左值改变对象中的值**，该**左值**就是一个**可修改的左值**  
  > 6、例如`const char *pc = "Behold";`这条声明，创建了一个**标识符为 pc**的**对象**，存储**字符串的地址**。由于可以设置**pc**重新**指向**其他字符串，所以**标识符 pc**是一个**可修改的左值**(该`const`只保证字符串**内容不被修改**)。由于`*pc`**指向**存储'B'字符的**数据对象**，所以`*pc`是一个**左值**，但**不是可修改的左值**；与此类似，因为**字符串字面量**本身**指定**了存储字符串的**对象**，所以它也是一个**左值**，但也**不是可修改的左值**

- **新概念引入**

  > 1、可以用**存储期**描述**对象**，所谓**存储期**是指**对象**在**内存**中**保留了多长时间**  
  > 2、**标识符**用于**访问对象**，可以用**作用域**和**链接**描述标识符，标识符的**作用域**和**链接**表明了**程序哪些部分可以使用它**  
  > 3、不同的**存储类别**具有不同的**存储期**、**作用域**和**链接**  
  > 4、**标识符**可以在源代码的**多文件**中**共享**、可用于**特定文件**的**任意函数**中、可仅限于**特定函数**中使用，甚至只在**函数中某部分**使用  
  > 5、**对象**可存在于程序的**执行期**，也可仅存在于它**所在函数的执行期**。对于**并发编程**，**对象**可以在**特定线程的执行期**存在

##### **作用域、链接与存储期**

- **作用域**

  - **作用域**描述程序中**可访问标识符**的**区域**。一个 C 变量的**作用域**可以是**块作用域**、**函数作用域**、**函数原型作用域**或**文件作用域**

  - **块作用域**

    ```c
    double blocky(double cleo)      // cleo的作用域开始
    {
        double partrick = 0.0;      // partrick的作用域开始
        for(int i = 0; i < 10; i++) // i的作用域开始
        {
            double q = cleo * i;    // q的作用域开始
            ...
            partrick *= q;
        }                           // i,q的作用域结束
        return patrick;
    }                               // cleo,partrick的作用域结束
    ```

    > 1、到目前为止，**示例程序**中使用的**变量**几乎都具有**块作用域**  
    > 2、**块**是用一对**花括号括起来**的**代码区域**。例如**整个函数体**是一个**块**，函数中的任意**复合语句**也是一个**块**  
    > 3、定义在**块**中的**变量**具有**块作用域**，**块作用域变量**的**可见范围**是从**定义处**到包含该定义的**块的末尾**。另外，虽然函数**形参声明**在函数的**左花括号之前**，但它们也**具有块作用域**，属于**函数体**这个**块**，同理对于一些**复合语句**也是这样(如`for()`循环)

  - **函数作用域**

    > 1、**函数作用域**仅用于`goto`**语句**的**标签**。这意味着即使**一个标签首次出现**在函数的**内层块**中，它的**作用域**也延伸至**整个函数**  
    > 2、如果在**两个块**中**使用相同的标签**会很混乱，**标签**的**函数作用域**防止了这样的事情发生

  - **函数原型作用域**

    > 1、**函数原型作用域**用于**函数原型**中的**形参名**：`int def(int mouse, double large);`，**函数原型作用域**的**范围**是从形参**定义处**到函数原型**声明结束**  
    > 2、这意味着，**编译器**在处理**函数原型**中的**形参**时，**只关注它的类型**，而**形参名**(如果有的话，因为可以省略)通常**无关紧要**。而且即使函数原型**有形参名**，也**不必**与**函数定义**中的形参名**相匹配**  
    > 3、只有在**变长数组**中，**形参名才有用**：`void def(int n, int m, arr[n][m])`，**方括号**中**必须使用**在**函数原型**中**已声明的名称**

  - **文件作用域**

    ```c
    #include <stdio.h>
    int units = 0;        // 具有文件作用域

    void def(void)
    {
        ...
    }

    int main(void)
    {
        ...
        return 0;
    }
    ```

    > 1、变量定义在**函数**的**外面**，具有**文件作用域**。具有**文件作用域**的**变量**，从**定义处**到该定义**所在文件末尾**均**可见**  
    > 2、如示例**units**变量，具有**文件作用域**，`def()`和`main()`**都可以使用它**(更准确的说，**units**具有**外部链接文件作用域**，稍后讲解)  
    > 3、由于这样的**变量可用于多个函数**，所以**文件作用域变量**也被称为**全局变量**

  - **翻译单元和文件**

    > 1、你认为的**多个文件**在**编译器**中可能**以一个文件出现**。例如，通常在**源代码**(.c 拓展名)中**包含一个或多个头文件**(.h 拓展名)，**头文件**会依次**包含其他头文件**，所以会包含**多个**单独的**物理文件**  
    > 2、但是，**C 预处理**实际上是用包含的**头文件内容**替换`#include`**指令**。所以**编译器**把**源代码文件**和**所有头文件**都看成是**一个**包含信息的**单独文件**，这个文件被称为**翻译单元**  
    > 3、描述一个具有**文件作用域**的**变量**时，它的**实际可见范围**是**整个翻译单元**。如果程序由**多个源代码文件**组成，那么该程序也将由**多个翻译单元**组成，**每个翻译单元**对应**一个源代码文件**和**它所包含的文件**

- **链接**

  - **基本概念**

    > 1、C 变量有 3 种**链接属性**：**外部链接**、**内部链接**或**无链接**  
    > 2、具有**块作用域**、**函数作用域**或**函数原型作用域**的**变量**都是**无链接变量**。这意味着这些变量**属于定义它们的块、函数或函数原型私有**  
    > 3、具有**文件作用域**的**变量**可以是**外部链接**或**内部链接**。**外部链接变量**可以在**多文件程序**中使用，**内部链接变量**只能在**一个翻译单元**中使用

  - **非正式用语的简称**

    > 1、C 标准用**内部链接的文件作用域**描述**仅限于一个翻译单元**的作用域，用**外部链接的文件作用域**描述**可延伸至其他翻译单元**的作用域，这些是**正式用语**  
    > 2、对于程序员而言这些用语太长了。因此一些程序员把**内部链接的文件作用域**简称为**文件作用域**，把**外部链接的文件作用域**简称为**全局作用域**或**程序作用域**

  - 如何知道**文件作用域变量**是**内部链接**还是**外部链接**？可以看**外部定义**是否使用了**储存类别说明符**`static`：

    ```c
    int giants = 5;             // 文件作用域，外部链接
    static int dodgers = 3;     // 文件作用域，内部链接
    /*该文件和同一程序的其他文件，都可以使用giants，但dodgers属文件私有*/
    int main(void)
    {
        ...
        return 0;
    }
    ```

- **存储期**

  - **作用域**和**链接**描述了**标识符**的**可见性**，**存储期**描述了通过这些**标识符**访问的**对象**的**生存期**。C 对象有 4 种**存储期**：**静态存储期**、**线程存储期**、**自动存储期**、**动态分配存储期**

  - **静态存储期**

    > 1、如果**对象**具有**静态存储期**，那么它在**程序执行期间一直存在**。**文件作用域变量**具有**静态存储期**  
    > 2、注意，对于**文件作用域变量**，**关键字**`static`表明其**链接**属性，而非**存储期**。所有的**文件作用域变量**都具有**静态存储期**

  - **线程存储期**

    > 1、**线程存储期**用于**并发程序**设计，**程序执行**可被分为**多个线程**。具有**线程存储期**的**对象**，从**被声明**到**线程结束**都**一直存在**  
    > 2、以**关键字**`_Thread_local`声明一个**对象**时，每个**线程**都获得该**变量**的**私有备份**

  - **自动存储期**

    > 1、**块作用域**通常都具有**自动存储期**。当程序**进入**定义这些变量的**块**时，为这些变量**分配内存**，**退出**这个**块**时，**释放**刚才分配的**内存**  
    > 2、这种做法相当于把**自动变量**占用的**内存**视为一个**可重复使用**的**工作区**或**暂存区**。例如**一个函数调用结束**时，其**变量**占用的**内存**可用于**存储下一个被调函数的变量**  
    > 3、**变长数组**稍有不同，它们的**存储期**从**声明处**到**块的末尾**，而不是从**块的开始**到**末尾**  
    > 4、我们到**目前为止**使用的**局部变量**都是**自动类别**。然而，**块作用域变量**也能具有**静态存储期**，为此需要**把变量声明在块中**并在声明前加上**关键字**`static`

  - **使块作用域变量具有静态存储期**

    ```c
    void more(int number)
    {
        int index;
        static int ct=0;
        ...
    }
    ```

    > 1、该程序中，变量**ct**由于**声明在块中**且使用`static`**关键字**，因此**ct 存储在静态内存中**，从**程序被载入**到**程序结束**期间都**一直存在**  
    > 2、注意，它的**作用域**定义在`more()`函数**块**中，只有在**执行该函数**时，程序才能使用**ct**访问它所**指向的对象**  
    > 3、但是，**该函数**可以给**其他函数**提供该**存储区**的**地址**，以便**间接访问**该**对象**，例如通过**指针形参**或**返回值**

  - **动态分配存储期**在本章后面介绍。C 使用**作用域**、**链接**和**存储期**为变量定义了**多种存储方案**。由于教程不涉及**并发程序**设计，所以不再赘述这方面的内容

##### **C 的存储类别**

- C 有 5 种**存储类别**：**自动**、**寄存器**、**静态块作用域**、**静态外部链接**、**静态内部链接**。如下表：

  |         存储类别         | 存储期 | 作用域 | 链接 | 声明方式                       |
  | :----------------------: | :----: | :----: | :--: | ------------------------------ |
  |           自动           |  自动  |   块   |  无  | 块内                           |
  |          寄存器          |  自动  |   块   |  无  | 块内，使用关键字`register`     |
  | 静态块作用域(静态无链接) |  静态  |   块   |  无  | 块内，使用关键字`static`       |
  |       静态外部链接       |  静态  |  文件  | 外部 | 所有函数外                     |
  |       静态内部链接       |  静态  |  文件  | 内部 | 所有函数外，使用关键字`static` |

- **自动变量**

  - 属于**自动存储类别**的**变量**具有**自动存储期**、**块作用域**且**无链接**，其拥有这**三者**的所有**特点**。**默认情况**下，声明在**块**或**函数头**中的**任何变量**都属于**自动存储类别**

  - `auto`**关键字**

    ```c
    int main(void)
    {
        auto int plox;
        ...
        return 0;
    }
    ```

    > 1、为了**更清楚表达**你的**意图**，可以显式使用**关键字**`auto`  
    > 2、**关键字**`auto`是**存储类别说明符**。但要注意`auto`在**C++**中用法**完全不同**

  - **内层块与外层块变量同名隐藏**

    ```c
    #include <stdio.h>

    int main(void)
    {
        int x = 30; // 原始的 x=30
        printf("outer block:%p %d\n", &x, x);
        // 定义一个单独的块
        {
            int x = 77; // 新的 x，隐藏了原始的 x
            printf("inner block:%p %d\n", &x, x);
        }
        // 离开块后，仍使用原始的 x
        printf("outer block:%p %d\n", &x, x);
        while (x++ < 33) // 原始的 x
        {
            int x = 100; // 新的 x，隐藏了原始的 x
            x++;
            printf("while loop :%p %d\n", &x, x);
        }
        printf("outer block:%p %d\n", &x, x);
        return 0;
    }
    ```

    ```
    outer block:000000000061FE1C 30
    inner block:000000000061FE18 77
    outer block:000000000061FE1C 30
    while loop :000000000061FE14 101
    while loop :000000000061FE14 101
    while loop :000000000061FE14 101
    outer block:000000000061FE1C 34
    ```

    > 1、如果**内层块**与**外层块**变量**同名**，**内层块**将会**隐藏外层块的定义**，但当**离开内层块**后，**外层块变量**的**作用域**又回到了**原来的作用域**  
    > 2、程序中，较难理解的是`while()`循环部分。`while()`循环的**条件**内使用的**x**是**原始的 x**，其每次**先参与**`while`的**判断**，再**自增 1**(因此参与判断的 x 的值分别为 30、31、32、33，当 x=33 时循环中断，但由于`x++`所以 x 仍然自增 1)。`while()`循环的**内部**，**每次**执行循环都会创建一个**新的 x=100**(此时进入块内，与原始的 x 已无关系，原始 x 已被隐藏)，由于**块作用域**每次循环结束就**销毁新建的 x**，因此实际创建了**三个 x**，又由于**自动存储期**每次**创建的 x**会**复用**前面**销毁的 x 的地址**，所以**三次输出**都是**101**且**地址相同**  
    > 3、我们的**编译器**在**创建**`while()`循环体中的**x**时，并**未复用**前一个**块**(即程序中单独的那对花括号)**销毁的 x 的地址**，有的编译器会这样做(则`while`的**x**复用前面`FE18`的地址)

  - **没有花括号的块**

    > 1、前面提到一个**C99**特性：作为**循环**或`if`**语句**的一部分，即使**不使用花括号**，**也是一个块**  
    > 2、更完整的说，**整个循环**是它**所在块**的**子块**，**循环体**是整个**循环块**的**子块**。相似的，`if`**语句**是一个**块**，其相关联的**子语句**是`if`**语句**的**子块**

  - **编译器对 C99 和 C11 的支持**

    > 1、有些**编译器**并**不支持 C99/C11**的这些**作用域规则**(如 Microsoft Visual Stutio 2012)  
    > 2、有些**编译器**会提供**激活这些规则**的选项，如**gcc**默认**支持**了**部分 C99 特性**，但要用`-std=c99`选项激活**其他特性**，命令行输出`gcc -std=c99 文件名`激活  
    > 3、与此类似，**gcc**或**clang**都要使用`-std=c1x`或`-std=c11`选项，才支持**C11 特性**

- **寄存器变量**

  > 1、**变量**通常存储在**内存**中。但**如果幸运的话**，**寄存器变量**将被存储在**CPU 的寄存器**中，或者概括地说，存储在**最快的可用内存**中。与**普通变量**相比，**访问**和**处理**这些变量的**速度更快**  
  > 2、由于**寄存器变量**存储在**寄存器**中，而非**内存**中，所以**无法获取**寄存器变量的**地址**  
  > 3、绝大多数方面，**寄存器变量**和**自动变量**一样(块作用域、无链接、自动存储期)。使用**存储类别说明符**`register`即可**声明寄存器变量**，如`register int quick;`  
  > 4、前面之所以说“**如果幸运的话**”，是因为声明变量为`register`与**直接命令**相比更像是一种**请求**。**编译器**会根据实际**寄存器**或**最快可用内存**的**数量**衡量你的请求，或者**直接忽略**。如果**忽略**，**寄存器变量**就变成**普通变量**，但仍然**不能**对该变量使用**地址运算符**

- **块作用域的静态变量**

  - **静态变量**中**静态**的意思是该**变量**在**内存**中**原地不动**，并**不是值不变**。具有**文件作用域**的变量**自动具有**且**必须**是**静态存储期**

  - 前面提到过，可以创建具有**静态存储期**、**块作用域**的**局部变量**。**这些变量**和**自动变量**具有**相同**的**作用域**，但是程序**离开**它们**所在的函数**后，这些变量**不会消失**。也就是说，这些变量具有**块作用域**、**无链接**、**静态存储期**

  - `static`**关键字**

    ```c
    #include <stdio.h>

    void def(void)
    {
        int fade = 1;
        static int stay = 1; // 块作用域的静态变量，具有静态存储期
        printf("fade = %d, stay = %d\n", fade++, stay++);
    }

    int main(void)
    {
        for (int i = 1; i <= 3; i++)
        {
            printf("%d: ", i);
            def();
        }
        return 0;
    }
    ```

    ```
    1: fade = 1, stay = 1
    2: fade = 1, stay = 2
    3: fade = 1, stay = 3
    ```

    > 1、在**块**中，以**存储类别说明符**`static`以声明**块作用域的静态变量**  
    > 2、从程序的运行结果可以看出，**静态变量 stay**保存了它**递增 1**后的值，但**fade**每次都是**1**。这表明了**初始化的不同**：每次调用`def()`都会**初始化 fade**，但**stay**只在编译时**被初始化一次**  
    > 3、不能在**函数形参**中使用`static`，如`int wontwork(static int flu);`

- **外部链接的静态变量**

  - **外部链接的静态变量**具有**块作用域**、**外部链接**、**静态存储期**。该类别有时称为**外部存储类别**，属于该类别的**变量**称为**外部变量**

  - **外部存储类别的使用**

    ```c
    #include <stdio.h>

    int Errupt;       // 外部定义的变量
    double Up[100];   // 外部定义的数组
    extern char Coal; // 如果只是本文件的声明，extern可省略，如果Coal被定义在另一个源代码文件中，则必须需要extern声明

    int main(void)
    {
        extern int Errupt;  // 可选的声明
        extern double Up[]; // 可选的声明
        return 0;
    }
    ```

    > 1、把**变量**的**定义性声明**放在所有**函数外**便创建了**外部变量**  
    > 2、为了指出**该函数使用**了**外部变量**，可以在**函数内**使用关键字`extern`**再次声明**。如果一个**源代码文件**使用的**外部变量**被**定义**在**另一个源代码文件**中，则必须用`extern`关键字声明该变量  
    > 3、注意示例中，`main()`中声明**Up 数组**时不用指明**数组大小**，因为前面**外部变量**第一次声明已经提供了**数组大小信息**。此外`main()`中的这**两条声明**都**可以省略**，使用`extern`**再次声明**只是为了**说明告知**`main()`要使用这**两个变量**  
    > 4、如果`main()`中的**两条声明**都去除`extern`**关键字**(如`int Errupt;`)会怎样？这相当于在`main()`中**创建了**一个**自动变量**，它是一个**独立**的**局部变量**，**与原来的外部变量 Errupt 不同**。此时原先的**外部变量仍然存在**，只是在**块**内(即`main()`中)执行语句时，**块作用域**的变量(即`main()`中声明的 Errupt)会**隐藏**原先**文件作用域**(即外部变量 Errupt)的**同名变量**。因此如果不得已要使用**与外部变量同名**的**局部变量**，最好在**局部变量声明**时显式使用`auto`**存储类别说明符**，以清楚告知他人你的这种意图

- **内部链接的静态变量**

  - **内部链接的静态变量**具有**静态存储期**、**文件作用域**、**内部链接**

  - `static`**关键字**

    ```c
    static int svil = 1;  // 静态变量，内部链接
    int main(void)
    {
        ...
        return 0;
    }
    ```

    > 1、在**所有函数外部**(这点与外部变量相同)，用**存储类别说明符**`static`定义的**变量**具有这种存储类别  
    > 2、**普通的外部变量**可用于**同一程序**中**任意文件**的**任意函数**，但是**内部链接的静态变量**只能用于**同一个文件**的**任意函数**  
    > 3、同样可以使用**储存类别说明符**`extern`，在**函数中**再次**重复声明**任何具有**文件作用域**的变量。这样的声明**不会改变其链接属性**

##### **存储类别补充**

- **多文件**

  - 只有当**程序**由**多个翻译单元**组成时，才体现**区别内部链接**和**外部链接**的重要性

  - **C 的变量共享**

    > 1、复杂的 C 程序通常由**多个**单独的**源代码文件**组成。有时，这些文件可能要**共享**一个**外部变量**。C 通过在**一个文件**中进行**定义式声明**，然后在**其他文件**中进行**引用式声明**来实现共享  
    > 2、也就是说，除了一个**定义式声明**外，**其他声明**都要使用`extern`**关键字**，而且，只有**定义式声明**才能**初始化变量**  
    > 3、如果**外部变量**定义在**一个文件**里，**其他文件**在使用它前必须先用`extern`**声明它**。也就是说，在文件中对**外部变量**进行**定义式声明**但是单方面**允许其他文件使用**，**其他文件**在用`extern`声明前**不能直接使用**

- **储存类别说明符**

  - C 语言共有**6 个关键字**作为**存储类别说明符**，分别是`auto`、`register`、`static`、`extern`、`_Thread_local`、`typedef`

  - **存储类别说明符**

    > 1、`typedef`与任何**内存存储**无关，把它归为此类有一些**语法上的原因**。尤其是，在绝大多数情况下，**不能**在**声明**中**使用多个存储类别说明符**，所以这意味着不能使用**多个存储类别说明符**作为`typedef`的一部分  
    > 2、`_Thread_local`是**唯一例外**，其可以和`static`或`extern`**一起使用**  
    > 3、`auto`表明**变量**是**自动存储期**，只能用于**块作用域**的**变量声明**中。由于**块**中的**变量**本就具有**自动存储期**，显式使用`auto`大多情况是为了**明确表达**要使用**与外部变量同名**的**局部变量**的意图  
    > 4、`register`也只用于**块作用域**的变量，它把变量归为**寄存器存储类别**，请求**最快速度访问**该变量，同时还**保护变量地址不被获取**  
    > 5、`static`说明符创建的对象具有**静态存储期**。**载入程序时创建对象**，**程序结束对象消失**  
    > 6、`extern`表明声明的变量**定义在别处**

- **储存类别和函数**

  - **函数**也有**存储类别**，可以是**外部函数**(默认)或**静态函数**。此外**C99**新增了第三种类别——**内联函数**，将在 16 章介绍

  - **示例程序**

    ```c
    double gamma(double);   // 该函数默认为外部函数
    static double beta(int, int);
    extern double delta(double, int);
    ```

    > 1、**外部函数**可以被**其他文件**的函数**访问**，**静态函数**只能用于**其定义所在的文件**  
    > 2、在**同一个程序**中，**其他文件**的函数**可以调用**`gamma()`和`delta()`，但**不能调用**`bate()`，因为以`static`**存储类别说明符**创建的函数属于**特定模块私有**  
    > 3、这样做**避免了名称冲突**的问题，由于`beta()`**受限于**它所在的文件，所以**其他文件**中可以使用**与之同名**的函数  
    > 4、通常的做法是：使用`extern`**声明**定义在**其他文件**中的函数。这么做是为了**表明**当前文件中的使用的**函数被定义在别处**。除非使用`static`关键字，否则一般函数声明都**默认为**`extern`

- **存储类别的选择**

  - 对于**使用哪种存储类别**的回答，大多数是**自动存储类别**，要知道**默认类别**就是**自动存储类别**

  - 你可能会认为**外部存储类别**很不错，把**所有变量**设置成**外部变量**，就不需要**参数**和**指针**在函数间**传递信息**了。然而，如果这样做，很可能**A 函数**会**违背你的意图**，私自修改**B 函数**要使用的变量。无数程序员的**经验表明**，随意使用**外部存储类别**的变量导致的**后果**会**远远超过**它带来的**便利**

  - **保护性程序设计**的黄金法则是：“**按需知道**”原则。尽量在**函数内部**解决**该函数的任务**，**只共享**那些**需要共享的变量**。因此，在**使用某类别**前，考虑一下**是否有必要**这样做

##### **随机数函数和静态变量**

- C 语言的**随机数函数**是一个使用**内部链接**的**静态变量函数**。**ANSI C**库提供了一个`rand()`函数**生成随机数**

- 生成随机数有**多种算法**，ANSI C 允许 C 实现针对**特定机器**使用**最佳算法**。然而，ANSI C 标准还提供了一个**可移植**的**标准算法**，在**不同系统**生成**相同的随机数**。实际上，`rand()`是**伪随机数**生成器，意思是**可预测**生成数字的**实际序列**，但是，数字在其**取值范围**内**均匀分布**

- **实现原理分析**

  - **随机函数**

    - 为了看清**程序内部情况**，我们使用**可移植**的**ANSI 版本**(标准版本)，而不是**编译器内置**的`rand()`函数(实际使用可以直接使用编译器内置版本，只是生成的**公式可能不同**)

    - **随机函数示例**(多文件编译)

      ```c
      /* rand0.c —— 随机数函数文件 */

      static unsigned long int next = 1; // 种子

      unsigned int rand0(void)
      {
          // 生成伪随机数的公式
          next = next * 1103515245 + 12345; // 更新种子的公式
          return (unsigned int)(next / 65536) % 32768;  // 返回随机数的公式，(unsigned int)为强制类型转换
      }
      ```

      ```c
      /* r_drive0.c 主运行文件，与 rand0.c 函数文件一起编译 */

      #include <stdio.h>

      extern unsigned int rand0(void); // 声明跨文件调用外部函数

      int main(void)
      {
          for (int i = 0; i < 5; i++)
          {
              printf("%d\n", rand0());  // 输出随机数
          }
          return 0;
      }
      ```

      ```
      16838
      5758
      10113
      17515
      31051
      ```

    - **示例解析**

      > 1、**可移植版本**的**方案**开始于一个“**种子**”**数字**。该函数使用该种子**生成新的数**，这个**新数**又成为**新的种子**。然后**新的种子**可用于生成**更新的种子**，以此类推。因此**这个种子**需要是一个**静态变量**，**保持时刻存在**并记录种子**以便函数访问**  
      > 2、如示例`rand0.c`函数文件中，**seed**就是**种子**，其在**ANSI 方案**中默认被**初始化为 1**。**生成随机数**的**函数**中，先**利用公式**和**seed 自身数值**来**更新 seed 的值**(即生成新种子)，然后`return`**利用公式**返回一个**按照公式生成**的**伪随机数**，`return`中`%32768`说明返回的数一定在**0~32767**之间  
      > 3、`r_drive0.c`主运行文件和`rand0.c`**一起编译并运行**。输出证明**调用正常**，结果确实生成了**伪随机数**。但如果**多运行几次**，会发现每次生成的**伪随机数**都是按照**相同规律出现**的(即生成的**随机数队列**是一样的，都是 16838、5758、10113...)。这是因为，每次**程序开始运行时**，随机数生成都**开始于种子 1**  
      > 4、为了解决这一问题，我们需要想种办法让**每次程序开始时**的**种子不同**，即需要一种办法**重置种子**

  - **重置种子**

    - 我们可以引入**另一个函数**`srand1()`**重置种子**来解决**随机数队列相同**的问题(`srand1()`相当于 C 库的`srand()`函数)

    - 关键在于，要让**随机数函数**中的**next 变量**，成为**只供**`rand0()`和`srand1()`**访问**的**内部链接静态变量**(“按需知道”原则)

    - **重置种子示例**(多文件编译)

      ```c
      /* rand0.c 函数文件 */

      static unsigned long int next = 1; // 种子

      unsigned int rand0(void)
      {
          // 生成伪随机数的公式
          next = next * 1103515245 + 12345; // 更新种子的公式
          return (unsigned int)(next / 65536) % 32768;  // 返回随机数的公式，(unsigned int)为强制类型转换
      }

      // 添加 srand1() 函数
      void srand1(unsigned int seed)
      {
          next = seed;  // 重置种子
      }
      ```

      ```c
      /* r_drive0.c 主运行文件，与 rand0.c 函数文件一起编译 */

      #include <stdio.h>
      #include <stdlib.h>

      extern unsigned int rand0(void); // 声明跨文件调用外部函数
      extern int rand1(void);          // 声明跨文件调用外部函数

      int main(void)
      {
          unsigned seed;
          printf("输入你想要的随机数的种子\n");
          // while判断输入是否有效合法
          while (scanf("%u", &seed) == 1)
          {
              srand1(seed); // 重置种子
              for (int i = 1; i <= 5; i++)
                  printf("%d\n", rand0()); // 输出随机数
              printf("输入您的下一个种子，或输入q退出\n");
          }
          return 0;
      }
      ```

    - **示例解析**

      > 1、由于**next**具有**内部链接**的**文件作用域静态变量**，意味着`rand0()`和`srand1()`**都能使用**它，但**其他文件**的函数**无法访问**它。这符合了程序设计“**按需知道**”的原则  
      > 2、现在的示例程序中，由于**每次运行**执行了`srand1()`**重置种子**，所以**种子**都是**输入的数字**，因此**随机数函数**的**随机性更强**了  
      > 3、但这样**重置种子**还是**比较麻烦**，有没有什么办法能**自动重置种子**，答案是有的

- **项目中使用随机数(自动重置种子)**

  - 在**项目中**使用随机数，不需要再编写`rand0.c`**函数文件**了，前面只是为了**方便看清内部的操作**。项目中，可以直接使用**编译器提供**的版本：`rand()`**函数**和`srand()`**函数**，它们被**集成在**`stdlib.h`**头文件**中，与前面`rand0.c`中定义的函数**使用方法相同**

  - 此外，在项目中很多时候需要程序**自动重置种子**以**生成随机数**，思路如下

    > 1、如果**C 实现**允许访问一些**可变的量**(如，系统时钟)，可以用**这些值**来**初始化种子**  
    > 2、例如**ANSI C**有一个`time()`**函数**，**集成在**`time.h`**头文件**中，可以**返回系统时间**。该返回值是一个**可运算类型**，且**随时间变化而变化**，便很适合做**自动重置种子**的**值**  
    > 3、`time()`的**返回类型**是`time_t`，这与`srand()`接受的`unsigned int`**类型不符**，但我们可以使用**强制类型转换**(注意别忘了`time.h`头文件)：`srand( (unsigned int)time(0) );`  
    > 4、一般而言，`time()`接受的**参数**是一个`time_t`**类型对象**的**地址**，而**时间值**就存储在**传入的地址**上(将时间值存入传入的地址)。当然也可以传入**空指针 0**作为**参数**，这样只不过**仅能通过返回值机制**来**提取值**

##### **分配内存：malloc()和 free()**

- 我们前面讨论的**存储类别**有一个**共同之处**：在**确定**用哪种**存储类别**后，根据已制定好的**内存管理规则**，自动选择**作用域**和**存储期**。然而，还有**更灵活**的选择，即用**库函数**来**分配**和**管理内存**

- `malloc()`**函数**

  - C 可以在**程序运行时**分配**更多的内存**，主要的工具是`malloc()`函数，其被包含在`stdlib.h`中

  - **函数使用**

    > 1、`malloc()`函数用于**主动分配内存**。其接受**一个参数**，表示所需的**内存字节数**，返回**动态分配内存块**的**首字节地址**  
    > 2、`malloc()`函数会找到合适的**空闲内存块**，这样的内存是**匿名**的。也就是说，该函数可以**分配内存**，但**不会为其赋名**  
    > 3、可以把返回的**首字节地址**赋值给一个**指针变量**，并使用指针**访问**这块内存

  - **函数的返回类型**

    > 1、由于**char**表示**1 字节**，所以曾经`malloc()`的**返回类型**通常被定义为**指向 char 的指针**  
    > 2、然而从**ANSI C**标准起，C 使用一个**新的类型**——**指向 void 的指针**。该类型**相当于**一个**通用指针**，将这种类型**赋值**给**任意其他类型的指针**，完全**不用考虑类型匹配**的问题  
    > 3、`malloc()`函数还可用于返回**指向数组的指针**、**指向结构的指针**等，所以通常**该函数**的**返回值**会被**强制转换**为**对应匹配的类型**。在**ANSI C**中，应该坚持使用**强制类型转换**以**提高代码可读性**(可选，因为第 2 条的说明)  
    > 4、如果`malloc()`**分配内存失败**，将返回**空指针**

  - **使用**`malloc()`**创建数组**

    ```c
    #include <stdlib.h> // 注意不要忘了头文件

    double *ptd;
    ptd = (double *)malloc(30 * sizeof(double));
    ```

    > 1、要使用`malloc()`**创建一个数组**，除了要用`malloc()`**请求一块内存**，还需要一个**指针**记录这块内存的**位置**  
    > 2、示例中，`sizeof(double)`表示**一个 double 类型**所需的**内存大小**，`30 * sizeof(double)`表示**需要 30 个 double 的大小**(即可以看做 30 个元素)  
    > 3、`(double *)`为**强制类型转换**，仅用于**提高代码可读性**，因为`malloc()`**返回值**是**指向 void 的指针**，可以**不用考虑类型匹配**问题  
    > 4、注意，**指针 ptd**被声明**指向一个 double 类型**，而**不是指向内含 30 个 double 的块**。回忆一下，**数组名**是该数组**首元素地址**，因此如果让**ptd**指向这个**块的首元素**，就能像**使用数组名一样**使用它。也就是说，可以使用表达式`ptd[0]`、`ptd[1]`分别访问该**块**的**首元素**和**第二个元素**，以此类推

  - `malloc()`**创建的数组的特点**

    > 1、`malloc()`**创建的数组**和曾经学过的**变长数组**，都可以**创建动态数组**  
    > 2、**动态数组**与**普通数组**的不同在于，前者可以在**运行时**再**选择数组的大小**和**分配内存**(详细介绍见**变长数组**)  
    > 3、此外**C99**前不允许`double item[n];`，因为**n 不允许是变量**，但可以`ptd = malloc(n * sizeof(double));`，因此`malloc()`**创建数组**比**变长数组**要**更灵活**

- `free()`**函数**

  - 通常，`malloc()`要与`free()`**配套使用**，`free()`可以**释放**之前`malloc()`**分配的内存**，其也被包含在`stdlib.h`头文件中

  - **函数使用**

    > 1、`free()`函数用于**释放**`malloc()`**分配的内存**，其接受**一个参数**，即之前`malloc()`**返回的地址**  
    > 2、因此，**动态分配内存**的**存储期**就是从调用`malloc()`**分配内存开始**，到调用`free()`**释放内存为止**。试想`malloc()`和`free()`管理着一个**内存池**，每次调用`malloc()`便**分配给程序使用**，每次调用`free()`便**将内存归还**给**内存池**，以便**重复使用**这些内存  
    > 3、`free()`只能接受`malloc()`**分配的内存**的**地址**，不能释放**通过其他方式**(如：声明)**分配**的**内存**

  - `free()`**的重要性**

    > 1、**静态内存的数量**在编译时是**固定**的，在程序运行期间也**不会改变**。**自动变量使用的内存数量**在程序执行期间**自动增加或减少**。但是**动态分配的内存**则**只会增加**，除非用`free()`进行**释放**  
    > 2、假设一个程序需要**大量调用**`malloc()`**分配内存**，但**没有使用**`free()`**释放内存**，就可能在运行时**耗尽所有可分配的内存**导致程序出错  
    > 3、这类为题称为**内存泄漏**，因此需要**及时使用**`free()`**释放内存**避免这类问题发生

- `calloc()`**函数**

  - 分配内存还可以使用`calloc()`**函数**，其用法与`malloc()`**大致相同**

  - **函数使用**

    ```c
    #include <stdlib.h>

    long *newmem;
    newmem = (long *) calloc(100, sizeof(long));
    ```

    > 1、和`malloc()`类似，`calloc()`在**ANSI C**前**返回指向 char 的指针**，在**ANSI C**后**返回指向 void 的指针**  
    > 2、`calloc()`接受**两个参数**(**ANSI C**规定是`size_t`类型)，**第一个参数**是所需的**存储单元数量**，**第二个参数**是**存储单元大小**(以字节为单位)  
    > 3、`calloc()`还有一个**特性**，它会把**块**中**所有位**都**设置为 0**。此外，`free()`也可以释放`calloc()`分配的内存

##### **ANSI C 类型限定符**

- **引入**

  > 1、我们通常用**类型**和**存储类别**来描述一个变量。**C90**还**新增**了两个属性：**恒常性**和**易变性**，可以分别用**关键字**`const`和`volatile`来声明，以这两个**关键字**创建的**类型**是**限定类型**  
  > 2、**C99**标准**新增**了**第三个限定符**：`restrict`，用于提高编译器优化  
  > 3、**C11**标准**新增**了**第四个限定符**：`_Atomic`。**C11**提供了一个**可选库**，由`stdatomic.h`管理，以支持**并发程序设计**，而且`_Atomic`是**可选支持项**  
  > 4、**C99**为**类型限定符**新增了一个**属性**：它们现在是**幂等**的。这个属性的意思是，可以在**一条声明**中**多次使用**同一个限定符，**多余**的限定符将被**忽略**

- `const`**类型限定符**在之前**第 4 章**和**第 10 章**已经详细介绍过，在此略过

- `volatile`**类型限定符**

  - **作用及用途**

    > 1、`volatile`**类型限定符**告知计算机，**代理**(而不是该变量所在的程序)**可以改变**该变量的**值**  
    > 2、通常，它被用于**硬件地址**以及**其他程序**或**同时运行的线程**中**共享数据**。例如，一个**地址**上可能存储着当前的**时钟时间**，无论程序做什么，**地址**上的**值**都**随时间变化而改变**。或者一个**地址**用于接受**另一台计算机**传入的**信息**

  - **使用语法**

    ```c
    /* volatile语法与const一样 */
    volatile int loc1;    // loc1是一个易变的位置
    volatile int * ploc;  // ploc是一个指向易变位置的指针
    ```

  - **为什么列入 ANSI 标准**

    ```c
    val1 = x;
    /*
    省略中间一些不使用x的代码
    */
    val2 = x;
    ```

    > 1、开始可能认为`volatile`是个**可有可无**的概念，为何**ANSI**要将其**放入标准**？是因为它**涉及编译器的优化**  
    > 2、**智能的**(进行优化的)**编译器**会注意到以上代码**使用了 2 次 x**，但并**未改变**它的**值**，于是**编译器**把**x 的值**临时存储在**寄存器**中，然后再**val2**使用**x**时，才从**寄存器中**(而非原始内存位置上)**读取 x 的值**，以**节约时间**。这个过程被称为**高速缓存**  
    > 3、通常**高速缓存**是个不错的优化方案，但如果一些**其他代理**在以上两条语句间**改变了 x 的值**，就**不能这样优化**了。如果没有`volatile`**关键字**，**编译器**就**不知道**这种事情**是否发生**，因此为了**安全起见**，编译器**不会进行高速缓存**。这便是**ANSI 前**的情况  
    > 4、现在，如果声明中**没有**`volatile`**关键字**，编译器会**假定变量的值使用过程中不变**，然后再**尝试优化代码**

- `restrict`**类型限定符**

  - **作用及用途**

    > 1、`restrict`**关键字**允许编译器**优化某部分代码**以更好地**支持运算**  
    > 2、它**只能用于指针**，表明**该指针**是**访问数据对象**的**唯一且初始**的方式

  - **深入理解优化部分代码**

    ```c
    int ar[10];
    int *restrict restar = (int *)malloc(10 * sizeof(int));
    int *par = ar;
    /*-----------------------------------------------------*/
    for (int n = 0; n < 10; n++)
    {
        par[n] += 5;
        restar[n] += 5;
        ar[n] += 2;
        par[n] += 3;
        restar[n] += 3;
    }
    ```

    > 1、这里，指针**restar**是访问`malloc()`**所分配内存**的**唯一且初始**的方式，因此可以用`restrict`**限定它**；而指针**par**既不是**访问 ar 数组中数据**的**初始方式**，也不是**唯一方式**，所以不用将其设置为`restrict`  
    > 2、由于之前**声明了 restar**为`restrict`，**编译器**可以把`for()`中涉及**restar**的**两条语句**简化替换为`restar[n] += 8;`(原本是先+5，后+3)。但是如果将`for()`中与**par**相关的**两条语句**简化替换为`par[n] += 8;`就**不可以**，因为**par**在**两次访问相同数据**之间，**用 ar 改变过**该数据的**值**  
    > 3、在本例中，如果**未使用**`restrict`，**编译器**就必须**假设最坏的情况**(即两次使用指针之间，其他标识符可能更改了数据)。如果**使用了**`restrict`，**编译器**则可以选择捷径**优化计算**

- `_Atomic`**类型限定符**

  - **简介概述**

    > 1、**并发程序设计**把**程序执行**分为**可以同时执行**的**多个线程**。这给程序设计带来了**新的挑战**，包括**如何管理并访问相同数据的不同线程**  
    > 2、**C11**通过包含**可选的头文件**`stdatomic.h`和`threads.h`**提供了**一些**可选的**(不是必须实现的)**管理方法**  
    > 3、值得注意的是，要通过各种**宏函数**来访问**原子类型**。当一个**线程**对一个**原子类型的对象**执行**原子操作**时，**其他线程不能访问**该对象，如下示例

  - **示例程序**

    ```c
    #include <stdatomic.h>

    int hogs;                 // 普通声明
    hogs = 12;                // 普通赋值
    /*---------------可以替换为---------------*/
    _Atomic int hogs;         // hogs是一个原子类型的变量
    atomic_store(&hogs, 12);  // stdatomic.h中的宏
    ```

    > 1、这里，在**hogs**中存储的**12**是一个**原子过程**，**其他线程不能访问 hogs**  
    > 2、编写这一代码的前提，是编译器要支持这一新特性

---

#### **文件输入/输出**

---

<div class="success">

> **章节概要**：与文件进行通信；文本模式和二进制模式；I/O 的级别；标准文件；标准 I/O；`fopen()`函数；文件指针；`getc()`和`putc()`函数；`fclose()`函数；指向标准文件的指针；简单的文件压缩程序；文件 I/O；`fprintf()`、`fscanf()`函数和`rewind()`函数；`fgets()`和`fputs()`函数；随机访问：`fseek()`和`stell()`；`fgetpos()`和`fsetpos()`函数；其他标准 I/O 函数；`ungetc()`函数；`fflush()`函数；`setvbuf()`函数；二进制 I/O：`fread()`和`fwrite()`；`feof()`和`ferror()`函数

</div>

##### **与文件进行通信**

- 有时，需要**程序**从**文件**中**读取信息**或**把信息写入文件**。这种**程序与文件交互**的形式就是**文件重定向**(第 8 章介绍过)。这种方法很简单，但是**有一定限制**，尤其对于**交互性程序**。C 提供了更强大的**文件通信方法**，可以**在程序中打开文件**，然后使用特殊的**I/O 函数**与文件交互。在研究这些方法之前，先简要介绍下**文件的性质**

- **文件是什么**

  > 1、**文件**通常是在**磁盘或固态硬盘**上的一段**已命名的存储区**  
  > 2、对我们而言，`stdio.h`就是一个**文件**的**名称**，该文件中包含一些**有用的信息**。对于**操作系统**而言，文件**更复杂**一些  
  > 3、例如，**大型文件**会被**分开存储**，或者包含一些**额外的数据**，方便**操作系统**确定**文件的种类**。然而这些都是**操作系统**所关心的，程序员关心的是**C 程序如何处理文件**  
  > 4、C 把**文件**看做是**一系列连续的字节**，**每个字节**都能被**单独读取**。这与**UNIX**环境中的**文件结构**相对应。由于**其他环境**中可能**无法完全对应**这个模型，C 提供**两种文件模式**：**文本模式**和**二进制模式**

- **文本模式和二进制模式**

  - 首先，要区分**文本内容**与**二进制内容**、**文本文件格式**和**二进制文件格式**以及文件的**文本模式**和**二进制模式**

  - **文本与二进制的文件格式和内容**

    > 1、**所有文件**的**内容**都以**二进制形式**(0 或 1)**存储**  
    > 2、但是，如果**文件**最初使用**二进制编码的字符**(如 ASCII 或 Unicode)**表示文本**，该文件就是**文本文件**，其中包含**文本内容**  
    > 3、如果文件中的**二进制值**表示**机器语言代码**、**数值数据**、**图片**或**音乐编码**等，该文件就是**二进制文件**，其中包含**二进制内容**

  - **文本与二进制模式**

    > 1、由于各个**操作系统**对**文件**的**识别与管理方式**不同，为了规范**文本文件**的处理，C 提供**两种访问文件的途径**：**二进制模式**和**文本模式**  
    > 2、在**二进制模式**中，程序可以**访问**文件的**每个字节**。而在**文本模式**中，程序**所见的内容**和文件的**实际内容不同**  
    > 3、程序以**文本模式**读取文件时，把**本地环境**表示的**行末尾**或**文件结尾**映射为**C 模式**。例如 C 的**文本模式**在**MS-DOS**平台，**读取**文件时，会把`\r\n`(MS-DOS 中表示的行末尾)转换成`\n`，**写入**文件时，恰好与此**相反**  
    > 4、虽然 C 提供了**二进制模式**和**文本模式**，但这两种模式的**实现可以相同**。因为**UNIX**只使用一种文件格式，这两种模式对**UNIX**实现**完全相同**，对**Linux**也是如此

- **I/O 的级别**

  > 1、除了选择文件的**模式**，大多数情况下，还可以选择**I/O**的**两个级别**(即处理文件访问的两个级别)  
  > 2、**底层 I/O**使用**操作系统**提供的**基本 I/O 服务**，**标准高级 I/O**使用**C 库**的**标准包**和`stdio.h`**头文件定义**  
  > 3、因为**无法保证**所有的**操作系统**都使用**相同的底层 I/O 模型**，C 标准只支持**标准 I/O 包**  
  > 4、有些实现会提供**底层库**，但是 C 标准建立了**可移植的 I/O 模型**，我们主要讨论这些**I/O**

- **标准文件**

  > 1、C 程序会自动打开**3 个文件**，它们被称为**标准输入**、**标准输出**、**标准错误输出**  
  > 2、在**默认情况**下，**标准输入**是系统的**普通输入设备**，通常为**键盘**；**标准输出**和**标准错误输出**是系统的**普通输出设备**，通常为**显示屏**  
  > 3、通常，**标准输入**为程序**提供输入**，它是`getchar()`和`scanf()`使用的文件；程序通常**输出**到**标准输出**，它是`putchar()`、`puts()`和`printf()`使用的文件  
  > 4、**第 8 章**提到的**重定向**，便是将**其他文件**视为**标准输入**和**标准输出**，但并不会重定向**标准错误输出**。这样很好，否则只能打开文件才能看到错误信息了

##### **标准 I/O**

- **标准 I/O 的优点**

  > 1、与**底层 I/O**相比，**标准 I/O 包**除了**可移植**以外，还有**两个好处**  
  > 2、第一，**标准 I/O**有许多专门的**函数**简化了**处理不同 I/O**的问题。例如`printf()`把**不同形式**的数据转换成与**终端**相适应的**字符串输出**  
  > 3、第二，**输入和输出**都是**缓冲**的。也就是说，一次转移**一大块信息**而不是**一字节信息**(通常至少 512 字节)。例如程序**读取文件**时，**一块数据**被**拷贝**到**缓存区**，这种**缓冲**极大地提高了**数据传输速率**

- **示例程序**

  ```c
  /*注意本程序使用了命令行参数，需要使用命令行运行并传入参数*/
  #include <stdio.h>
  #include <stdlib.h> // 提供exit()的原型

  // 使用命令行参数
  int main(int argc, char *argv[])
  {
      int ch;
      FILE *fp; // 文件指针
      unsigned long ct = 0;
      // 判断命令行参数是否成功读取
      if (argc != 2)
      {
          // 如果读取有误输出提示语并退出
          printf("Usage: %s filename\n", argv[0]);
          exit(EXIT_FAILURE);
      }
      // 判断文件是否成功打开
      if ((fp = fopen(argv[1], "r")) == NULL)
      {
          printf("Can't open %s\n", argv[1]);
          exit(EXIT_FAILURE);
      }
      // 将文件内容打印到屏幕并记录文件的字符数
      while ((ch = getc(fp)) != EOF)
      {
          putc(ch, stdout); // 等效于putchar(ch)
          ct++;
      }
      fclose(fp); // 关闭文件
      printf("\n%d", ct);
      return 0;
  }
  ```

- **fopen()函数**

  - 程序可以使用`fopen()`**打开文件**，其声明在`stdio.h`**头文件**中

  - `fopen()`的**第一个参数**是**待打开的文件名称**，更准确的说，是一个**包含该文件名**的**字符串地址**。**第二个参数**是**一个字符串**，用于指定**打开文件的模式**

  - `fopen()`**的模式字符串**

    |                     模式字符串                     | 含义                                                                                                                               |
    | :------------------------------------------------: | ---------------------------------------------------------------------------------------------------------------------------------- |
    |                        "r"                         | 以读模式打开文件                                                                                                                   |
    |                        "w"                         | 以写模式打开文件，将现有文件的长度截为 0，如果文件不存在，则创建一个新文件                                                         |
    |                        "a"                         | 以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件                                                         |
    |                        "r+"                        | 以更新模式打开文件(即可以读写文件)                                                                                                 |
    |                        "w+"                        | 以更新模式打开文件(即可以读写文件)，将现有文件的长度截为 0，如果文件不存在，则创建一个新文件                                       |
    |                        "a+"                        | 以更新模式打开文件(即可以读写文件)，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件。可以读整个文件，但只能从末尾添加内容 |
    | "rb","wb","ab","rb+","r+b","wb+","w+b","ab+","a+b" | 与上一个模式类似，但是以二进制模式而不是文本模式打开文件                                                                           |
    |           "wx","wbx","w+x","wb+x","w+bx"           | (C11)类似非 x 模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败                                                         |

    > 1、像**UNIX**和**Linux**这样**只有一种文件类型**的系统，**带 b 字母**的模式和**不带 b 字母**的模式**相同**  
    > 2、**C11**新增了**带 x 字母**的**写模式**，与**以前的写模式**相比**具有更多特性**。第一，如果以**传统的写模式**打开一个现有文件，`fopen()`会把该文件长度**截为 0**，就会**丢失该文件的内容**；但使用**带 x 的写模式**，即使`fopen()`操作失败，也**不会删除源文件内容**。第二，如果**环境允许**，**x 模式**的**独占特性**使得其他程序或线程**无法访问正在被打开的文件**

  - `fopen()`**与文件指针**

    > 1、程序成功**打开文件**后，`fopen()`将返回**文件指针**，**其他 I/O 函数**可以使用这个指针**指定该文件**  
    > 2、**文件指针**(该例中的 fp)的**类型**是**指向 FILE 的指针**，`FILE`是一个**定义在**`stdio.h`中的**派生类型**  
    > 3、**文件指针**并不指向**实际的文件**，它指向一个**包含文件信息**的**数据对象**，其中包含**操作文件**的**I/O 函数**所用的**缓冲区信息**

- **getc()和 putc()函数**

  - `getc()`和`putc()`与`getchar()`和`putchar()`**作用类似**，所不同的是，要告诉`getc()`和`putc()`函数**使用哪一个文件**

  - `getc`接受**一个参数**，即**文件指针**；`putc()`接受**两个参数**，第一个是**待写入的字符**，第二个是**文件指针**

  - **使用方式**

    > 1、`ch = getchar();`的意思是从**标准输入**中**获取一个字符**，而`ch = getc(fp);`的意思是从**fp 指定的文件**中**获取一个字符**。与此类似，`putc(ch, fpout);`的意思是把**字符 ch**放入**FILE 指针 fpout 指定的文件**中  
    > 2、示例程序中，`putc(ch, stdout);`将`stdout`作为**第二个参数**。`stdout`作为与**标准输出**相关联的**文件指针**，定义在`stdio.h`中，所以`putc(ch, stdout);`与`putchar(ch);`**作用相同**  
    > 3、如果`getc()`在**读取一个字符**时发现是**文件结尾**，将返回特殊值**EOF**

- **fclose()函数**

  - 程序可以使用`fclose()`**关闭文件**，必要时**刷新缓冲区**，其接受**一个参数**，即**文件指针**，如`fclose(fp)`函数**关闭 fp 指定的文件**

  - 对于**较正式的程序**，应该检查**是否成功关闭文件**。如果成功关闭，`fclose()`**返回 0**，否则返回**EOF**

- **指向标准文件的指针**

  | 标准文件 | 文件指针 | 通常使用的设备 |
  | :------: | :------: | :------------: |
  | 标准输入 |  stdin   |      键盘      |
  | 标准输出 |  stdout  |     显示器     |
  | 标准错误 |  stderr  |     显示器     |

##### **简单的文件压缩程序**

```c
/* 将文件压缩成原来的1/3*(仅压缩大小) */
/* 同样本程序依然使用命令行参数传入参数 */
#include <stdio.h>
#include <stdlib.h> // 提供 exit() 的原型
#include <string.h> // 提供 strcpy()、strcat()的原型
#define LEN 40

int main(int argc, char *argv[])
{
    FILE *in, *out; // 声明两个文件指针
    int ch;
    char name[LEN]; // 存储输出文件名
    int count = 0;

    // 检查命令行参数
    if (argc < 2)
    {
        fprintf(stderr, "Usage: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 设置输入
    if ((in = fopen(argv[1], "r")) == NULL) // 以读模式打开文件
    {
        fprintf(stderr, "I couldn't open the file '%s' \n", argv[1]);
        exit(EXIT_FAILURE);
    }

    // 设置输出
    strncpy(name, argv[1], LEN - 5); // 拷贝文件名，LEN-5留出5字符添加文件后缀名
    name[LEN - 5] = '\0';
    strcat(name, ".red");                 // 在文件名后添加.red后缀
    if ((out = fopen(name, "w")) == NULL) // 以写模式打开文件
    {
        fprintf(stderr, "Can't create output file\n");
        exit(3);
    }

    // 拷贝数据
    while ((ch = getc(in)) != EOF)
        if (count++ % 3 == 0)
            putc(ch, out); // 打印每三个字符的第一个字符

    // 关闭文件，收尾
    if (fclose(in) != 0 || fclose(out) != 0)
        fprintf(stderr, "Error in closing files\n");
    return 0;
}
```

##### **文件 I/O**

- **fprintf()、fscanf()函数和 rewind()函数**

  - `fprintf()`和`fscanf()`函数的**工作方式**与我们熟悉的`printf()`和`scanf()`**相似**，只是前两者需要用**第一个参数**指定**待处理的文件**

  - `rewind()`可以让程序回到**文件开始处**，其接受**一个参数**，即**文件指针**

  - **示例程序**

    ```c
    /* 将终端输入的字符存入文件，并从文件再次读取输出到终端 */
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #define MAX 41

    int main(void)
    {
        FILE *fp;
        char words[MAX];
        if ((fp = fopen("wordy", "a+")) == NULL)
        {
            fprintf(stdout, "Can't open 'wordy' file\n");
            exit(EXIT_FAILURE);
        }
        puts("输入单词将其添加到文件中，在新的一行输入#符号退出");       // 终端提示语
        while ((fscanf(stdin, "%40s", words) == 1) && (words[0] != '#')) // 从 stdin 接受至多40字符存入 words，且首字符不为#
            fprintf(fp, "%s\n", words);                                  // 向 fp 指向的文件输出字符串，内容为 words 的字符
        puts("文件预览：");                                              // 终端提示语
        rewind(fp);                                                      // 回到文件开始处
        while (fscanf(fp, "%s", words) == 1)                             // 从 fp 指向的文件接受字符，存入 words
            puts(words);                                                 // 输出到屏幕上
        fclose(fp);
        return 0;
    }
    ```

- **fgets()和 fputs()函数**

  - **第 11 章**简要介绍过这两个函数，在此简单回顾

  - `fgets()`**函数**

    > 1、语法`fgets(words,STLEN,fp);`。**第一个参数**为**存储字符串的地址**，**第二个参数**为**输入字符串的大小**，**第三个参数**为**文件指针**  
    > 2、`fgets()`**读取输入**，直到**第一个换行符后**，或**文件结尾**，或`STLEN-1`**个字符**，在末尾添加一个**空字符**使其成为**字符串**  
    > 3、`fgets()`**遇到 EOF**时将**返回 NULL 值**，可以利用这一特性检查**是否到达文件结尾**；如果**未遇到 EOF**则**返回第一个参数的地址**

  - `fputs()`**函数**

    > 1、语法`fputs(words,fp);`。**第一个参数**为**所需输出字符串的地址**，**第二个参数**为**文件指针**  
    > 2、`fputs`在打印字符串时**不会在末尾添加换行符**

##### **随机访问：fseek()和 stell()**

- 有了`fseek()`函数，便可把**文件**看做是**数组**，在`fopen()`打开的**文件**中直接**移动到任意字节处**

- 注意，`fseek()`有**3 个参数**，**返回 int 类型**的值；`ftell()`**返回 long 类型**的值，表示**文件**中的**当前位置**

- **示例程序**

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #define CNTL_Z '\032' // DOS 文本文件中的文件结尾标记
  #define SLEN 81

  int main(void)
  {
      char file[SLEN];
      char ch;
      FILE *fp;
      long count, last;

      puts("输入文件名：");
      scanf("%80s", file);
      if ((fp = fopen(file, "rb")) == NULL) // 只读模式
      {
          puts("无法打开");
          exit(EXIT_FAILURE);
      }
      fseek(fp, 0L, SEEK_END); // 定位到文件末尾
      last = ftell(fp);
      for (count = 1L; count <= last; count++)
      {
          fseek(fp, -count, SEEK_END);    // 回退(倒序输出)
          ch = getc(fp);
          if (ch != CNTL_Z && ch != '\r') // MS-DOS 文件
              putchar(ch);
      }
      fclose(fp);
      return 0;
  }
  ```

- **fseek()函数**

  - `fseek`**的使用**

    > 1、`fseek()`的**第一个参数**是**FILE 指针**，指向**待查找的文件**，`fopen()`应该**已经打开该文件**  
    > 2、`fseek()`的**第二个参数**是**偏移量**，该参数表示从**设置的起始点**开始要**移动的距离**。该参数必须是一个**long 类型**的值(**L 后缀**表明其值是**long 类型**)，可以为**正**(**前移**)、**负**(**后移**)或者**0**(**不动**)  
    > 3、`fseek()`的**第三个参数**是**模式**，由该参数**确定起始点**。模式如**下表**(**旧的实现**可能**缺少**这些定义，可以用**数值 0L、1L、2L**分别表示这**三种模式**)

    |   模式   | 偏移量的起始点 |
    | :------: | :------------: |
    | SEEK_SET |   文件开始处   |
    | SEEK_CUR |    当前位置    |
    | SEEK_END |    文件末尾    |

  - `fseek()`**的一些示例**

    ```c
    fseek(fp, 0L, SEEK_SET);      // 定位至文件开始处
    fseek(fp, 10L, SEEK_SET);     // 定位至文件中第10个字节
    fseek(fp, 2L, SEEK_CUR);      // 从文件当前位置前移2字节
    fseek(fp, 0L, SEEK_END);      // 定位至文件结尾
    fseek(fp, -10L, SEEK_END);    // 从文件结尾回退10字节
    ```

  - 如果**一切正常**，`fseek()`的**返回值为 0**；如果**出现错误**(如试图移动的距离超出文件范围)，其**返回值为-1**

- **ftell()函数**

  - `ftell()`函数的**返回类型**是**long**，它**返回**的是**参数指向文件**的**当前位置**距离**文件开始处**的字节数

  - **实例要素分析**

    > 1、示例中首先使用了`fseek(fp, 0L, SEEK_END)`将**当前位置**设置在**文件末尾**  
    > 2、此时`ftell(fp)`的值就是**文件开始处**到**结尾**的**字节数**，`last = ftell(fp)`将其赋给**last**  
    > 3、然后再是`for`**循环**中使用了**last**作为**条件范围**

- **fgetpos()和 fsetpos()函数**

  - **函数介绍**

    > 1、`fseek()`和`ftell()`的**潜在问题**是，他们都把大小限制在**long 能表示的范围内**。鉴于此，**ANSI C**新增了两个**处理较大文件**的**新定位函数**：`fgetpos()`和`fsetpos()`  
    > 2、这两个函数**不使用 long 类型**的值表示位置，他们使用一种**新类型**——**fpos_t**(file position type，文件定位类型)。**fpos_t**类型**不是基本类型**，它根据**其他类型**来定义  
    > 3、**fpos_t**的**变量**或**数据对象**可以在文件中**指定一个位置**，它**不能是数组类型**，除此之外，没有其他限制。**实现**可以提供一个满足**特殊平台要求**的类型，例如**fpos_t**可以实现为**结构**

  - **函数使用简介**

    > 1、`fgetpos()`的函数原型为`int fgetpos(FILE * restrict stream, fpos_t * restrict pos);`  
    > 2、调用该函数时，它把**fpos_t 类型的值**放在**pos 指向的位置**上，该值描述文件中**当前位置**距**文件开头**的字节数。如果成功，**返回 0**，如果失败，**返回非 0**  
    > 3、`fsetpos()`的函数原型为`int fsetpos(FILE *stream, const fpos_t *pos);`  
    > 4、调用该函数时，使用**pos 指向位置**上的**fpos_t 类型值**来设置**文件指针**指向**偏移该值后指定的位置**。如果成功，**返回 0**，如果失败，**返回非 0**。其中，**fpos_t**类型的值应通过**之前调用的**`fgetpos()`获得

##### **其他标准 I/O 函数**

- **ungetc()函数**

  > 1、**函数原型**：`int ungetc(int c, FILE *fp)`  
  > 2、`ungetc()`函数把**c 指定的字符**放回**输入流**中  
  > 3、如果把一个字符**放回输入流**，下次调用**标准输入函数**时将**读取该字符**

- **fflush()函数**

  > 1、**函数原型**：`int fflush(FILE *fp)`  
  > 2、调用`fflush()`函数引起**输出缓冲区**中所有的**未写入数据**被发送到**fp 指定的输出文件**，这个过程被称为**刷新缓冲区**。如果**fp**是**空指针**，所有**输出缓冲区**都被刷新  
  > 3、在**输入流**中使用`fflush()`效果是**未定义**的。只要**最近一次操作**不是输入操作，就可以用该函数来**更新流**

- **setvbuf()函数**

  > 1、**函数原型**：`int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size)`  
  > 2、`setvbuf()`函数**创建**了一个供**标准 I/O 函数**替换使用的**缓冲区**。在**打开文件后**且**未对流进行其他操作前**调用该函数  
  > 3、**指针 fp**识别**待处理的流**；**buf**指向**待使用的存储区**；**mode**的选择有**三种**：`_IOFBF`表示**完全缓冲**，`_IOLBF`表示**行缓冲**，`_IONBF`表示**无缓冲**  
  > 4、如果**buf**的**值不是 NULL**，则必须**创建一个缓冲区**，如果把**NULL**作为**buf 的值**，该函数会为自己**分配一个缓冲区**  
  > 5、如果函数操作成功，**返回 0**，否则**返回非 0 值**

- **二进制 I/O：fread()和 fwrite()**

  - **引入介绍**

    > 1、之前用到的**标准 I/O 函数**都是**面向文本**的，用于处理**字符**和**字符串**。如何在文件中**保存数值信息**？  
    > 2、用`fprintf()`**函数**和`%f`**转换说明**只是把**数值**保存为**字符串**。例如有`double num = 1./3.;`的**声明**，有`fprintf(fp, "%f", num);`的**语句**，**num**也不过只被存储为**8 个字符**：`0.333333`，存储后，**读取文件**时就**无法**将其**恢复为更高的精度**。一般而言，`fprintf()`把**数值**转换为**字符数据**，这种转换**可能**会**改变值**  
    > 3、为保证数值在**存储前后一致**，**最精确**的做法是使用**与计算机相同**的**位组合**来存储。因此，**double 类型**的值应该存储在一个**double 大小的单元**中。如果以**程序**所用的**表示法**把数据**存储在文件**中，则称以**二进制形式**存储数据  
    > 4、对于**标准 I/O**，`fread()`和`fwrite()`函数用于以**二进制形式**处理数据

    ![](https://s2.loli.net/2022/08/15/MTtH5YSchlCR23z.png)

  - `fwrite()`**函数**

    ```c
    char buffer[256];
    fwrite(buffer, 256, 1, fp);
    /*-----------------------*/
    double earnings[10];
    fwrite(earnings, sizeof(double), 10, fp);
    ```

    > 1、**函数原型**：`size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)`  
    > 2、`fwrite()`把**二进制数据**写入文件。其中**指针 ptr**是**待写入数据块的地址**，**size**表示**待写入数据块的大小**(以字节为单位)，**nmemb**表示**待写入数据块的数量**(也是一次性写入数据块的数量)，**fp**表示**待写入的文件**  
    > 3、注意`fwrite()`**第一个参数**类型是**指向 void 的指针**(通用类型指针)，因此**示例**中分别传入**指向 char 的指针**和**指向 double 的指针**都是合法的  
    > 4、`fwrite()`函数**返回成功写入项的数量**。正常情况下返回值就是**nmemb**，出现错误返回值就会**比 nmemb 小**

  - `fread()`**函数**

    ```c
    double earnings[10];
    fread(earnings, sizeof(double), 10, fp);
    ```

    > 1、**函数原型**：`size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)`  
    > 2、`fread()`函数用于**读取**被`fwrite()`写入文件的**数据**。其**接受参数**与`fwrite()`**一致**，其中**ptr**是**待读取文件数据**在**内存中的地址**，**fp**指定**待读取的文件**  
    > 3、`fread()`函数**返回成功读取项的数量**。正常情况下返回值就是**nmemb**，出现错误或读到文件结尾返回值就会**比 nmemb 小**

- **feof()和 ferror()函数**

  > 1、**函数原型**：`int feof(FILE *fp)`，`int ferror(FILE *fp)`  
  > 2、如果**标准输入函数**返回**EOF**，则通常表明函数已**到达文件结尾**。然而当出现**读取错误**时，函数也会返回**EOF**。`feof()`和`ferror()`用于**区分**这**两种情况**  
  > 3、当上一次**输入调用**检测到**文件结尾**时，`feof()`返回**非 0 值**，否则**返回 0**；当**读或写出现错误**，`ferror()`返回**非 0 值**，否则**返回 0**

---

#### **结构和其他数据形式**

---

<div class="success">

> **章节概要**：初识结构体；建立结构声明；定义结构变量；初始化结构；访问结构成员；结构的初始化器；结构数组；声明结构数组；标识结构数组的成员；嵌套结构；指向结构的指针；声明和初始化结构指针；用指针访问成员；向函数传递结构的信息；传递结构成员；传递结构的地址；传递结构；其他结构特性；使用结构数组的函数；结构与内存分配；结构中的字符指针与`malloc()`；复合字面量和结构；伸缩型数组成员；匿名结构；把结构内容保存到文件；链式结构；联合简介；枚举类型；共享名称空间；`typedef`简介；其他复杂的声明；类型声明黄金法则；函数指针

</div>

##### **初识结构体**

- **示例问题：创建图书目录**

  - **引入**

    > 1、假如你需要打印一份**图书目录**，要打印每本书的**各种信息**(书名、作者、出版社、日期、页数等)。**这些信息**其中一些可以存储在**字符数组**中，其他一些又需要**int 数组**或**float 数组**  
    > 2、用**7 个不同的数组**分别记录**比较繁琐**，尤其是如果你需要**多份列表**(一份按书名排序，一份按作者排序等)。如果能把图书目录的**信息**都包含在**一个数组**里更好，每个元素包含**一本书**的**相关信息**  
    > 3、我们需要一种既能**包含字符串**又能**包含数字**的**数据形式**，而且还要保持**各信息的独立**。C 的**结构体**就满足这种情况下的需求

  - **示例程序**

    ```c
    #include <stdio.h>
    #include <string.h>
    #define MAXTITL 41 // 书名最大长度+1
    #define MAXAUTL 31 // 作者姓名最大长度+1

    // 之前自己自定义的 s_gets 函数
    char *s_gets(char *str, int n)
    {
        char *ret_val; // 创建指针(同时也是存储字符串的变量)
        int i = 0;
        ret_val = fgets(str, n, stdin); // fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL
        if (ret_val)                    // 即，ret_val != NULL，判断是否读到文件结尾
        {
            while (str[i] != '\n' && str[i] != '\0') // 忽略跳过正常字符
                i++;
            if (str[i] == '\n') // 出现换行符替换为空字符，即不存储换行符
                str[i] = '\0';
            else                          // 否则就是读到了空字符
                while (getchar() != '\n') // 丢弃该输入行的其余字符
                    continue;
        }
        return ret_val;
    }

    // 定义结构模板：标记是 book
    struct book
    {
        char title[MAXTITL];
        char author[MAXAUTL];
        float value;
    }; // 结构模板结束，注意分号

    int main(void)
    {
        struct book library; // 把 library 声明为一个 book 类型的变量
        printf("输入书名：");
        s_gets(library.title, MAXTITL); // 使用 s_gets 函数访问将信息写入 library.title，即结构中的 title 变量
        printf("输入作者：");
        s_gets(library.author, MAXAUTL);
        printf("输入价钱：");
        scanf("%f", &library.value);
        printf("书名：%s\n作者：%s\n价钱：%.2f", library.title, library.author, library.value);
        return 0;
    }
    ```

- **建立结构声明**

  - **结构声明**描述了一个**结构**的**组织布局**，声明类似下面这样：

    ```c
    struct book
    {
        char title[41];
        char author[31];
        float value;
    };
    ```

  - **声明分析**

    > 1、该声明描述了一个由**两个字符数组**和**一个 float 类型变量**组成的**结构**。该声明并**未创建实际的数据对象**，只描述该对象**由什么组成**  
    > 2、有时我们把**结构声明**称为**模板**，因为它勾勒出结构是**如何存储数据**的。但注意此**模板**并非**C++的模板**，C++的模板要**更为强大**  
    > 3、定义时，首先是**关键字**`struct`，表明**跟在其后**的是一个**结构**，后面是一个可选的**标记**(该例中为 book)，稍后程序中可以**使用该标记引用该结构**。所以后面程序**可以声明**`struct book library;`，这把**library**声明为一个**使用 book 结构布局**的**结构变量**  
    > 4、在**结构声明**中，用一对**花括号**括起来的是**结构成员列表**。每个成员都用**自己的声明**来描述，成员可以是**任意一种数据类型**，甚至可以是**其他结构**。**右花括号**后面的**分号**是必需的，表示结构布局**定义结束**  
    > 5、可以把**结构声明**放在**所有函数外部**(如本例)，也可以放在**一个函数定义的内部**。如果放在**函数内部**，则该结构**标记仅供该函数内部使用**

- **定义结构变量**

  - **定义结构变量**

    > 1、**结构**有**两层含义**。一层含义是**结构布局**(未让编译器为数据分配空间)；另一层含义(同时也是下一步)是**创建一个结构变量**  
    > 2、程序中**创建结构变量**的一行是`struct book library;`，编译器执行这行代码便**创建了一个结构变量 library**。编译器**使用 book 模板**为该变量**分配空间**，这些**分配的空间**都与**名称 library**结合在一起  
    > 3、在**结构变量**的声明中，`struct book`所起的作用**相当于**一般声明中的`int`或`float`。例如，你也可以**定义两个**`struct book`类型的变量，或者定义**指向**`struct book`**类型结构**的**指针**  
    > 4、如`struct book doyle, panshin, *ptbook;`，其中的**doyle**和**panshin**都是**以 book 为模板**定义的独立的**结构变量**，**指针 ptbook**可以**指向**任何**book 类型的结构变量**

  - **补充说明**

    - 就**计算机**而言，`struct book library;`这条声明，是**以下声明**的**简化**：

      ```c
      struct book
      {
          char title[41];
          char author[31];
          float value;
      } library;  // 声明的右花括号后跟变量名
      ```

    - 换言之，**声明结构**的过程和**定义结构变量**的过程**可以组合**成一个过程。如下，组合后**可以省略结构标记**：

      ```c
      struct
      {
          char title[41];
          char author[31];
          float value;
      } library;
      ```

    - 然而，如果打算**多次使用结构模板**，就要使用**带标记的形式**。所以不建议使用以上形式单独组合使用

- **初始化结构**

  - 我们可以通过`int count = 0;`和`int fibo[4] = {0,1,2,3};`**初始化变量和数组**，**结构变量**能否**初始化**？

  - **初始化一个结构变量**与**初始化数组**语法类似(但要注意 ANSI C 前不能用自动变量初始化结构)：

    ```c
    struct book library = {
        "This is book name",
        "author name",
        1.95
    };
    ```

  - 简言之，可以使用一对**花括号**括起来的**初始化列表**来**初始化结构变量**，各项用**逗号分隔**。示例之所以**换行**是为了**提高代码可读性**

- **访问结构成员**

  > 1、**结构**就类似于一个**超级数组**，想要访问这个**超级数组**中的**元素**，需要使用**结构成员运算符**——**点**`.`  
  > 2、例如`library.value`即访问**library**的**value**部分。你可以像使用任何**float 变量**那样使用`library.value`  
  > 3、本质上，`.title`、`.author`和`.value`就相当于**book 结构**的**下标**

- **结构的初始化器**

  - **C99**和**C11**为结构提供了**指定初始化器**，其语法与**数组**的**指定初始化器**类似

  - **结构的初始化器**使用**点运算符**和**成员名**标识特定的元素。例如**先初始化 value**，**再初始化 author**，示例如下：

    ```c
    struct book library = {
        .value = 10.99,
        .author = "author name"
    };
    ```

  - 与数组类似，在**指定初始化器**后面的**普通初始化器**，会初始化**指定成员后面的成员**。如下示例，**value**先被**指定初始化**为**10.01**，后被**普通初始化覆盖**为**19.11**(因为其模板定义时紧跟在 author 后面，即为 author 后面的成员)

    ```c
    struct book library = {
        .value = 10.99,
        .author = "author name",
        19.11
    };
    ```

##### **结构数组**

- **示例拓展**

  - **引入**

    > 1、接下来，我们要使上面的程序拓展成**可以处理多本书**，**每本书的信息**都可以用一个**book 类型**的**结构变量**来表示  
    > 2、可以使用这一类型的**结构数组**来处理**多本书**，如下面的示例程序  
    > 3、注意示例程序创建了一个内含**100 个结构变量**的**结构数组**。由于该数组是**自动存储类别**的对象，**信息**被存储在**栈**中。如此大的数组需要**很大一块内存**，这可能导致一些问题，比如**栈溢出**。这是由于编译器可能使用了一个**默认大小的栈**，要修正这个问题，可以使用**编译器选项**设置**栈大小**为**10000**，或者也可以创建**静态或外部数组**(这样不会存储在栈内)

  - **示例程序**

    ```c
    #include <stdio.h>
    #include <string.h>
    #define MAXTITL 41 // 书名最大长度+1
    #define MAXAUTL 31 // 作者姓名最大长度+1
    #define MAXBKS 100 // 书籍最大数量

    // 之前自己自定义的 s_gets 函数
    char *s_gets(char *str, int n)
    {
        char *ret_val; // 创建指针(同时也是存储字符串的变量)
        int i = 0;
        ret_val = fgets(str, n, stdin); // fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL
        if (ret_val)                    // 即，ret_val != NULL，判断是否读到文件结尾
        {
            while (str[i] != '\n' && str[i] != '\0') // 忽略跳过正常字符
                i++;
            if (str[i] == '\n') // 出现换行符替换为空字符，即不存储换行符
                str[i] = '\0';
            else                          // 否则就是读到了空字符
                while (getchar() != '\n') // 丢弃该输入行的其余字符
                    continue;
        }
        return ret_val;
    }

    struct book
    {
        char title[MAXTITL];
        char author[MAXAUTL];
        float value;
    };

    int main(void)
    {
        struct book library[MAXBKS]; // book 类型结构的数组
        int count = 0, index;
        printf("输入书名，在新行行首换行停止程序：");
        // 计数小于最大书籍数 && 输入title正常 && 不停止程序
        while (count < MAXBKS && s_gets(library[count].title, MAXTITL) != NULL && library[count].title[0] != '\0')
        {
            printf("现在输入作者：");
            s_gets(library[count].author, MAXAUTL);
            printf("现在输入价钱：");
            scanf("%f", &library[count++].value); // 输入结束后，count++
            while (getchar() != '\n')             // 清理输入行(scanf输入会保留换行符)
                continue;
            if (count < MAXBKS)
                printf("输入下一本书名：");
        }

        if (count > 0)
        {
            printf("这是你的书籍信息单：\n");
            for (index = 0; index < count; index++)
                printf("%s  %s  %.2f\n", library[index].title, library[index].author, library[index].value);
        }
        else
            printf("没有书籍信息");
        return 0;
    }
    ```

- **声明结构数组**

  > 1、声明**结构数组**和声明**其他类型的数组**类似，例如`struct book library[50]`  
  > 2、以上代码把**library**声明为一个**内含 50 个元素**的数组。数组的**每个元素**都是一个**book 类型**的**结构**  
  > 3、因此，`library[0]`是**第 1 个 book 类型结构变量**，`library[1]`是**第 2 个 book 类型结构变量**  
  > 4、**数组名 library**本身**不是结构名**，它只是一个**数组名**

- **标识结构数组的成员**

  > 1、为了标识**结构数组**的**成员**，可以采用**访问单独结构**的规则：**结构名**后加一个**点运算符**，再写**成员名**  
  > 2、只是对于**结构数组**，结构名为`library[0]`这种形式，而非`library`(library 只是数组名)  
  > 3、因此**访问对象**为`library[0].title`、`library[1].author`等等

##### **嵌套结构**

- **示例程序**

  ```c
  #include <stdio.h>
  #define LEN 20

  struct names
  {
      char first[LEN];
      char last[LEN];
  };

  struct guy
  {
      struct names handle; // 嵌套结构
      char favfood[LEN];
      char job[LEN];
      float income;
  };

  int main(void)
  {
      // 初始化结构变量
      struct guy fellow = {
          {"Ewen", "Villard"},
          "grilled salmon",
          "personality coach",
          68112.00
      };
      printf("朋友信息：\n");
      printf("名：%s  姓：%s\n", fellow.handle.first, fellow.handle.last);
      printf("喜欢的食物：%s\n职业：%s\n收入：%.2f",fellow.favfood, fellow.job, fellow.income);
      return 0;
  }
  ```

- **示例解析**

  > 1、首先注意如何在**结构声明**中**创建嵌套结构**。和声明**int 类型变量**一样，先进行声明`struct names handle`，该声明表示**handle**是一个**struct names**类型的**变量**(当然文件中应**提前声明 names**)  
  > 2、其次注意如何**访问嵌套结构**的**成员**。此时应使用两次**点运算符**，如`fellow.handle.first`，意为找到**fellow**中嵌套的**handle**，再找到**handle**的**first 成员**  
  > 3、**初始化**结构变量时，**嵌套的结构**也仍需按照**初始化语法**进行初始化，即需要用**花括号**包裹

##### **指向结构的指针**

- **为何要使用指向结构的指针**

  > 1、就像**指向数组的指针**比**数组本身**更容易操控(如排序问题)一样，**指向结构的指针**通常比**结构本身**更容易操控  
  > 2、在一些**早期的 C 实现**中，结构**不能作为参数**传递给函数，但是**可以传递指向结构的指针**  
  > 3、即使能传递一个结构，传递指针通常**更有效率**  
  > 4、一些用于**表示数据的结构**中包含**指向其他结构的指针**

- **示例程序**

  ```c
  #include <stdio.h>
  #define LEN 20

  struct names
  {
      char first[LEN];
      char last[LEN];
  };

  struct guy
  {
      struct names handle;
      char favfood[LEN];
      char job[LEN];
      float income;
  };

  int main(void)
  {
      struct guy fellow[2] = {
          {
              {"Ewen", "Villard"},
              "grilled salmon",
              "personality coach",
              68112.00
          },
          {
              {"Rodney", "Swillbelly"},
              "tripe",
              "tabloid editor",
              432400.00
          }
      };
      struct guy *him;      // 一个指向结构的指针
      him = &fellow[0];     // 指针指向 fellow[0]
      printf("%p %p\n", &fellow[0], &fellow[1]);
      printf("%p %p\n", him, him + 1);
      printf("him->income: %.2f  (*him).income: %.2f\n", him->income, (*him).income);
      him ++;               // 指向下一个结构
      printf("him->favfood: %s  (*him).handle.last: %s\n", him->favfood, (*him).handle.last);
      return 0;
  }
  ```

  ```
  000000000061FD70 000000000061FDC4
  000000000061FD70 000000000061FDC4
  him->income: 68112.00  (*him).income: 68112.00
  him->favfood: tripe  (*him).handle.last: Swillbelly
  ```

- **声明和初始化结构指针**

  > 1、声明**结构指针**很简单：`struct guy *him;`。首先是**关键字**`struct`，其次是**结构标记**`guy`，然后是**一个星号**`*`，其后跟着**指针名**`him`。这个语法和**其他指针声明**一样  
  > 2、该声明并**未创建**一个**新的结构**，但是**指针 him**可以**指向任意**现有的**guy 类型结构**  
  > 3、**和数组不同**的是，**结构变量名**并不是**结构变量的地址**，因此要在**结构变量名**前面加上**取地址运算符**`&`  
  > 4、在本例中，**fellow**是一个**结构数组**，这意味着`fellow[0]`**才是一个结构**。所以要让**him**指向`fellow[0]`
  > 5、比较**输出的前两行**，发现`him + 1`相当于`him`**指向的地址+84**(十六进制 DC4 - D70 = 54，换算十进制 84)。这是因为**每个 guy 结构**都占**84 字节**内存(20+20+20+20+4)  
  > 6、在有些系统中，一个结构的大小**可能大于各成员大小之和**，这是因为系统对**数据**进行**校准**的过程中产生了一些**缝隙**。例如有些操作系统必须把**每个成员**都放在**偶数地址**或**4 的倍数**的地址上

- **用指针访问成员**

  > 1、第一种方法是使用`->`**运算符**，有以下关系：`him == &barney`，那么`him->income`即是`barney.income`。换句话说，**指向结构的指针**后面的`->`**运算符**和**结构变量名**后面的`.`**运算符**工作方式相同。这里要注意**him**是一个**指针**，`him->income`是**指针所指结构**的**一个成员**  
  > 2、第二种方法是：如果`him == &fellow[0]`，那么`*him == fellow[0]`，因为`&`和`*`是一对**互逆运算符**。因此有`fellow[0].income == (*him).income`。注意**必须使用圆括号**，因为`.`比`*`**优先级更高**

##### **向函数传递结构的信息**

- **传递结构成员**

  ```c
  #include <stdio.h>

  struct funds
  {
      double bankfund;
      double savefund;
  };

  double sum(double x, double y)
  {
      return (x + y);
  }

  int main(void)
  {
      struct funds stan = {
          4032.27,
          8543.94
      };
      // 传参
      printf("%.2f", sum(stan.bankfund, stan.savefund));
      return 0;
  }
  ```

  > 1、只要**结构成员**是一个**具有单个值**的数据类型，即可把它**作为参数**传递给**接受该类型**的函数  
  > 2、当然，如果需要在**被调函数**中修改**主调函数**中成员的值，需要**传递成员的地址**(`&stan.bankfund`)

- **传递结构的地址**

  ```c
  #include <stdio.h>

  struct funds
  {
      double bankfund;
      double savefund;
  };

  double sum(const struct funds *money) // 参数是一个指针
  {
      return (money->bankfund + money->savefund); // 通过指针访问成员
  }

  int main(void)
  {
      struct funds stan = {
          4032.27,
          8543.94
      };
      // 传参
      printf("%.2f", sum(&stan));
      return 0;
  }
  ```

  > 1、这次将**结构的地址**作为参数，`sum()`**函数**使用**指向 funds 结构的指针**(money)作为参数，，把地址`&stan`传给函数，使**money**指向**结构变量 stan**  
  > 2、函数中，通过**指针访问成员**(`->`运算符)，获取`stan.bankfund`和`stan.savefund`的值  
  > 3、由于该函数并不能改变**指针所指向值**的**内容**，所以把**money**声明为一个**指向 const 的指针**

- **传递结构**

  ```c
  #include <stdio.h>

  struct funds
  {
      double bankfund;
      double savefund;
  };

  double sum(struct funds moolah) // 参数是一个结构
  {
      return (moolah.bankfund + moolah.savefund); // 通过结构变量访问成员
  }

  int main(void)
  {
      struct funds stan = {
          4032.27,
          8543.94
      };
      // 传参
      printf("%.2f", sum(stan));
      return 0;
  }
  ```

  > 1、对于**允许把结构作为参数**的编译器(一些旧的实现不允许这样做)，可以通过**上述示例**方式传递结构  
  > 2、**函数**`sum()`被调用时，**创建**了一个名为**moolah**的**自动结构变量**，其**各成员**被**初始化**为**stan 结构变量相应成员**的值的**副本**  
  > 3、因此，**传递指针**的方式使用的是**原始的结构**进行计算，而这种方式使用的是**新创建的 moolah 副本**进行计算，因此该程序使用`moolah.bankfund`访问**成员**

- **其他结构特性**

  - **结构赋值**

    > 1、现在的 C 允许**把一个结构赋值给另一个结构**(但是数组不能这样做)  
    > 2、也就是说，如果**n_data**和**o_data**都是**相同类型的结构**，可以这样做：`o_data = n_data`  
    > 3、这条语句把**n_data**的**每个成员的值**都赋给**o_data**的**相应成员**。即使**成员是数组**，**也能完成赋值**

  - **结构作为返回值**

    > 1、现在的 C，**函数**不仅能把**结构**作为**参数**传递，还能把**结构**作为**返回值**返回  
    > 2、例如一个**常规的函数**，接受一个**指向结构的指针**作为**参数**，并通过指针**改变数据**。现在还可以在**函数**内**定义单独的结构变量**，在**函数内**对该**结构变量**进行操作，最后将其**作为返回值**返回。  
    > 3、例如**函数**为`void def(void)`，函数内定义**结构变量**为**person**，函数**返回语句**为`return person;`，主函数有**同类型结构变量 person_data**，便可以通过`person_data = def();`将`def()`**函数内**的**person**，**作为返回值赋给 person_data**

- **使用结构数组的函数**

  > 1、整体传参方式和之前**传递一个数组**类似。**数组名**就是**首元素地址**(数组地址)，可以将其**传给指针**，另外该函数还需要访问**结构模板**  
  > 2、**函数定义**时参数定义大致为`double sum(struct funds money[], int n);`，其中`money[]`就是一个**指针**(也可以写为`*money`，这样写是为了提醒他人这是一个数组地址)，**n**为数组**元素个数**  
  > 3、在主函数中**调用函数**`sum(jones, 5)`(其中 jones 被定义为`struct funds jones[5]`)。**数组名 jones**就是**首元素地址**，因此**指针 money**初始值相当于`money = &jones[0]`  
  > 4、因为**money**指向**jones 的首元素**，所以`money[0]`就是`jones[0]`的**另一个名称**。与此类似，`money[1]`就是**第二个元素**，在**函数中**便使用`money[下标].成员名`访问成员

##### **结构与内存分配**

- **结构中的字符指针与 malloc()**

  - **问题分析**

    > 1、到目前为止，我们在**结构**中都是使用**字符数组**存储字符串，能否像学习**字符串**时使用**指向 char 的指针**存储字符串？  
    > 2、通常而言是可行的，但是**实际使用**时，也会出现**指向 char 的指针**存储字符串时的**通病**——**内存分配**  
    > 3、使用**这样的方式**存储字符串，由于**指针所指向的位置**并**未被分配**，因此其**存储的位置地址**可以是**任何值**，这可能会**篡改程序**的**其他数据**，导致程序崩溃  
    > 4、因此如果要用**结构存储字符串**，用**字符数组**较为简单，如果使用**指针**，误用可能导致严重的问题，因此最好配合`malloc()`**函数**提前分配内存

  - **指针与**`malloc()`**函数**

    ```c
    #include <stdio.h>
    #include <string.h> // 提供 strcpy()、strlen()的原型
    #include <stdlib.h> // 提供 malloc()、free()的原型
    #define SLEN 81

    struct namect
    {
        char *fname; // 使用指针存储字符串
        char *lname;
        int letters; // 统计名字字符数
    };

    // 之前自定义的 s_gets() 函数
    char *s_gets(char *str, int n)
    {
        char *ret_val; // 创建指针(同时也是存储字符串的变量)
        int i = 0;
        ret_val = fgets(str, n, stdin); // fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同(注意 ret_val 会和 str 指向同一个地址)，如果读到文件结尾返回NULL
        if (ret_val)                    // 即，ret_val != NULL，判断是否读到文件结尾
        {
            while (str[i] != '\n' && str[i] != '\0') // 忽略跳过正常字符
                i++;
            if (str[i] == '\n') // 出现换行符替换为空字符，即不存储换行符
                str[i] = '\0';
            else                          // 否则就是读到了空字符
                while (getchar() != '\n') // 丢弃该输入行的其余字符
                    continue;
        }
        return ret_val;
    }

    // 获取信息
    void getinfo(struct namect *pst) // 传递指针
    {
        char temp[SLEN];
        printf("输入名字：");
        s_gets(temp, SLEN);
        // 分配内存以存储名字
        pst->fname = (char *)malloc(strlen(temp) + 1); // 分配存储 temp+1 所需的大小
        strcpy(pst->fname, temp);                      // 拷贝字符串
        printf("输入姓氏：");
        s_gets(temp, SLEN);
        pst->lname = (char *)malloc(strlen(temp) + 1);
        strcpy(pst->lname, temp);
    }

    // 处理信息
    void makeinfo(struct namect *pst)
    {
        // 计算名字字符个数
        pst->letters = strlen(pst->fname) + strlen(pst->lname);
    }

    // 打印信息
    void showinfo(struct namect *pst)
    {
        printf("%s  %s  %d\n", pst->fname, pst->lname, pst->letters);
    }

    // 释放分配的内存
    void cleanup(struct namect *pst)
    {
        free(pst->fname);
        free(pst->lname);
    }

    int main(void)
    {
        struct namect person; // 名为person的结构变量
        getinfo(&person);
        makeinfo(&person);
        showinfo(&person);
        cleanup(&person);
        return 0;
    }
    ```

- **复合字面量和结构**

  > 1、**C99**的**复合字面量**特性不仅可以用于**数组**，还可以用于**结构**。如果只需要一个**临时结构值**，复合字面量很好用  
  > 2、可以使用**复合字面量**创建一个**结构**作为**函数的参数**或**赋给另一个结构**  
  > 3、语法与**数组复合字面量**相似，将**类型名**放在**圆括号**中，后面紧跟一个用**花括号**括起来的**初始化列表**，示例如下

  ```c
  struct book
  {
      char title[20];
      char author[20];
      float value;
  };

  int main(void)
  {
      struct book readfirst;
      readfirst = (struct book){"food","Nick",11.25};   // 使用复合字面量创建临时结构值赋值
      return 0;
  }
  ```

- **伸缩型数组成员**

  - **简介**

    > 1、**C99**新增了一个特性：**伸缩型数组成员**。利用这项特性声明的**结构**，其**最后一个数组成员**具有一些**特性**  
    > 2、第 1 个特性是，该数组**不会立即存在**  
    > 3、第 2 个特性是，使用这个**伸缩型数组成员**可以编写合适的代码，就**好像**它**确实存在**并**具有所需数目的元素**

  - **声明伸缩型数组成员**

    ```c
    struct flex
    {
        int count;
        double average;
        double score[];   // 伸缩型数组成员
    };
    ```

    > 1、**伸缩型数组成员**必须是结构的**最后一个成员**  
    > 2、结构中必须**至少有一个成员**  
    > 3、**伸缩数组**的声明类似于**普通数组**，只是**方括号中是空的**

  - **使用伸缩型数组成员**

    - 声明一个**struct flex**类型的**结构变量**时，不能用**score**去做任何事，因为**没有**给这个数组**预留存储空间**

    - 实际上，**C99**的意图不是让你声明**struct flex**类型的**结构变量**，而是希望你声明**指向 struct flex 类型的指针**，然后用`malloc()`函数来**分配足够的空间**，以存储**struct flex**类型结构的**常规内容**和**伸缩型数组成员**所需的**额外空间**

    - 例如，假设用**score**表示一个**内含 5 个 double 类型值**的**数组**，可以这样做：

      ```c
      struct flex * pf;   // 声明一个指针
      // 请求为一个结构和一个数组分配存储空间
      pf = malloc(sizeof(struct flex) + 5 * sizeof(double));    // 一个struct flex的空间 + 5个double的空间
      ```

    - 现在有**足够储存空间**存储**count**、**average**和一个**内含 5 个 double 类型值**的**数组**，可以用**指针 pf**访问这些成员：

      ```c
      pf -> count = 5;        // 访问 count 成员
      pf -> score[2] = 18.5;  // 访问数组的一个元素
      ```

    - 此时，可以将**5 个 double 类型值**的**5**换为一个**变量 n**，就可以更方便的**伸缩数组大小**。即`malloc()`分配时，`malloc(sizeof(struct flex) + n * sizeof(double))`，其中**n**就表示**伸缩型数组成员**的**元素个数**

  - **一些特殊的处理要求**

    > 1、第一，**不能**用结构进行**赋值或拷贝**(即`*pf1 = *pf2`这样)，这样做只会拷贝**除伸缩型数组成员外**的**其他成员**。如果确实要拷贝，应使用`memcpy()`函数(第 16 章介绍)  
    > 2、不要以**按值方式**把这种结构**传递给函数**。原因相同，**按值传递**一个参数与**赋值**类似。应该把**结构的地址**传给函数  
    > 3、不要使用**带伸缩型数组成员的结构**作为**数组成员**或**另一个结构的成员**

- **匿名结构**

  - **匿名结构**是一个**没有名称的结构成员**。**C11**中，可以用**嵌套**的**匿名成员结构**定义结构：

    ```c
    struct person
    {
        int id;
        struct {char first[20]; char last[20];};    // 匿名结构
    };
    ```

  - **特点**

    > 1、假设需要一个**struct person**类型的**结构变量 ted**，**初始化 ted**的方式与初始化一个**嵌套结构**方式相同：`struct person ted = {12, {"Ted", "Grass"}};`  
    > 2、但是在**访问 ted 时**，相比嵌套结构**简化了步骤**。只需把**first**和**last**看作**person 的成员**，使用`ted.first`即可访问，而不需要像**嵌套结构**那样使用`ted.xxxxx.first`访问  
    > 3、当然，这样看来也可以把**first**和**last**直接作为**person 的成员**，**匿名特性**在**嵌套联合**中更加有用，后续介绍

##### **把结构内容保存到文件**

- **引入**

  > 1、由于**结构**可以**存储不同类型**的信息，所以它是**构建数据库**的重要工具。我们要把这些信息**存储在文件**中，并且能**再次检索**  
  > 2、**数据库文件**可以包含**任意数量**的此类数据对象。存储在一个结构中的**整套信息**被称为**记录**，**单独的项**被称为**字段**  
  > 3、或许**存储记录**最没效率的方法是用`fprintf()`。首先便是当结构的**成员更多**时，`fprintf()`所需要使用的**转换说明**也更多；其次**检索**时还**存在问题**，因为程序要知道**一个字段结束**和**另一个字段开始**的**位置**  
  > 4、更好的方案是使用`fread()`和`fwrite()`函数读写**结构大小**的**单元**。回忆一下，这两个函数使用与程序相同的**二进制表示法**，如`fwrite(&primer, sizeof(struct book), 1, pbooks);`。定位到**primer 结构变量**开始的位置，并把结构中的**所有字节**都拷贝到**pbooks 所指文件**中，`sizeof(struct book)`告诉函数**待拷贝的一块数据的大小**(即 struct book 类型的大小)，**1**表示**一次拷贝一块数据**

- **示例程序**

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #define MAXTITL 40
  #define MAXAUTL 40
  #define MAXBKS 10 // 最大书籍数量

  struct book
  {
      char title[MAXTITL];
      char author[MAXAUTL];
      float value;
  };

  // 之前自定义的 s_gets() 函数
  char *s_gets(char *str, int n)
  {
      char *ret_val;
      int i = 0;
      ret_val = fgets(str, n, stdin);
      if (ret_val)
      {
          while (str[i] != '\n' && str[i] != '\0')
              i++;
          if (str[i] == '\n')
              str[i] = '\0';
          else
              while (getchar() != '\n')
                  continue;
      }
      return ret_val;
  }

  int main(void)
  {
      struct book library[MAXBKS]; // 定义结构数组
      int ct = 0, index, filecount;
      FILE *pbooks;
      int size = sizeof(struct book);

      // 打开文件
      if ((pbooks = fopen("book.dat", "a+b")) == NULL)
      {
          fputs("无法打开book.dat\n", stderr);
          exit(1);
      }

      // 读取数据文件中已经存储的数据，存入library，并打印之前存储的数据
      rewind(pbooks); // 定位到文件开始处
      // 遍历的 ct 小于数组元素个数 && 读取二进制内容并写入library正常
      while (ct < MAXBKS && fread(&library[ct], size, 1, pbooks) == 1)
      {
          if (ct == 0)
              puts("book.dat当前的内容："); // 首次的提示语
          printf("%s  %s  %.2f\n", library[ct].title, library[ct].author, library[ct].value);
          ct++;
      }

      // filecount 记录以前已写到结构数组第几个元素。判断目前结构数组是否有多余位置存储新数据
      filecount = ct;
      if (ct == MAXBKS)
      {
          fputs("book.dat文件已满\n", stderr);
          exit(2);
      }

      // 向library写入新数据
      puts("请添加新的书籍名称：(在新的一行回车停止)");
      // 遍历的 ct 小于数组元素个数 && 读取书籍名称正常 && 不在新的一行回车停止程序
      while (ct < MAXBKS && s_gets(library[ct].title, MAXTITL) != NULL && library[ct].title[0] != '\0')
      {
          puts("现在输入作者：");
          s_gets(library[ct].author, MAXAUTL);
          puts("现在输入价钱(或编号)：");
          scanf("%f", &library[ct].value);
          while (getchar() != '\n') // 清理输入行
              continue;
          if (ct < MAXBKS)
              puts("输入下一本书的标题：");
          ct++;
      }

      // 输出添加后的library，并写入数据文件
      if (ct > 0)
      {
          puts("这是新的书单列表：");
          for (index = 0; index < ct; index++)
              printf("%s  %s  %.2f\n", library[index].title, library[index].author, library[index].value);
          fwrite(&library[filecount], size, ct - filecount, pbooks);
      }
      else
      {
          puts("没有新书写入");
      }
      fclose(pbooks);
      return 0;
  }
  ```

- **示例重点**

  > 1、以`a+b`模式**打开文件**。`a+`模式允许程序**读取文件**并可以在**末尾追加内容**，`b`表明程序将使用**二进制文件格式**  
  > 2、选择**二进制模式**是因为`fread()`和`fwrite()`要使用二进制文件。`rewind()`函数确保**文件指针**处于**文件开始处**，为读文件做好准备  
  > 3、**写入新的数据**时，我们本也可以用一个**循环**在**文件末尾**使用`fwrite()`**一次添加一个结构**，但示例中使用`fwrite()`**一次写入一块数据**。**filecount**表示**第一个新写入的结构**的下标，表达式`ct - filecount`就是**新添加书籍的数量**
  > 4、虽然**结构**中有些内容是**文本**，但**value**成员不是文本。如果使用**文本编辑器**查看**book.dat**，其中**文本部分**内容显示正常，但**数值部分**内容不可读，甚至可能乱码

##### **链式结构**

- **结构**有很多种用途，除了前面介绍的，还有一种是**创建新的数据形式**

  > 1、计算机用户已经开发出的一些**数据形式**比我们提到过的**数组**和**简单结构**能更有效地**解决特定问题**  
  > 2、这些形式包括**队列**、**二叉树**、**堆**、**哈希表**和**图表**，许多这样的形式都由**链式结构**组成  
  > 3、通常，每个结构都包含**一两个数据项**和**一两个指向其他同类型结构**的**指针**。这些指针把**一个结构**和**另一个结构**链接起来，并**提供一种路径**能遍历**整个彼此链接的结构**

- **二叉树演示**

  > 1、下图是一个**二叉树结构**的示意图  
  > 2、考虑有**10 个节点的树**的情况下，他有 2<sup>10</sup>-1 个(或 1023 个)**节点**，可以**存储 1023 个单词**  
  > 3、如果这些单词**以某种规则排列**，自上而下**逐级查找**，**最多**只需要**移动 9 次**即可找到；如果放在数组中，至多需要遍历**1023 个元素**才能找到

  ![](https://s2.loli.net/2022/08/20/Ar9saJQcVT2R6Sj.png)

##### **联合简介**

- **概述**

  > 1、**联合**是一种**数据类型**，它能在**同一个内存空间**中存储**不同的数据类型**(不是同时存储)  
  > 2、其典型的用法是，设计一种表以**存储既无规律**、**事先也不知道顺序**的**混合类型**  
  > 3、使用**联合类型**的**数组**，其中的联合都**大小相等**，每个联合可以存储**各种数据类型**

- **声明联合**

  - 创建**联合**和创建**结构**的方式相同，需要一个**联合模板**和一个**联合变量**

    ```c
    // 声明联合模板
    union hold
    {
        int digit;
        double bigfl;
        char letter;
    };

    // 声明联合变量
    union hold fit;       // hold 类型的联合变量
    union hold save[10];  // 内含10个联合变量的数组
    union hold *pu;       // 指向 hold 类型联合变量的指针
    ```

  - **联合与结构的不同**

    > 1、根据**如上示例**声明的**结构**，可以存储**一个 int 类型**、**一个 double 类型**和**一个 char 类型**的值(三种类型都可以存储)  
    > 2、然而，声明的**联合**，只能存储**一个 int 类型**或**一个 double 类型**或**一个 char 类型**的值(只能存储其一)

- **初始化联合**

  ```c
  union hold valA;
  valA.letter = 'R';
  union hold valB = valA;             // 用另一个联合来初始化
  union hold valC = {88};             // 初始化联合的第一个元素：digit 成员
  union hold valD = {.bigfl = 118.2}; // 指定初始化器
  ```

  > 1、可以**初始化联合**，但要注意，联合**只能存储一个值**。  
  > 2、共有**三种**初始化的方法：把**一个联合**初始化为**另一个同类型的联合**；初始化**联合的第一个元素**；或者根据**C99**标准，使用**指定初始化器**

- **使用联合**

  ```c
  // 使用联合
  fit.digit = 23;       // 把 23 存储在 fit 中，占 2 字节
  fit.bigfl = 2.0;      // 清除 23，存储 2.0，占 8 字节
  fit.letter = 'h';     // 清除 2.0，存储 h，占 1 字节

  // 使用指针访问联合
  pu = &fit;            // 此处 pu 是一个指向联合的指针
  x = pu->digit;        // 相当于 x = fit.digit
  ```

  > 1、**点运算符**表示**正在使用哪种数据类型**  
  > 2、在联合中，**一次只储一个值**。即使有**足够的空间**，也**不能同时存储**一个**char 类型值**和一个**int 类型值**。编写代码时要注意**当前存储**在联合中的**数据类型**  
  > 3、和**用指针访问结构**一样，**用指针访问联合**也要用`->`**运算符**

- **联合的一种用途**

  - **引入**

    > 1、**联合**的**主要用途之一**是，在**结构**中存储**与其成员有从属关系的信息**  
    > 2、例如，用**一个结构**表示**一辆汽车**。如果汽车**属于驾驶者**，就用一个**结构成员**描述这个**所有者**；如果**汽车被租赁**，就用**一个成员**来描述其**租赁公司**

  - **示例思路**

    ```c
    struct owner    // 个人拥有者信息
    {
        char socsecurity[12];
        ...
    };

    struct leasecompany   // 租赁公司信息
    {
        char name[40];
        char headquarters[40];
        ...
    };

    union data    // 创建联合
    {
        struct owner owncar;            // 创建成员，为 owner 类型结构变量
        struct leasecompany leasecar;   // 创建成员，为 leasecompany 类型结构变量
    };

    struct car_data     // 使用结构表示一辆车的信息
    {
        char make[15];
        int status;   // 人为约定私有为 0， 租赁为 1
        union data onwerinfo;
        ...
    };
    ```

  - **示例说明**

    > 1、假设有**flits**是**car_data 类型**的**结构变量**  
    > 2、如果`flits.status == 0`(即私有)，程序将设计为使用`flits.ownerinfo.owncar.socsecurity`  
    > 3、如果`flits.status == 1`(即租赁)，程序将设计为使用`flits.ownerinfo.leasecar.name`

- **匿名联合**

  - **匿名联合**和**匿名结构**的工作原理相同，即**匿名联合**是一个结构或联合的**无名联合成员**

  - 例如，我们可以把上面程序的`car_data`重新定义：

    ```c
    struct owner    // 个人拥有者信息
    {
        char socsecurity[12];
        ...
    };

    struct leasecompany   // 租赁公司信息
    {
        char name[40];
        char headquarters[40];
        ...
    };

    struct car_data     // 使用结构表示一辆车的信息
    {
        char make[15];
        int status;   // 人为约定私有为 0， 租赁为 1
        union         // 创建匿名联合
        {
            struct owner owncar;            // 创建成员，为 owner 类型结构变量
            struct leasecompany leasecar;   // 创建成员，为 leasecompany 类型结构变量
        };
        ...
    };
    ```

  - 现在，像**匿名结构**一样，可以用`flits.owncar.socsecurity`代替原先的`flits.owninfo.owncar.socsecurity`

##### **枚举类型**

- **简介**

  > 1、可以用**枚举类型**声明**符号名称**来表示**整型常量**  
  > 2、使用`enum`**关键字**，可以**创建一个新**“**类型**”并指定它**可具有的值**  
  > 3、实际上，**enum**常量是**int**类型，因此，只要能使用**int 类型**的地方就可以使用**枚举类型**  
  > 4、**枚举类型**的**目的**，是**提高程序的可读性**，它的语法**与结构的语法相同**

- **声明与使用枚举类型**

  ```c
  // 声明枚举类型
  enum spectrum {red, orange, yellow, green, blue, violet};   // 枚举声明
  enum spectrum color;    // 声明枚举变量

  // 使用枚举类型
  color = blue;
  if (color == yellow)
      ...;
  for (color = red; color <= violet; color++)
      ...;
  ```

  > 1、第一个声明创建了**spectrum**作为**标记名**，允许把`enum spectrum`作为一个**类型名**使用。第二个声明使**color**作为**该类型的变量**  
  > 2、第一个声明中的**花括号**内的**标识符**枚举了**spectrum 变量可能有的值**。因此，**color**可能的值是**red**、**orange**、**yellow**等。这些**符号常量**被称为**枚举符**  
  > 3、虽然**枚举符**是**int 类型**，但是**枚举变量**可以是**任意整数类型**，前提是该整数类型**可以存储枚举常量**  
  > 4、例如，**spectrum**的**枚举符**范围是**0 ~ 5**，所以编译器可以用`unsigned char`类型来**表示 color 变量**

- **C 与 C++的枚举兼容性**

  > 1、**C** 枚举的一些特性**并不适用于 C++**  
  > 2、例如，C 允许**枚举变量**使用`++`**运算符**，但 **C++ 标准不允许**  
  > 3、所以，如果需要**和 C++ 标准兼容**，必须把**上面例子**的**color**声明为**int 类型**

- **enum 常量**

  > 1、**blue**和**red**到底是什么？从**技术层面**看，它们是**int 类型的常量**  
  > 2、例如假定有前面的枚举声明，`printf("red = %d, orange = %d", red, orange)`**的输出为**`red = 0, orange = 1`  
  > 3、**red**成为一个**有名称的常量**，**代表整数 0**。类似的，其他**标识符**都是**有名称的常量**，分别代表**1~5**  
  > 4、只要**能使用整型常量**的地方就**都能使用枚举常量**。例如**声明数组**时，可以用**枚举常量**表示**数组的大小**；在`switch`**语句**中，可以把**枚举常量**作为**标签**  
  > 5、默认情况下，**枚举列表**中的**常量**都被赋予**0**、**1**、**2**等

- **枚举常量赋值**

  > 1、**枚举声明**中，可以为**枚举常量**指定**整数值**。如`enum levels {low = 100, medium = 500, high = 2000};`  
  > 2、如果**只给一个**枚举常量赋值，没有对**后面的**枚举常量赋值，那么**后面的常量**会被赋予**后续的值**  
  > 3、例如`enum feline{cat, lynx = 10, puma, tiger};`，**cat**的值为**0**(默认)，**lynx**、**puma**与**tiger**的值分别为**10**、**11**、**12**

- **共享名称空间**

  > 1、C 语言使用**名称空间**(namespace)，标识**程序中的各部分**，即**通过名称**来识别  
  > 2、**作用域**是**名称空间**概念的**一部分**：两个**不同作用域**的**同名变量不冲突**，两个**相同作用域**的**同名变量冲突**  
  > 3、**名称空间**是**分类别**的，在**特定作用域**中的**结构标记**、**联合标记**、**枚举标记**都**共享相同的名称空间**，**该名称空间**与普通变量使用的**空间不同**  
  > 4、例如**在 C 中**，**同时声明**`struct rect {double x; double y;};`和`int rect;`**不会产生冲突**  
  > 5、尽管如此，以**两种不同的方式**使用**相同的标识符**会造成混乱。另外**C++ 不允许这样做**，因为它将**标识名**和**变量名**放在**相同的名称空间**里

##### **typedef 简介**

- **typedef 简介**

  > 1、`typedef`工具是一个**高级数据特性**，利用`typedef`可以为某一类型**自定义名称**。这方面与`#define`**类似**，但是两者有**3 处不同**  
  > 2、与`#define`不同，`typedef`创建的**符号名只受限于类型**，**不能用于值**  
  > 3、`typedef`由**编译器**解释，而不是**预处理器**  
  > 4、在其受限范围内，`typedef`**比**`#define`**更灵活**

- **typedef 的使用**

  > 1、假设用**BYTE**表示**1 字节的数组**，只需像定义**char 类型变量**一样定义**BYTE**，然后在定义**前面加上关键字**`typedef`：即`typedef char BYTE;`  
  > 2、随后，便可以使用**BYTE**来**定义变量**，如`BYTE x, y[10], *z;`  
  > 3、该定义的**作用域**取决于`typedef`**定义所在的位置**，`typedef`中使用的名称**遵循变量的命名规则**  
  > 4、通常`typedef`定义中用**大写字母**表示**被定义的名称**，以**提醒用户**这个类型名是一个**符号缩写**

- **typedef 的一些用途**

  - `typedef`的**一些特性**与`#define`的**功能重合**

    ```c
    typedef char BYTE;
    #define BYTE char
    ```

  - 但是`typedef`也有`#define`**没有的功能**

    ```c
    char * STRING;
    typedef char * STRING;
    #define STRING char *
    ```

    > 1、**没有**`typedef`关键字的话，**编译器**会把**STRING**识别为**指向 char 的指针**  
    > 2、**使用**`typedef`，**编译器**将**STRING**解释成**类型的标识符**，该**类型**是**指向 char 的指针**  
    > 3、**使用**`typedef`，`STRING name, sign;`**相当于**`char *name, *sign;`，声明的**两个变量都是指针**  
    > 4、但如果**使用**`#define`，`STRING name, sign;`**会相当于**`char *name, sign;`，则**只有 name 是指针**

  - 还可以把`typedef`**用于结构**

    ```c
    typedef struct complex{   //此处 complex 标识名可省略
        float real;
        float imag;
    } CONPLEX;

    struct complex num1;
    COMPLEX num2;
    ```

  - 此外，`typedef`更常用于**给复杂的类型命名**，如`typedef char (* FRPTC())[5] TYPENAME;`

##### **其他复杂的声明**

- C 允许用户**自定义数据形式**。虽然我们常用的是一些**简单的形式**，但是**根据需要**有时也会用到一些**复杂的形式**

- **复杂声明可使用的符号**

  | 符号 |     含义     |
  | :--: | :----------: |
  |  \*  | 表示一个指针 |
  |  ()  | 表示一个函数 |
  |  []  | 表示一个数组 |

- **一些复杂声明的示例**

  ```c
  int board[8][8];        // 声明一个指向 int 数组的数组
  int **ptr;              // 声明一个指向指针的指针，被指向的指针指向 int
  int *risks[10];         // 声明一个内含10个元素的数组，每个元素都是一个指向 int 的指针
  int (*rusk)[10];        // 声明一个指向数组的指针，该数组内含10个 int 类型的值
  int *oof[3][4];         // 声明一个3*4的二维数组，每个元素都是指向 int 的指针
  int (*uuf)[3][4];       // 声明一个指向3*4二维数组的指针，该数组中内含 int 类型的值
  int (*uof[3])[4];       // 声明一个内含3个元素的数组，其中每个指针都指向一个内含4个 int 类型值的数组
  ```

- **符号优先级**

  > 1、要看懂以上的声明，需要**注意符号的优先级**  
  > 2、**数组名**后面的`[]`和`()`具有**相同优先级**，他们**比**`*`**优先级更高**  
  > 3、`[]`和`()`**优先级相同**，因此正常情况下，**自左向右看**

- **类型声明黄金法则**

  > 详见我的另一篇博文，点击跳转：[类型声明黄金法则](https://www.shengqibaozao.eu.org/2022/08/23/%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99/)

- 对于这种**复杂声明**，使用`typedef`的**作用**就**逐渐明显**了

##### **函数指针**

- 通过上一节的学习可知，可以声明一个**指向函数的指针**。通常，**函数指针**用作**另一个函数的参数**，告诉该函数**要使用哪一个函数**

- **函数指针简介与声明**

  > 1、假设有一个**指向 int 类型变量的指针**，该指针就**存储**着这个**int 类型变量**存储在内存位置的**地址**。同样，**函数也有地址**，因为函数的**机器语言实现**由**载入内存**的代码组成，**指向函数的指针**中存储着**函数代码的起始处地址**  
  > 2、声明一个**数据指针**时，必须声明指针所**指向的数据类型**。对于声明**函数指针**，必须声明指针**指向的的函数类型**。为此，要**指明函数签名**，即函数的**返回类型**和**形参类型**  
  > 3、例如现有**函数原型**`void ToUpper(char *);`，声明**函数指针**应为`void (*pf)(char *);`。注意由于**运算符优先级**必须要使用**圆括号**，否则`void *pf(char *);`意为**pf 是一个返回字符指针的函数**

- **使用函数指针**

  ```c
  void ToUpper(char *);
  void ToLower(char *);
  int round(double);

  void (*pf)(char *);
  pf = ToUpper;         // 有效，ToUpper是该类型函数的地址
  pf = ToLower;         // 有效，ToUpper是该类型函数的地址
  pf = round;           // 无效，round与指针类型不匹配
  pf = ToLower();       // 无效，ToLower()不是地址

  pf = ToUpper;
  char mis[] = "Nina Metier";
  (*pf)(mis);           // 语法1
  pf(mis);              // 语法2
  ```

  > 1、声明了**函数指针**后，可以把**类型匹配**的**函数地址**赋给它。在这种上下文中，**函数名**可以用作表示**函数的地址**  
  > 2、既然可以**用数据指针访问数据**，就可以**用函数指针访问函数**。只是有两种**逻辑上不一致**的语法能这样做  
  > 3、**语法 1**中，由于**pf 指向**`ToUpper`**函数**，那么`*pf`就**相当于**`ToUpper`**函数**。所以`(*pf)(mis)`与`ToUpper(mis)`等效  
  > 4、**语法 2**中，由于**函数名**是**指针**，那么**指针和函数名**可以**互换使用**(从 pf 的赋值表达式就能看出 ToUpper 和 pf 是等价的)。因此`pf(mis)`和`ToUpper(mis)`等效

- **函数指针作为参数**

  > 1、作为**函数的参数**是**数值指针**最常见的用法之一，**函数指针**亦如此。考虑以下**函数原型**：`void show(void (*fp)(char *), char *str);`  
  > 2、它声明了**两个形参**，**fp**和**str**。**fp**是一个**函数指针**，**str**是一个**数据指针**。更具体地说，**fp**指向的函数**接受**`char *`**类型**，**返回类型为 void**；**str**指向一个**char 类型的值**  
  > 3、可以这样**调用函数**：`show(ToUpper, mis);`。在函数内仍可以通过**函数指针 fp**来**调用函数**：`(*fp)(mis);`

---

#### **位操作**

---

<div class="success">

> **章节概要**：二进制数、位、字节；二进制整数；有符号整数；二进制浮点数；其他进制数；八进制；十六进制；进制赋值；C 按位运算符；按位逻辑运算符；移位运算符；常用用法；掩码；打开位；关闭位；切换位；检查位的值；乘除次幂；位字段；简介与声明；位字段的使用；位字段越界问题；位字段示例；对齐特性；对齐特性介绍；`_Alignof`运算符；`_Alignas`说明符；使用示例

</div>

##### **二进制数、位、字节**

- **二进制整数**

  > 1、通常，**1 字节**(1 byte)包含**8 位**(8 bits)。C 语言用**字节**表示**存储系统字符集**所需的大小，所以 C 字节可能是**8 位**、**9 位**、**16 位**或其他值  
  > 2、不过，描述**存储器芯片**和**数据传输率**中所用的字节指的是**8 位字节**。简化起见，我们假定**1 字节**是**8 位**(计算机界常用**八位组**这个术语特指**8 位字节**)  
  > 3、可以**从左往右**给这 8 位分别编号**7~0**。在一字节中，**编号是 7**的位称为**高阶位**，**编号是 0**的位称为**低阶位**，每一位的**编号**对应**2 的相应指数**  
  > 4、**8 位字节**能表示的最大的数是**11111111**，即**255**；能表示的最小的数是**00000000**，即**0**  
  > 5、因此**一字节**可存储**0~255 范围内**共**256 种值**，程序可以用**1 字节**存储**自-128 至 127**同样**256 种值**

  ![](https://s2.loli.net/2022/09/03/Kf2F4WbADjHgXs6.png)

- **有符号整数**

  - **符号量表示法**

    > 1、如何表示**有符号整数**取决于**硬件**，而不是 C 语言  
    > 2、也许**表示有符号数**最简单的办法是**用 1 位**(如高阶位)**存储符号**，**剩下 7 位**表示**数字本身**。用这种**符号量表示法**，表示的**范围为-127~127**  
    > 3、这种方法的缺点是有**两个 0**，**+0 和-0**，很容易混淆，而且用**两个位组合**表示**一个数字**有些浪费

  - **二进制补码**

    > 1、**二进制补码**避免了这个问题，是当今**最常用的系统**  
    > 2、**二进制补码**用 1 字节中的**后 7 位**表示**0~127**，通常高阶位**设置为 0**，表明**值为正**。如果**高阶位是 1**，则表明**值为负**，然后从一个**9 位组合**的**100000000**(即二进制的 256)**减去**一个**负数的位组合**，结果是**该负值的量**  
    > 3、假设一个**负值的位组合**是**10000000**。作为一个**无符号整数**，该组合**表示 128**；作为一个**有符号整数**，该组合表示的**值为负**(高阶位是 1)，值为**100000000 - 10000000**，**该数位-128**。类似的，**10000001**则**表示-127**，**11111111**则**表示-1**。这种方法可以**表示-128~127 范围内**的数  
    > 4、要得到一个**二进制补码数**的**相反数**，最简单的方法是**反转每一位然后+1**。如**1 是 00000001**，则**表示-1**应为**11111110+1**，即**11111111**

  - **二进制反码**

    > 1、**二进制反码**通过**反转位组合**中的**每一位**形成一个**负数**。例如**00000001 是 1**，**11111110 即为-1**  
    > 2、但这种方法**也有一个-0**，且**仅能表示-127~127 之间的数**

- **二进制浮点数**

  - **浮点数**分**两部分存储**：**二进制小数**和**二进制指数**

  - **二进制小数**

    > 1、一个普通的**浮点数 0.527**，表示如下：`5/10 + 2/100 + 7/1000`。从左往右，各分母都是**10 的递增次幂**  
    > 2、类似的，在**二进制小数中**，使用**2 的递增次幂**作为分母  
    > 3、所以**二进制小数 .101**表示为`1/2 + 0/4 + 1/8`，换为**十进制**为`0.5 + 0 + 0.125`，即**0.625**  
    > 4、许多分数**不能用十进制精确表示**(如 1/3)，同样的，许多分数也**不能用二进制精确表示**。二进制表示法只能精确表示**多个 1/2 的幂的和**，像**1/3**或**2/5**就不能精确表示

  - **浮点数表示法**

    > 1、为了在计算机中表示一个**浮点数**，要**留出若干位**(因系统而异)**存储二进制分数**，其他位**存储指数**  
    > 2、一般而言，**数字的实际值**是由**二进制小数**乘以**2 的指定次幂**组成  
    > 3、在实际计算时，一个**浮点数\*4**，那么**二进制小数不变**，而是**指数\*2**，**二进制分数不变**  
    > 4、如果一份**浮点数**乘以一个**不是 2 的幂**的数，会**改变小数部分**，如有必要，也会**改变指数部分**

##### **其他进制数**

- 计算机界通常使用**八进制**计数系统和**十六进制**计数系统。因为**8 和 16**都是**2 的幂**，比**十进制**更接近计算机的**二进制系统**

- **八进制**

  > 1、**八进制**指**八进制计数系统**。该系统**基于 8 的幂**，用**0~7 表示数字**，**满八进一**  
  > 2、了解**八进制**最简单的办法是，每个**八进制位**对应**3 个二进制位**。八进制转二进制时，**每一位**对应**3 位二进制位**，通过二进制**对应 2 的幂**凑出这一位八进制的值  
  > 3、例如，八进制的**6**转换二进制为**110**(4+2+0)，八进制的**35**转换二进制为**011101**(三位拆开看，0+2+1，4+0+1)。左侧的 0 可以省略，**中间和右侧的 0 不能省略**

- **十六进制**

  > 1、**十六进制**指**十六进制计数系统**。该系统**基于 16 的幂**，用**0~9**表示正常的**0~9**，用**A~F**表示**10~15**，**满十六进一**  
  > 2、因此十进制的**17**用十六进制表示为**11**(16+1)，十进制的**33**表示为**21**(16\*2+1)，十进制的**30**表示为**1E**(16+14)  
  > 3、每个**十六进制位**对应**4 个二进制位**，因此**两个十六进制位**恰好对应一个**8 位字节**，此外十六进制与二进制的转换方法与八进制类似  
  > 4、例如十六进制**E1**转换二进制为**11100001**(四位拆开看，8+4+2+0，0+0+0+1)

- **进制赋值**

  > 1、为**变量赋值**时可以分别使用`0b`、`0o`、`0x`表示**赋值的数**分别为**二进制**、**八进制**、**十六进制**  
  > 2、例如可以这样写：`num = 0b1001`、`num = 0o1007`、`num = 0x100F`

##### **C 按位运算符**

- C 提供**按位逻辑运算符**和**移位运算符**。在下面的例子中，为了方便理解，使用**二进制计数法**写出值

- **按位逻辑运算符**

  - 4 个**按位逻辑运算符**都用于**整型数据**，包括**char**。之所以叫做**按位**运算，是因为这些操作**针对每一个位进行**，不影响它左右两边的位

  - **按位取反**：`~`

    > 1、**一元运算符**`~`可以将**二进制**中的**1 变成 0**，**0 变成 1**。如**表达式**`~(10011010)`的**结果为 01100101**  
    > 2、假设**变量 val**已被赋值**2**。在二进制中，**00000010**表示**2**，那么`~val`的值是**11111101**，即**253**  
    > 3、注意，**只是使用**运算符**不会改变 val 的值**，只是创建了一个可以**使用或赋值**的**新值**：`newval = ~val`。如果**需要改变**val 的值需要**对 val 赋值**：`val = ~val`

  - **按位与**：`&`

    > 1、**二元运算符**`&`通过**逐位比较**两个运算对象，**生成一个新值**  
    > 2、对于**每个位**，只有**两个运算对象**中**相应的位都为 1**时，**对应结果位**的**值为 1**  
    > 3、如**表达式**`(10010011) & (00111101)`的**结果为 00010001**

  - **按位或**：`|`

    > 1、**二元运算符**`|`通过**逐位比较**两个运算对象，**生成一个新值**  
    > 2、对于**每个位**，只要**两个运算对象**中**相应的位至少有一个为 1**时，**对应结果位**的**值为 1**  
    > 3、如**表达式**`(10010011) | (00111101)`的**结果为 10111111**

  - **按位异或**：`^`

    > 1、**二元运算符**`^`通过**逐位比较**两个运算对象，**生成一个新值**  
    > 2、对于**每个位**，**两个运算对象**中**相应的位不同**时，**对应结果位**的**值为 1**  
    > 3、如**表达式**`(10010011) ^ (00111101)`的**结果为 10101110**

  - 对于`&`、`|`、`^`**运算符**，同样也有**复合运算符**`&=`、`|=`、`^=`

- **移位运算符**

  - 下面介绍 C 的**移位运算符**，移位运算符**向左或向右移动位**。示例中同样使用**二进制数**便于理解

  - **左移运算符**：`<<`

    > 1、**左移运算符**将其左侧的**运算对象每一位的值**，**向左移动指定位数**  
    > 2、左侧运算对象**移出左末尾端的值丢失**，用**0**填补**空缺位置**
    > 3、如**表达式**`(10001010) << 2`的**结果为 00101000**

  - **右移运算符**：`>>`

    > 1、**右移运算符**将其左侧的**运算对象每一位的值**，**向右移动指定位数**  
    > 2、左侧运算对象**移出右末尾端的值丢失**。对于**无符号类型**，用**0**填补**空缺位置**；对于**有符号类型**，结果**取决于机器**，空出的位置**可用 0 填充**，或者用**符号位**(即最左端的位)**副本**填充  
    > 3、如**表达式**`(10001010) >> 2`的**结果可能为 00100010 或 11100010**

  - **示例程序：数字转为二进制**

    ```c
    #include <stdio.h>
    #include <limits.h> // 提供 CHAR_BIT 的定义，CHAR_BIT 表示 char 中的位数

    // 整数转换为二进制字符串
    char *itobs(int n, char *ps)
    {
        int i;
        int size = CHAR_BIT * sizeof(int);
        for (i = size - 1; i >= 0; i--, n >>= 1)
            ps[i] = (01 & n) + '0';
        ps[size] = '\0'; // 添加空字符
    }

    // 4位一组显示二进制字符串
    void show_bstr(char *str)
    {
        int i = 0;
        while (str[i]) // 不是空字符串
        {
            putchar(str[i]);
            // 每4位添加空格
            if (++i % 4 == 0 && str[i])
                putchar(' ');
        }
    }

    int main(void)
    {
        char bin_str[CHAR_BIT * sizeof(int) + 1]; // CHAR_BIT * sizeof(int) 表示 int 类型的位数，+1 留出一位给空字符
        int number;
        puts("输入一个数字：");
        while (scanf("%d", &number) == 1)
        {
            itobs(number, bin_str);
            printf("%d is ", number);
            show_bstr(bin_str);
            putchar('\n');
        }
        return 0;
    }
    ```

    > 1、`itobs()`函数中有对`01 & n`求值。**01**是一个**八进制掩码**，其只有**0 号位为 1**，因此`01 & n`就是**n 最后一位的值**(值为 1 或 0)  
    > 2、但对于数组而言，需要的是**字符**而**不是数值**，因此该值`+ '0'`(或加上对应 ASCII 码值 48)即可**完成转换**。其结果存放在数组**倒数第二个元素**中(size - 1)  
    > 3、然后，**循环执行**`i--`和`n >>= 1`，。`i--`移动到数组**前一个元素**，`n>>=1`使**所有位右移 1**。进入下一轮迭代，处理的是**n**中**新的最右端的值**，将其结果存储在**倒数第三个元素**中，以此类推

  - **示例程序：切换一个值的后 n 位**

    ```c
    // 该函数可被上个示例调用
    int invert_end(int num, int bits)
    {
        int mask = 0;
        int bitval = 1;
        while (bits-- > 0)
        {
            mask |= bitval;
            bitval <<= 1;
        }
        return num ^ mask;
    }
    ```

    > 1、`~`**运算符**切换一个字节的**所有位**，而不是选定的**少数位**。但是`^`运算符可用于**切换单个位**  
    > 2、`while`循环用于**创建所需的掩码 mask**。起初，**mask**所有位**都为 0**，第一轮循环将**mask**的**0 号位**设置为**1**，第二轮将**1 号位**设置为**1**，以此类推  
    > 3、循环**bits**次，**mask**的**后 bits 位**就都被**设置为 1**。最后，`num ^ mask`运算即得**所需结果**

##### **运算符常用用法**

- **掩码**

  - **按位与运算符**常用于**掩码**。所谓**掩码**指的是一些**设置为开**(1)**或关**(0)的**位组合**

  - **掩码的认识与使用**

    > 1、假设定义符号常量**MASK**为**2**，其**二进制**为**00000010**，研究该语句：`flags = flags & MASK;`  
    > 2、使用**按位与运算符**任何位**与 0 组合**都**得 0**，因此对该语句只有**1 号位**的**值不变**(因为 MASK 只有 1 号位为 1)。**这个过程**叫做**使用掩码**，因为**掩码中的 0 隐藏了 flags 中相应的位**  
    > 3、可以这样类比，把掩码中的**0 看做不透明**，**1 看做透明**。因此只有**MASK 为 1 的位**才**可见**

    ![](https://s2.loli.net/2022/09/04/w1LThuqetzNlRED.png)

- **打开位**(**设置位**)

  - 有时，需要**打开一个值**的**特定位**，同时保持**其他位不变**。这种情况可以使用**按位或运算符**

  - **打开位的使用**

    > 1、对于`flags = flags | MASK;`语句，可以通过**设置 MASK 的值**来控制**打开 flags 的特定位**  
    > 2、因为使用`|`运算符，任何位**与 0 组合**，**结果都为本身**；任何位**与 1 组合**，**结果都为 1**  
    > 3、例如需要设置 flags 的**1 和 3 号位为开**(1)，则可以设置**MASK**为**10**(二进制为 00001010)，通过`flags |= MASK;`实现

- **关闭位**(**清空位**)

  - 和**打开特定的位**类似，有时也需要在**不影响其他位**的情况下**关闭指定的位**

  - **关闭位的使用**

    > 1、对于`flags = flags & ~MASK;`语句，可以通过**设置 MASK 的值**来控制**关闭 flags 的特定位**  
    > 2、因为使用`&`运算符，任何位**与 1 组合**，**结果都为本身**；任何位**与 0 组合**，**结果都为 0**  
    > 3、例如需要设置 flags 的**1 和 3 号位为关**(0)，则可以设置**MASK**为**10**(二进制为 00001010)，通过`flags &= ~MASK;`实现  
    > 4、根据个人喜好，也可以不使用`~MASK`而**直接使用 MASK**，这种表示方法便**以 0 标记需要关闭的位**，**MASK**应为**11110101**，语句为`flags &= MASK;`

- **切换位**

  - **切换位**指的是**打开已关闭的位**，或**关闭已打开的位**。这种情况可以使用**按位异或运算符**

  - **切换位的使用**

    > 1、对于`flags ^= MASK;`语句，可以通过**设置 MASK 的值**来**切换指定位的状态**  
    > 2、因为使用`^`运算符，任何位**与 1 组合**，**结果都会切换**(1 变 0,0 变 1)；任何位**与 0 组合**，**结果都不变**  
    > 3、例如需要**切换** flags 的**1 和 3 号位的状态**(0)，则可以设置**MASK**为**10**(二进制为 00001010)，通过`flags ^= MASK;`实现

- **检查位的值**

  - 有时需要**检查确认某位的值**，例如**flags 的 1 号位是否为 1**，**不能**像下面这样**直接比较**(即使 flags 的 1 号位为 1，其他位也会导致结果为假)

    ```c
    if (flags == MASK)
        puts("Wow!");     // 不能正常工作
    ```

  - 必须先**覆盖 flags 的其他位**，**只用 1 号位**比较

    ```c
    int flags, MASK1, MASK0;
    // MASK1 用于比较flags 1号位是否为 1，MASK0 用于比较1号位是否为 0
    flags = 0b1011;
    MASK1 = 0b0010;
    MASK0 = 0b1101;

    // 比较flags的 1号位是否为 1
    if((flags & MASK1) == MASK1)    // & 优先级比 == 低，所以需要括号
        puts("Wow!");

    // 比较flags的 1号位是否为 0
    if((flags | MASK0) == MASK0)
        puts("Wow!");
    ```

- **乘除次幂**

  - **移位运算符**针对**2 的幂**提供快速有效的**乘除法**(类似十进制移动小数点快速乘除 10)

    ```c
    number << n;      // number 乘以 2 的 n次幂
    number >> n;      // number 为非负时，number 除以 2 的 n次幂
    ```

##### **位字段**

- **简介与声明**

  > 1、**操控位**的第二种方法是**位字段**。**位字段**是一个**signed int**或**unsigned int**类型变量中的**一组相邻的位**  
  > 2、**位字段**通过一个**结构声明**来建立，该结构声明**为每个字段提供标签**，并确定该字段的**宽度**  
  > 3、随后，可通过普通的**结构成员运算符**`.`**单独**给这些字段**赋值**  
  > 4、由于**每个字段恰好为 1 位**，所以**只能赋值 1 或 0**。**结构变量**被存储在**int 大小的内存单元**中，但是在本例中**只使用了其中 4 位**

  ```c
  // 建立一个 4个 1位 的字段：
  struct {
      unsigned int autfd : 1;
      unsigned int bldfc : 1;
      unsigned int undln : 1;
      unsigned int itals : 1;
  } prnt;

  // 为字段单独赋值：
  prnt.itals = 0;
  prnt.undln = 1;
  ```

- **位字段的使用**

  - **带有位字段的结构**提供一种**记录设置**的方便途径。许多设置(如字体的粗体或斜体)就是**简单的二选一**，例如**开或关**、**真或假**等。如果**只需要使用 1 位**，就**不需要使用整个变量**

  - 有时，某些设置也有**多个选择**，因此**需要多位来表示**。这没问题，字段**不限制 1 位大小**，可以使用如下的示例。只是，要确保**赋值不超过字段可容纳范围**

    ```c
    // 创建 2个 2位 的字段和 1个 8位 的字段：
    struct {
        unsigned int code1 : 2;   // 2位 为 2位二进制，即可表示 2^2 个数，范围为 0~3
        unsigned int code2 : 2;
        unsigned int code3 : 8;
    } prcode;

    // 赋值：
    prcode.code1 = 0;
    prcode.code2 = 3;
    prcode.code3 = 102;
    ```

- **位字段越界问题**

  > 1、如果**声明的总位数**超过了**一个 unsigned int 类型**的大小，会用到**下一个 unsigned int 类型**的**存储位置**  
  > 2、一个字段**不允许跨越**两个**unsigned int**之间的**边界**。**编译器**会自动**移动跨界的字段**，保持**unsigned int**的**边界对齐**  
  > 3、一旦发生这种情况，**第一个 unsigned int**中会留下一个**未命名的**“**洞**”。可以使用**未命名的字段宽度**来**填充**未命名的洞；可以使用一个**宽度为 0 的未命名字段**迫使下一个字段与下一个整数**对齐**  
  > 4、示例中，`stuff.field1`和`stuff.field2`之间，有一个**2 位的空隙**；`stuff.field3`将**存储在下一个 unsigned int 中**  
  > 5、**字段存储**在一个 int 中的**顺序取决于机器**。另外，不同的机器中**两个字段边界的位置也有区别**。由于这些原因，位字段通常都**不容易移植**

  ```c
  struct {
      unsigned int field1 : 1;
      unsigned int : 2;
      unsigned int field2 : 1;
      unsigned int : 0;
      unsigned int field3 : 1;
  } stuff;
  ```

- **位字段示例**

  - **打印方框属性**

    > 1、在屏幕上表**示一个方框的属性**。为简化问题，假设方框具有如下几种属性  
    > 2、方框是**透明或不透明**的  
    > 3、**填充色**：黑、红、绿、黄、蓝、紫、青、白  
    > 4、边框**可见或隐藏**  
    > 5、**边框颜色**：与填充色相同的可能
    > 6、边框使用**实线**、**点线或虚线**

  - **示例程序**

    ```c
    #include <stdio.h>
    #include <stdbool.h>

    /* 线的样式 */
    #define SOLID 0
    #define DOTTED 1
    #define DASHED 2
    /* 三原色 */
    #define BLUE 4
    #define GREEN 2
    #define RED 1
    /* 混合色 */
    #define BLACK 0
    #define YELLOW (RED | GREEN)
    #define MAGENTA (RED | BLUE)
    #define CYAN (BLUE | GREEN)
    #define WHITE (RED | GREEN | BLUE)

    // 定义颜色的字符串
    const char *colors[8] = {"black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"};

    // 定义位字段
    struct box_props
    {
        bool opaque : 1;               // 1 为透明，0 为不透明
        unsigned int fill_color : 3;   // 左侧位表示蓝色，中间位绿色，右侧位红色，通过三原色调色表示其他色
        unsigned int : 4;              // 填充位
        bool show_border : 1;          // 1 为可见，0 为不可见
        unsigned int border_color : 3; // 同 fill_color
        unsigned int border_style : 2; // 0、1、2分别表示实线、点线、虚线
        unsigned int : 2;              // 填充位
    };

    // 显示设置的函数
    void show_setting(struct box_props *pb)
    {
        printf("Box is %s.\n", pb->opaque == true ? "opaque" : "transparent");
        printf("The fill color is %s.\n", colors[pb->fill_color]);
        printf("Border %s.\n", pb->show_border == true ? "shown" : "not shown");
        printf("The border color is %s.\n", colors[pb->border_color]);
        printf("The border style is ");
        switch (pb->border_style)
        {
        case SOLID:
            printf("solid.\n");
            break;
        case DOTTED:
            printf("dotted.\n");
            break;
        case DASHED:
            printf("dashed.\n");
            break;
        default:
            printf("unknown.\n");
        }
    }

    int main(void)
    {
        /* 创建并初始化 box_props 结构 */
        struct box_props box = {true, YELLOW, true, GREEN, DASHED};

        printf("Original box settings:\n");
        show_setting(&box);

        box.opaque = false;
        box.fill_color = WHITE;
        box.border_color = MAGENTA;
        box.border_style = SOLID;
        printf("\nModified box settings:\n");
        show_setting(&box);
        return 0;
    }
    ```

##### **对齐特性**

- **对齐特性介绍**

  > 1、**C11**的**对齐特性**比**用位填充字节**更自然，它们还代表 C 在处理**硬件相关问题**上的能力。在这种上下文中，**对齐**指的是**如何安排对象在内存中的位置**  
  > 2、例如，为了**效率最大化**，系统可能要把一个**double 类型值**存储在**4 字节内存地址**上，但却允许把**char**存储在**任意地址**  
  > 3、大多数程序员都对**对齐**不以为然，但是，有些情况又**受益于对齐控制**。例如把**数据**从一个**硬件位置**转移到**另一个位置**，或者**调用指令**同时操作**多个数据项**

- **\_Alignof 运算符**

  > 1、`_Alignof`**运算符**给出**一个类型**的**对齐要求**，在**关键字**`_Alignof`后面的**圆括号**写上**类型名**即可：`size_t d_align = _Alignof(float);`  
  > 2、假设**d_align**的**值是 4**，意思是**float 类型对象**的**对齐要求是 4**。也就是说，**4**是存储该类型值**相邻地址**的**字节数**  
  > 3、一般而言，**对齐值**都应该是**2 的非负整数次幂**。**较大的对齐值**被称为**stricter**或**stronger**，**较小的对齐值**被称为**weaker**

- **\_Alignas 说明符**

  > 1、`_Alignas`**说明符**指定**一个变量**或**一个类型**的**对齐值**。但是，**不应该要求该值小于基本对齐值**  
  > 2、例如，如果**float 类型**的**基本对齐值是 4**，就**不该请求其对齐值**为**1 或 2**  
  > 3、该**说明符**用作**声明的一部分**，说明符后面的**圆括号**内包含**对齐值的类型**：`_Alignas(double) char c1;`、`_Alignas(8) char c2;`、`char _Alignas(double) c_arr[sizeof(double)];`  
  > 4、注意，**Clang 3.2 版本**要求`_Alignas(type)`说明符**在类型说明符后面**，如上**第三个示例**。但后来**Clang 3.3 版本**也支持了**前两种在后的顺序**，**GCC 4.7.3 版本**也能识别**这两种顺序**

- **使用示例**

  ```c
  #include <stdio.h>

  int main(void)
  {
      double dx;
      char ca;
      char cx;
      double dz;
      char cb;
      char _Alignas(double) cz; // 设置变量 cz 的对齐值为double类型的对齐值

      printf("char alignment:   %zd\n", _Alignof(char));   // 利用_Alignof()获取char类型对齐值
      printf("double alignment: %zd\n", _Alignof(double)); // 利用_Alignof()获取double类型对齐值
      printf("cz alignment:     %zd\n", _Alignof(cz));     // 利用_Alignof()获取cz类型对齐值
      printf("&dx: %p\n", &dx);
      printf("&ca: %p\n", &ca);
      printf("&cx: %p\n", &cx);
      printf("&dz: %p\n", &dz);
      printf("&cb: %p\n", &cb);
      printf("&cz: %p\n", &cz);
      return 0;
  }
  ```

  ```
  char alignment:   1
  double alignment: 8
  cz alignment:     8
  &dx: 000000000061FE18
  &ca: 000000000061FE17
  &cx: 000000000061FE16
  &dz: 000000000061FE08
  &cb: 000000000061FE07
  &cz: 000000000061FE00
  ```

---

#### **C 预处理器和 C 库**

---

<div class="success">

> **章节概要**：翻译程序的第一步；明示常量：`#define`；明示常量简介；记号；重定义常量；在`#define`中使用参数；用宏参数创建字符串：`#`运算符；预处理器粘合剂：`##`运算符；变参宏：`...`和`__VA_ARGS__`；文件包含：`#include`；使用头文件；头文件常用形式；头文件的使用价值；其他指令；`#undef`指令；从 C 预处理器角度看已定义；条件编译；预定义宏；`#line`和`#error`；`#pragma`；泛型选择`_Generic`；函数说明符；内联函数`inline`；`_Noreturn`说明符；C 库；数学库`math.h`；类型变体；`tgmath.h`库；通用工具库`stdlib.h`；断言库`assert.h`；字符串库`string.h`；可变参数库`stdarg.h`

</div>

##### **翻译程序的第一步**

- 在**预处理**之前，**编译器**必须对该程序进行一些**翻译处理**

  > 1、首先，编译器把**源代码**中出现的字符**映射**到**源字符集**。该过程处理**多字节字符**和**三字符序列**——**字符拓展**让 C 更加**国际化**  
  > 2、编译器定位每个**反斜杠后面跟着换行符**的实例(注意此处的换行符指的是按下`Enter`在源代码中换行产生的字符，而不是符号表征`\n`)，并**删除它们**。也就是说，将后面示例中的**多个物理行**转换成**一个逻辑行**  
  > 3、编译器把文本划分成**预处理记号序列**、**空白序列**和**注释序列**(记号是由空格、制表符或换行符分隔的项)。这里要注意的是，编译器将**用空格替换每一条注释**  
  > 4、最后，程序已经准备好进入**预处理阶段**，**预处理器**查找一行中**以**`#`**开始**的**预处理指令**

  ```c
  // 多个物理行
  printf("That's wond\
        erful!\n");
  // 将被替换为一个逻辑行
  printf("That's wonderful!\n");

  // 源码中的注释
  int/*这是一条注释*/fox;
  // 将被替换为空格
  int fox;
  ```

##### **明示常量：#define**

- `#define`**预处理器指令**和其他预处理器指令一样，以`#`作为**一行的开始**。之前我们大量使用`#define`指令来定义**明示常量**(符号常量)，但该指令还有**许多其他用途**

- **明示常量简介**

  > 1、`#define`**指令**可以出现在**源文件**的**任何地方**，其定义从**指令出现处**到**文件末尾**有效  
  > 2、**预处理器指令**从`#`**开始**运行，到后面的**第一个换行符为止**。也就是说，指令的长度**仅限一行**(然而，预处理开始前，编译器会把多个物理行处理为一行逻辑行，所以可以使用`\`换行)  
  > 3、每行`#define`都由**三部分组成**。第一部分是`#define`**指令本身**；第二部分是**选定的缩写**，也称为**宏**；第三部分称为**替换列表**或**替换体**  
  > 4、有些**宏**代表**值**，这些**宏**被称为**类对象宏**，C 语言还有**类函数宏**，稍后讨论。**宏的名称**中**不允许有空格**，且必须**遵循 C 变量命名规则**  
  > 5、一旦**预处理器**在程序中找到**宏的实例**后，就会**用替换体代替该宏**(也有例外)。从**宏**变成**最终替换文本**的过程称为**宏展开**

- **简单示例**

  ```c
  #include <stdio.h>

  #define TWO 2
  // 反斜杠利用预处理前的翻译处理规则，把定义延续到下一行
  #define OW "Consistency is the last refuge of the unimagina\
  tive. - Oscar Wilde\n"

  #define FOUR TWO*TWO
  #define PX printf("X is %d.\n", x);
  #define FMT "X is %d.\n"

  int main(void)
  {
      int x = TWO;
      // 调用类函数宏 PX
      PX;
      x = FOUR;
      // 调用 FMT 字符串
      printf(FMT, x);
      printf("%s", OW);
      // 字符串内并不会调用宏，仅为正常字符
      printf("TWO: OW\n");
      return 0;
  }
  ```

  ```
  X is 2.
  X is 4.
  Consistency is the last refuge of the unimaginative. - Oscar Wilde
  TWO: OW
  ```

- **记号**

  > 1、从**技术角度**看，可以把**宏的替换体**看做是**记号型字符串**，而不是**字符型字符串**  
  > 2、C**预处理器记号**是宏定义的**替换体**中**单独的词**，用**空白**把这些**词**分开  
  > 3、例如`#define FOUR 2*2`中，该宏定义**有一个记号**，即`2*2`；在`#define SIX 2 * 3`中，则**有三个记号**，即`2`、`*`、`3`  
  > 4、如果**预处理器**把该替换体解释为**字符型字符串**，则用`2 * 3`替换**SIX**，即**额外的空格是替换体的一部分**。如果将其解释为**记号型字符串**，则用**3 个的记号**`2`、`*`、`3`(将原先空格视为各记号的分隔符)来替换**SIX**  
  > 5、**实际应用**中，也有一些 C 编译器把**宏替换体**视为**字符串**而不是**记号**。只有在**更复杂的情况**下，二者的区别才有**实际意义**

- **重定义常量**

  > 1、假设先**把 LIMIT 定义为 20**，稍后在该文件中**又把它定义为 25**，这个过程称为**重定义常量**  
  > 2、不同的**实现**采用不同的**重定义方案**，除非**新定义**与**旧定义**相同，否则**可能将其视为错误**。另外一些实现**允许重定义**，但会**给出警告**  
  > 3、**ANSI**标准采用**第一种方案**，即**新旧定义完全相同**才允许重定义。此处的**相同**指**相同的记号**，如`#define FOUR 2*2`与`#define FOUR 2 * 2`**并不相同**  
  > 4、如果需要**重定义宏**，可以使用`#undef`**指令**(稍后介绍)

##### **在 #define 中使用参数**

- **简介概述**

  > 1、在`#define`中**使用参数**可以创建**外形和作用与函数类似**的**类函数宏**  
  > 2、**带有参数的宏**看起来很像**函数**，因为这样的宏**也使用圆括号**  
  > 3、**类函数宏定义**的圆括号内可以有**一个或多个参数**，随后这些**参数**出现在**替换体**中

- **示例程序**

  ```c
  #include <stdio.h>

  #define SQUARE(X) X *X

  int main(void)
  {
      int x = 5;
      int z;
      printf("x = %d\n", x);
      z = SQUARE(x);
      printf("SQUARE(x)：     %d\n", z);
      z = SQUARE(2);
      printf("SQUARE(x)：     %d\n", z);
      z = SQUARE(x + 2);
      printf("SQUARE(x + 2)： %d\n", z);
      z = SQUARE(++x);
      printf("SQUARE(++x)：   %d\n", z);
      return 0;
  }
  ```

  ```
  x = 5
  SQUARE(x)：     25
  SQUARE(x)：     4
  SQUARE(x + 2)： 17
  SQUARE(++x)：   42
  ```

  > 1、前两行的结果与预期相符，但第三行的`SQUARE(x + 2)`的结果为**17**，你可能认为其结果是**7\*7 = 49**。实际原因是，**预处理器不做计算**、**不求值**，**只替换字符序列**
  > 2、因此**预处理器**把**出现 x 的地方**都**替换为 x+2**，即`SQUARE(x + 2)`表达式的**值为 5+2\*5+2 = 17**。要解决这个问题，需要将**宏定义**改为`#define SQUARE(x) (x)*(x)`，这样表达式的**值为(5+2)\*(5+2) = 49**。因此，使用**足够多的括号**可以确保**运算和结合**的**正确顺序**  
  > 3、尽管如此，还是**无法避免**最后一种情况，`SQUARE(++x)`变成了`++x*++x`，**递增了两次 x**。此处运算为**6\*7 = 42**，有些编译器会在**乘法运算之前**完成**第二次递增**，结果可能为**7\*7 = 49**。但无论哪种解释，结果**都不是**我们想要的**6\*6 = 36**，因此应**避免**用`++x`等**递增递减运算符**作为**宏参数**

- **用宏参数创建字符串：#运算符**

  - **引入**

    > 1、有`#define PSQR(X) printf("the square of X is %d", ((X) * (X)));`的**宏定义**  
    > 2、假设这样**使用宏**：`PSQR(8)`，输出为`the square of X is 64`  
    > 3、此时**双引号字符串**内的**X**被视为**普通文本**，而不是一个**可被替换的记号**

  - `#`**运算符**

    > 1、C 允许在**字符串**中包含**宏参数**。在**类函数宏**的**替换体**中，`#`作为一个**预处理运算符**，可以把**记号**转换成**字符串**  
    > 2、例如如果**X**是一个**宏形参**，那么`#X`就是转换为**字符串 X 的形参名**。这个过程称为**字符串化**  
    > 3、例如有`#define PSQR(X) printf("the square of " #X " is %d", ((X) * (X)));`的**定义**  
    > 4、此时定义`y=5`，`PSQR(y);`的**输出为**`the square of y is 25`；`PSQR(2 + 4);`的**输出为**`the square of 2 + 4 is 36`

- **预处理器粘合剂：##运算符**

  > 1、与`#`类似，`##`**运算符**可以用于**类函数宏**的替换部分。而且，`##`还可用于**类对象宏**的替换部分  
  > 2、`##`把**两个记号**组合成**一个记号**。例如有`#define XNAME(N) x ## N`的定义  
  > 3、此时`XNAME(y)`将**展开为**`xy`；`XNAME(4)`将**展开为**`x4`

- **变参宏：...和\_\_VA_ARGS\_\_**

  > 1、一些**函数**(如`printf()`)接受**数量可变的参数**。`stdvar.h`**头文件**提供了工具(稍后介绍)，让用户自定义带**可变参数**的**函数**  
  > 2、**C99/C11**也对**宏**提供了这样的工具，通过把**宏参数列表**中**最后的参数**写成`...`来实现这一功能。这样，**预定义宏**`__VA_ARGS__`可用在**替换部分**中，表明省略号**代表什么**  
  > 3、例如有`#define PR(X, ...) printf("Message " #X "：" __VA_ARGS__)`的**定义**  
  > 4、此时`PR(1, "hello");`的**输出为**`Message 1： hello`；`PR(2)`的**输出为**`Message 2：`

##### **文件包含：#include**

- **简介概述**

  > 1、当**预处理器**发现`#include`指令时，会**查看**后面的**文件名**，并把**文件的内容**包含到**当前文件**中(即替换源文件中的`#include`指令)  
  > 2、`#include`有**两种形式**：`#include <stdio.h>`和`#include "mystuff.h"`，即**尖括号**和**双引号**  
  > 3、**尖括号**告诉**预处理器**在**标准系统目录**中查找文件，**双引号**告诉**预处理器**首先在**当前目录**中查找，后查找**标准系统目录**  
  > 4、**集成开发环境**(**IDE**)也有**标准路径**或**系统头文件的路径**。许多**IDE**提供**菜单选项**，**指定**用**尖括号**时的**查找路径**。使用**双引号**时有些**编译器**会搜索**源代码文件所在目录**，有的会搜索**当前工作目录**，有的会搜索**项目文件所在目录**  
  > 5、**ANSI C**不为文件提供**统一的目录模型**，因为不同计算机所用**系统不同**。一般而言，**命名文件**的方法**因系统而异**，但是**尖括号**和**双引号**的规则**与系统无关**  
  > 6、C 语言习惯用`.h`**后缀**表示**头文件**，这些文件**包含需要放在程序顶部的信息**。头文件经常包含一些**预处理器指令**  
  > 7、包含一个**大型头文件**不一定显著增加程序大小。在大部分情况下，**头文件的内容**是**编译器**生成最终代码时**所需要的信息**，而**不是添加到最终代码中的材料**

- **使用头文件**

  - 浏览任何一个**标准头文件**都可以了解**头文件**的**基本信息**，头文件中最常用的形式如下

  - **头文件常用形式**

    > 1、**明示常量**：例如**头文件**`stdio.h`中定义的**EOF**、**NULL**和**BUFSIZE**(标准 I/O 缓冲区大小)  
    > 2、**宏函数**：例如`getchar()`通常用`getc(stdin)`定义，而`getc()`经常用于定义**较复杂的宏**，**头文件**`ctype.h`通常包含**ctype 系列函数**的**宏定义**  
    > 3、**函数声明**：例如**头文件**`string.h`，包含**字符串系列函数**的**函数声明**  
    > 4、**结构模板定义**：**标准 I/O 函数**使用**FILE 结构**，该结构中包含了**文件和文件缓冲区**相关的信息。**FILE 结构**在**头文件**`stdio.h`中  
    > 5、**类型定义**：**标准 I/O 函数**使用**指向 FILE 的指针**作为参数。通常，**头文件**`stdio.h`用`#define`或`typedef`把**FILE**定义为**指向结构的指针**。类似的，`size_t`和`time_t`定义在头文件中

  - **头文件的使用价值**

    > 1、许多程序员都在程序中**使用自己开发的标准头文件**。如果**开发一系列相关的函数或结构**，那么这种方法特别有价值  
    > 2、另外，还可以使用头文件**声明外部变量**供**其他文件共享**。在**源代码**中定义一个**文件作用域**的**外部链接变量**`int a = 0;`，然后在**与之关联的头文件**中进行**引用式声明**`extern int a;`，这样**这行代码**便会出现在**包含了该头文件的其实文件**中  
    > 3、需要包含头文件的另一种情况是，**使用**具有**文件作用域**、**内部链接**和`const`**限定符**的**变量或数组**。`const`防止值被**意外修改**，内部链接`static`意味着每个**包含该头文件的文件**都获得**一份副本**。因此不需要在一个文件中进行**定义式声明**，在其他文件中进行**引用式声明**

##### **其他指令**

- **#undef 指令**

  > 1、`#undef`指令用于**取消已定义的**`#define`**指令**  
  > 2、也就是说，假如有`#define LIMIT 400`，可以通过`#undef LIMIT`**移除上面的定义**。现在就可以把**LIMIT**重新定义为一个新值  
  > 3、如果想使用一个名称，又不确定之前是否已经使用过，为**安全起见**，可以**先用**`#undef`**取消定义**

- **从 C 预处理器角度看已定义**

  ```c
  #define LIMIT 1000          // LIMIT是已定义的
  #define GOOD                // GOOD是已定义的
  #define A(X) ((-(X))*(X))   // A是已定义的
  int q;                      // q不是宏，因此是未定义的
  #undef GOOD                 // GOOD取消定义，是未定义的
  ```

  > 1、**预处理器**在**识别标识符**时，遵循**与 C 相同的规则**(标识符的命名规则)  
  > 2、当**预处理器**在**预处理器指令**中发现一个**标识符**时，会将该**标识符**当做**已定义的**或**未定义的**。  
  > 3、这里的**已定义**表示**由预处理器定义**。如果**标识符**是同一个文件中由前面的`#define`**创建的一个宏名**，而且没有用`#undef`**关闭**，那么该**标识符**是**已定义**的  
  > 4、如果**标识符不是宏**，假设是一个**文件作用域**的**C 变量**，那么该标识符**对预处理器而言**就是**未定义的**

- **条件编译**

  - 可以使用**其他指令**创建**条件编译**。也就是说，可以使用这些指令告诉**编译器**根据**编译时的条件**而**执行或忽略**信息(或代码)块

  - `#ifdef`、`#else`、`#endif`**指令**

    ```c
    // 使用语法
    #ifdef MAVIS              // 如果已经用 #define 定义了 MAVIS，则执行下面的指令
        #include "horse.h"
        #define STABLES 5
    #else                     // 如果没有用 #define 定义 MAVIS，则执行下面的指令
        #include "cow.h"
        #define STABLES 15
    #endif

    // 实际使用示例
    #define JUST_CHECKING 1
    int total = 0;
    for(int i = 1; i <= LIMIT; i++)
    {
        total += 2 * i*i + 1;
    #ifdef JUST_CHECKING
        printf("i=%d total=%d\n", i, total);
    #endif
    }
    ```

    > 1、这里使用的**较新的编译器和 ANSI 标准支持**的**缩进格式**。如果使用**旧的编译器**，则必须**左对齐**所有指令或**至少左对齐**`#`号  
    > 2、`#ifdef`指令说明，如果预处理器**已定义**了后面的**标识符**，则执行`#else`**或**`#endif`**指令之前**的**所有指令**  
    > 3、如果预处理器**未定义**后面的**标识符**，且有`#else`指令，则执行`#else`**和**`#endif`**之间**的**所有代码**

  - `#ifndef`**指令**

    > 1、`#ifndef`**指令**与`#ifdef`**指令**用法类似，也可以和`#else`、`#ifdef`**一起使用**，但他们的**逻辑相反**  
    > 2、`#ifndef`判断后面的**标识符**是否是**未定义的**，常用于**定义之前未定义的常量**

  - `#if`**和**`#elif`**指令**

    > 1、`#if`指令**很像**C 语言的`if`，后面跟**整型常量表达式**，如果**表达式为非零**，则**表达式为真**。同样`#elif`也**很像**C 语言的`else if`  
    > 2、**较新的编译器**提供另一种方法**测试名称是否已定义**，即用`#if defined (VAX)`代替`#ifdef VAX`  
    > 3、这里的`defined`是一个**预处理运算符**，如果它的参数用`#defined`**定义过**，则**返回 1**，否则**返回 0**。这种方法的好处是可以和`#elif`一起使用

- **预定义宏**

  - C 规定了一些**预定义宏**，如下表：

    |          宏          | 含义                                                         |
    | :------------------: | ------------------------------------------------------------ |
    |     \_\_DATE\_\_     | 预处理的日期(Mmm dd yyyy 形式的字符串字面量，如 Nov 23 2013) |
    |     \_\_FILE\_\_     | 表达当前源代码文件名的字符串字面量                           |
    |     \_\_LINE\_\_     | 表示当前源代码文件中行号的整型常量                           |
    |     \_\_STDC\_\_     | 设置为 1 时，表明实现遵循 C 标准                             |
    | \_\_STDC_HOSTED\_\_  | 本机环境设置为 1，否则设置为 0                               |
    | \_\_STDC_VERSION\_\_ | 支持 C99 标准，设置为 199901L；支持 C11 标准，设置为 201112L |
    |     \_\_TIME\_\_     | 翻译代码的时间，格式为 hh:mm:ss                              |

  - **C99**提供`__func__`的**预定义标识符**，它展开为一个**代表函数名的字符串**(该函数包含该标识符)。那么，`__func__`必须具有**函数作用域**而不是**文件作用域**，因此`__func__`是**预定义标识符**而不是**预定义宏**

- **#line 和 #error**

  - `#line`指令**重置**`__LINE__`和`__FILE__`宏报告的**行号和文件名**，可以这样使用：

    ```c
    #line 1000            // 把当前行号重置为 1000
    #line 10 "cool.c"     // 把当前行号重置为 10，文件名重置为 cool.c
    ```

  - `#error`指令让**预处理器发出一条错误信息**，该消息包含**指令中的文本**。如果可能的话，**编译过程应该中断**，可以这样使用：

    ```c
    #if __STDC_VERSION__ != 201112L
        #error Not C11
    #endif
    ```

- **#pragma**

  > 1、在现在的编译器中，可以通过**命令行参数**或**IDE 菜单**修改**编译器的一些设置**。`#pragma`把**编译器指令**放入**源代码**中  
  > 2、例如在开发**C99**时，**标准**被称为**C9X**，可以使用下面的**编译指示**让编译器支持**C9X**：`#pragma c9x on`  
  > 3、一般而言，**编译器**都有自己的**编译指示集**。例如，**编译指示**可能用于控制分配给自动变量的**内存量**，或者设置错误检查的**严格程度**，或者**启用非标准语言特性**等  
  > 4、**C99**还提供`_Pragma`**预处理器运算符**，该运算符把**字符串**转换成普通的**编译指示**。该运算符**不使用**`#`**符号**，所以可以把它**作为宏展开的一部分**  
  > 5、例如`_Pragma("nonstandardtreatmenttypeB on")`**等价于**`#pragma nonstandardtreatmenttypeB on`

- **泛型选择 \_Generic**

  - **引入**

    > 1、在程序设计中，**泛型编程**指那些**没有特定类型**，但是一旦**指定一种类型**，就可以**转换成指定类型**的代码  
    > 2、例如在**C++**模板中可以创建**泛型算法**，然后编译器**根据指定的类型**自动使用**实例化代码**  
    > 3、但是 C 没有这种功能。然而**C11**新增了一种表达式，叫做**泛型选择表达式**，可根据**表达式的类型**选择一个值  
    > 4、泛型选择表达式**不是预处理器指令**，但是在一些**泛型编程**中它常作`#define`**宏定义**的一部分

  - `_Generic`

    > 1、这是一个**泛型选择表达式**的示例：`_Generic(x, int:0, float:1, double:2, default:3)`  
    > 2、`_Generic`是**C11**的关键字，后面的**圆括号**中包含多个用**逗号分隔**的**项**。第一个项是一个**表达式**，后面的每个项都由**一个类型**、**一个冒号**和**一个值**组成  
    > 3、**第一个项**的**类型**匹配哪个**标签**，**整个表达式的值**就是**该标签后的值**。如上面例子的**x**为**int 类型**，则值为`int:`**后的值**(即 0)，如果没有类型匹配的标签，表达式的值就是`default:`**后的值**  
    > 4、**泛型选择语句**与`switch`语句**类似**，只是前者用**表达式的类型**匹配标签，后者用**表达式的值**匹配标签  
    > 5、下面是一个把**泛型选择语句**与**宏定义**组合的例子：

    ```c
    /* 使用 \符号 把一条逻辑行分为多条物理行 */
    #define MYTYPE(X) _Generic((X),\
        int: "int",\
        float: "float",\
        double: "double",\
        default: "other"\
    )
    ```

##### **函数说明符**

- **内联函数简介**

  > 1、通常，**函数调用**都有一定的**开销**，因为函数的**调用过程**包含**建立调用**、**传递参数**、**跳转到函数代码返回**  
  > 2、使用**宏**使**代码内联**，可以**避免**这样的**开销**。**C99**还提供另一种方法：**内联函数**  
  > 3、**C99**标准中对其的叙述是：把**函数**变成**内联函数**意味着**尽可能快地调用**该函数，其具体效果由实现定义。因此把函数变成**内联函数**，**编译器**可能会用**内联代码**替换**函数调用**，并执行一些**其他的优化**，也**可能不起作用**

- **创建内联函数**

  ```c
  #include <stdio.h>
  inline static void eatline()        // 内联函数定义/原型
  {
      while(getchar() != '\n')
          continue;
  }
  ```

  > 1、**创建内联函数的定义**有多种方法，**标准规定**一个具有**内部链接**的函数可以成为**内联函数**，还规定**内联函数的定义**与**调用该函数的代码**必须在**同一文件**  
  > 2、因此，最简单的办法是使用**函数说明符**`inline`和**存储类别说明符**`static`来**创建内联函数**  
  > 3、由于并**未给内联函数预留单独的代码块**，所以**无法获得**内联函数的**地址**(实际上可以获得，不过这样做之后，编译器会生成一个非内联函数)。另外，**内联函数**无法在**调试器**中显示  
  > 4、**内联函数**应该**比较短小**，较长的函数变成内联并为节约多少时间，因为**执行函数体**的时间比**调用函数**的时间长得多

- **\_Noreturn 函数**

  > 1、**C99**新增`inline`关键字时，它是唯一的函数说明符。后来**C11**新增了**第二个函数说明符**`_Noreturn`  
  > 2、`_Noreturn`表明**调用完成后函数不返回主函数**。`exit()`函数是`_Noreturn`函数的**一个示例**，一旦调用`exit()`，它便**不会再返回**主调函数  
  > 3、`_Noreturn`的目的是告诉**用户和编译器**，这个特殊的函数不会把控制返回主调程序。**告诉用户避免滥用**该函数，**通知编译器可优化**这些代码

##### **C 库**

- 最初，并没有**官方的 C 库**。后来**基于 UNIX 的 C 实现**成为了**标准**，**ANSI C**委员会主要**以这个标准为基础**，开发了一个**官方的标准库**。在意识到 C 语言应用范围扩大后，委员会**重新定义了这个库**，使之可以**应用于其他系统**

- **数学库 math.h**

  | 函数原型                         | 描述(1 弧度 = 180/π = 57.296°)           |
  | -------------------------------- | ---------------------------------------- |
  | double acos(double x)            | 返回余弦值为 x 的角度(0 ~ π 弧度)        |
  | double asin(double x)            | 返回正弦值为 x 的角度(-π/2 ~ π/2 弧度)   |
  | double atan(double x)            | 返回正切值为 x 的角度(-π/2 ~ π/2 弧度)   |
  | double atan2(double y, double x) | 返回正切值为 y/x 的角度(-π/2 ~ π/2 弧度) |
  | double cos(double x)             | 返回 x 的余弦值，x 的单位为弧度          |
  | double sin(double x)             | 返回 x 的正弦值，x 的单位为弧度          |
  | double tan(double x)             | 返回 x 的正切值，x 的单位为弧度          |
  | double exp(double x)             | 返回 x 的指数函数的值                    |
  | double log(double x)             | 返回 x 的自然对数值                      |
  | double log10(double x)           | 返回 x 的以 10 为底的对数值              |
  | double pow(double x, double y)   | 返回 x 的 y 次幂                         |
  | double sqrt(double x)            | 返回二次根下 x 的值                      |
  | double cbrt(double x)            | 返回三次根下 x 的值                      |
  | double ceil(double x)            | 返回不小于 x 的最小整数值                |
  | double fabs(double x)            | 返回 x 的绝对值                          |
  | double floor(double x)           | 返回不大于 x 的最大整数值                |

- **类型变体**

  > 1、基本的**浮点型数学函数**接受**double 类型**的参数，并**返回 double 类型**的值。当然，也可以把**float**或**long double**参数传递给这些函数，它们也能正常工作  
  > 2、这样做很方便，但**不是最好的处理方式**。例如如果**不需要双精度**，**float**单精度**速度会更快**；**long double 类型**的值传给**double**可能会**损失精度**，值可能**不是原来的值**  
  > 3、**C 标准**专门为**float**和**long double**提供了标准函数，即**原函数名后**加上`f`或`l`**后缀**。因此`sqrtf()`是`sqrt()`的**float 版本**，`sqrtl()`是`sqrt()`的**long double 版本**  
  > 4、可以利用**C11**新增的**泛型选择表达式**定义一个**泛型宏**，根据**参数类型**选择合适的数学函数版本，如下：

  ```c
  #include <stdio.h>
  #include <math.h>

  // 主体为 _Generic(X) (X)，注意分辨，_Generic部分用于选择版本(即函数名)，与后面的(X)拼接形成函数
  #define SQRT(X) _Generic((X),\
      long double: sqrtl,\
      float: sqrtf,\
      default: sqrt)(X)
  // 这样定义，在调用时只需要调用 SQRT(X) 就可以自动选择最合适的版本
  ```

- **tgmath.h 库**

  > 1、**C99**提供的`tgmath.h`头文件中定义了**泛型类型宏**，其效果与上面**类型变体**的程序示例**类似**  
  > 2、`tgmath.h`创建一个**泛型类型宏**，与**原来 double 版本**的函数名**同名**。其会根据**参数类型**自动选择**展开对应版本**  
  > 3、`complex.h`中声明了与**复数运算**相关的函数，例如`csqrtf()`、`csqrt()`、`csqrtl()`，也分别对应**不同版本**。如果提供这些支持，`tgmath.h`中的`sqrt()`宏**也能展开**为相应的**复数平方根函数**  
  > 4、如果包含`tgmath.h`，要调用`sqrt()`**函数**而不是`sqrt()`**宏**，可以把被调用的函数名**括起来**：`(sqrt)(x)`

- **通用工具库 stdlib.h**

  - `exit()`**和**`atexit()`**函数**

    - **引入**

      > 1、在前面的章节已经使用过`exit()`函数。而且，在`main()`**返回系统时**将自动调用`exit()`  
      > 2、**ANSI 标准**还新增了一些不错的功能，注重最重要的是**可以指定在执行**`exit()`**时**调用的**特定函数**  
      > 3、`atexit()`通过**注册要在退出时调用的函数**来**提供这一特性**，`atexit()`函数接受一个**函数指针**作为参数

    - `atexit()`**的用法**

      > 1、函数使用**函数指针**。要使用`atexit()`**函数**，只需把**退出时要调用的函数地址**传递给`atexit()`即可(**函数名**作为**函数参数**时相当于**函数地址**)  
      > 2、**传入参数**后，`atexit()`**注册**函数列表中的**函数**，当**调用**`exit()`时就会**执行这些函数**。**ANSI**保证，在这个**列表中至少可以放 32 个函数**  
      > 3、最后**调用**`exit()`时，`exit()`会**执行这些函数**。**执行顺序**与**列表中函数顺序相反**，即**最后添加的函数最先执行**  
      > 4、`atexit()`注册的函数**应该不带任何参数**且**返回类型为 void**。通常这些函数会执行一些**清理任务**，如**更新监视程序的文件**或**重置环境变量**

    - **程序示例**

      ```c
      #include <stdio.h>
      #include <stdlib.h>

      void sign_off(void)
      {
          puts("Thus terminates another magnificent program from");
          puts("Seesaw Software");
      }

      void too_bad(void)
      {
          puts("Seesaw Software extends its heartfelt condolences");
          puts("to you upon the failure of your program");
      }

      int main(void)
      {
          int n;
          atexit(sign_off); // 注册 sign_off 函数
          puts("Enter an integer:");
          if (scanf("%d", &n) != 1)
          {
              puts("That's no integer!");
              atexit(too_bad); // 注册 too_bad 函数
              exit(EXIT_FAILURE);
          }
          printf("%d is %s\n", n, (n % 2 == 0) ? "even" : "odd");
          return 0;
      }
      ```

      ```
      Enter an integer:
      212
      212 is even
      Thus terminates another magnificent program from
      Seesaw Software
      ```

      ```
      Enter an integer:
      a
      That's no integer!
      Seesaw Software extends its heartfelt condolences
      to you upon the failure of your program
      Thus terminates another magnificent program from
      Seesaw Software
      ```

  - `qsort()`**函数**

    - `qsort()`**的用法**

      > 1、对**较大型的数组**而言，**快速排序**算法是**最有效的排序算法之一**。**快速排序**算法在 C 实现的名称是`qsort()`  
      > 2、`qsort()`函数**排序数组的数据对象**，其原型为`void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));`  
      > 3、**第一个参数**是**指针**，指向待排序**数组的首元素**(void 类型指针，可以引入任何类型数组)  
      > 4、**第二个参数**是**待排序项的数量**。函数原型将该值**转换为 size_t 类型**  
      > 5、**第三个参数**是待排序数组**每个元素的大小**(由于第一个参数转换为 void 指针，所以函数不知道每个元素的大小，因此需要补偿该信息)  
      > 6、**第四个参数**是一个**指向函数的指针**，指向一个**自定义的比较函数**，用于**确定排序的顺序**  
      > 7、**自定义的比较函数**应接受**两个参数**，分别指向**待比较两项的指针**。**返回值**为**int 类型**，**返回正数**则告知`qsort()`**交换**，相等**返回 0**，**返回负数**则**不操作**(见示例程序)

    - **程序示例**

      ```c
      /* 程序自动随机生成一组浮点数数组，并排序 */
      #include <stdio.h>
      #include <stdlib.h>

      #define NUM 40 // 数组元素数

      // 随机生成数组
      void fillarray(double ar[], int n)
      {
          for (int index = 1; index < n; index++)
              ar[index] = (double)rand() / ((double)rand() + 0.1);
      }

      // 打印数组
      void showarray(double ar[], int n)
      {
          int index;
          for (index = 0; index < n; index++)
          {
              printf("%9.4f ", ar[index]);
              if (index % 6 == 5)
                  putchar('\n');
          }
          if (index % 6 != 0)
              putchar('\n');
      }

      // 自定义排序函数，按从小到大排序
      int mycomp(const void *p1, const void *p2)
      {
          // 要使用指向对应类型(double)的指针来访问这两个值
          const double *a1 = (const double *)p1;
          const double *a2 = (const double *)p2;

          // 如果此处符号改为 > ，则从大到小排序
          if (*a1 < *a2)
              return -1;
          else if (*a1 == *a2)
              return 0;
          else
              return 1;
      }

      int main(void)
      {
          double vals[NUM];
          fillarray(vals, NUM);
          puts("Random list:");
          showarray(vals, NUM);
          qsort(vals, NUM, sizeof(double), mycomp);
          puts("\nSorted list:");
          showarray(vals, NUM);
          return 0;
      }
      ```

      ```
      Random list:
        0.0000    0.0022    0.2390    1.2191    0.3910    1.1021
        0.2027    1.3835    20.2830   0.2508    0.8880    2.2179
        25.4866   0.0236    0.9308    0.9911    0.2507    1.2802
        0.0939    0.9760    1.7217    1.2054    1.0326    3.7892
        1.9635    4.1137    0.9241    0.9971    1.5582    0.8955
        35.3798   4.0579    12.0460   0.0096    1.0109    0.8506
        1.1529    2.3614    1.5876    0.4825

      Sorted list:
        0.0000    0.0022    0.0096    0.0236    0.0939    0.2027
        0.2390    0.2507    0.2508    0.3910    0.4825    0.8506
        0.8880    0.8955    0.9241    0.9308    0.9760    0.9911
        0.9971    1.0109    1.0326    1.1021    1.1529    1.2054
        1.2191    1.2802    1.3835    1.5582    1.5876    1.7217
        1.9635    2.2179    2.3614    3.7892    4.0579    4.1137
        12.0460   20.2830   25.4866   35.3798
      ```

- **断言库 assert.h**

  - `assert()`**宏**

    > 1、`assert.h`**断言库**是一个**辅助调试程序**的小型库  
    > 2、`assert()`**宏**接受一个**整形表达式**作为参数。如果表达式**求值为假**，`assert()`则在**标准错误流**(stderr)中**写入一条错误信息**，并**调用**`abort()`**函数**(定义在`stdlib.h`)**终止程序**  
    > 3、`assert()`是为了**标识**出程序中**某些条件为真**的**关键位置**，如果为**假**则**终止程序**。**终止程序**后会显示**失败的测试**、**包含测试的文件名和行号**  
    > 4、使用`assert()`有**几个好处**：它不仅能**自动标识文件**和出问题的**行号**，还能**无需更改代码做到自动开启或关闭**  
    > 5、如果认为已经**排除了 bug**，可以把`#define NDEBUG`**宏**写在`#include <assert.h>`前面，重新编译后就会**禁用所有**`assert()`语句

  - `_Static_assert`**宏**

    > 1、`assert()`是在**运行时进行检查**。**C11**新增的`_Static_assert()`可以在**编译时检查**  
    > 2、因此，`assert()`会导致**运行中**的程序**终止**，而`_Static_assert()`会导致程序**无法通过编译**  
    > 3、`_Static_assert()`接受**两个参数**：第一个是**整型常量表达式**，第二个是**一个字符串**  
    > 4、如果第一个表达式**求值为假**，编译器会**显示字符串**并且**不编译程序**  
    > 5、使用示例：`_Static_assert(CHAR_BIT == 16, "16-bit char falsely assumed")`(包含`limits.h`)

- **字符串库 string.h**

  - **引入**

    > 1、不能把一个**数组赋给**另一个**数组**，所以要通过**循环**把数组中的**每个元素赋给**另一个数组**相应的元素**  
    > 2、有一个**例外的情况**：使用`strcpy()`和`strncpy()`函数来**处理字符数组**。此外`memcpy()`和`memmove()`函数提供**类似的方法**处理**任何类型的数组**

  - `memcpy()`**与**`memmove()`

    > 1、两个**函数的原型**：`void *memcpy(void *restrict s1, const void *restrict s2, size_t n);`与`void memmove(void *s1, const void *s2, size_t n);`  
    > 2、这**两个函数**都从**s2**指向的位置**拷贝 n 字节**到**s1**指向的位置，且**都返回 s1 的值**  
    > 3、`memcpy()`的参数**带关键字**`restrict`，即其**假设两个内存区域之间没有重叠**；而`memmove()`不做这样的假设，所以**拷贝过程**类似先把所有字节拷贝到一个**临时缓存区**，再拷贝到**最终目的地**  
    > 4、如果使用`memcpy()`时**两区域出现重叠**，该行为是**未定义的**。这意味着函数**可能正常工作**，也**可能失败**  
    > 5、由于函数被设计用于**任何数据类型**，所以使用**指向 void 的指针**。因此，**第三个参数**的**字节数**应指明待拷贝字节数，如`10 * sizeof(double)`

- **可变参数库 stdarg.h**

  - 本章前面提到过**变参宏**，而`stdarg.h`头文件为**函数**提供了一个**类似的功能**，但用法较为复杂，**必须按如下步骤进行**：

    > 1、提供一个**使用省略号**的**函数原型**  
    > 2、在**函数定义**中创建一个`va_list`**类型的变量**  
    > 3、用**宏**把该**变量初始化**为一个**参数列表**  
    > 4、用**宏访问参数列表**  
    > 5、用**宏完成清理工作**

  - **提供一个使用省略号的函数原型**

    ```c
    void f1(int n, ...);                    // 有效
    int f2(const char *s, int k, ...);      // 有效
    char f3(char c1, ..., char c2);         // 无效，省略号不在最后
    double f4(...);                         // 无效，没有形参
    /*---------------------------------------------------------*/
    f1(2, 200, 400);                        // 2表示省略号部分接受 2个额外参数
    f1(4, 13, 117, 18, 23)                  // 4表示省略号部分接受 4个额外参数
    ```

    > 1、这种**函数原型**应该有一个**形参列表**，其中**至少有一个形参**和**一个省略号**(省略号应在最右侧)  
    > 2、**最右边的形参**(即省略号左边的形参)有着特殊的作用，标准用**parmN**这个术语来描述**该形参**(`f1()`中 parmN 为 n，`f2()`中 parmN 为 k)  
    > 3、传递给**parmN 形参**的**实际参数**是**省略号部分**代表的**参数数量**，如示例中的调用

  - **创建一个 va_list 类型变量并初始化参数列表**

    ```c
    double sum(int lim, ...)
    {
        va_list ap;         // 声明一个存储参数的对象
        va_start(ap, lim);  // 把 ap 初始化为参数列表
        /*
        后续代码
        */
    }
    ```

    > 1、声明在`stdarg.h`中的`va_list`**类型**代表一种用于存储**形参对应的形参列表**中**省略号部分的数据对象**  
    > 2、**变参函数**的**定义起始部分**类似上述示例，该例中**lim**是**parmN 形参**，表明**变参列表**中**参数数量**  
    > 3、然后使用`va_start()`**宏**，将**参数列表**拷贝到`va_list`**变量**中。宏接受**两个参数**：`va_list`**变量**和**parmN 形参**。如该例为`va_start(ap, lim);`

  - **访问参数列表内容与清理工作**

    > 1、访问**参数列表**的**内容**涉及到另一个**宏**`va_arg()`。其接受**两个参数**：`va_list`**变量**和**一个类型名**  
    > 2、**表示类型的参数**指定**返回的类型**，注意**要与传入参数类型一一对应**  
    > 3、**第一次调用**`va_arg()`返回**参数列表第 1 项**，**第二次调用**返回**第 2 项**，以此类推  
    > 4、最后，应使用`val_end()`**完成清理**，**释放动态分配的内存**，释放后将**不能通过被释放的**`va_list`**变量访问列表**，如有需要访问则需要**重新执行**`va_start()`
    > 5、但因为`val_arg()`不提供**返回之前参数**的方法，所以有必要保存`va_list`**类型变量**的**副本**。使用**C99**新增的`va_copy()`接受**两个**`va_list`**变量**，将**第二个参数**拷贝给**第一个参数**

---

#### **高级数据表示**

---

<div class="success">

> **章节概要**：研究数据表示；结构数组的局限；从数组到链表；优化指针数组；链表引入；使用链表；抽象数据类型(ADT)；建立抽象；建立接口；实现接口；使用接口；队列 ADT；定义队列 ADT；建立接口；实现接口

</div>

##### **研究数据表示**

- **本章总览**

  > 1、学习计算机语言和学习音乐、木工或工程学一样，首先要学会**使用工具**。对目前为止，我们也一直都在**学习各种编程技能**  
  > 2、然而，如果要**提高到更高层次**，**工具是次要的**，真正的挑战是**设计和创建一个项目**  
  > 3、本章将**重点介绍这个更高的层次**，涉及的内容可能会比较难，但这些内容十分有价值  
  > 4、本章还会**介绍一些算法**，即**操控数据的方法**，并进一步研究**设计数据类型**的过程。这是一个把**算法**和**数据表示**相匹配的过程，期间会用到一些常见的**数据形式**，如**队列**、**列表**、**二叉树**  
  > 5、本章还将介绍**抽象数据类型**(ADT)的概念。**抽象数据类型**以**面向问题**而不是**面向语言**的方式，把**解决问题的方法**和**数据表示**结合起来。理解**ADT**可以为学习**面向对象程序设计**和**C++语言**做好准备

- **问题引入**

  > 1、我们来处理一个**数据表示的示例**。假设要编写一个程序，让用户输入**一年内**看过的**所有电影**，要存储**每部影片**的**各种信息**(片名、年份、导演、主演、片长、种类等)  
  > 2、建议使用**一个结构**存储**每部电影**，**一个数组**存储**一年内看过的电影**。为简单起见，我们假定结构**只有两个成员**：**片名**和**评级**  
  > 3、对此，我们按照这种思路编写如下程序：

  ```c
  /* 使用一个结构数组 */
  #include <stdio.h>
  #include <string.h>
  #define TSIZE 45 // 存储片名的数组大小
  #define FMAX 5   // 影片的最大数量

  // 定义结构模板，标记为 film
  struct film
  {
      char title[TSIZE];
      int rating;
  };

  // 之前自定义的 s_gets() 函数
  char *s_gets(char *str, int n)
  {
      int i = 0;
      char *ret_val;
      ret_val = fgets(str, n, stdin);
      if (ret_val)
      {
          while (str[i] != '\0' && str[i] != '\n')
              i++;
          if (str[i] == '\n')
              str[i] = '\0';
          else
              while (getchar() != '\n')
                  continue;
      }
      return ret_val;
  }

  int main(void)
  {
      // 定义结构数组
      struct film movies[FMAX];
      int i = 0, j;

      puts("输入电影名：");
      while (i < FMAX && s_gets(movies[i].title, TSIZE) != NULL && movies[i].title[0] != '\0')
      {
          puts("输入评分<0-10>：");
          scanf("%d", &movies[i++].rating);
          while (getchar() != '\n')
              continue;
          puts("输入下一部电影名(或换行退出)：");
      }
      if (i == 0)
          printf("没有写入数据");
      else
      {
          printf("获取的电影表格：\n");
          for (j = 0; j < i; j++)
              printf("电影：%s，    评分：%d\n", movies[j].title, movies[j].rating);
      }
      return 0;
  }
  ```

- **结构数组的局限**

  > 1、该程序创建了一个**结构数组**，然后把用户输入的**数据存储在数组**中  
  > 2、这样设计程序有点问题。首先，电影名的**字符数组大小**和**整个结构数组大小**可能会不够。当然**可以增加**，但程序却会**浪费很多空间**  
  > 3、另外，一些**编译器**对**自动存储类别变量**(如 movie)的**内存数量**做了**默认限制**，**大型数组**可能会**超过默认设置的值**。可以把数组声明为**静态**或**外部数组**，或者**设置编译器**使用**更大的栈**，但这样并**不能从根本解决问题**  
  > 4、程序**真正的问题**是**数据表示不够灵活**，在**运行时再确定所需内存量**会更好。为此，应使用**动态内存分配**，这样便可以更灵活地分配大小：

  ```c
  #define TSIZE 45 // 存储片名的数组大小
  struct film
  {
      char title[TSIZE];
      int rating;
  };
  // ...
  int n,i;
  struct film *movies;  // 声明指向结构的指针
  // ...
  printf("输入电影的数量：\n");
  scanf("%d", &n);
  movies = (struct film *)malloc(n * sizeof(struct film));  // 使用 malloc() 分配内存
  ```

##### **从数组到链表**

- **进一步优化**

  > 1、对于**上面的例子**，我们可以**进一步优化**。最理想的情况是，用户可以**不确定的添加数据**(而不是事先指定输入多少项)，也**不用分配多余的空间**  
  > 2、这可以通过在**输入每一项后点调用**`malloc()`函数分配**能储存该项的空间**。如果用户**输入 300 部**，就**调用 300 次**`malloc()`  
  > 3、不过，我们又制造了**另一个麻烦**。如果**调用一次**`malloc()`直接分配 300 个**film 结构**，分配的是**连续的内存块**，只需要用一个**单独的指向 struct 变量的指针**，**指向第一个结构**，就能通过**数组表示法**访问**块中的每个结构**。而现在**调用 300 次**`malloc()`,**无法保证**每次调用`malloc()`都能分配到**连续的内存块**，因此你可能需要**300 个指针**，**每个指针**指向一个**单独存储的结构**  
  > 4、**一种解决方法**是创建一个**大型的指针数组**，并在**分配新结构时**逐个**为这些指针赋值**(如示例)  
  > 5、但我们并不打算用这种方法。虽然如果**用不完 500 个指针**，这种办法也**节约了大量内存**，因为**500 个指针的数组**比**500 个结构的数组**所占内存少得多。尽管如此，也还是会**浪费一些空间**，而且还是**有数量上限**

  ```c
  /* 并不完美的解决方案 */
  #define TSIZE 45 // 存储片名的数组大小
  #define FMAX 500 // 影片的最大数量
  struct film
  {
      char title[TSIZE];
      int rating;
  };
  // ...
  struct film *movies[FMAX];  // 定义结构指针数组
  int i;
  // ...
  movies[i] = (struct film *)malloc(sizeof(struct film));
  ```

- **优化指针数组**

  > 1、对于上面的问题，还有一种**更好的方法**。每次使用`malloc()`**为新结构分配空间**时，**也为新指针分配空间**  
  > 2、但是，这样还得需要**另一个指针**来跟踪**新分配的指针**；同样，这个**用于跟踪新指针**的**指针**本身，**又需要**一个指针来跟踪  
  > 3、因此要**重新定义结构**才能解决这个**潜在的问题**。即**每个结构中**，都包含**指向下一个结构的指针**。然后**创建新结构**时，可以把**该结构的地址**存储在**上一个结构的指针**中  
  > 4、简言之，可以**这样定义结构**：

  ```c
  #define TSIZE 45 // 存储片名的数组大小
  struct film
  {
      char title[TSIZE];
      int rating;
      struct film *next;  // 存储下一个结构位置的指针
  };
  ```

- **链表引入**

  > 1、虽然**结构**不能含有**与本身类型相同的结构**，但可以含有**同类型结构的指针**。**这种定义**是**定义链表**的基础，**链表**中的**每一项**都包含着**在何处能找到下一项**的**信息**  
  > 2、学习链表的代码前，先**从概念上理解一个链表**。假设用户输入的**片名**为**Modern TImes**，**等级**为**10**  
  > 3、程序将为**第 1 个 film 类型的结构**分配空间，将**字符串**拷贝到**title 成员**，**数值**拷贝到**rating 成员**。为了表明该结构**后面没有其他结构**，程序要把**指针变量 next**设置为**NULL**(空指针)  
  > 4、当然，还需要一个**单独的指针**存储**第一个结构的指针**(`struct film *head;`)，该指针被称为**头指针**。**头指针**指向**链表中的第一项**  
  > 5、现在，假设用户**输入第二部电影**，则程序为**第 2 个 film 类型的结构**分配空间，把**新结构的地址**存储在**上一个结构**(即第一个结构)的**next 成员**中(擦写了之前的 NULL 值)，并把**第二个结构**中的**next 成员设置为 NULL**，表明该结构目前是**链表最后一个结构**  
  > 6、以此类推，通过**头指针**访问**第一个结构**，就能**一个个访问 next 成员**来访问**下一个结构**，直到**最后一个结构**的**next 为 NULL**

  ![](https://s2.loli.net/2022/10/09/w7tuvRHG5beKsad.png)

- **使用链表**

  - **示例程序**

    ```c
    #include <stdio.h>
    #include <stdlib.h> // 提供 malloc() 的原型
    #include <string.h> // 提供 strcpy() 的原型
    #define TSIZE 45    // 存储片名的数组大小

    // 定义结构模板，标记为 film
    struct film
    {
        char title[TSIZE];
        int rating;
        struct film *next; // 指向链表中的下一个结构
    };

    // 之前定义的 s_gets() 函数
    char *s_gets(char *str, int n)
    {
        int i = 0;
        char *ret_val;
        ret_val = fgets(str, n, stdin);
        if (ret_val)
        {
            while (str[i] != '\n' && str[i] != '\0')
                i++;
            if (str[i] == '\n')
                str[i] = '\0';
            else
                while (getchar() != '\n')
                    continue;
        }
        return ret_val;
    }

    int main(void)
    {
        struct film *head = NULL;    // 链表头指针(第一个结构的位置)
        struct film *prev, *current; // 上一个结构指针与当前结构指针
        char input[TSIZE];           // 临时存储电影名

        // 收集并存储信息
        puts("输入第一个电影的名字：");
        // 输入input无误 且 首字符不为\0
        while (s_gets(input, TSIZE) != NULL && input[0] != '\0')
        {
            current = (struct film *)malloc(sizeof(struct film)); // 为当前指针 current 分配一个 struct film 大小的空间用来存储结构
            if (head == NULL)                                     // 如果 current 是第一个结构
                head = current;                                   // 将 head 头指针指向 current 的位置
            else                                                  // 如果是后续的结构
                prev->next = current;                             // 上一个结构中的 next 指针指向当前 current 的位置
            current->next = NULL;                                 // 将当前结构的 next 成员设置为 NULL，表明是当前链表的最后一个元素
            strcpy(current->title, input);                        // 将临时存储电影名的 input 的内容复制到当前结构的 title 成员
            puts("输入你的评分<1-10>：");
            scanf("%d", &current->rating);
            while (getchar() != '\n')
                continue;
            puts("输入下一个电影名(或换行退出)");
            prev = current; // 将表示上一个结构位置的指针 prev 指向 current
        }

        // 打印电影列表
        if (head == NULL) // 头指针仍然为NULL，则没有结构
            printf("没有数据写入");
        else
            printf("这是你的电影列表：\n");
        current = head;         // 让 current 指向 head 头指针
        while (current != NULL) // 只要 current 不是 NULL 空指针(即不是链表最后一个元素)
        {
            printf("电影：%s    评分：%d\n", current->title, current->rating);
            current = current->next; // 让 current 指向 next 成员所指向的下一个结构的位置
        }

        // 完成任务，释放内存
        current = head; // 让 current 指向 head 头指针
        while (current != NULL)
        {
            head = current->next; // 提前让 head 指向下一个结构的位置
            free(current);        // 释放 current 的内存
            current = head;       // 让 current 指向提前准备好的指向下一个结构位置的 head
        }
        return 0;
    }
    ```

  - **继续反思**

    > 1、程序还有**些许的不足**。例如程序**没有检查**`malloc()`是否**成功请求**到内存，也**无法删除链表中的项**。不过这些不足可以弥补，例如添加代码**检查**`malloc()`**返回值是否是 NULL**(返回 NULL 说明未成功获得内存)。如果需要**删除链表中的项**，还需要额外编写更多代码  
    > 2、因此，这种用**特定方法**解决**特定问题**，并在**需要时才添加相关功能**的编程方式通常不是最好的解决方案。另一方面，通常**无法预料**程序要完成的**所有任务**  
    > 3、如果要**修改程序**，首先应该**强调最初的设计**，并**简化其他细节**。上面的示例并**没有遵循这个原则**，它把**概念模型**和**代码细节**混在一起  
    > 4、例如程序的**概念模型**是**在一个链表中添加项**，但程序却**把一些细节放在最明显的位置**(例如`malloc()`、current->next 指针等等处理细节)，没有**突出接口**  
    > 5、如果程序能**以某种方式强调**给链表添加项，并**隐藏具体处理细节**会更好。把**用户接口**和**代码细节**分开的程序，更**容易理解和更新**。我们下面就会学习有关内容

##### **抽象数据类型(ADT)**

- **引入**

  > 1、在编程时，应根据**编程问题**匹配合适的**数据类型**。前例中每个**链表项**由**一个字符串**和**一个 int 值**构成，C 中没有直接与之匹配的基本类型，所以我们定义了一个**结构**来代表单独的**项**  
  > 2、本质上，我们使用**C 语言的功能**设计了一种**符合程序要求**的**新数据类型**，只是我们的**做法并不系统**。现在我们将使用更系统的方法**定义数据类型**  
  > 3、什么是**类型**？**类型**指两类信息：**属性**和**操作**。例如，**int 类型**的**属性**是它代表一个整数值，因此它共享整数的属性；允许对**int 类型**进行的**算术操作**有：改变类型值符号、相加、相减、相乘、相除、取模。当**声明一个 int 类型变量**时，就表明了**只可对此变量进行这些操作**  
  > 4、假设要**定义一个新的数据类型**。首先，必须**提供存储数据的方法**，例如**设计一个结构**；其次，必须**提供操纵数据的方法**  
  > 5、前例程序用**链接的结构**存储信息，通过代码实现了如何**添加和显示信息**，尽管如此，并**未清楚表明**正在创建一个**新类型**

- **定义新类型的方法**

  > 1、**计算机科学领域**开发了一种**定义新类型**的好方法，用三个步骤完成**从抽象到具体**的过程：  
  > 2、提供**类型属性和相关操作**的**抽象描述**。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种**正式的抽象描述**被称为**抽象数据类型**(**ADT**)  
  > 3、开发一个**实现 ADT**的**编程接口**。也就是说，指明**如何存储数据**和**执行所需操作的函数**。例如 C 中，可以提供**结构定义**和**操纵该结构的函数原型**。这些**作用于用户定义类型**的**函数**相当于**C 基本类型的内置运算符**。需要使用该新类型的程序员可以**使用这个接口**进行编程  
  > 4、**编写代码实现接口**。这一步至关重要，但是使用该新类型的程序员**无需了解具体的实现细节**

- **建立抽象**

  - **分析链表类型**

    - 从根本上看，电影项目所需的是一个**项链表**。每一项包含**电影名和评级**。你所需的操作是**向链表末尾添加新项**和**显示链表内容**。我们把**需要处理这些需求**的**抽象类型**叫做**链表**

    - 链表具有哪些**属性**？链表应该**能存储多个项**，而且这些**项以某种方式排列**，这样才能描述链表的第一项、第二项或最后一项

    - 链表应**提供一些操作**，如：

      > 1、初始化一个空链表  
      > 2、在链表末尾添加一个新项  
      > 3、确定链表是否为空  
      > 4、确定链表是否已满  
      > 5、确定链表中的项数  
      > 6、访问链表中的每一项执行一些操作，如显示该项

    - 对该电影程序来说，暂时不需要其他操作，但一般的**链表还应该包含以下操作**：

      > 1、在链表任意位置插入一个项  
      > 2、移除链表中的一个项  
      > 3、在链表中检索一个项(不改变链表)  
      > 4、用另一个项替换链表中的一个项  
      > 5、在链表中搜索一个项

  - **该类型总结如下**，下一步是为该**链表 ADT**开发一个**C 接口**

    ```c
    /*
    类型名：      简单链表
    类型属性：    可以存储一系列项
    类型操作：    初始化链表为空
                确定链表为空
                确定链表已满
                确定链表中的项数
                在链表末尾添加项
                遍历链表，处理链表中的项
                请空链表
    */
    ```

- **建立接口**

  - **接口数据类型**

    - 这个**简单链表**的**接口**有两个部分，第一部分是**描述如何表示数据**，第二部分是**描述实现 ADT 操作的函数**

    - **接口设计**应尽量与**ADT 的描述**保持一致，因此，应该用某种**通用的 Item 类型**而不是一些**特殊类型**(如 int 或 struct film)

    - 可以用 C 的`typedef`功能来**定义所需的 Item 类型**

      ```c
      #define TSIZE 45  // 存储片名的数组大小
      struct film
      {
          char title[TSIZE];
          int rating;
      };
      // 将 film 结构设置别名 Item
      typedef struct film Item;
      ```

    - 然后，就可以在**定义的其余部分**使用 Item 类型，如果以后需要**其他数据形式**的**链表**，可以**重新定义 Item 类型**，而不必更改**其余的接口定义**

  - **进一步设计如何存储项**

    - 在之前链表的示例程序中用**链式结构**处理得很好，所以在这里我们也用相同的方法(链表的实现中，每一个链节叫做节点 node)

      ```c
      // 将 node 结构设置别名为 Node
      typedef struct node
      {
          Item item;            // 包含 film 结构
          struct node * next;   // 指向下一个结构
      } Node;
      // 将指向 Node 的指针(实际就是一个链表)设置别名 List，表示指向链表开始处的指针
      typedef Node * List;
      ```

    - 是否有其他方法定义**List 类型**？例如，还可以**添加一个变量**，**记录项数**(稍后程序示例会使用这种，现在**仍使用前面的方法**定义 List 类型)

      ```c
      typedef struct list
      {
          Node *head;    // 指向链表头的指针
          int size;      // 链表中的项数
      } List;
      ```

    - 因此，`List movies;`创建了**该链表所需类型**的**指针 movies**。这里要着重理解**声明创建了一个链表**，而不是**一个指向节点的指针**或**一个结构**

  - **隐藏实现细节**

    - **movies**代表的**确切数据**应该是**接口层次**不可见的**实现细节**

    - 例如，程序启动后应把**头指针**初始化为**NULL**，你的实现细节应如下

      ```c
      movies = NULL;

      // 稍后你会发现 List 类型的结构实现(即第二种定义List类型的方法)会更好，应该这样初始化
      movies.head = NULL;
      movies.size = 0;
      ```

    - 而**使用该类型的程序员**不需要知道**List 类型变量**的**实现细节**，只需要使用你**提前设计好的**`InitializeList()`**函数**来**初始化链表**即可

    - 这是**数据隐藏**的一个示例，**数据隐藏**是一个从编程的更高层次**隐藏数据表示细节**的艺术

    - 为了**指引用户使用**，你需要在拟定的`InitializeList()`**函数**前**提供一些注释**帮助使用者**使用函数**

      ```c
      /*
      操作：初始化一个链表
      前置条件：plist指向一个链表
      后置条件：链表初始化为空
      */
      void InitializeList(List *plist);
      ```

  - **接口头文件示例**(使用`#ifndef`防止多次包含一个头文件)

    ```c
    /* list.h 简单链表类型的接口头文件 */

    // 使用 #ifndef 检测是否 LIST_H_ 未定义，防止多次包含同一个文件，注意 #endif 在该头文件末尾
    #ifndef LIST_H_
    // 此处预处理器定义 LIST_H_，如果再次重复调用该头文件，#ifndef 将使得这部分代码不会执行
    #define LIST_H_
    #include <stdbool.h>

    /* 特定程序的声明 */

    #define TSIZE 45 // 存储片名的数组大小
    struct film
    {
        char title[TSIZE];
        int rating;
    };

    /* 一般类型定义 */

    typedef struct film Item;

    typedef struct node
    {
        Item item;
        struct node *next;
    } Node;

    typedef Node * List;

    /* 函数原型 */

    /*
    操作：初始化一个链表
    前提条件：plist 指向一个链表
    后置条件：链表初始化为空
    */
    void InitializeList(List *plist);

    /*
    操作：确定链表是否为空，plist 指向一个已初始化的链表
    后置条件：如果链表为空，返回 true，否则返回 false
    */
    bool ListIsEmpty(List *plist);

    /*
    操作：确定链表是否已满，plist 指向一个已初始化的链表
    后置条件：如果链表已满，返回 true，否则返回 false
    */
    bool ListIsFull(List *plist);

    /*
    操作：确定链表中的项数，plist 指向一个已初始化的链表
    后置条件：该函数返回链表中的项数
    */
    unsigned int ListItemCount(const List *plist);

    /*
    操作：在链表末尾添加项
    前提条件：item 是一个待添加至链表的项，plist 指向一个已初始化的链表
    后置条件：如果可以，该函数在链表末尾添加一个项，且返回 true，否则返回 false
    */
    bool AddItem(Item item, List *plist);

    /*
    操作：把函数作用于链表的每一项
    前提条件：plist 指向一个已初始化的链表，pfun 指向一个函数(该函数接受一个Item类型的参数，且无返回值)
    后置条件：pfun 指向的函数作用于链表中的每一项一次
    */
    void Traverse(const List *plist, void(*pfun)(Item item));

    /*
    操作：释放已分配的内存(如果有的话)，plist 指向一个已初始化的链表
    后置条件：释放了为链表分配的所有内存，链表设置为空
    */
    void EmptyTheList(List *plist);

    #endif
    ```

- **实现接口**

  - **说明**

    > 1、当然，我们还必须**实现 List 接口**。C 方法是把**函数定义**和**具体实现**统一放在`list.c`文件中  
    > 2、然后，**整个程序由**`list.h`(定义数据结构和提供用户接口的原型)、`list.c`(提供函数代码实现接口)、`film.c`(把链表接口应用于特定编程问题的源代码文件)**组成**  
    > 3、下面，演示了`list.c`的**一种实现**，要**运行整个电影程序**，需要把`film.c`和`list.c`**一起编译和链接**

  - **示例程序**

    ```c
    /* list.c 支持链表操作的函数 */
    #include <stdio.h>
    #include <stdlib.h>
    #include "list.h"

    // 局部函数
    static void CopyToNode(Item item, Node *pnode)
    {
        pnode->item = item; // 拷贝结构
    }

    /* 接口函数 */
    // 把链表设置为空
    void InitializeList(List *plist)
    {
        *plist = NULL;
    }

    // 如果链表为空，返回 true
    bool ListIsEmpty(List *plist)
    {
        if (*plist == NULL)
            return true;
        else
            return false;
    }

    // 如果链表已满，返回 true
    bool ListIsFull(List *plist)
    {
        Node *pt;
        bool full;

        pt = (Node *)malloc(sizeof(Node));
        if (pt == NULL)
            full = true;
        else
            full = false;
        free(pt);

        return full;
    }

    // 返回节点的数量
    unsigned int ListItemCount(const List *plist)
    {
        unsigned int count = 0;
        Node *pnode = *plist; // 设置链表的开始

        while (pnode != NULL)
        {
            ++count;
            pnode = pnode->next; // 设置下一个节点
        }

        return count;
    }

    // 创建存储项的节点，并将其添加至由 plist 指向的链表末尾(较慢的实现)
    bool AddItem(Item item, List *plist)
    {
        Node *pnew;
        Node *scan = *plist;

        pnew = (Node *)malloc(sizeof(Node));
        if (pnew == NULL)
            return false; // 内存分配失败时退出函数

        CopyToNode(item, pnew);
        pnew->next = NULL;
        if (scan == NULL)  // 如果 scan(即plist)为空链表，就说明是链表第一个项
            *plist = pnew; // 把 pnew 放在链表的开头
        else
        {
            while (scan->next != NULL)
                scan = scan->next; // 找到链表的末尾
            scan->next = pnew;
        }
        return true;
    }

    // 访问每个节点并执行 pfun 指向的函数
    void Traverse(const List *plist, void (*pfun)(Item item))
    {
        Node *pnode = *plist; // 设置链表的开始

        while (pnode != NULL)
        {
            (*pfun)(pnode->item); // 把函数应用于链表中的项
            pnode = pnode->next;  // 前进到下一项
        }
    }

    /* 释放由 malloc() 分配的内存 */
    // 设置链表的指针为 NULL
    void EmptyTheList(List *plist)
    {
        Node *psave;
        while (*plist != NULL)
        {
            psave = (*plist)->next; // 保存下一个节点的地址
            free(*plist);           // 释放当前节点
            *plist = psave;         // 前进至下一节点
        }
    }
    ```

- **使用接口**

  - **说明**

    > 1、我们的目标是，这个**接口**编写程序，但是**不必知道**具体的**实现细节**(如函数的具体实现细节)  
    > 2、在编写**具体函数**之前，我们需要重新设计一下**电影程序**。由于**接口**要使用**List**和**Item**类型，所以该程序也应该**使用这些类型**

  - **程序示例**

    ```c
    /* film.c 电影程序 */
    /* 与 list.c 一起编译 */
    #include <stdio.h>
    #include <stdlib.h> // 提供 exit() 的原型
    #include "list.h"   // 定义 List、Item

    void showmovies(Item item)
    {
        printf("电影：%s  评分：%d\n", item.title, item.rating);
    }

    char *s_gets(char *str, int n)
    {
        char *ret_val;
        int i = 0;
        ret_val = fgets(str, n, stdin);
        if (ret_val)
        {
            while (str[i] != '\0' && str[i] != '\n')
                i++;
            if (str[i] == '\n')
                str[i] = '\0';
            else
                while (getchar() != '\n')
                    continue;
        }
        return ret_val;
    }

    int main(void)
    {
        List movies;
        Item temp;

        // 初始化
        InitializeList(&movies);
        if (ListIsFull(&movies))
        {
            fprintf(stderr, "没有空余内存\n");
            exit(1);
        }

        // 获取用户输入并存储
        puts("输入第一个电影名：");
        while (s_gets(temp.title, TSIZE) != NULL && temp.title[0] != '\0')
        {
            puts("输入你的评分：");
            scanf("%d", &temp.rating);
            while (getchar() != '\n')
                continue;

            if (AddItem(temp, &movies) == false)
            {
                fprintf(stderr, "内存分配错误\n");
                break;
            }
            if (ListIsFull(&movies))
            {
                fprintf(stderr, "列表已满\n");
                break;
            }
            puts("输入下一个电影名(或换行退出)：");
        }

        // 显示
        if (ListIsEmpty(&movies))
            printf("没有数据写入\n");
        else
        {
            printf("这是你的电影列表：\n");
            Traverse(&movies, showmovies);
        }
        printf("你一共添加了%d个电影\n", ListItemCount(&movies));

        // 清理
        EmptyThelist(&movies);
        printf("再见！\n");
        system("pause");
    }
    ```

##### **队列 ADT**

- **定义队列 ADT**

  - **分析队列类型**

    > 1、**队列**是具有**两个特殊属性**的**链表**  
    > 2、第一，**新项只能添加到链表末尾**。从这方面看，队列和简单链表类似  
    > 3、第二，**只能从链表的开头移除项**  
    > 4、**队列**是一种**先进先出**(first in first out，缩写为 FIFO)的**数据形式**

    ```c
    /*
    类型名：      队列
    类型属性：    可以存储一系列项
    类型操作：    初始化列表为空
                确定队列为空
                确定队列已满
                确定队列中的项数
                在队列末尾添加项
                在队列开头删除或恢复项
                清空队列
    */
    ```

- **建立接口**

  - **实现接口数据表示**

    - 确定**队列**中使用**何种 C 数据形式**

      > 1、有可能是**数组**。**数组的优点**是**方便使用**，而且**向数组末尾添加项**很简单  
      > 2、问题是如何**从队列的开头删除项**。类比于排队买票的队列，从队列的**开头删除一个项**包括**拷贝数组首元素的值**和**把数组剩余各项依次向前移动一个位置**  
      > 3、**编程实现**这个过程很简单，但是会**浪费大量的计算机时间**  
      > 4、第二种**解决数组队列删除问题**的方法是**改变队列首端的位置**，**其余元素不动**

      ![](https://s2.loli.net/2022/10/24/5stZrQ9BJiPALR2.png)

    - 进一步优化**数组队列**的模型

      > 1、解决这种问题的一个好方法是，**使数组成为环形**。这意味着**把数组的首尾相连**，即数组的**首元素**紧跟在**最后一个元素**后面  
      > 2、这样，当**到达数组末尾**时，如果**首元素空出**，就可以把**新添加的项**存储到这些**空出的元素**中  
      > 3、可以想象在一张条形的纸上画出数组，然后把数组的收尾粘起来形成一个环。当然**要做一些标记**，**以免尾端超过首端**

      ![](https://s2.loli.net/2022/10/24/EU8xl4btJ1YsVpB.png)

    - **使用链表实现接口数据表示**

      - 另一种方法是**使用链表**。好处是**删除首项**时**不必移动其他元素**，只需**重置头指针指向新的首元素**

      - 由于我们已经讨论过**链表**，**所以采用这个方案**。我们用一个**整数队列**进行测试：`typedef int Item;`

      - **链表**由**节点**构成，所以下一步是**定义节点**

        ```c
        typedef struct node
        {
            Item item;
            struct node *next;
        } Node;
        ```

      - 对**队列**而言，要**保存首尾项**，还可以**使用指针**来完成。另外可以用一个**计数器**来记录队列中的**项数**。因此**结构成员**如下

        ```c
        typedef struct queue
        {
            Node *front;      // 指向队列首项的指针
            Node *rear;       // 指向队列尾项的指针
            int items;        // 队列中的项数
        } Queue;
        ```

  - **接口头文件示例**

    ```c
    /* queue.h 队列的接口头文件 */

    #ifndef QUEUE_H_
    #define QUEUE_H_
    #include <stdbool.h>

    // 在这里插入 Item 类型的定义，例如
    typedef int Item; // 用于 use_q.c
    // 或者 typedef struct item{int gumption; int charisma;} Item;

    typedef struct node
    {
        Item item;
        struct node *next;
    } Node;

    typedef struct queue
    {
        Node *front; // 指向队列首项的指针
        Node *rear;  // 指向队列尾项的指针
        int items;   // 队列中的项数
    } Queue;

    /*
    操作：初始化队列
    前提条件：pq 指向一个队列
    后置条件：队列被初始化为空
    */
    void InitializeQueue(Queue *pq);

    /*
    操作：检查队列是否已满
    前提条件：pq 指向一个已被初始化的队列
    后置条件：如果队列已满则返回 true，否则返回 false
    */
    bool QueueIsFull(Queue *pq);

    /*
    操作：检查队列是否为空
    前提条件：pq 指向一个已被初始化的队列
    后置条件：如果队列为空则返回 true，否则返回 false
    */
    bool QueueIsEmpty(Queue *pq);

    /*
    操作：确定队列中的项数
    前提条件：pq 指向一个已被初始化的队列
    后置条件：返回队列中的项数
    */
    int QueueItemCount(Queue *pq);

    /*
    操作：在队列末尾添加项
    前提条件：pq 指向一个已被初始化的队列，item 是要被添加在队列末尾的项
    后置条件：如果队列不为空，item 将被添加在队列的末尾，函数返回 true；否则，队列不改变，函数返回 false
    */
    bool EnQueue(Item item, Queue *pq);

    /*
    操作：从队列开头删除项
    前提条件：pq 指向一个已被初始化的队列
    后置条件：如果队列不为空，队列首端的 item 将被拷贝到 *pitem 中并被删除，函数返回 true；如果该操作使得队列为空，则重置队列为空；如果执行该操作前队列为空，函数返回 false
    */
    bool DeQueue(Item *pitem, Queue *pq);

    /*
    操作：清空队列
    前提条件：pq 指向一个已被初始化的队列
    后置条件：队列被清空
    */
    void EmptyTheQueue(Queue *pq);

    #endif
    ```

- **实现接口**

  - **示例程序**

    - 码字中。。。

---

#### **页底评论**

---
