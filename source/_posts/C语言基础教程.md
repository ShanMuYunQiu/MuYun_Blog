---
title: C语言基础教程
author: 圣奇宝枣
description: 有关于C语言的基础教程，包括基本语法与基础的底层逻辑知识，比较适合有一定经验的初学者上手
sticky: 1
date: 2022-05-09 08:21:06
updated: 2022-07-30 15:13:19
readmore: true
tags:
  - 编程
  - C语言
  - 基础语法
categories:
  - 编程语言入门
---

---

#### **初识 C 语言**

---

<div class="success">

> **章节概要**：C 语言的特点；计算机工作原理；高级计算机语言；编译器；编程步骤；C 编程机制

</div>

##### **特点**

- **设计特性**：
  > C 语言融合了**计算机科学理论**和**实践的控制特性**  
  > C 语言的设计理念让用户轻松完成**自顶向下的规划**、**结构化编程**和**模块化设计**

<!-- more -->

- **高效性**：
  > C 语言充分利用计算机的优势，因此**程序更紧凑**，**运行速度很快**  
  > C 语言具有通常汇编语言才具有的微调控制能力，可以更具具体情况**微调程序**以获得**最大运行速度**或**最有效地使用内存**
- **可移植性**：
  > C 是可移植的语言，这意味着，在一种系统中编写的 C 程序**稍作修改**或**不修改**就能在其他系统上运行  
  > 注意程序中针对**特殊硬件设备**(如显示监视器)或**操作系统特殊功能**编写的部分**通常不可移植**  
  > C 语言与 UNIX 关系密切，**UNIX 系统**通常会将 C 编译器作为**软件包**的一部分  
  > 供个人计算机使用的 C 编译器很多，因此在**各个版本的操作系统**上，都可以找到合适的 C 编译器
- **强大而灵活**：
  > C 语言功能**强大而灵活**  
  > UNIX 操作系统、其他语言(FORTRAN、Perl、Python、Pascal)等的**编译器**和**解释器**都是**用 C 语言编写**的
- **面向程序员**：
  > C 语言是为了满足程序员的需求而设计的，程序员可以利用 C **访问硬件**、**操控内存中的位**  
  > 大多数 C 实现都有一个**大型的库**，包含众多有用的 **C 函数**，可以让程序员更加方便地使用 C 语言

##### **通俗了解计算机工作原理**

- 简而言之，计算机的**工作原理**是：如果希望计算机做某些事，就必须为其提供**特殊的指令列表**(**程序**)，确切地告诉计算机要做的事以及如何做。你必须用**计算机能直接明白的语言**(**机器语言**)创建程序。这是一项繁杂、乏味、费力的任务

##### **高级计算机语言与编译器**

- **高级编程语言**(如 C 语言)以多种方式**简化了编程工作**。首先，不必用数字码表示指令；其次，使用的指令更贴近你如何想这个问题，而不是类似计算机那样繁琐的步骤
- **编译器**是把**高级语言**程序**翻译**成计算机能理解的**机器语言**指令集的程序，在计算机看来，高级语言指令就是一堆无法理解的无用数据。由此，程序员进行高级思维活动，而编译器则负责处理冗长乏味的细节工作

##### **使用 C 语言的 7 个步骤**

- C 是**编译型语言**，我们把编写 C 语言的程序分解为七个步骤：
  > 1、定义程序的目标  
  > 2、设计程序  
  > 3、编写代码  
  > 4、编译  
  > 5、运行程序  
  > 6、测试与调试程序  
  > 7、维护和修改代码

##### **编程机制**

- 用 C 语言编写程序时，编写的内容被储存在文本文件中，该文件被称为**源代码文件**(**source code file**)。大部分 C 系统，都要求文件名以`.c`结尾
- C 编程的**基本策略**是，用程序把**源代码**文件**转换**成**可执行文件**(其中包含可直接运行的机器语言代码)  
  典型的 C 实现通过**编译**和**链接**两个步骤来完成这一过程。**编译器**把源代码转换成**中间代码**，**连接器**把中间代码和其他代码**合并**，生成可执行文件  
  ![](https://s2.loli.net/2022/05/22/ZyhE6a39RIPUOg4.png)

---

#### **C 语言概述**

---

<div class="success">

> **章节概要**：C 语言程序简单示例；`#include`与头文件；主函数`main`；注释；花括号；声明与变量；赋值；`printf`函数；`return`语句；C 语言程序基础结构；多条声明；打印多个值；多个函数；关键字和保留标识符

</div>

##### **简单的 C 程序示例及分析**

```c
#include <stdio.h>

int main(void)                //一个简单的C程序
{
    int num;                  //定义一个名为num的变量
    num = 1;                  //为num赋一个值
    printf("I am a simple "); //使用printf函数
    printf("computer.\n");
    printf("my favourite number is %d because it is first.\n", num);
    return 0;
}
```

- **程序分析及知识概要**

  - `#include`指令和**头文件**
    > 1、`#include <stdio.h>`在程序的**第一行**，该语句作用相当于把`stdio.h`**文件**中的**所有内容**都**输入该行所在位置**，本质上是一种“**拷贝-粘贴**”的操作。`include`文件提供了一种方便的途径共享许多程序共有的信息  
    > 2、`#include`这行代码是一条 C**预处理器命令**，通常，C 编译器在编译前会对源码做一些**准备工作**，即**预处理**  
    > 3、所有的 C 编译器软件都提供`stdio.h`头文件，该文件包含供编译器使用的**IO 函数**(**I:input 输入，O:output 输出**)。该文件名含义为**标准输入/输出头文件**。通常，C 程序顶部的信息集合被称为**头文件**
  - `main()`函数
    > 1、`main()`函数是程序的**主函数**，它是程序的入口点，**从这里开始执行**  
    > 2、`int main()`中`int`是函数的**返回类型**，表明函数**返回操作系统**的是**整数**，此处将在后续探讨  
    > 3、如果浏览旧式的 C 代码，会发现程序如`main()`开始，C90 标准勉强接受这种形式，但 C99 和 C11 标准不允许，因此不要这样写  
    > 4、你还会看到`void main()`的形式，部分编译器允许这样写，但所有标准都未认可，因此也不要这样写
  - **注释**
    > 1、注释是一种**记录程序信息**的方式，**被注释的部分不会被程序运行**  
    > 2、可以使用`/*注释内容*/`进行注释，此类注释可以换行注释，直到`*/`为止  
    > 3、也可以使用`//`进行注释(C99 新加入)，此类注释不能换行，直到行尾为止
  - **花括号**
    > 1、程序中花括号`{}`把`main()`括起来，一般而言，所有的**C 函数**都**使用花括号标记**函数体的**开始和结束**  
    > 2、花括号还可用于把函数中**多条语句**合并为一个**单元**和**块**
  - **声明与变量**
    > 1、`int num;`这行代码叫做**声明**，声明是 C 语言中最重要的特性之一  
    > 2、该条例中，声明**完成了两件事**。其一，函数中**有一个**名为`num`的**变量**，其二，`int`表示`num`的**数据类型**是一个**整数**  
    > 3、`int`是 C 语言中的一个**关键字**，表示一种基本的 C 语言**数据类型**。关键字是**语言定义的单词**，不能用做其他用途，例如不可作为函数名或变量名  
    > 4、`num`是一个**标识符**，也就是一个**变量、函数或其他实体**的**名称**  
    > 5、把**变量**声明正确的为**数据类型**(整型、浮点型、字符等)，**计算机**才能正确的**存储、读取和解释数据**  
    > 6、变量的**命名**，要尽可能使用**有意义**的变量名或标识符，如程序需要一个变量属羊，则可起名**sheep_count**。变量命名时仅可以使用**大小写字母、数字和下划线**，且第一个字母不能是数字
  - **赋值**
    > 1、`num = 1`是**赋值表达式语句**，**赋值**是 C 语言的**基本操作**之一，意为“**把值 1 赋给变量**`num`”  
    > 2、在执行`int num`声明时，编译器在计算机**内存**中为变量`num`**预留了空间**，然后执行赋值表达式语句时，把值存储在**预留的位置**  
    > 3、注意，赋值表达式语句**从右侧把值赋给左侧**，另外，该语句以分号`;`结尾
  - `printf`函数
    > 1、`printf`是 C 语言的一个**标准函数**，圆括号`()`表明`printf`是一个**函数名**，**圆括号中的内容**是从`main()`函数**传递**给`printf`函数的信息  
    > 2、`printf`函数会查看**双引号中的内容**(**字符串**)，并将其**打印**到屏幕上  
    > 3、`\n`的作用是**换行**，`\n`组合代表一个**换行符**。换行符是一个**转义列表**，用于代表**难以表示**或**无法输入**的字符。如`\t`代表**Tab 键**，`\b`代表**Backspace 键**，每个转义序列都以**反斜杠**`\`开始  
    > 4、对比发现，参数中的`%d`被数字 1**代替**了，而 1 就是`num`的值。`%d`是一个**占位符**，其作用是**指明**输入`num`的**位置**
  - `return`语句
    > 1、`int main(void)`中的`int`表明函数`main`要**返回一个整数**，C 标准**要求**`main()`这样做。  
    > 2、**有返回值**的 C 函数要有`return`语句，该语句以`return`关键字**开始**，后面是**待返回的值**，并以分号`;`**结尾**  
    > 3、如果遗漏`main`函数末尾的`return`语句，程序在运行至最外面的`}`时，会自动**返回**一个**默认值**，**即 0**。因此此处**可以省略**，但在**其他**有返回值的函数中**不可省略**，所以**建议保留**此习惯

- **简单程序的结构**

  - 程序由**一个或多个函数**组成，**必须有**`main()`函数。
  - 函数由**函数头**和**函数体**组成，函数头包括**函数名**、**传入该函数的信息类型**和**函数的返回值类型**
  - 通过**函数名后**的**圆括号**可以识别出函数，圆括号里**可能为空**，**可能有参数**
  - **函数体**被**花括号**括起来，由一系列**语句**、**声明**组成

  ![](https://s2.loli.net/2022/05/22/Rm4WvcyqaZkgLuQ.png)

  - 简言之，一个简单的 C 语言程序格式如下(**大部分语句**都以**分号**`;`**结尾**)：

  ```c
  #include <stdio.h>
  int main(void)
  {
      //语句
      return 0;
  }
  ```

##### **进一步使用 C**

```c
//把2英寻转换成英尺
#include <stdio.h>
int main(void)
{
    int feet, fathoms;
    fathoms = 2;
    feet = 6 * fathoms;
    printf("There are %d feet in %d fathoms!\n", feet, fathoms);
    printf("Yes,I said %d feet!\n", 6 * fathoms);
    return 0;
}
```

- **程序分析及知识概要**
  - **多条声明**
    > 1、`int feet, fathoms;`语句，使用**多条声明**声明了**两个变量**，使用**逗号**`,`隔开，此语句与`int feet;`+`int fathoms;`等价
  - **打印多个值**
    > 1、程序的**第一个**`printf()`进行了**两次替换**，**按顺序**将`feet`、`fathoms`替换了两个`%d`  
    > 2、第二个`printf()`说明待打印的值**不一定是变量**，只要**可求值**得出**合适类型值的项**即可

##### **多个函数**

- 把**自己的函数**添加到程序中，此处只做简单了解，后续学习：

```c
#include <stdio.h>
void def(void)
{
    printf("hello world!");
}

int main(void)
{
    def();
    return 0;
}
```

##### **关键字和保留标识符**

- 下表中**粗体** 表示`C90`标准新增关键字，_斜体_ 表示`C99`标准新增关键字，**粗斜体** 表示`C11`标准新增关键字

  |  关键字   |  关键字  |    关键字    |        关键字         |
  | :-------: | :------: | :----------: | :-------------------: |
  |   auto    |  extern  |    short     |         while         |
  |   break   |  float   |  **signed**  |    **_\_Alignas_**    |
  |   case    |   for    |    sizeof    |    **_\_Alignof_**    |
  |   char    |   goto   |    static    |    **_\_Atomic_**     |
  | **const** |    if    |    struct    |     **_\_Bool_**      |
  | continue  | _inline_ |    switch    |    **_\_Complex_**    |
  |  default  |   int    |   typedef    |    **_\_Generic_**    |
  |    do     |   long   |    union     |   **_\_Imaginary_**   |
  |  double   | register |   unsigned   |   **_\_Noreturn_**    |
  |   else    | restrict |   **void**   | **_\_Static_assert_** |
  | **enum**  |  return  | **volatile** | **_\_Thread_local_**  |

---

#### **数据和 C**

---

<div class="success">

> **章节概要**：交互式程序；变量与常量数据；数据；位、字节、字；存储单元换算；数据类型关键字；C 语言基本数据类型；进制打印显示；可移植类型；使用程序获得数据类型大小

</div>

##### **示例程序(交互式程序引入)**

```c
#include <stdio.h>
int main(void)
{
    float weight;
    float value;
    printf("Please enter your weight in pounds:");
    scanf("%f", &weight);
    value = 1700.0 * weight * 14.5833;
    printf("your weight in platinum is worth $%.2f.\n", value);
    return 0;
}
```

- **新元素简单分析**
  - 新的**变量声明**，使用`float`**浮点数**类型，浮点类型可以**储存带小数的数字**，详细说明见本章后面部分
  - 为了打印**新类型**的变量(**浮点数**)，`printf`处使用`%f`**处理浮点值**了
  - `%.2f`用于**精确控制输出**，指定**保留小数**后两位
  - `scanf()`函数用于**读取键盘的输入**，`%f`说明`scanf()`**读取输入浮点数**，`&weight`告诉`scanf()`把输入的值**赋给**名为`weight`的**变量**
  - `scanf()`函数使用`&`**符号**表明找到`weight`变量的地点，下章将详细讨论，目前请按照这样写

##### **变量与常量数据**

- **变量**：有些**数据类型**在程序运行期间**可能会改变**或**被赋值**，这些称为**变量**
- **常量**：有些**数据类型**在程序使用之前已经**预先设定**好了，整个程序运行过程中**没有变化**，称为**常量**

##### **数据**

- **位、字节、字**

  > **位、字节、字**是描述**计算机数据单元**或**存储单元**的术语，这里主要指**储存单元**
  >
  > **位**(**bit**)：**最小的储存单元**。可以储存**0 或 1**，是计算机内存的**基本构成块**  
  > **字节**(**byte**)：**常用的**计算机存储单位，**字节**是**位**的**集合**，一个**字节**可以储存**8 位**。这是字节的**标准定义**，至少在衡量存储单位时是这样  
  > **字**(**word**)：是**设计计算机时**给定的**自然存储单位**，对于 8 位的微型计算机，一个字长只有 8 位。从那以后，个人计算机字节增至 16 位、32 位，直至目前的 64 位。计算机的**字长越大**，**数据转移越快**，允许的**内存访问也更多**

- **存储单元换算**

  > 1 TB=1024 GB  
  > 1 GB=1024 MB  
  > 1 MB=1024 KB  
  > 1 KB=1024 Bytes(字节)  
  > 1 Byte(字节)=8 bits(位)  
  > 1 Word(字)=2 Bytes(字节)

- **整数**

  - 和数学概念一样，**整数是没有小数部分的数**，例如 2、-23、2456 都是整数
  - 计算机以**二进制数字**存储整数，如整数 **7** 二进制写为 **111**，因此要在**8 位字节**中存储该数字，需要**前 5 位**设置为**0**，**后 3 位**设置为**1**

  ![](https://s2.loli.net/2022/05/22/lB6cG1hnKCqD8mY.png)

- **浮点数**

  - 与数学中**实数**概念差不多，例如 2.75、3.16E7、7.00、2e-8 都是浮点数
  - 注意，在一个值后面**加上小数点**，该值就成为一个**浮点数**，所以**7 是整数**，**7.00 是浮点数**
  - 此处简要介绍**e 计数法**(**科学计数法**)：**3.16E7**表示 **3.16 \* 10<sup>7</sup>**
  - 这里关键要理解**浮点数**与**整数**的**储存方案不同**，计算机把浮点数分成**小数部分**和**指数部分**表示，而且**分开存储这两部分**。**7.0**写成**0.7E1**，这里，**0.7 是小数部分**，**1 是指数部分**。计算机在内部使用**二进制**和**2 的幂**进行储存，后续探讨(**此处图例以十进制下理解为例**)

  ![](https://s2.loli.net/2022/05/22/3JspxLR21l7TcDd.png)

##### **数据类型关键字**

| 最初 K&R 给出的关键字 | C90 标准添加的关键字 | C99 标准添加的关键字 |
| :-------------------: | :------------------: | :------------------: |
|          int          |        signed        |        \_Bool        |
|         long          |         void         |      \_Complex       |
|         short         |                      |     \_Imaginary      |
|       unsigned        |                      |                      |
|         char          |                      |                      |
|         float         |                      |                      |
|        double         |                      |                      |

##### **C 语言基本数据类型**

- `int`**类型**

  > 1、C 语言中的**整数类型**可表示**不同的取值范围**和**正负值**，一般情况下使用`int`能应付绝大多数情况  
  > 2、`int`类型是**有符号整型**，即`int`的值**必须是整数**，可以是正整数、负整数、0  
  > 3、`int`类型的**取值范围**因**计算机系统而异**，一般而言，储存一个`int`要**占用一个机器字长**  
  > 4、早期**16 位**的取值范围为-2<sup>15</sup> ~ 2<sup>15</sup>-1，即`-32768 ~ 32767`，**ISO C 规定**`int`**最小范围**为`-32768 ~ 32767`  
  > 5、一般来说，系统会用一个**特殊位的值**(**未使用的第 16 位**)表示**有符号整数**的**正负号**  
  > 6、使用`%d`**打印**整数类型，`%d`称为**转换说明**，他**指定**应该用什么**格式**显示一个值  
  > 7、**显示不同进制**：使用`%d`显示十进制，`%o`显示八进制，`%x`显示十六进制。**显示前缀**使用`%#o`、`%#x`、`%#X`

  ```c
  #include <stdio.h>
  int main(void)
  {
      int x = 100;
      printf("dec=%d ; octal=%o ; hex=%x  \n", x, x, x);
      printf("dec=%#o ; octal=%#x ; hex=%#X", x, x, x);
      return 0;
  }
  ```

- **其他整数类型**

  > 1、`short`类型：占用空间可能比`int`少，有符号类型  
  > 2、`long`类型：占用空间可能比`int`多，有符号类型  
  > 3、`long long`类型(**C99 加入**)：占用空间可能比`long`多，**至少 64 位**，有符号类型  
  > 4、`unsigned`类型：**非负整型**，**16 位**取值范围 0 ~ 2<sup>16</sup>-1，即`0 ~ 65535`  
  > 5、**C90 后**，新增`unsigned short`、`unsigned long`；**C99 后**，新增`unsigned long long`  
  > 6、在任何**有符号类型前**添加关键字`signed`，可**强调**使用有符号类型的**意图**  
  > 7、空间“**可能**”多与少是因为 C**只规定**了`short`不能多于`int`，`long`不能少于`int`  
  > 8、现在**个人计算机**常见设置是，`long long`占**64 位**，`long`占**32 位**，`int`占**16 位**或**32 位**，`short`占**16 位**  
  > 9、打印时，使用`%u`打印`unsigned`类型，使用`%ld`打印`long`类型，使用`%lld`打印`long long`类型，使用`%hd`打印`short`类型

- **浮点数类型**

  > 1、**浮点类型**能表示**包括小数**在内更大范围的数，浮点数的表示类似**科学计数法**。在计算机中，科学计数法中的 10 的**指数**，跟写在字母`e`后面，如 1.02 \* 10<sup>3</sup>记作`1.02e3`  
  > 2、**单精度浮点数**`float`，C 语言规定其至少能表示**6 位有效数字**，且取值范围至少是 10<sup>-37</sup> ~ 10<sup>37</sup>。通常，系统储存一个浮点数要**占用 32 位**，**其中 8 位**用于表示**指数的值和符号**，**剩下 24 位**用于表示**非指数部分及其符号**  
  > 3、**双精度浮点数**`double`，其与`float`类型的**最小取值范围相同**，但必须至少能表示**10 位有效数字**，一般来说，`double`**占用 64 位**而非 32 位。一些系统将多出来的 32 位**全用来**表示**非指数部分**，不仅增加**有效数字位数**(**即精度**)，还减少了**舍入误差**；另一些系统把**其中一些位**分配给**指数部分**，以容纳**更大的指数**，增加**可表示数的范围**。无论哪种类型，`double`类型的值**至少有 13 位有效数字**  
  > 4、`long double`，可以满足比`double`更高的精度要求，不过，C 只保证`long double`类型至少与`double`类型的**精度相同**  
  > 5、浮点数后面加上`f`**或**`F`**后缀**可**覆盖默认设置**，编译器会将**浮点型常量**看做`float`类型，如**2.3f**，**9.11E9F**；使用`l`**或**`L`**后缀**使数字成为`long double`类型；没有后缀的浮点型常量是`double`类型  
  > 6、**打印浮点值**时，使用`%f`打印`float`类型，用`%e`打印**指数计数法**的浮点值，如果系统支持十六进制的浮点数，使用`%a`打印**十六进制**的浮点值，打印`double`或`long double`要使用`%Lf`、`%Le`和`%La`的转换说明

- `char`**字符类型**

  > 1、`char`类型用来**储存字符**，如**字母**或**标点符号**  
  > 2、从技术层面来看，`char`是**整数类型**，因为`char`类型**实际储存**的是**整数**而不是字符。计算机使用**数字编码**来**处理字符**，即用特定**整数**代表特定**字符**  
  > 3、C 常用编码为**ASCII**编码，其中如**整数 65**代表**大写字母 A**，**整数 97**代表**小写字母 a**，**整数 48**代表**数字 0**  
  > 4、标准**ASCII 码**范围为**0~127**，只需 7 位二进制数即可表示。通常，`char`被定义为**8 位的存储单元**  
  > 5、C 语言把**1 字节**定义为`char`类型占用的**位**(**bit**)**数**  
  > 6、`char`赋值时，需要传入**char 字符类型**的数据，即**单引号**`''`包裹的字符，如`char set = 'A'`。此外也可使用**ASCII 码**进行赋值，如`char set = 65`  
  > 7、有一些**代表行为**的**非打印字符**，如换行、退格、回车、蜂鸣等，这些字符**打印不出来**。如需要表示这些字符，可以使用**ASCII 码**，比如蜂鸣：`char beep = 7`。此外也可以使用**转义字符**，如`char beep = '\a'`  
  > 8、使用`%c`**打印**`char`类型字符，如果使用`%d`**打印**，则会打印**字符对应 ACSII 码的整数**

  | 转义序列 | 含义                                                                   |
  | :------: | ---------------------------------------------------------------------- |
  |    \a    | 警报(ANSI C)                                                           |
  |    \b    | 退格                                                                   |
  |    \f    | 换页                                                                   |
  |    \n    | 换行                                                                   |
  |    \r    | 回车                                                                   |
  |    \t    | 水平制表符                                                             |
  |    \v    | 垂直制表符                                                             |
  |   \\\    | 反斜杠(\)                                                              |
  |   \\'    | 单引号(')                                                              |
  |   \0oo   | 八进制值(`oo`必须是有效的八进制数，即每个`o`可表示`0~7`中的一个数)     |
  |   \xhh   | 十六进制值(`hh`必须是有效的十六进制数，即每个`h`可表示`0~f`中的一个数) |

- `_Bool`**布尔类型**

  > 1、**C99**标准新增了`_Bool`类型，用于表示**布尔值**，即逻辑值**true**和**false**  
  > 2、因为 C 语言用**值 1**表示**true**，**值 0**表示**false**，所以`_Bool`类型实质上也是一种**整数类型**  
  > 3、原则上它仅占用**1 位存储空间**，因为对与**0 和 1**而言，一位的存储空间足够了

- **可移植类型：**`stdint.h`**和**`inttypes.h`

  > 1、**C99**新增两个**头文件**`stdint.h`和`inttypes.h`，以确保 C 语言**各类型**在**各系统**中**功能正常**  
  > 2、C 语言为**现有类型**创建了**更多类型名**，这些新类型名**被定义在**`stdint.h`中  
  > 3、如在**精确宽度整数类型中**，`int32_t`**表示 32 位的有符号整数类型**。在使用**32 位系统**时，头文件会把`int32_t`当做`int`的**别名**；而在`int`为**16 位**，`long`为**32 位**的系统中，系统会把`int32_t`当做`long`的别名。然后，使用`int32_t`类型**编写程序并包含**`stdint.h`**头文件**时，**编译器**会把`int`或`long`**替换**成与**当前系统匹配**的类型  
  > 4、如果系统**不支持精确宽度整数类型**，可以使用**最小宽度类型**，例如`int_least8_t`是**可容纳 8 位有符号整数值**的类型中**宽度最小**的类型的一个**别名**  
  > 5、如果更关心**速度**而非空间，则可使用**最快最小宽度类型**，如`int_fast8_t`被定义为**系统中**对**8 位有符号值**而言**运算最快的整数类型**  
  > 6、如果需要**最大整数类型**，最大的有符号整数类型`intmax_t`**可储存任何有效的有符号整数值**。类似的，`uintmax_t`表示最大的无符号整数类型，这种类型可能比`long long`和`unsigned long long`**更大**  
  > 7、C 标准针对这种**输入和输出**，提供了一些**字符串宏**来显示可移植类型，例如`inttypes.h`中定义了`PRId32`**字符串宏**，代表打印**32 位有符号值**的**合适转换说明**(**如 d 或 l**)

  ```c
  #include <stdio.h>
  #include <inttypes.h>
  int main(void)
  {
      int32_t me32;
      me32 = 45933945;
      printf("me32 = %" PRId32 "\n", me32);
      return 0;
  }
  ```

- **复数和虚数**

  > 1、许多**科学**和**工程计算**都要用到**复数和虚数**，**C99**支持复数和虚数，但是**有所保留**  
  > 2、**复数类型**：有`float_Complex`、`double_Complex`和`long double_Complex`。例如`float_Complex`变量应包含**两个**`float`**类型的值**，分别表示复数的**实部和虚部**  
  > 3、**虚数类型**：有`float_Imaginary`、`double_Imaginary`和`long double_Imaginary`  
  > 4、如果包含`complex.h`头文件，便可用`complex`代替`_Complex`，用`imaginary`代替`_Imaginary`，还可以用 1 代替-1 的平方根

- **其他类型**

  > 1、C 语言中**没有字符串类型**，却也能很好的处理字符串，详见后续  
  > 2、C 语言还有一些**基本类型衍生**的其他类型，如数组、指针、结构、联合，详见后续  
  > 3、本章程序案例简单使用到了**指针**，如`scanf()`函数用到的`&`前缀，便创建了一个指针，告诉`scanf()`把数据放在何处

##### **获取类型大小**

- 可以使用`sizeof()`获取以**字节**为单位的**类型大小**，**C99**和**C11**提供`%zd`匹配`sizeof()`返回值，其余不支持的编译器可用`%u`或`%lu`代替

```c
#include <stdio.h>
int main(void)
{
    printf("Type int has a size of %zd bytes.\n", sizeof(int));
    printf("Type char has a size of %zd bytes.\n", sizeof(char));
    printf("Type float has a size of %zd bytes.\n", sizeof(float));
    return 0;
}
```

---

#### **字符串和格式化输入输出**

---

<div class="success">

> **章节概要**：字符串简介；char 类型数组与 null 字符；`strlen()`函数；常量与 C 预处理器；明示常量；`printf()`函数；参数传递；`scanf()`函数；`scanf`多个输入与返回值

</div>

##### **示例程序**

```c
#include <stdio.h>
#include <string.h>
#define DENSITY 62.4 // 定义人体密度
int main(void)
{
    float weight, volume;
    int size, letters;
    char name[40];
    printf("Hi! What's your first name?\n");
    scanf("%s", name);
    printf("%s,whats's your weight in pounds?\n", name);
    scanf("%f", &weight);
    size = sizeof(name);
    letters = strlen(name);
    volume = weight / DENSITY;
    printf("well, %s, your volume is %2.2f cubic feet\n", name, volume);
    printf("Also, your first name has %d letters,\n", letters);
    printf("and we have %d bytes to store it.\n", size);
    return 0;
}
```

- **新元素简单分析**

  - 用**数组**储存**字符串**。在该程序中，用户**输入的名**被储存在**数组**中，该数组占用内存中**40 个连续的字节**，每个字节储存一个字符值
  - 使用`%s`**转换说明**来**处理字符串**的输入和输出。注意，在`scanf`中，`name`**没有**`&`**前缀**，而`weight`有(稍后解释，`&weight`和`name`都是**地址**)
  - 用 C**预处理器**把**字符常量**`DENSITY`定义为 62.4
  - 用 C 函数`strlen()`获取字符串的长度

##### **字符串简介**

> 1、**字符串**是**一个或多个字符**的**序列**，如`"I came from America"`  
> 2、**双引号**`"`不是字符串的一部分，仅是**告知编译器**它**括起来的是字符串**，就如**单引号**`'`用于标识单个字符一样

##### **char 类型数组与 null 字符**

> 1、C 语言**没有**专门用于**存储字符串**的变量类型，字符都被储存在`char`**类型数组**中。**数组**由**连续的存储单元**组成，字符串的**字符**被储存在**相邻的存储单元**中，每个单元储存一个字符  
> 2、数组**末尾位置**有一个**空字符**(**\0**)，C 语言用**空字符**(**null**)标记**字符串结束**。这意味着**数组容量**必须**比存储字符数多 1**  
> 3、**数组**是**同类型数据元素**的**有序序列**，**方括号**`[]`表示这是一个数组  
> 4、使用`%s`来转换**打印**一个**字符串**  
> 5、**字符串**与**字符**`char`不是同一种类型，因为**字符串**最后有**空字符标识**，而`char`**只存储该字符**  
> 6、使用`strlen()`函数可以得到**字符串的字符长度**，且`strlen()`并**不会计入空字符**

##### **常量与 C 预处理器**

- **为什么要使用常量**

  > 1、使用常量名比数字**表达的信息更多**，如`area = PI * d`与`area = 3.14 * d`相比**更加直观**  
  > 2、对于程序中**多次使用同一个常量时**，如果常量的值需要**修改**，**只需要修改常量值**即可

- **如何创建符号常量**

  - 可以**定义变量**，将**其值**定义为**所需的值**，但这样程序可能会**无意间改变它的值**
  - 使用**C 预处理器**定义，格式为`#define 常量名 值`，**编译程序时**，所有的**常量名**都会**被替换**为它们的值
    - 定义常量时，**习惯上**建议**全用大写**，以此**告知他人**这是一个常量，提高程序可读性；此外也有**小众习惯**使用`c_变量名`或`k_变量名`表示常量
    - **注意**：`define`常量名后的内容用于替换符号常量，不要将`#define NUM 20`写成`#define NUM = 20`，这样定义的**WORD**值为`=20`而非`20`
  - **C90**标准新增限定词`const`，表示**只读**，也可用此**作为**常量使用(其只表明**只读变量**)，如`const float PI=3.14`

- **明示常量**

  - C 头文件`limits.h`与`float.h`分别提供与**整数与浮点数**类型**大小限制**相关的说明，如`limits.h`中有类似以下代码：
    ```c
    #define INT_MAX +32767
    #define INT_MIN -32768
    ```
  - 这些**明示常量**代表`int`类型可表示的**最大值和最小值**，**该头文件**会为这些明示常量提供**不同的值**，如果系统使用**32 位的 int**且程序包含`limits.h`头文件，则可以使用`printf()`与`%d`转换输出**该常量 32 位 int 的值**
  - 如果系统使用**4 字节的 int**，**该头文件**将提供**符合 4 字节的对应值**
  - 下为`limits.h`中的一些明示常量：

    |  明示常量  | 含义                            |
    | :--------: | ------------------------------- |
    |  CHAR_BIT  | char 类型的位数                 |
    |  CHAR_MAX  | char 类型的最大值               |
    |  CHAR_MIN  | char 类型的最小值               |
    | SCHAR_MAX  | signed char 类型最大值          |
    | SCHAR_MIN  | signed char 类型最小值          |
    | UCHAR_MAX  | unsigned char 类型的最大值      |
    |  SHRT_MAX  | short 类型的最大值              |
    | USHRT_MAX  | unsigned short 类型的最大值     |
    |  INT_MAX   | int 类型的最大值                |
    |  UINT_MAX  | unsigned int 类型的最大值       |
    |  LONG_MAX  | long 类型的最大值               |
    | ULONG_MAX  | unsigned long 类型的最大值      |
    | LLONG_MAX  | long long 类型的最大值          |
    | ULLONG_MAX | unsigned long long 类型的最大值 |

  - 相似的，`float.h`头文件下也有一些明示常量：

    |    明示常量    | 含义                                                |
    | :------------: | --------------------------------------------------- |
    |  FLT_MANT_DIG  | float 类型的尾数位数                                |
    |    FLT_DIG     | float 类型的最小有效数字位数(十进制)                |
    | FLT_MIN_10_EXP | 带全部有效数字的 float 类型的最小负指数(以 10 为底) |
    | FLT_MAX_10_EXP | float 类型的最大正指数(以 10 为底)                  |
    |    FLT_MIN     | 保留全部精度的 float 类型最小正数                   |
    |    FLT_MAX     | float 类型的最大正数                                |
    |  FLT_EPSILON   | 1.00 和比 1.00 大的最小 float 类型值之间的差值      |

##### **printf()函数**

- 请求`printf()`打印数据的**指令**要与待打印**数据类型**相匹配。例如，**打印整数**使用`%d`，**打印字符**使用`%c`。这些符号称为**转换说明**，它们指定如何把数据转换成**可显示的形式**。

- **ANSI C**标准为`printf()`提供的**转换说明**

  | 转换说明 | 输出                                                                    |
  | :------: | ----------------------------------------------------------------------- |
  |    %a    | 浮点数、十六进制数和 p 计数法                                           |
  |    %A    | 浮点数、十六进制数和 p 计数法                                           |
  |    %c    | 单个字符                                                                |
  |    %d    | 有符号十进制整数                                                        |
  |    %e    | 浮点数，e 计数法                                                        |
  |    %E    | 浮点数，e 计数法                                                        |
  |    %f    | 浮点数，十进制计数法                                                    |
  |    %g    | 根据值的不同，自动选择%f 或%e。%e 格式用于指数小于-4 或者大于等于精度时 |
  |    %G    | 根据值的不同，自动选择%f 或%E。%E 格式用于指数小于-4 或者大于等于精度时 |
  |    %i    | 有符号十进制整数(与%d 相同)                                             |
  |    %o    | 无符号八进制整数                                                        |
  |    %p    | 指针                                                                    |
  |    %s    | 字符串                                                                  |
  |    %u    | 无符号十进制整数                                                        |
  |    %x    | 无符号十六进制整数，使用十六进制数 0f                                   |
  |    %X    | 无符号十六进制整数，使用十六进制数 0F                                   |
  |    %%    | 打印一个百分号                                                          |

- `prinft()`的转换说明**修饰符**，在`%`与**转换字符**之间插入**修饰符**可修饰基本转换说明

  | 修饰符 | 含义                                                                                                                                                                                                                                                                                                                                  |
  | :----: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  |  标记  | 本表格下一张表格描述了 5 种标记(-、+、空格、#、0)，可以不使用标记或使用多个标记，如`%-10d`                                                                                                                                                                                                                                            |
  |  数字  | 最小字段宽度，如果该字段不能容纳待打印内容则会使用更宽的字段，如`%4d`                                                                                                                                                                                                                                                                 |
  | .数字  | 精度。对于`%e`和`%f`转换，表示小数点右边数字位数 ； 对于`%g`转换，表示有效数字的最大位数 ； 对于`%s`转换，表示待打印字符最大数量 ； 对于**整型**转换，表示待打印数字的最小位数。如有必要，使用前导 0 达到这个位数，只使用`.`表示其后跟随一个 0，所以`%.f`与`%.0f`相同。如`%5.2f`表示打印一个字段宽度为 5，小数点后有 2 位数字的浮点数 |
  |   h    | 和整型转换说明一起使用，表示 short int 或 unsigned short int 类型的值，如`%hu`、`%hx`、`%6.4hd`                                                                                                                                                                                                                                       |
  |   hh   | 和整型转换说明一起使用，表示 signed char 或 unsigned char 类型的值，如`%hhu`、`%hhx`、`%6.4hhd`                                                                                                                                                                                                                                       |
  |   j    | 和整型转换说明一起使用，表示 intmax_t 或 uintmax_t 的值，这些类型定义在`stdint.h`中                                                                                                                                                                                                                                                   |
  |   l    | 和整型转换说明一起使用，表示 long int 或 unsigned long int 类型的值                                                                                                                                                                                                                                                                   |
  |   ll   | 和整型转换说明一起使用，表示 long long int 或 unsigned long long int 类型的值                                                                                                                                                                                                                                                         |
  |   L    | 和浮点转换说明一起使用，表示 long double 的值                                                                                                                                                                                                                                                                                         |
  |   t    | 和整型转换说明一起使用，表示 ptrdiff_t 类型的值，ptrdiff_t 是两个指针差值的类型(C99)                                                                                                                                                                                                                                                  |
  |   z    | 和整型转换说明一起使用，表示 size_t 类型的值，size_t 是 sizeof 返回的类型(C99)                                                                                                                                                                                                                                                        |

  - 注：`%u`标记**不能把数字和符号分开**，会报错!!

- `printf()`中的**标记**

  | 标记 | 含义                                                                                                                                                                                                     |
  | :--: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  |  -   | 待打印项左对齐，即从字段左侧开始打印该项，如`%-20s`                                                                                                                                                      |
  |  +   | 有符号值若为正，则在值前面显示加号(正号)，若为负则显示减号(负号)，如`%+6.2f`                                                                                                                             |
  | 空格 | 有符号值若为正，则在值前面显示前导空格(不显示任何符号)，若为负则显示减号(负号)覆盖前导空格，如`% 6.2f`                                                                                                   |
  |  #   | 把结果转换成另一种形式。如果是`%o`格式，则从 0 开始 ； 如果是`%x`格式，则从 0x 开始 ； 如果是**浮点**格式，`#`则保证了即使后面没有任何数字也打印一个小数点 ； 如果是`%g`格式，`#`防止结果后面的 0 被删除 |
  |  0   | 对于数值格式，使用前导 0 代替空格填充字段宽度 ； 对于整数格式，如果出现-标记或指定精度，则忽略该标记                                                                                                     |

##### **参数传递**

- **参数传递机制**因实现而异，下面以**本机系统**中的**本程序**分析参数传递。该调用告诉计算机把**变量 n1、n2、n3、n4**的值传递给程序，是一种**常见的传参方式**

  ```c
  #include <stdio.h>
  int main(void)
  {
      float n1 = 3.0;
      double n2 = 3.0;
      long n3 = 2000000000;
      long n4 = 1234567890;
      printf("%ld  %ld  %ld  %ld", n1, n2, n3, n4);
      return 0;
  }
  ```

  > 1、程序把**传入的值**放入被称为**栈**的**内存区域**，计算机根据**变量类型**(**不是转换说明**)把值放入**栈**中。  
  > 2、因此，**n1**被储存在**栈**中，**占 8 字节**(**float 被转换成 double 类型**)。同样，**n2**在**栈**中也占**8 字节**，而**n3、n4**分别占**4 字节**  
  > 3、然后，控制转到`printf()`，其根据**转换说明**从**栈**中读取值。`%ld`转换说明表明**应读取 4 字节**，所以`printf()`读取**前 4 字节**作为**第 1 个值**。这是**n1 前半部分**，将被解释成**long 类型整数**，根据下一个转换说明，`printf()`**再读取 4 字节**，这是**n1 后半部分**，将被解释为**第 2 个 long 类型整数**  
  > 4、类似的，继续读取**第 3、4 个**`%ld`，读取为**n2 的前、后半部分**，并解释成**两个 long 类型整数**  
  > 5、因此，对于**n3、n4**虽然用对了转换说明，但还是**读错了字节**

  ![](https://s2.loli.net/2022/05/25/jvdeNSciuAJbRaY.png)

##### **scanf()函数**

- `scanf()`是最通用的**输入函数**，因为它可以读取**不同格式的数据**，其将输入的**字符串**转换成**整数**、**浮点数**、**字符**或**字符串**

- `scanf()`使用**指向变量的指针**，而`printf()`使用**变量、常量、表达式**

- `scanf()`的**多个输入**

  > 1、可以通过`scanf("%d%d",&n,&m)`的格式**输入多个数据**  
  > 2、`scanf()`函数允许把**普通字符**放在**格式字符串**中，**除空格外**的字符必须与输入字符串**严格匹配**  
  > 3、如`scanf("%d,%d",&n,&m)`，用户必须输入**两个整数**，并以**逗号分隔**  
  > 4、除了`%c`，其他转换说明都会**自动跳过待输入值前面的所有空白**

- `scanf()`的**返回值**

  > `scanf()`函数返回**成功读取的项数**  
  > 如果**没有成功读取**任何项，且需要读取**一个数字**而用户输入一个**数值字符串**，其便返回**0**  
  > 当`scanf()`检测到“**文件结尾**”时，会返回**EOF**。这是`stdio.h`中定义的特殊值，通常会用`#define`将其定义为-1

- **ANSI C**标准为`scanf()`准备的**转换说明**和转换说明**修饰符**

  - `scanf`的**转换说明**与**修饰符**与`printf`的基本一致，但过程上从**转换输出**变成了**解释输入**，具体使用方法参考`printf`的表格

---

#### **运算符、表达式和语句**

---

<div class="success">

> **章节概要**：`while`循环简述；运算符；赋值术语；`sizeof`运算符和`size_t`类型；表达式、语句和块；语句术语；类型转换；强制类型转换；带参数的函数；形参实参

</div>

##### **while 循环简述**

- **示例程序**

  ```c
  #include <stdio.h>
  #define ADJUST 6.37
  int main(void)
  {
      const double SCALE = 0.333;
      double shoe, foot;
      printf("Shoe size (men's)   foot length\n");
      shoe = 3.0;
      while (shoe < 10.5)
      {
          foot = SCALE * shoe + ADJUST;
          printf("%10.1f %15.2f inches\n", shoe, foot);
          shoe = shoe +1;
      }
      printf("If the shoe fits , wear it.\n");
      return 0;
  }
  ```

- **while 循环**

  > 1、当**条件语句**为**真**时，执行**循环体**。**圆括号**内为**关系表达式**，**花括号**内为**循环体**  
  > 2、该程序中，程序判断`shoe < 18.5`**是否为真**，执行**循环体**内的代码，到达**花括号**时**再次判断表达式**，为**真**则**继续执行**，当**条件语句**为**假**时，**结束循环**

##### **运算符**

- **赋值运算符: =**

  > 1、C 语言中，**等号**`=`意为**赋值**而非**相等**。**赋值运算符**将**右侧的值赋给左侧**  
  > 2、当**赋值运算符**连用时，如`a=b=c=10`，仍按照**从右向左**方式**链式赋值**，即`c=10`，`b=c`，`a=b`

  - **几个术语：数据对象、左值、右值、项**

    > **数据对象**：赋值表达式语句的目的是把**值**储存到**内存位置**上，用于储存**值**的**数据存储区域**统称为**数据对象**  
    > **左值**：是 C 语言的术语，用于标识**特定数据对象**的**名称**或**表达式**。因此，**对象**指的是**实际的数据储存**，而**左值**是用于**标识**或**定位**储存**位置**的**标签**  
    > **右值**：指的是**赋值**给**可修改左值**的**量**，且**本身不是左值**  
    > **项**：学习名称时，被称为**项**的就是**运算对象**(如，赋值运算符左侧的项)。**运算对象**是**运算符**操作的对象

- **基本算术运算符**

  > 1、**加法运算符**`+`、**减法运算符**`-`、**乘法运算符**`*`、**除法运算符**`/`  
  > 2、**加和减**都被称为**二元运算符**  
  > 3、C 语言中的**除法**，若变量类型为**整数**，则除法的**商**的**小数部分**会**被舍弃**

- **符号运算符: +和-**

  > 1、`+`**和**`-`还可以做**符号运算符**，用作**正负号**  
  > 2、用作**正负号**时，为**一元运算符**

- **取模(余)运算符**

  > 1、用于**整数运算**，得到相除的**余数**，如`9 % 2 = 1`  
  > 2、**负数求模**，**C99**后，若**第一个运算对象**为**负数**，那么取模的结果为**负数**，反之亦然。如`11 % -5 = 1`，`-11 % 5 = -1`，`-11 % -5 = -1`

- **递增/减运算符: ++和--**

  > 1、下文以`++`为例  
  > 2、两种形式：`++`出现在**变量前**，为**前缀模式**；`++`出现在**变量后**，为**后缀模式**  
  > 3、该**运算符作用**为变量**自加一**，如`a++`意为`a = a + 1`  
  > 4、当**单独使用**递增运算符时，使用哪种形式都没关系  
  > 5、当使用**较为复杂**时，**则会不同**。如`q = 2*++a;`，意为**a 递增 1，后 2\*a，再将结果赋给 q**；而`q = 2*a++;`，意为**2\*a，后将结果赋给 q，再 a 递增 1**  
  > 6、由于**前后缀模式**的以上特性会对代码**产生不同的影响**，因此最好**单独使用**(如需复合使用时，可以先单独自增再使用)

- **sizeof 运算符和 size_t 类型**

  > 1、第 3 章已介绍，`sizeof`运算符用于以**字节**为单位返回**运算对象的大小**  
  > 2、C 语言规定，`sizeof`返回`size_t`类型数值，这是一个**无符号整数类型**，其为**语言定义**的**标准类型**  
  > 3、**C99**后使用`%zd`用于转换显示`size_t`类型，如不支持可以使用`%u`或`%lu`代替

##### **表达式、语句和块**

- **表达式**

  > 1、**表达式**由**运算符**和**运算对象**组成。**最简单的表达式**是**单个运算对象**，以此为基础可以建立**复杂的表达式**  
  > 2、**运算对象**可以是**常量**、**变量**或**二者的组合**  
  > 3、每个表达式**都有一个值**，如`q=5*2`作为一个整体的**值为 10**；表达式`q>3`的值为**布尔值**，为**true**或**false**，即值为 1 或 0

- **语句**

  > 1、**语句**是 C 程序的**基本构建块**，**一条语句**相当于**一条完整的计算机指令**，C 中大部分语句都以**分号**`;`**结尾**  
  > 2、最简单的语句为**空语句**，只有一个分号构成；C 把**末尾加上一个分号**的**表达式**也**看做语句**，因此`8;`，`3+4;`这些语句也没问题，只是在程序中**什么都不做**

  - **副作用、序列点、完整表达式**

    > 1、**副作用**：副作用是对**数据对象**或**文件**的**修改**。例如语句`states=50;`，其**副作用**为**修改**变量 states 的值为 50。这似乎是**主要目的**，而在**C 语言的角度**看，**主要目的**是**对表达式求值**，如**表达式**`4+6`求值得`10`，给出**表达式**`states=50`求值得`50`  
    > 2、**序列点**：是**程序执行**的点，在该点上，**所有的副作用**都在**进入下一步之前**发生。**语句**中的**分号**标记了一个序列点，另外，任何**完整表达式**的结束也是一个序列点  
    > 3、**完整表达式**：指这个表达式**不是**另一个**更大表达式**的**子表达式**

- **复合语句(块)**

  > **复合语句**：是用**花括号**括起来的**一条或多条语句**，**复合语句**也称为**块**

##### **类型转换**

- 通常，在**语句**和**表达式**中，应使用**类型相同**的变量和常量。但是，如果使用**混合类型**，C 会采用一套规则进行**自动类型转换**，虽然这很便利，但有一定危险性，尤其是在无意间混合使用类型的情况下

- **基本的类型转换规则**

  > 1、当类型转换出现在**表达式**时，无论是`unsigned`还是`signed`的`char`和`short`都会被自动转换成`int`，如有必要会被自动转换成`unsigned int`(如果`short`和`int`**大小相同**，`unsigned short`就比`int`大，此时`unsigned short`会被转换成`unsigned int`)。由于都是**较小类型**转换为**较大类型**，所以这些转换被称为**升级**  
  > 2、涉及**两种类型**的**运算**，两个值会被**分别转换**成两种类型的**更高级别**  
  > 3、类型的**级别从高至低**依次是：`long double`、`double`、`float`、`unsigned long long`、`long long`、`unsigned long`、`long`、`unsigned int` 、`int`。**例外**的情况是，当`long`和`int`**大小相同时**，`unsigned int`级别比`long`的级别高。之所以`short`和`char`没有列出，是因为它们已经**被升级**成了`int`或`unsigned int`  
  > 4、在**赋值表达式语句**中，计算的**最终结果**会被转换成**被赋值变量**的类型，因此该过程可能导致类型**升级或降级**  
  > 5、当作为**函数参数传递**时，`char`和`short`被转换成`int`，`float`被转换成`double`。第九章将介绍，函数原型会覆盖自动升级

- **强制类型转换**

  - 通常，应该避免**自动类型转换**，尤其是**类型降级**，但如果能小心使用，类型转换也很方便
  - 当需要进行**精确的类型转换**，或者在程序中**表明类型转换的意图**，此时要用到**强制类型转换**
  - **强制类型转换**:在某个量**前面**放置用**圆括号**`()`括起来的**类型名**，该**类型名**即是希望转换成的**目标类型**。**圆括号**和它括起来的**类型名**构成了**强制类型转换运算符**，其通用形式为`(type)`，例子为`score = (int)1.6 + (int)1.7`

##### **带参数的函数**

- **示例程序**

  ```c
  #include <stdio.h>
  void pound(int n)           // 定义函数
  {
      while (n-- > 0)
      {
          printf("#");
      }
      printf("\n");
  }

  int main(void)
  {
      int times = 5;
      char ch = '!';
      float f = 6.0;
      pound(times);
      pound(ch);
      pound(f);
      return 0;
  }
  ```

- **参数-形参、实参**

  - 首先，看**函数头**`void pound(int n)`，如果函数**不接受任何参数**，那么**圆括号中**应写上`void`。由于该函数接受一个`int`类型的**参数**，所以其中包含一个`int`类型的**变量 n**的声明。参数名应遵循 C 语言的**命名规则**
  - 声明参数就创建了被称为**形式参数**的**变量**(简称**形参**)，该例中，形式参数是 int 类型的**变量 n**；像`pound(10)`这样的**函数调用**会把 **10** 赋给 **n** ，我们称函数调用**传递的值**为**实际参数**(简称**实参**)
  - 函数调用`pound(10)`把**实参 10**传递给**函数**，函数将 **10** 赋给**形参**
  - **变量名**是函数**私有的**，即在**函数中定义**的变量名**不会**和**别处的相同名称**发生冲突

- **函数调用**

  - 现在，来学习**函数调用**，如第一次调用`pound(times)`，**times**的值**5**被赋给**n**，因此函数打印了**5 个井号和一个换行符**
  - 第二次调用`pound(ch)`，此时**ch**是`char`类型变量，被初始化为`!`，其**ASCII 码**为**33**。由于函数形参类型为`int`，与`char`不匹配，所以程序开头的**函数原型**发挥了作用；**原型**即**函数声明**，描述函数**返回值**和**参数**，`pound`原型说明了两点：
    > 1、函数**没有返回值**(**函数名**前关键字为`void`)  
    > 2、函数有一个`int`类型的**形参**
  - 函数原型告诉编译器，函数**接受一个**`int`类型的**参数**，当编译器执行到`pound(n)`时，参数**ch**被自动转换成`int`类型，于是从**1 字节的 33**变成了**4 字节的 33**。于此类型，第三次调用`pound(f)`也使得`float`类型**转换成合适的**`int`**类型**

---

#### **C 控制语句:循环**

---

<div class="success">

> **章节概要**：再探`while`循环；`while`循环语句；迭代；关系运算符与关系表达式；真(true)与假(false)；`bool`布尔变量；`for`循环；`for`的几种使用示例；复合赋值运算符；出口条件循环`do-while`；循环嵌套；数组简介；函数返回值的使用

</div>

##### **再探 while 循环**

- **程序示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      long num;
      long sum = 0L;
      int status;
      printf("Please enter an integer to be summed");
      printf("(q to quit):");
      status = scanf("%ld", &num);
      while (status == 1)
      {
          sum = sum + num;
          printf("Please enter next integer (q to quit):");
          status = scanf("%ld", &num);
      }
      printf("Those integer sum to %ld.\n", sum);
      return 0;
  }
  ```

  - **新元素分析**

    - **sum**初始值为`0L`，为`long`类型的`0`，而非`int`类型的`0`
    - `==`为**相等运算符**，用于判断**前后值是否相等**，不要与`=`**赋值运算符**混淆
    - `scanf()`函数的**返回值**，返回**成功读取项的数量**，因此此处读取**1 个整数**，则**成功后**返回**1**

##### **while 循环语句**

- **while 循环语句格式**

  ```c
  while(关系表达式){
      循环体;
  }
  ```

- **迭代**:在循环的**关系表达式**为**假(0)**之前，循环的**判断和执行**一直**重复进行**，**每一次循环**都被称为一次**迭代**

- **循环条件**

  - 在**构建循环**时，必须让**测试表达式**的值**有变化**，表达式最终要为**假**(**0**)，否则循环就不会停止
  - 可以使用`while(1)`来构建简单的**死循环**，之后会将到如何**破除循环**
  - 注意**循环终止**的时间，只有**大括号内的语句**会**循环执行**，注意哪些语句需要循环执行，哪些不需要

##### **关系运算符与关系表达式**

- **关系运算符**

  > `==`：**相等运算符**，用于判断**前后值是否相等**，不要与`=`**赋值运算符**混淆  
  > `!=`：**不等运算符**，用于判断**前后值是否不相等**  
  > `<`：**小于运算符**，用于判断**前值是否小于后值**  
  > `>`：**大于运算符**，用于判断**前值是否大于后值**  
  > `<=`：**小于等于运算符**，用于判断**前值是否小于等于后值**  
  > `>=`：**大于等于运算符**，用于判断**前值是否大于等于后值**

- **真(true)与假(false)**

  > 1、**关系表达式**会产生**真(true)**和**假(false)**的值，**真(true)**值通过打印会得到为**1**，**假(false)**值通过打印会得到为**0**  
  > 2、因此`while`循环**判断**的实际为**表达式的真假值**  
  > 3、而在 C 语言中，一般所有**非 0 的值**都可以被识别为**真(true)**，只有**0**被识别为**假(false)**

- **\_Bool 布尔变量**

  > 1、**C99**新增了`_Bool`**布尔**类型变量，其只能储存**真(true)**和**假(false)**，所有其他非零数值都会被转换为**真(true)**  
  > 2、`stdbool.h`头文件让`bool`成为了`_Bool`的别名，还把**true**和**false**分别定义为**1**和**0**的**符号常量**  
  > 3、且使用该头文件的代码可以与`C++`**兼容**，因为`C++`把`bool`、`true`、`false`定义为**关键字**

##### **for 循环**

- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      const int NUMBER = 22;
      int count;
      for (count = 1; count <= NUMBER; count++)
      {
          printf("Be my Valentine\n");
      }
      return 0;
  }
  ```

- **for 循环格式**

  ```c
  for(初始化;测试条件;执行更新){
      循环体
  }
  ```

  > 1、`for`后面的括号中有**三个表达式**，分别用**两个分号**`;`隔开  
  > 2、**第 1 个**表达式是**初始化**，只会在`for`**循环开始时**执行**一次**  
  > 3、**第 2 个**表达式是**测试条件**，**测试条件**为**真(true)**时**执行**循环体**，**测试条件**为**假(false)**时**结束**循环**  
  > 4、**第 3 个**表达式是**执行更新**，**每次循环结束时求值**

- **for 的灵活性**

  - `for`循环十分灵活，可以利用**三个表达式**完成**几乎所有**需要的**条件判断**，使用`for`循环能更轻松清楚地完成**遍历**
  - **逗号运算符**`,`使得**循环头**可以包含**更多表达式**，如`for(i=0,a=10; i<a; i=i+2,a++)`
  - `for`循环的其他几种妙用

    ```c
    #include <stdio.h>
    int main(void)
    {
        //输出20内平方表
        printf("数字        平方\n");
        for (int i = 1; i <= 20; i++)
        {
            printf("%-11d %-11d\n", i, i * i);
        }
        return 0;
    }
    ```

    ```c
    #include <stdio.h>
    int main(void)
    {
        //输出ASCII码表
        printf("字符        ASCII码\n");
        for (char i = 'A'; i <= 'z'; i++)
        {
            printf("%-11c %-11d\n", i, i);
        }
        return 0;
    }
    ```

    ```c
    #include <stdio.h>
    int main(void)
    {
        //输出20内的、平方小于350的偶数
        //注: &&为“与”，表示两者皆满足；i+=2同i=i+2
        for (int i = 0; i <= 20 && i * i < 350; i += 2)
        {
            printf("%d\n", i);
        }
        return 0;
    }
    ```

##### **复合赋值运算符**

- **复合赋值运算符**:`+=`、`-=`、`*=`、`/=`、`%=`

- **符号赋值运算符**`+=`表示**加法赋值**，如`a+=2`意义等同于`a=a+2`，其余以此类推

##### **出口条件循环 do-while**

- 是`while`循环的一种**变种**，`while`为**入口处判断**，`do-while`为**出口处判断**
- 特点为**第一次执行**，无论如何`do-while`的**循环体至少执行一次**，出口处再**判断是否下次循环**。如下程序即使**count 初始值大于 22**，也会执行一次**do 内循环体**
- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int count=1;
      do
      {
          printf("Be my Valentine\n");
          count++;
      } while (count < 22);
      return 0;
  }
  ```

##### **循环嵌套**

- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      //输出乘法表
      for (int i = 1; i <= 9; i++)
      {
          for (int j = 1; j <= i; j++)
          {
              printf("%d*%d=%-2d  ", j, i, i*j);
          }
          printf("\n");
      }
      return 0;
  }
  ```

- **循环嵌套**

  > 1、**循环嵌套**指在**循环内**包含**另一个循环**，执行顺序为**外层循环**过程中执行多次**内层循环**，两个循环的**大括号**分别**标识自己的循环体部分**  
  > 2、如上述示例程序**乘法表**，通过最内层`printf`能得知，使用**j**表示乘法表**第一个数字**，使用**i**表示**第二个数字**，使用**i\*j**表示**乘法的积**  
  > 3、通过`j<=i`的**循环条件**防止出现`2*3`后再次出现`3*2`**重复**  
  > 4、建议自己运行一次程序，感受循环的顺序，也可以改变几个数值，看看程序的变化

##### **数组简介**

- 在许多程序中，数组很重要。**数组**可以作为一种**储存多个相关元素**的**便利方式**，将在第十章详细介绍

- **数组**

  > 1、数组是**按顺序存储**的一系列**类型相同**的值，如 10 个`char`类型数值或 10 个`int`类型数值  
  > 2、整个数组有一个**数组名**，通过**整数下标**访问数组中**单独的项**或**元素**

- **数组声明与使用**

  > **数组声明**：示例`int a[15]`，表示声明一个**内涵 15 个元素**的整数数组  
  > **数组使用**：通过**下标**访问**指定元素**。数组的**第一个元素**为`a[0]`，**第二个元素**为`a[1]`，以此类推。实际上**数组元素**的使用与**同类型变量**相同  
  > **陷阱**：考虑到 C 执行速度，C 编译器**不会检查**数组**下标是否正常**，注意数组元素**不要超出定义的范围**  
  > **下标**：用于**标识数组元素的数字**叫做**下标**、**索引**或**偏移量**。下标**必须是整数**且要**从 0 开始计数**

- **for 循环中使用数组**

  - `for`**循环**的**数组使用**，可以通过利用**循环变量**的变化来**切换数组的元素**，示例如下：

    ```c
    #include <stdio.h>
    int main(void)
    {
        int a[10];
        //循环输入
        for (int i = 0; i < 10; i++)
        {
            scanf("%d", &a[i]);
        }
        //循环输出
        for (int i = 0; i < 10; i++)
        {
            printf("%-5d  ", a[i]);
        }
        return 0;
    }
    ```

##### **函数返回值的使用**

- 对于**有返回值的函数**，函数最后的`return`**语句**表示函数的**返回值**，即执行完函数后，函数**返回的值**

- **编写**一个有返回值的函数，需要注意以下几点：

  > 1、定义函数时，**确定函数的返回类型**  
  > 2、使用`return`表明待返回的值

- **示例程序**

  ```c
  #include <stdio.h>

  // double 函数名 表明函数返回一个double类型的值
  double power(double n, int p)
  {
      double pow = 1;
      for (int i = 1; i <= p; i++)
      {
          pow *= n;
      }
      // 返回pow的值
      return pow;
  }

  int main(void)
  {
      // a^b
      double a;
      int b;
      printf("输入底数:");
      scanf("%lf", &a);
      printf("输入指数:");
      scanf("%d", &b);
      // 调用函数
      printf("乘方结果:%lf", power(a, b));
      return 0;
  }
  ```

---

#### **C 控制语句:分支和跳转**

---

<div class="success">

> **章节概要**：`if`语句；`if-else` 语句与 `else-if` 语句；`if` 与 `else` 的配对和嵌套 `if`；`getchar()`与`putchar()`函数；`ctype.h`系列的字符函数；逻辑运算符；备选拼写：`iso646.h`头文件；条件(三目)运算符；循环辅助：`continue`和`break`；`switch` 语句；`goto` 语句

</div>

##### **if 语句**

- **示例程序**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int a, b;
      scanf("%d%d", &a, &b);
      if (a > b)
      {
          printf("Sure,A>B!\n");
      }
      printf("Over!");
      return 0;
  }
  ```

- **if 语句**

  > 1、`if`**语句**被称为**分支语句**或**选择语句**，因为它相当于一个**交叉点**，程序要在两条分支中**选择一条**执行  
  > 2、程序如果对**分支表达式**求值为**真**，则执行**执行语句**，否则**跳过**执行语句  
  > 3、`if`**语句**的通用形式如下

  ```c
  if (分支表达式){
      执行语句;
  }
  ```

##### **if-else 语句与 else-if 语句**

- **if-else 语句**

  > 1、简单的`if`**语句**可以让程序选择**执行一条语句或跳过**，而`if-else`**语句**可以在**两条语句之间做选择**  
  > 2、程序如果对**分支表达式**求值为**真**，则执行**执行语句 1**，否则执行**执行语句 2**  
  > 3、`if-else`**语句**的通用形式如下

  ```c
  if (分支表达式){
      执行语句1;
  }
  else{
      执行语句2;
  }
  ```

- **else-if 语句**

  > 1、`else-if`**语句**为**多重选择**语句，可以在**多个分支之间做选择**  
  > 2、程序会根据表达式是否为真**逐步判断**，特别注意，如果**第一个表达式为真**，则**不会继续向下执行**  
  > 3、`else-if`**语句**的通用形式如下

  ```c
  if (分支表达式1){
      执行语句1;
  }
  else if (分支表达式2){
      执行语句2;
  }
  else{
      执行语句3;
  }
  ```

##### **if 与 else 的配对和嵌套 if**

- 当一个程序有**多个**`if`和`else`，**如果没有花括号**，`else`将与**离它最近**的`if`配对，除非最近的 if 被花括号括起来  
  ![](https://s2.loli.net/2022/06/13/cyX9MLRs4nvfZ3x.png)

- 有关`if`的嵌套，与`for`的嵌套基本雷同，只需要注意**不同嵌套的花括号包括的范围**即可

##### **getchar()与 putchar()函数**

- **getchar()与 putchar()的使用**

  > 1、`getchar()`**函数**用于从**标准输入流**中**读取一个字符**，并将其存储在变量中  
  > 2、如把字符**储存进**变量**ch**，则写为`ch = getchar()`，其等效于`scanf("%c", &ch)`  
  > 3、`putchar()`**函数**用于**打印它的参数**  
  > 4、如打印**ch**的值，则写为`putchar(ch)`，其等效于`printf("%c",ch)`  
  > 5、由于这些函数**只处理字符**，所以比`scanf`与`printf`**更快更轻量**，而且**不需要转换说明**

- **探索如何工作的程序示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      char ch;
      ch = getchar();    // 读取第一个字符
      while (ch != '\n') // 当不为换行符时循环，即一行字符未结束时
      {
          if (ch == ' ') // 留下空格不变
          {
              putchar(ch);
          }
          else
          {
              putchar(ch + 1); //其他字符改变+1
          }
          ch = getchar(); //获取下一个字符
      }
      putchar(ch); //打印换行符
      return 0;
  }
  ```

  - 该程序**可以进行优化**，将**如下形式的循环**替换为**后者**

    ```c
    ch = getchar();
    while (ch != '\n'){
        ...
        ch = getchar();
    }
    ```

    ```c
    while ( (ch=getchar()) != '\n'){
        ...
    }
    ```

  - 这样的写法体现了**C 特有的编程风格**——**把两个行为合并成一个表达式**
  - 程序中的`putchar(ch+1);`语句，再次演示了**字符**实际上是**作为整数储存**的

##### **ctype.h 系列的字符函数**

- C 有一系列专门用于**处理字符**的**函数**，`ctype.h`**头文件**包含了这些**函数**的原型。这些函数**接受一个字符作为参数**，如果该字符**属于某特殊的类别**，则返回**true**，否则返回**false**

- `ctype.h`的**字符测试函数**

  |   函数名   | 如果是下列参数，返回值为 true                                          |
  | :--------: | ---------------------------------------------------------------------- |
  | isalnum()  | 字母或数字                                                             |
  | isalpha()  | 字母                                                                   |
  | isblank()  | 标准的空白字符(空格、换行、水平制表符)或其他本地指定为空白的字符       |
  | iscntrl()  | 控制字符，如`Ctrl+B`                                                   |
  | isdigit()  | 数字                                                                   |
  | isxdigit() | 十六进制数字符                                                         |
  | isgraph()  | 除空格以外的任意可打印字符                                             |
  | islower()  | 小写字母                                                               |
  | isupper()  | 大写字母                                                               |
  | isprint()  | 可打印字符                                                             |
  | ispunct()  | 标点符号(除空格和字母数字以外的任何可打印字符)                         |
  | isspace()  | 空白符(空格、换行、换页、回车、垂直或水平制表符、其他本地定义的空白符) |

- `ctype.h`的**字符映射函数**

  |  函数名   | 行为                                                 |
  | :-------: | ---------------------------------------------------- |
  | tolower() | 如果参数是大写字符，则函数返回小写，否则返回原始参数 |
  | toupper() | 如果参数是小写字符，则函数返回大写，否则返回原始参数 |

##### **逻辑运算符**

- C 语言的`if`和`while`语句通常需要使用**关系表达式**作为测试条件。有时需要**多个关系表达式组合**，来判断**多个条件的逻辑关系**，**逻辑运算符**便可满足这一需求

- **3 种逻辑运算符**

  > 1、`&&`**逻辑与**：如果连接的两个表达式**都为 true**，则**返回 true**  
  > 2、`||`**逻辑或**：如果连接的两个表达式**至少有一个为 true**，则**返回 true**  
  > 3、`!`**逻辑非**：如果表达式为 **true**，则**返回 false**；如果表达式为 **false**，则**返回 true**

- **逻辑运算符优先级**

  > 1、`!`优先级**最高**、`&&`优先级**次之**、`||`优先级**最低**  
  > 2、`!`的优先级**仅次于圆括号**，比乘法运算符还高。`&&`、`||`的优先级都**比关系运算符低**，**比赋值运算符高**  
  > 3、因此，表达式`a>b && b>c || b>d`相当于`((a>b) && (b>c)) || (b>d)`

- **备选拼写：iso646.h 头文件**
  - 由于 C 使用**标准美式键盘**开发，部分键盘并**没有美式键盘的符号**。使用`iso646.h`**头文件**，可以使用`and`、`or`、`not`分别代替`&&`、`||`、`!`

##### **条件(三目)运算符**

- C 提供**条件(三目)运算符**作为表达`if-else`的一种便捷方式，常用于为一个变量**判断赋值或输出的值**时使用

- **三目运算符的使用**
  - **基本语法**：`测试条件 ? 结果true执行表达式 : 结果false执行表达式`
  - 例如`a = (num<0) ? -y : y;`等效于如下语句：
    ```c
    if (num < 0) {
        a = -y;
    } else {
        a = y;
    }
    ```
  - **三目运算符**也可以**嵌套使用**，使用**小括号表明不同层级部分**

##### **循环辅助：continue 和 break**

- **语句功能**

  > `continue`**语句**：在**循环过程**中，如果执行到`continue`语句，则会从`continue`执行处**跳过本层本次循环**的剩余内容，**继续执行下一次循环**  
  > `break`**语句**：在**循环过程**中，如果执行到`break`语句，则会从`break`执行处**终止本层循环**且**跳过未执行内容**，**不再进行下一次本层循环**

- **语句优势**
  > 1、可以**更加灵活**的控制循环的执行  
  > 2、能够**减少不必要的**`if-else`**层级缩进**，提高代码的**可读性**  
  > 3、使代码语句**结构更清晰紧凑**

##### **switch 语句**

- 使用**条件运算符**和`if-else`语句很容易编写**二选一**的程序，然而有时程序需要从**多个选项中选择**，尽管可以使用`else if`实现，但大多情况下`switch`**更加方便**

- **基本语法**

  ```c
  switch (表达式){
      case 表达式的可能值1:
          语句;
          break;
      case 表达式的可能值2:
          语句;
          break;
      ...
      default:
          语句;
          break;
  }
  ```

- **注意事项**

  > 1、`break`语句使程序离开`switch`语句，**直接执行**`switch`后的**下一条语句**，如果**没有**`break`，则会**按顺序**将**条件成立处**向后**所有**`case`内语句执行完毕，直到`default`语句后退出  
  > 2、C 语言的`case`一般都**指定一个值**，**不能使用一个范围**  
  > 3、关于`switch`不使用`break`会**向后执行**的特性，可以在特定的地方设定`break`，来利用这个特性，如下设计统计字母出现次数的程序

  ```c
  #include <stdio.h>
  int main(void)
  {
      char ch;                              // 输入字母
      int a_ct, b_ct, c_ct, d_ct, e_ct;     // 统计abcde的次数
      a_ct = b_ct = c_ct = d_ct = e_ct = 0; // 初始化为0
      printf("enter some text;enter # to quit");
      while ((ch = getchar()) != '#')
      {
          switch (ch)
          {
          case 'a': // 检测a时执行，并会向下执行'A'的语句
          case 'A': // 不论大写小写a，都会执行语句计入统计
              a_ct++;
              break; // break终止继续执行
          // 以此类推，此处省略bcde的case
          }
      }
      printf("A   B   C   D   E\n");
      printf("%-4d%-4d%-4d%-4d%-4d", a_ct, b_ct, c_ct, d_ct, e_ct);
      return 0;
  }
  ```

- **swith 与 if-else**

  > 1、通常而言，`switch`能干的`if-else`**都能实现**，但`switch`的运行**速度更快**  
  > 2、当需要判断**一个范围**或**浮点变量或表达式**时，`switch`**无法实现**  
  > 3、`switch`通常只是`if-else`的**优化**，对比之下，仍是`if-else`**泛用性更强**

##### **goto 语句**

- 早期版本的**BASIC**和**FORTRAN**所依赖的`goto`语句，在 C 中**仍然可用**，但**非常不建议**使用，即使没有`goto`语句 C 语言也仍能运行良好，且**逻辑更加清晰**

- **基本语法**

  ```c
  语句标签(如:part1):语句

  goto 语句标签;
  ```

---

#### **字符输入输出与输入验证**

---

<div class="success">

> **章节概要**：单字符 I/O:`getchar`与`putchar`；缓冲区；完全缓冲 I/O 与行缓冲 I/O；结束键盘输入(C 处理文件的方式)；文件；流；检测文件结尾；C 语言的`EOF`；重定向和文件；UNIX、Linux 和 DOS 重定向(流的输送)、重定向注意事项；创建更友好的用户界面；处理缓冲输入的换行符；处理混合数值字符输入的错误；输入验证

</div>

##### **单字符 I/O:getchar 与 putchar**

- 在第七章中提到过，`getchar()`和`putchar()`每次**只处理一个字符**。可能这种方法过于笨拙，但这种方法**很适合计算机**。而且，这是绝大多数**文本处理程序**所用的**核心方法**

- 详细用法请参照**前一章**

- 为何输入的字符能直接**显示在屏幕**上？如果用一个**特殊字符**(如`#`)来**结束输入**，就无法**在文本中使用**这个字符。是否有**更好的办法**结束输入？首先要了解**C 程序如何处理键盘输入**，尤其是**缓冲**和**标准输入文件**的概念

##### **缓冲区**

- **缓冲输入与缓冲区**

  > **缓冲输入**：对于**程序输入**，大部分系统在用户按下`Enter`之前**不会重复打印**刚输入的字符，即在**重复输入字符**时，不会在终端出现`H(输入)H(输入后处理输出的字符)e(第二格输入的字符)elllloo`这样的情况。这种**输入形式**称为**缓冲输入**  
  > **缓冲区**：用户**输入的字符**会先被**收集并储存**在一个被称为**缓冲区**的**临时储存区**，按下`Enter`时，程序才可使用用户输入的字符

  ![](https://s2.loli.net/2022/06/15/gP38vdLms4abNn1.png)

- **为什么要有缓冲区**

  > 1、把**若干字符**作为**一个块**传输比**逐个发送**这些字符**节约时间**  
  > 2、如果用户**打错字符**，可以**直接通过键盘修正**，当最后按下`Enter`时，传输的是**正确的输入**  
  > 3、虽然缓冲输入**好处很多**，但某些**交互式程序**也需要**无缓冲输入**，比如在**游戏中**，希望**按下一个按键**就**立刻执行**相应的指令。因此缓冲输入和无缓冲输入**都有用武之地**

- **完全缓冲 I/O 与行缓冲 I/O**

  > **完全缓冲输入**：指当**缓冲区被填满**时才**刷新缓冲区**(内容被发送至目的地)，通常出现在**文件输入**中。**缓冲区大小**取决于**系统**，常见**512 字节**和**4096 字节**  
  > **行缓冲输入**：指在**出现换行**时**刷新缓冲区**。**键盘输入**通常是**行缓冲输入**，所以在按下`Enter`时才**刷新缓冲区**

- **使用缓冲输入还是无缓冲输入**

  > 1、**ANSI C**和**后续的 C 标准**都规定**输入是缓冲的**，不过最初 K&R 把这个**决定权**交给了**编译器的编写者**  
  > 2、**ANSI C**决定把**缓冲输入**作为**标准输入**的原因是：一些计算机**不允许无缓冲输入**  
  > 3、**ANSI C**没有提供**调用无缓冲输入**的**标准方式**，这意味着能否进行无缓冲输入**取决于计算机系统**

##### **结束键盘输入(C 处理文件的方式)**

- **文件、流和键盘输入**

  - **文件**

    > 1、**文件**是**储存器**中**储存信息的区域**。通常，文件都**保存**在某种**永久储存器**中(如硬盘、U 盘、DVD 等)。  
    > 2、毫无疑问，文件对于计算机系统**相当重要**。例如你编写的**C 程序**就保存在**文件**中，用来**编译 C 程序**的**程序**也保存在**文件**中  
    > 3、某些程序需要**访问指定的文件**。当**编译**储存在名为`echo.c`**文件**中的**程序**时，编译器**打开**`echo.c`文件并**读取**其中的内容，当编译器**处理完后**，会**关闭**该文件  
    > 4、其他程序，例如**文字处理器**，不仅要**打开**、**读取**、**关闭**文件，还要把数据**写入**文件

  - **C 语言与文件**

    > 1、C 是一门强大、灵活的语言，有许多用于**打开**、**读取**、**写入**、**关闭**文件的**库函数**  
    > 2、从**较低层面**上，C 可以使用**主机操作系统**的**基本文件工具**直接处理文件，这些直接**调用操作系统**的**函数**被称为**底层 I/O**。但计算机系统**各不相同**，所以**不可能**为普通的**底层 I/O**函数创建**标准库**  
    > 3、从**较高层面**上，C 还可以通过**标准 I/O 包**来处理文件。这涉及**创建**用于处理文件的**标准模型**和一套**标准 I/O 函数**。这一层面上，具体的**C 实现**负责**处理不同系统的差异**，以便用户使用**统一**的界面

  - **流(stream)**

    > 1、从**概念上**看，C 程序**处理**的是**流**，而**不是直接处理文件**  
    > 2、**流**是一个**实际输入或输出**映射的**理想化数据流**。这意味着**不同属性**和**不同种类**的输入，由**属性更统一**的**流**来表示  
    > 3、于是，**打开文件的过程**就是把**流**与**文件**关联，而且**读写**都通过**流**来完成

- **文件结尾**

  - **操作系统检测文件结尾**

    > 1、计算机**操作系统**要以某种方式**判断文件的开始和结束**，其中**一种方法**是，在**文件末尾**放一个**特殊的字符**标记文件结尾  
    > 2、**CP/M**，**IBM-DOS**，**MS-DOS**的文本文件曾经都**用过这种方法**。如今这些操作系统可以使用**内嵌的**`Ctrl+Z`字符来标记文件结尾  
    > 3、这**曾经是**操作系统使用的**唯一标记**，不过现在有一些**其他选择**，如**记录文件的大小**。所以现代的文本文件**不一定有**嵌入的`Ctrl+Z`，但如果有，**操作系统**会**将其视为**一个**文件结尾的标记**，如后附图  
    > 4、操作系统使用的**另一种方法**是**储存文件大小的信息**。如果文件有**3000 字节**，那么**读到 3000 字节**时便**达到文件的末尾**  
    > 5、**MS-DOS**及其相关系统使用这种方法**处理二进制文件**，因为用这种方法可以在文件中**储存所有的字符**。新版的**DOS**也使用这种方式**处理文本文件**。**UNIX**使用这种方式**处理所有的文件**

    ![](https://s2.loli.net/2022/06/16/ANt5CdYcEu94Og1.png)

  - **C 语言检测文件结尾**

    > 1、在 C 语言中，用`getchar()`读取文件**检测到文件结尾**时，会返回**特殊值**`EOF`(End Of Line 缩写)。`scanf()`检测到文件结尾时也返回`EOF`  
    > 2、通常，`EOF`被定义在`stdio.h`**文件中**：`#define EOF (-1)`

  - **关于 EOF**

    > 1、为什么是**选用-1**？因为`getchar()`函数的**返回值**介于**0~127**，这些值对应**标准字符集**。但是如果系统能识别**拓展字符集**，则**返回值**可能在**0~255**。但无论哪种情况，-1**都不对应任何字符**，所以选用-1 标记文章结尾  
    > 2、某些系统也许把`EOF`**定义为-1 以外的值**，但是**定义的值**一定与**输入字符**所产生的**返回值**会**不同**。如果包含`stdio.h`文件，并使用`EOF`符号，就**不必担心**值不同的问题。这里关键要理解`EOF`**是一个值**，标志着**检测到文件结尾**，**并不是**在文件中**找得到的符号**  
    > 3、如何在**程序中使用**？把`getchar()`的**返回值**和`EOF`比较，如果**不同**则**没有到达文件结尾**，即如下：`while((ch = getchar()) != EOF)`

  - **键盘模拟文件结尾条件**

    - 如果**正在读取**的是**键盘输入**而**不是文件**会怎样？绝大部分系统都有办法**通过键盘模拟文件结尾条件**。如下示例：

      ```c
      #include <stdio.h>
      int main(void)
      {
          int ch;
          while ((ch = getchar()) != EOF)
          {
              putchar(ch);
          }
          return 0;
      }
      ```

    > 1、不用定义`EOF`，因为`stdio.h`已经**定义过了**  
    > 2、不用担心`EOF`的**实际值**，因为`EOF`在`stdio.h`中用`#define`预处理指令定义，**可直接使用**  
    > 3、变量**ch**的类型从`char`变成了`int`，因为`char`的变量只能表示**0~255**的**无符号**整数，但`EOF`的**值是-1**。还好`getchar()`函数**实际返回值类型**是`int`，所以它可以读取`EOF`字符。如果实现使用**有符号**的`char`类型，也可以把**ch**声明为`char`，但最好还是用**更通用**的形式  
    > 4、由于`getchar()`**返回类型**是`int`，如果把`getchar()`的**返回值**赋给`char`变量，一些编译器可能会**警告甚至丢失数据**  
    > 5、**ch**是**整数**不会影响`putchar()`，该函数仍然会**打印等价字符**  
    > 6、使用该程序进行**键盘输入**，要设法输入`EOF`字符，不能只输入**字符 EOF**，也不能只输入**数值-1**(会被当做一个连字符和一个数字 1)。正确的方法是**找出当前系统的要求**，如大多数**UNIX**和**Linux**系统中在**一行开始**使用`Ctrl+Z`会**传输文件结尾信号**，而**Windows**系统中在**一行开始**使用`Ctrl+Z`会**传输文件结尾信号**，所以在程序中需要**设立不同的提示语**提醒用户

##### **重定向和文件**

- 默认情况下，C 程序使用**标准 I/O**包查找**标准输入**作为**输入源**，这就是前面介绍过的**stdin 流**，它是把数据**读入计算机**的常用方式

- **程序使用文件的两种方式**

  > 1、显式使用**特定的函数**打开、关闭、读取、写入文件，将在第 13 章介绍  
  > 2、设计能与键盘和屏幕互动的程序，通过不同的渠道**重定向**输入至文件和从文件输出，下面主要介绍此类**重定向**

- **UNIX、Linux 和 DOS 重定向**

  - UNIX(运行命令行模式)、Linux(ditto)和 Windows 命令行(注意使用**cmd**而不是**终端**)提示都能**重定向输入输出**。**重定向输入**让程序**使用文件**而不是键盘输入，**重定向输出**让程序**输出至文件**而不是屏幕

  - **重定向输入**

    > 1、假设已经编译了**echo.c**程序，并生成了一个名为**echo**的**可执行文件**(Windows 中为**echo.exe**，**注意后续命令注意使用带有文件后缀的名字**)。想要**运行**该程序，在**命令行**的**对应目录**中输入可执行文件名：`./echo`，**Windows**下输入`echo.exe`，即可执行可运行文件  
    > 2、现在，假设要用该程序处理**名为 passage**的**文本文件**(.txt)，文件中储存的是**可识别的字符**。此处由于操作对象是**字符**，所以使用文本文件。使用此命令代替上面的命令：`./echo < passage`，**Windows**下输入`echo.exe < passage.txt`  
    > 3、`<`符号是 UNIX 和 DOS/Windows 的**重定向运算符**。该运算符使**passage 文件**与**stdin 流**相关联，把文件中的内容**导入 echo 可执行程序**

  - **重定向输出**

    > 1、类似的，假设要用**echo 可执行程序**把**程序输出**的内容**发送到名为 passage 的新文件**，便可以使用`./echo > passage`，**Windows** 下输入`echo.exe > passage.txt`  
    > 2、`>`符号是第二个**重定向运算符**，创建了一个名为**passage 的新文件**，然后把 echo 的**输出写入该文件**。通常会**擦除该文件的内容**，然后**替换新的内容**，在下一行开始处按下`Ctrl+D`(UNIX)或`Ctrl+Z`(DOS)即可**结束该程序**

  - **组合重定向**

    > 1、现在假设你希望制作一份**mywords 文件**的**副本**，并**命名为 savewords**，输入`./echo < mywords > savewords`，Windows 下输入`echo.exe < mywords.txt > savewords.txt`  
    > 2、下面的命令**也起作用**，因为**命令**与**重定向运算符的顺序无关**，如：`./echo > savewords < mywords`  
    > 3、在一条命令中，输入文件名和输出文件名**不能相同**，如：`./echo < mywords > mywords <==错误`，原因是`> mywords`在输入之前已导致**原 mywords 长度被截断为 0**

  - **其他重定向注意事项**

    > 1、重定向运算符连接**一个可执行程序**和**一个数据文件**，**不能直接连接两个可执行文件或连接两个数据文件**  
    > 2、使用重定向运算符**不能读取多个文件的输入**，也**不能把输出定向至多个文件**  
    > 3、文件名和运算符之间**空格不是必须的**，且**有些系统不能使用空格**  
    > 4、UNIX、Linux 或 Windows/DOS 还有`>>`运算符，该运算符可以**把数据添加到现有文件的末尾**且**不覆盖原内容**，而`|`运算符能**把一个文件的输出连接到另一个文件的输入**

##### **创建更友好的用户界面**

- **使用缓冲输入**

  - **示例程序(待优化程序)**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int guess = 1;
      printf("在1-100想一个数，输入y或n表示当前显示的数是否是你想的数\n");
      printf("数字是1吗\n");
      while (getchar() != 'y')
      {
          printf("那么，是%d吗\n", ++guess);
      }
      printf("好的，这便是你想的数字");
      return 0;
  }
  ```

  - 该示例程序有**以下问题**，对于用户的体验有影响

    > 1、**缓冲输入**要求用户按下`Enter`发送，这一动作也**传递了换行符**，程序必须**妥善处理**这个**换行符**  
    > 2、**用户的输入**可能并不会按照**人为约定**只输入**y 或 n**，仍有**其他输入**的可能，也需要**对应进行处理**

  - **处理缓冲输入的换行符**

    - 该程序每次**输入 n 时**，程序便打印了**两条消息**。这是由于程序**读取 n**作为用户**否定了数字 1**，另外**读取了一个换行符**作为用户**否定了数字 2**。此外**输入 no**，会打印三条语句，程序**将 n 和 o 分别当做了一次响应**，外加**换行符的一次响应**
    - **优化 1**：跳过剩余输入

      > 1、使用`while`循环，**循环丢弃**输入行最后**剩余的内容**，包括换行符  
      > 2、这种方法还能把**no**、**no way**都视为简单的**n**(因为只使用第一个字符，其余字符被丢弃)

      ```c
      while(getchar() != 'y')
      {
          printf("那么，是%d吗\n", ++guess);
          while(getchar() != '\n')
          {
              continue; //跳过剩余输入行
          }
      }
      ```

    - **优化 2**：使用变量储存响应以进行判断

      > 1、上述**方法 1**虽然解决了换行符的问题，但程序仍会将**f**视为**n**  
      > 2、可以添加一个**char**类型变量**储存响应**，再用`if`判断**筛选其他响应**

      ```c
      char response;
      while((response = getchar()) != 'y')
      {
          if (response == 'n')
          {
              printf("那么，是%d吗\n", ++guess);
          }
          else
          {
              printf("未知输入\n");
          }
          while(getchar() != '\n')
          {
              continue; //跳过剩余输入行
          }
      }
      ```

- **混合数值和字符输入**

  - **示例程序(待优化程序)**

  ```c
  #include <stdio.h>
  void display(char cr, int lines, int width)
  {
      // 该函数用于输出
      int row, col;
      for (row = 1; row <= lines; row++)
      {
          for (col = 1; col <= width; col++)
          {
              putchar(cr);
          }
          printf("\n");
      }
  }

  int main(void)
  {
      int ch, rows, cols;
      printf("输入要打印的字符、行数、每行个数\n");
      while ((ch = getchar()) != '\n')
      {
          scanf("%d%d", &rows, &cols);
          display(ch, rows, cols);
          printf("输入另一组数据继续，输入换行退出\n");
      }
      printf("Bye!");
      return 0;
  }
  ```

  - 该示例程序有**以下问题**，对于用户的体验有影响

    > 1、`getchar()`与`scanf()`各自使用都能完成各自的任务，但尽可能**不要将它们混用**。`getchar()`读取每个字符，**包括空格换行制表符**，`scanf()`会**跳过空格换行制表符**，上述程序便因此出错  
    > 2、当程序**输出完第一组**数据，就**直接退出**了，无法输入第二组数据  
    > 3、在**第一次输入**的最后一个数字后的**换行符**，`scanf()`将其**留在了输入队列里**，而`getchar()`不会跳过换行符。所以进入**下一次迭代**时，`getchar()`便**读取了该换行符**，将其赋给**ch**

  - **处理混合数值字符输入的错误**

    - **优化**：跳过**一轮输入结束**与**下一轮输出开始**之间所有的**换行符和空格**

      ```c
      /*修改主函数的while循环*/
      while ((ch = getchar()) != '\n')
      {
          if((scanf("%d%d", &rows, &cols)) != 2)
          {
              break;
          }
          display(ch, rows, cols);
          while(getchar() != '\n')
          {
              continue;
          }
          printf("输入另一组数据继续，输入换行退出\n");
      }
      ```

##### **输入验证**

- 在**实际应用**中，用户不一定会按照**程序的指令**行事，**用户的输入**和**程序期望**的输入**不匹配**时常发生。因此需要**输入验证**，**预料**一些可能的**输入错误**，并提前编写**处理错误**的程序

- 假设编写了一个**处理非负整数**的循环，提前推演**可能出现的错误**，便可以按如下方式处理：

  - 防止出现**负数**，使用**关系表达式**排除此种情况：

    ```c
    long n;
    scanf("%ld", &n); // 获取第一个值
    while (n >= 0)  // 判断是否为非负数
    {
        // 处理n(此处省略处理语句)
        scanf("%ld", &n);   // 继续获取下一个值
    }
    ```

  - 防止输入**错误类型**的值，判断`scanf()`**返回值**排除，并结合上处错误改进：

    ```c
    long n;
    while (scanf("%ld", &n)==1 && n>=0)
    {
        // 处理n(此处省略处理语句)
    }
    ```

  - 对于上处程序，当用户输入**错误的值**，会直接**结束程序**。此外还可以**提示用户**再次**输入正确的值**，但这种情况下，需要**处理有问题的输入**。因为`scanf()`的**错误输入**仍会**留在输入队列**，可以使用`getchar()`函数**逐字读取输入**，还可以将其**结合在一个函数内**，按如下改进：

    ```c
    long get_long(void)
    {
        long input;
        char ch;
        while (scanf("%ld", &input) != 1)
        {
            while ((ch = getchar()) != '\n')
            {
                putchar(); // 处理错误的输入
            }
            printf("输入有误，请重新输入\n");
        }
        return input;
    }
    ```

---

#### **函数**

---

<div class="success">

> **章节概要**：复习函数；函数概述；函数创建与使用；函数参数与返回值；ANSI C 函数原型；旧式声明问题及解决；递归；递归演示；递归的基本原理；尾递归；递归的优缺点；编译多源代码文件的程序;使用(自建)头文件；查找地址：&运算符；更改主调函数中的变量；指针简介；指针基本概念；间接运算符：\*；声明指针；使用指针在函数间通信

</div>

##### **复习函数**

- **函数概述**

  - **函数**：完成**特定任务**的**独立程序代码单元**。**语法规则**定义了函数的**结构**和**使用方式**

  - **功能**

    > 1、**执行某些动作**：如`printf()`把数据**打印**到屏幕  
    > 2、**找出一个值供程序使用**：如`strlen()`把**指定字符串**的**长度**返回给程序

  - **优点**

    > 1、可以省去编写**重复代码**的苦差  
    > 2、让程序更加**模块化**  
    > 3、提高代码的**可读性**  
    > 4、方便后期**修改**、**完善**

- **函数创建与使用**

  - **示例程序**

    ```c
    /*定义并使用starbar函数打印40个星号*/
    #include <stdio.h>

    void starbar(void); // 函数原型

    int main() // 主函数
    {
        starbar();  // 调用函数
        printf("hello world\n");
        starbar();
        return 0;
    }

    void starbar(void)  // 定义函数
    {
        for (int i=1;i<=40;i++){
            putchar('*');
        }
        putchar('\n');
    }
    ```

  - **函数基础**

    - 基本术语

      > 1、**函数原型**：告诉**编译器**函数`starbar()`的**相关信息**。其指明了函数的**返回值类型**和函数接收的**参数类型**，这些**信息**称为函数的**签名**  
      > 2、**函数调用**：表明在此**执行函数**  
      > 3、**函数定义**：指定**函数**具体要**做什么工作**  
      > 4、**补充**：**函数原型**与**函数定义**可以在**同一步**完成，即函数原型`void starbar(void)`后可以**直接跟花括号**进行**定义**。此外**函数原型**可以置于`main()`**主函数**内**声明变量处**

    - 函数类型

      > 1、**函数**和**变量**一样有**多种类型**，任何程序在**使用函数前**都要**声明函数类型**  
      > 2、`void starbar(void);`中第一个**void**表明函数**返回类型**是**void**，即**没有返回值**；**starbar**为**函数名**；第二个**void**表明函数**没有参数**；**分号**表明**仅在声明函数**，**不是在定义函数**  
      > 3、因此，**函数名前**的**类型**仅表明函数**返回值类型**，而**不是参数类型**

    - 函数的跨文件调用

      > 1、程序把`starbar()`和`main()`放在**一个文件**中，也可以将它们**分别**放在**两个文件**下  
      > 2、把函数都**放在一个文件**中的**单文件形式**比较**容易编译**，而**使用多个文件**方便在**不同程序**中使用**同一个函数**  
      > 3、如果把**函数**放在**单独的文件**中，要把`#define`和`include`指令也放入该文件，稍后会讨论如何**跨文件调用函数**

- **函数参数与返回值**

  - **示例程序**

    ```c
    #include <stdio.h>

    int plus_multiply(int num1, int num2, int num3)
    {
        int result;
        result = (num1 + num2) * num3;
        return result;
    }

    int main(void)
    {
        int a, b, c;
        printf("计算(a+b)*c的结果，请分别输入a,b,c的值：\n");
        scanf("%d%d%d", &a, &b, &c);
        printf("%d", plus_multiply(a, b, c));
        return 0;
    }
    ```

  - **形参与实参**

    > 1、**形式参数**：**函数定义**的**函数头**中声明的**变量**，称为**形参**  
    > 2、**实际参数**：出现在**函数调用**的**圆括号**内的**表达式**，称为**实参**

  - **函数参数的定义与使用**

    > 1、在**函数原型**的**圆括号**里，写入需要**传入的参数**的**类型**，以及**参数名**，即**定义形参**。语法为`void def (类型 形参1, 类型 形参2, ...)`，实例如`void def (int a, float b)`  
    > 2、**使用形参**，需要先**传入实参**。在调用函数时，**按顺序**传入**指定类型**的值(即**实参**)，此外也可以**分别定义**形参的值，如`def (b=实参1, a=实参2)`，便可将**实参的值**传入函数的**形参**

  - **返回值**

    > 1、如果说**参数**是方便**值**从**主调函数**前往**被调函数**，那**返回值**便是方便**值**从**被调函数**前往**主调函数**。函数中为`return`语句后的值  
    > 2、返回值的**类型**即为**函数原型**中定义的**函数类型**

##### **ANSI C 函数原型**

- **旧式声明**

  > 1、在**ANSI C**标准**之前**，声明函数的方案**有缺陷**，因为只需要声明**函数类型**，不用声明**任何参数**  
  > 2、如`int imin()`这个**函数声明**，只需要告知编译器`init()`**返回 int 类型的值**  
  > 3、然而，以上**函数声明**并未给出`imin()`函数的**参数个数和类型**。因此，如果**调用**`imin()`时使用的参数**个数不对**或**类型不匹配**，编译器根本**不会察觉**

- **问题所在**

  - **示例程序**

    ```c
    #include <stdio.h>

    int imax(); // 旧式声明

    int main(void)
    {
        printf("%d和%d的最大值是%d\n", 3, 5, imax(3));
        printf("%d和%d的最大值是%d\n", 3, 5, imax(3.0, 5.0));
        return 0;
    }

    int imax(n, m)
    int n, m;
    {
        return (n > m ? n : m);
    }
    ```

    ```
    3和5的最大值是1606416656
    3和5的最大值是3886
    ```

  - **问题分析**

    > 1、由于不同系统的**内部机制不同**，所以出现问题的**具体情况也不同**，下面介绍**PC**和**VAX**的情况  
    > 2、**主调函数**把它的**参数**储存在被称为**栈**的**临时储存区**，**被调函数**从**栈**中**读取**这些参数，而这两个过程**并未互相协调**  
    > 3、**主调函数**根据函数调用中的**实际参数**决定**传递的类型**，**被调函数**根据它的**形式参数**来**读取**值。因此，函数调用`imax(3)`把**一个整数**放在**栈**中，当函数**开始执行时**，它从**栈**中**读取两个整数**，而**实际**只存放了**一个**待读取的整数，所以读取的**第二个值**是当时**恰好在栈中**的**其他值**  
    > 4、**第二次**使用`imax()`函数时，它传递的是**float**类型的值。这次把两个**double**类型的值放在**栈**中(当 float 作为参数传递会被升级成 double)。**两个 double**的值就是**两个 64 位**的值，所以弓**128 位**的数据被存放在**栈**中。当`imax()`读取**两个 int**值时，即**读取前 64 位**，于是**出现错误**

- **解决方案**

  - 针对**参数不匹配**的问题，**ANSI C**标准要求在**声明函数**时还要声明**变量的类型**，即使用**函数原型**来声明函数的返回类型、参数数量、参数类型
  - 未标明`imax()`函数有两个**int**类型的**参数**，可以使用**下面两种函数原型**来声明

    ```c
    int imax(int, int);
    int imax(int a, int b);
    ```

  - **第一种**形式使用以**逗号分隔**的类型列表，**第二种**形式在类型后面**添加了变量名**。注意，这里的**变量名**是**假名**，**不必**与函数定义的**形式参数**名**一致**

##### **递归**

- **递归**：C 函数允许**调用它自己**，这种调用称为**递归**。递归有时难以捉摸，有时却很方便实用

- **递归演示**

  - **示例程序**

    ```c
    #include <stdio.h>

    void up_and_down(int n)
    {
        printf("Level %d: n location %p\n", n, &n); // #1
        if (n < 4)
        {
            up_and_down(n + 1);
        }
        printf("Level %d: n location %p\n", n, &n); // #2
    }

    int main(void)
    {
        up_and_down(1); // 调用递归函数
        return 0;
    }
    ```

    ```
    Level 1: n location 000000000061FE00
    Level 2: n location 000000000061FDD0
    Level 3: n location 000000000061FDA0
    Level 4: n location 000000000061FD70
    Level 4: n location 000000000061FD70
    Level 3: n location 000000000061FDA0
    Level 2: n location 000000000061FDD0
    Level 1: n location 000000000061FE00
    ```

  - **程序分析**

    > 1、`main()`函数**调用**`up_and_down()`，称为**第 1 级递归**，然后`up_and_down()`**调用自己**，这次调用称为**第 2 级递归**，第 2 级**再次调用**，称为**第 3 级递归**，以此类推  
    > 2、`%p`、`&`用于显示变量的**内存地址**，稍后解释  
    > 3、首先，`main()`函数调用带**参数 1**的`up_and_down()`函数，此时**n=1**，**语句#1**打印**Level 1**，由于**n<4**，执行调用**实际参数**为**n+1(即 2)**的`up_and_down()`(**第 2 级**)  
    > 4、**第 2 级**中**n=2**，所以**语句#1**打印**Level 2**，以此类推继续**递归调用**  
    > 5、当执行到**第 4 级**时**n=4**，`if`语句**n<4**为**false**，所以跳过执行**不再调用**自己，**第 4 级**继续执行**语句#2**，打印**Level 4**  
    > 6、此时**第 4 级**调用结束，控制返回它的**主调函数**(**即第 3 级**)，**第 3 级**继续执行**语句#2**，打印**Level 3**，以此类推，直到**第 1 级**返回`main()`函数  
    > 7、注意，每级递归的**变量 n**都属于每级递归**私有**，这点从**程序输出的地址**可以得出

- **递归的基本原理**

  > 1、**每级递归调用**都有**自己的变量**。也就是说，**第 1 级的 n**和**第 2 级的 n**是**完全不同**的  
  > 2、**每次函数调用**都会**返回一次**。当函数执行完毕，**控制权**将返回到**上一级递归**，程序必须**按顺序逐级返回递归**  
  > 3、递归函数中位于**递归调用之前**的语句，均按**被调函数的顺序**执行。例如上例按序**Level 1**、**Level 2**、**Level 3**、**Level 4**  
  > 4、递归函数中位于**递归调用之后**的语句，均按**被调函数相反的顺序**执行。例如上例按序**Level 4**、**Level 3**、**Level 2**、**Level 1**  
  > 5、虽然**每级递归**都有**自己的变量**，但是并**没有拷贝函数的代码**。程序**按顺序执行**函数中的代码，**递归调用**相当于又**从头开始按序执行**函数的代码。除了为每次递归调用**创建变量**外，**递归调用**非常类似一个**循环语句**  
  > 6、递归函数**必须包含**能让递归**调用停止**的语句。通常都使用`if`**语句**或其他等价的**测试条件**在**函数形参**等于**某特定值**时终止递归。因此，**每次递归**调用的**形参**都要使用**不同的值**

  ![](https://s2.loli.net/2022/07/01/VTa7kZndFOlJopy.png)

- **尾递归**

  - **尾递归**：把**递归调用**置于**函数末尾**。是**最简单的**递归形式，因为它**相当于循环**

  - **阶乘计算示例**(5 的阶乘：1\*2\*3\*4\*5；0 的阶乘=1)

  ```c
  #include <stdio.h>

  long fact(int n) // 直接使用for循环的函数
  {
      long ans;
      for (ans = 1; n > 1; n--) // 此处顺带初始化ans为1
      {
          ans *= n;
      }
      return ans;
  }

  long rfact(int n) // 使用递归的函数
  {
      long ans;
      if (n > 0)
      {
          ans = n * rfact(n - 1);
      }
      else
      {
          ans = 1;
      }
      return ans;
  }

  int main(void)
  {
      int num;
      do
      {
          printf("请输入一个0~12之间的整数：\n");
          scanf("%d", &num);
      } while (num < 0 || num > 12);
      printf("循环得到的结果：%ld\n", fact(num));
      printf("递归得到的结果：%ld\n", rfact(num));
      return 0;
  }
  ```

- **递归的优缺点**

  - 递归既有优点也有缺点。**优点**是递归对于**某些编程问题**提供了**最简单的解决方案**。**缺点**是一些**递归算法**会**快速消耗**计算机的**内存资源**，此外**不便于阅读和维护**

##### **编译多源代码文件的程序**

- 使用**多个函数**最简单的方法是把它们都放在**同一个文件**中，然后像编译**只有一个函数的文件**那样编译该文件即可。其他方法**因操作系统而异**，下面举例说明

- **UNIX**

  > 1、假定**UNIX 系统**中安装了**UNIX C 编译器 cc**，假设**file1.c**和**file2.c**是两个内涵 C 函数的文件  
  > 2、使用`cc file1.c file2.c`可以将**两个文件**编译成**一个**名为**a.out**的可执行文件，并**生成**两个名为**file1.o**和**file2.o**的目标文件  
  > 3、如果后来改动了**file1.c**而没有改动**file2.c**，可以使用`cc file1.c file2.o`来编译(如果**file2.o**文件还存在)

- **Linux**

  > 1、假定**Linux 系统**中安装了**GNU C 编译器 GCC**，假设**file1.c**和**file2.c**是两个内涵 C 函数的文件  
  > 2、使用`gcc file1.c file2.c`可以将**两个文件**编译成**一个**名为**a.out**的可执行文件，并**生成**两个名为**file1.o**和**file2.o**的目标文件  
  > 3、如果后来改动了**file1.c**而没有改动**file2.c**，可以使用`cc file1.c file2.o`来编译(如果**file2.o**文件还存在)

- **DOS 命令行编译器**

  > 1、绝大多数**DOS 命令行编译器**的工作原理和**UNIX 的 cc 命令类似**，只不过使用**不同名称**而已  
  > 2、一个**区别**是，对象文件的**拓展名**是`.obj`而不是`.o`

- **Windows 和 Mac 的 IDE 编译器**

  > 1、**Windows**和**Mac**使用的**集成开发环境 IDE**的编译器是**面向项目**的，这种 IDE 的编译器要**创建项目**来**运行单文件程序**  
  > 2、对于**多文件**程序，需要使用相应的**菜单命令**，把源代码加入一个项目中。要确保**所有源代码文件**都在**项目列表**中列出

- **使用头文件**

  > 1、如果把`main()`放在**第一个文件中**，**函数定义**放在**第二个文件中**，那么**第一个文件**仍然要使用**函数原型**  
  > 2、而把**函数原型**放在**头文件**中，就**不用**每次使用函数文件都**写出函数的原型**  
  > 3、此外，我们常常使用**C 预处理器**(`#define`)定义**符号常量**，也可以将其**写入头文件**，使用时只需要**包含**(`#include`)**该头文件**即可。这样更有利于**维护修改**，也利于对**常量的管理**  
  > 4、因此，将**函数原型**和**字符常量**放在**头文件**，是一个十分良好的**编程习惯**  
  > 5、`#include "xxx.h"`命令可以引入**自定义的头文件**，使用**双引号**`""`，且引号内如果是**同目录**可以**直接写文件名**，不同目录也可以使用**相对路径**和**绝对路径**

  - **如下案例**，编写一个模拟酒店收费管理的程序，注意**标注的文件名**来区分文件，请使用**多源代码文件**编译方法**编译文件**(程序运行仍会从`usehotel.c`的`main()`**主函数**开始)

    ```c
    /* hotel.h */
    #define QUIT 5
    #define HOTEL1 180.00
    #define HOTEL2 225.00
    #define HOTEL3 225.00
    #define HOTEL4 355.00
    #define DISCOUNT 0.95
    #define STARS "**************************************************"

    // 显示选择列表
    int menu(void);

    // 返回预定天数
    int getnights(void);

    // 计算费用并显示结果
    void showprice(double rate, int nights);
    ```

    ```c
    /* hotel.c */
    #include <stdio.h>
    #include "hotel.h"
    int menu(void)
    {
        int code, status;
        printf("\n%s\n", STARS);
        printf("enter the number to desired hotel:\n");
        printf("1) XXX Hotel1            2) XXX Hotel2\n");
        printf("3) XXX Hotel3            4) XXX Hotel4\n");
        printf("5) Quit\n");
        printf("%s\n", STARS);
        while ((status = scanf("%d", &code)) != 1 || (code < 1 || code > 5))
        {
            if (status != 1)
                scanf("%*s"); //处理非整数输入
            printf("Enter an integer from 1 to 5:\n");
        }
        return code;
    }

    int getnights(void)
    {
        int nights;
        printf("How many nights are you needed?\n");
        while (scanf("%d", &nights) != 1)
        {
            scanf("%*s"); //处理非整数输入
            printf("Enter an integer, such as 2\n");
        }
        return nights;
    }

    void showprice(double rate, int nights)
    {
        int n;
        double total = 0.0;
        double factor = 1.0;
        for (n = 1; n <= nights; n++, factor *= DISCOUNT)
            total += rate * factor;
        printf("The total cost will be &%0.2f.\n", total);
    }
    ```

    ```c
    /* usehotel.c */
    #include <stdio.h>
    #include "hotel.h"
    int main(void)
    {
        int nights;
        double hotel_rate;
        int code;
        while ((code = menu()) != QUIT)
        {
            switch (code)
            {
                case 1:
                    hotel_rate = HOTEL1;
                    break;
                case 2:
                    hotel_rate = HOTEL2;
                    break;
                case 3:
                    hotel_rate = HOTEL3;
                    break;
                case 4:
                    hotel_rate = HOTEL4;
                    break;
                default:
                    printf("Oops!\n");
                    break;
            }
            nights = getnights();
            showprice(hotel_rate,nights);
        }
        printf("Thank you and goodbye\n");
        return 0;
    }
    ```

  - 此外，**函数**也可以**直接定义**在头文件内，因此上述程序写为**单源代码文件**的方式可以**精简如下**：

    ```c
    /* hotel.h */
    #include <stdio.h> // 注意引入头文件
    #define QUIT 5
    #define HOTEL1 180.00
    #define HOTEL2 225.00
    #define HOTEL3 225.00
    #define HOTEL4 355.00
    #define DISCOUNT 0.95
    #define STARS "**************************************************"

    // 显示选择列表
    int menu(void)
    {
        int code, status;
        printf("\n%s\n", STARS);
        printf("enter the number to desired hotel:\n");
        printf("1) XXX Hotel1            2) XXX Hotel2\n");
        printf("3) XXX Hotel3            4) XXX Hotel4\n");
        printf("5) Quit\n");
        printf("%s\n", STARS);
        while ((status = scanf("%d", &code)) != 1 || (code < 1 || code > 5))
        {
            if (status != 1)
                scanf("%*s"); //处理非整数输入
            printf("Enter an integer from 1 to 5:\n");
        }
        return code;
    }

    // 返回预定天数
    int getnights(void)
    {
        int nights;
        printf("How many nights are you needed?\n");
        while (scanf("%d", &nights) != 1)
        {
            scanf("%*s"); //处理非整数输入
            printf("Enter an integer, such as 2\n");
        }
        return nights;
    }

    // 计算费用并显示结果
    void showprice(double rate, int nights)
    {
        int n;
        double total = 0.0;
        double factor = 1.0;
        for (n = 1; n <= nights; n++, factor *= DISCOUNT)
            total += rate * factor;
        printf("The total cost will be &%0.2f.\n", total);
    }
    ```

    ```c
    /* usehotel.c */
    同上例文件，写法不变
    此外由于hotel.h中引入了stdio.h，而本文件又调用了hotel.h，所以可以不再调用stdio.h，即删除本文件的#include <stdio.h>
    ```

##### **查找地址：&运算符**

- **指针**是 C 语言中**最重要的**(有时也是**最复杂的**)概念之一，用于**存储变量的地址**。前面使用的`scanf()`函数中就**使用地址作为参数**

- 如果**主调函数**不使用`return`**返回**的值，则必须通过**地址**才能**修改**主调函数中的值

- **一元**`&`**运算符**的用法

  - **一元**`&`**运算符**给出变量的**储存地址**，如果`pooh`是变量名，那么`&pooh`是变量的地址。可以把地址看做是**变量在内存中的位置**

  - **PC 地址**通常使用**十六进制**表示，`%p`是输出地址的**转换说明**

  - **示例程序**：查看不同函数中同名变量分别储存在什么位置

    ```c
    #include <stdio.h>

    void mikado(int bah)
    {
        int pooh = 10;
        printf("In mikado(), pooh= %d and &pooh= %p\n", pooh, &pooh);
        printf("In mikado(), bah= %d and &bah= %p\n", bah, &bah);
    }

    int main(void)
    {
        int pooh = 2, bah = 5;
        printf("In main(), pooh= %d and &pooh= %p\n", pooh, &pooh);
        printf("In main(), bah= %d and &bah= %p\n", bah, &bah);
        mikado(pooh);
        return 0;
    }
    ```

    ```
    In main(), pooh= 2 and &pooh= 000000000061FE1C
    In main(), bah= 5 and &bah= 000000000061FE18
    In mikado(), pooh= 10 and &pooh= 000000000061FDDC
    In mikado(), bah= 2 and &bah= 000000000061FDF0
    ```

  - **输出解析**

    > 1、两个**pooh**地址不同，两个**bah**的地址也不同，因此证实**计算机**把它们看做**4 个独立的变量**  
    > 2、函数调用`mikado(pooh)`把**实参 pooh=2**传递给了**形参 bah**。注意这种传递**只传递了值**，涉及的**两个变量并未改变**  
    > 3、注意**第 2 点**并非在**所有语言**都成立。如**FORTRAN**中，**子例程**会影响**主调例程**的**原始变量**。子例程**变量名**可能与原始变量**不同**，但它们的**地址相同**。但在 C 中不是这样，每个**C 函数**都有**自己的变量**，这样可以防止**原始变量**被**被调函数**的副作用**意外修改**，但也带来了**一些麻烦**

##### **更改主调函数中的变量**

- 有时需要在**一个函数**中改变**其他函数的变量**，则需要**使用指针**

- **程序示例**(**错误的方式**使用**函数**交换两个变量的**值**)

  ```c
  #include <stdio.h>

  void change(int u, int v)
  {
      int temp;
      temp = u;
      u = v;
      v = temp;
      printf("u:%d    v:%d\n",u,v);
  }

  int main(void)
  {
      int x = 5, y = 10;
      printf("before: %d %d\n", x, y);
      change(x, y);
      printf("after: %d %d\n", x, y);
      return 0;
  }
  ```

- **问题解析**

  > 1、但显然该程序`main()`中**x**和**y**的值**并未交换**，而交换函数`change()`内的**u**和**v**的值是**交换**的。问题出现在把**结果传回**`main()`时。  
  > 2、`change()`的变量并不是`main()`的变量，因此交换的**值**并不会**影响**`main()`中的**值**。  
  > 3、能否使用`return`**将值传回**`main()`？当然可以，但`return`只能把**被调函数**中的**一个值**传回，但现在**要传回两个值**，因此需要**使用指针**

##### **指针简介**

- **基本概念**

  - **指针**：一个**值**为**内存地址**的**变量**(或数据对象)。正如**char**类型变量**值是字符**，**int**类型变量**值是整数**，**指针**变量的**值是地址**

  - 假设一个**指针变量名**是**ptr**，则可以编写`ptr = &pooh`这条语句

    > 1、对于这条语句，我们说**ptr 指向 pooh**  
    > 2、**指针 ptr**和**地址 &pooh**的**区别**是，**指针 ptr**是**变量**，**地址 &pooh**是**常量**。或者说，**指针 ptr**是**可修改**的**左值**，**地址 &pooh**是**右值**  
    > 3、我们当然还可以**把 ptr 指向别处**，如`ptr = &bah`，现在**ptr 指向 bah**，**值**为**bah 的地址**

  - 要创建**指针变量**，要先**声明**指针变量的**类型**。假设想把**ptr**声明为**储存 int 类型变量地址**的指针，就要使用下面介绍的**新运算符**

- **间接运算符：**`*`

  > 1、假设已知`ptr = &bah;`，即**ptr 指向 bah**  
  > 2、使用**间接运算符**`*`，可以找出**储存在 bah 中**的**值**，语句为：`val = *ptr;`，意为**找出 ptr 指向的值**  
  > 3、该运算符有时也称为**解引用运算符**。但注意不要将其与**二元乘法运算符**混淆，虽然符号相同，但**语法功能不同**  
  > 4、将语句`ptr = &bah`和`val = *ptr`**放在一起**，其**功能作用**相当于此**赋值语句**：`val = bah;`  
  > 5、由此可见，使用**地址**和**间接运算符**可以**间接完成**上面赋值语句的功能，这也是其名称的由来

- **声明指针**

  - **声明指针变量示例**

    ```c
    int * pi;               // 指向int类型变量的指针
    char * pc;              // 指向char类型变量的指针
    float * pf, * pg;       // 指向float类型变量的指针
    ```

  - **声明解析**

    > 1、**类型说明符**表明了指针**所指向对象**的**类型**，**星号**表明**声明的变量**是一个**指针**  
    > 2、`*`和**指针名**之间的**空格可有可无**，通常在**声明时使用**空格，在**解引用时省略**空格  
    > 3、**pc 指向的值**(即\*pc)是`char`类型，而**pc 本身的类型**描述为"**指向 char 类型的指针**"  
    > 4、在大部分系统内部，该**地址**由一个**无符号整数**表示。但**不要**把**指针**认为是**整数类型**，为此，**ANSI C**专门为指针提供了`%p`的**格式转换说明**

    ![](https://s2.loli.net/2022/07/05/DgmC9sXaTE2ibY8.png)

- **使用指针在函数间通信**

  - 在上节**改变主调函数中的变量**中的程序，通过**函数**调换两个变量的值不能成功，在此可以**通过指针实现**

  - **示例程序**

    ```c
    #include <stdio.h>

    void change(int *u, int *v)
    {
        int temp;
        temp = *u;
        *u = *v;
        *v = temp;
    }

    int main(void)
    {
        int x = 5, y = 10;
        printf("before: %d %d\n", x, y);
        change(&x, &y);
        printf("after: %d %d\n", x, y);
        return 0;
    }
    ```

  - **程序解析**

    > 1、该函数传递的不是**x 和 y**的**值**，而是他们的**地址**。这意味着出现在`change()`**原型和定义**中的**形参 u 和 v**将**地址**作为它们的**值**。因此应把他们声明为**指针**。由于**x 和 y**是**整数**，所以**u 和 v**是**指向整数的指针**  
    > 2、在**函数体**中声明了一个交换值时必需的**临时变量 temp**，通过`temp = *u;`把**x 的值**存储在**temp**中  
    > 3、注意，**u 的值**是`&x`，这意味着可以用`*u`表示**x 的值**，这正是我们需要的。不要写成`temp = u;`，该语句意为把**x 的地址**赋给**temp**(u 的值就是 x 的地址)，而**不是 x 的值**  
    > 4、于是，通过这种形式进行交换，就可以做到**修改主调函数的值**的需求了

---

#### **数组与指针**

---

<div class="success">

> **章节概要**：数组；数组复习；初始化数组；只读数组；指定初始化器；指定初始化器的特性；数组元素赋值；数组边界；多维数组；二维数组；二维数组的声明；其他多维数组；指针和数组；指针处理数组；函数、数组与指针(声明数组形参)；使用指针形参；指针操作；不要解引用未初始化的指针；保护数组中的数据；对形参使用`const`；其他`const`内容；指针和多维数组；通过指针表示二维数组的值；数组指针与指针、多维数组深入；指向多维数组的指针；指针的兼容性；`C const`和`C++ const`；函数和多维数组指针；变长数组(VLA)；复合字面量

</div>

##### **数组**

- **数组复习**

  - **声明示例**

    ```c
    int main(void)
    {
        float candy[365];       // 内含365个float类型元素的数组
        char code[12];          // 内含12个char类型元素的数组
        int states[50];         // 内含50个int类型元素的数组
        ...
    }
    ```

  - **数组使用规则**

    > 1、前面介绍过，**数组**由**数据类型相同**的**一系列元素**组成。需要使用**数组**时，通过**声明数组**告诉**编译器**数组内含有**多少元素**和**元素类型**。**编译器**根据这些**信息**正确的**创建数组**  
    > 2、**普通变量**可以使用的**类型**，**数组元素都可以用**  
    > 3、**方括号**`[]`表示**candy**、**code**、**states**都是**数组**，方括号中的**数字**表示数组中的**元素个数**  
    > 4、要**访问**数组中的**元素**，通过使用数组**下标数**(也称为**索引**)**表示**数组中的各个**元素**。数组**元素编号**从**0**开始，所以`candy[0]`表示**candy**的**第 1 个元素**，`candy[364]`表示**第 365 个元素**，即**最后一个元素**

- **初始化数组**

  - **数组**通常被用来储存程序**需要的数据**。例如，一个内涵**12 个整数元素**的数组可以**储存 12 个月的天数**。这种情况下，在程序**一开始**就**初始化数组**比较好

  - **初始化数组的方法**

    - 只**存储单个值**的**变量**有时也称为**标量变量**，我们已经**很熟悉**如何**初始化**这种变量(代码中**PI**已被定义为**宏**)：

      ```c
      int fix = 1;
      float flax = PI * 2;
      ```

    - 而 C 使用**新的语法**来**初始化数组**：

      ```c
      int power[8] = {1, 2, 4, 6, 8, 16, 32, 64};       // ANSI C开始支持这种初始化
      ```

    - **语法解析**

      > 1、如上所示，用以**逗号分隔**的**值列表**(用**花括号**括起来)来**初始化数组**，**各值之间**用**逗号分隔**(逗号和值之间可以使用空格)  
      > 2、根据上面的**初始化**，把**1**赋给数组**首元素 power[0]**，**2**赋给**power[1]**，**按序**以此类推(注意 64 赋给的末元素是 power[7])  
      > 3、不支持**ANSI C**的编译器会把这种**初始化**识别为错误，在**数组声明前**加上关键字`static`即可解决(12 章将讨论此关键字)

  - **使用 const 声明数组**

    > 1、有时需要把**数组**设置为**只读**，这样**只能**从数组中**检索值**，不能把**新值写入**  
    > 2、要**创建只读数组**，应该用`const`声明和初始化数组，即`const int days[12] = {..., ..., ...}`  
    > 3、这样修改后，程序在**运行过程中**就**不能修改数组的内容**。一旦声明为`const`，便**不能**再给它**赋值**

  - **自动适配数组大小**

    ```c
    #include <stdio.h>
    int main(void)
    {
        const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31};
        for (int index = 0; index < sizeof(days) / sizeof(days[0]); index++)
        {
            printf("Month %2d has %d days.\n", index + 1, days[index]);
        }
        return 0;
    }
    ```

  - **注意事项**

    > 1、 使用数组前**必须先初始化**。与普通变量类似，在使用**数组元素**前**必须**先给它们**赋初值**，否则**编译器**使用的值是**内存相应位置上的现有值**(即都是**垃圾值**，会干扰程序运行)。只要**初始化**至少**1 个元素**的值，其余**未初始化**的值也会被**初始化为 0**  
    > 2、如果**初始化数组**时**省略**方括号中的**数字**，**编译器**会根据**初始化列表**中的**项数**来确定**数组大小**(如上"自动适配数组大小")  
    > 3、使用`sizeof()`计算**数组大小**(**字节**)时，`sizeof(days)`是**整个数组**的大小，`sizeof(days[0])`是数组中**一个元素**的大小

- **指定初始化器**

  - **C99**新增加了一个**新特性**：**指定初始化器**。利用该特性可以**初始化指定的数组元素**。例如只初始化**最后一个元素**

    > 1、传统 C 初始化：`int arr[6] = {0,0,0,0,0,212};`  
    > 2、**C99**规定，可以在**初始化列表**中使用带**方括号**的**下标**指明**待初始化的元素**：`int arr[6] = { [5] = 212 };`

  - **复杂示例**

    ```c
    #include <stdio.h>
    int main(void)
    {
        int arr[12] = {31, 28, [4] = 31, 30, 31, [1] = 29};
        for (int i = 0; i < 12; i++)
        {
            printf("index:%-3d    value:%d\n", i, arr[i]);
        }
        return 0;
    }
    ```

    ```
    index:0      value:31
    index:1      value:29
    index:2      value:0
    index:3      value:0
    index:4      value:31
    index:5      value:30
    index:6      value:31
    index:7      value:0
    index:8      value:0
    index:9      value:0
    index:10     value:0
    index:11     value:0
    ```

  - **特性解析**

    > 1、以上输出揭示了**指定初始化器**的**两个重要特性**  
    > 2、如果**指定初始化器**后面有**更多值**，如该例`[4] = 31,30,31`，那么**后面的值**将被用于**初始化指定元素后面的元素**(即 arr[5]和 arr[6]被初始化为 30 和 31)  
    > 3、如果**再次初始化**指定元素，那么**最后的初始化**将会**取代之前的初始化**(如 arr[1]先被初始化为 28，后被指定初始化`[1] = 29`初始化为 29)  
    > 4、如果未指定元素大小，如`int arr[] = {1, [6]=4, 9, 10};`，编译器将会把**数组大小**设置为**足够装得下初始化**的值(即该例下标应为 0~8，共 9 个元素)

- **数组元素赋值**

  - **示例程序**

    ```c
    #include <stdio.h>
    int main(void)
    {
        int arr[50];
        for (int i = 0; i < 50; i++)
        {
            arr[i] = i*2;
        }
        arr[6] = 10;
        return 0;
    }
    ```

  - **示例解析**

    > 1、声明**数组**后，可以借助**数组下标**给数组元素**赋值**，如已定义`int arr[20];`则可使用`arr[6] = 10;`来赋值对应元素  
    > 2、注意**多个元素**赋值应通过**循环遍历依次赋值**。C**不允许**把**数组**作为一个单元**赋给另一个数组**，**初始化外**也**不允许**使用**花括号列表**赋值

- **数组边界**

  > 1、在**使用数组**时，要防止数组**下标越界**，必须确保**下标**是**有效的值**  
  > 2、假设有`int doofi[20];`的**声明**，则使用时数组**下标**应在**0~19 的范围内**  
  > 3、编译器**不会检查**这种错误，但是一些编译器会**发出警告**，然后**继续编译**程序  
  > 4、在 C 标准中，使用**越界下标**的结果是**未定义**的。这意味着程序可能**看上去可以运行**，但是运行**结果很奇怪**，或**异常终止**  
  > 5、C 语言为什么会允许这种事发生？这要归功于**C 信任程序员**的原则。编译器没必要**捕获所有**的**下标错误**，这会**降低运行速度**；C 相信程序员能**编写正确的代码**，**不检查边界**，这样程序**运行速度更快**

##### **多维数组**

- **概念引入与分析**

  > 1、假如需要记录**5 年内每个月**的降水量，应该如何更方便的储存数据？  
  > 2、第一种方案，创建**60 个变量**，分别储存每个月的数据。但显然**十分麻烦**  
  > 3、第二种方案，使用**内涵 60 个元素的数组**，**每个元素**恰好表示**每月的数据**。这种更加可行，但**无法分辨年份**  
  > 4、第三种方案，创建**5 个分别内涵 12 个元素的数组**，以此分辨年份。但这种方案也**很麻烦**，且**不能满足更多年份**的需求  
  > 5、第四种方案，使用**二维数组**，下面介绍此种方案

- **二维数组**

  - 结合上例，可以将**二维数组**理解为**数组的数组**。**主数组**有**5 个元素**(表示 5 年)，这 5 个元素**每个元素**都是**内涵 12 个元素的数组**(表示每年 12 个月)

- **二维数组的声明**

  > 1、使用`float rain[5][12]`**声明**符合本需求的**二维数组**  
  > 2、分开来看，`rain[5]`表示数组**rain 有 5 个元素**，至于**每个元素**的情况，要看**声明的其余部分**  
  > 3、`float`和`[12]`说明**每个元素的类型**是**float[12]**。即**rain 的每个元素**本身都是一个**内含 12 个 float 类型值**的**数组**

  ![](https://s2.loli.net/2022/07/08/b9JKzUBwAcMarDi.png)

- **示例程序(十分重要，请理解代码，教程夹杂在代码中)**

  ```c
  #include <stdio.h>

  #define MONTHS 12
  #define YEARS 5
  #define LINE "========================================================="

  int main(void)
  {
      // 声明二维数组并初始化(这样初始化换行为了方便查看，也可以按规定格式写在一行)
      float rain[YEARS][MONTHS] = {
          {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6},
          {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3},
          {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4},
          {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2},
          {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}};
      int year, month;
      float subtot, total;

      /* 输出年总降水与年均降水 */
      printf("%s\n", LINE);
      printf("年份               降水量(英尺)\n");
      // year遍历年份，total计算所有年份(5年)总降水量
      for (year = 0, total = 0; year < YEARS; year++)
      {
          // month遍历月份，subtot计算每年总降水量
          for (month = 0, subtot = 0; month < MONTHS; month++)
          {
              subtot += rain[year][month];
          }
          printf("%4d %20.1f\n", 2018 + year, subtot);
          total += subtot;
      }
      printf("年均降水：%.1f\n", total / YEARS);
      printf("%s\n", LINE);

      /* 输出降水详情 */
      printf("     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n");
      for (year = 0; year < YEARS; year++)
      {
          printf("%d ", 2018 + year);
          for (month = 0; month < MONTHS; month++)
          {
              printf("%.1f ", rain[year][month]);
          }
          printf("\n");
      }
      printf("%s", LINE);
      return 0;
  }
  ```

  ```
  =========================================================
  年份               降水量(英尺)
  2018                 32.4
  2019                 37.9
  2020                 49.8
  2021                 44.0
  2022                 32.9
  年均降水：39.4
  =========================================================
       Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
  2018 4.3 4.3 4.3 3.0 2.0 1.2 0.2 0.2 0.4 2.4 3.5 6.6
  2019 8.5 8.2 1.2 1.6 2.4 0.0 5.2 0.9 0.3 0.9 1.4 7.3
  2020 9.1 8.5 6.7 4.3 2.1 0.8 0.2 0.2 1.1 2.3 6.1 8.4
  2021 7.2 9.9 8.4 3.3 1.2 0.8 0.4 0.0 0.6 1.7 4.3 6.2
  2022 7.6 5.6 3.8 2.8 3.8 0.2 0.0 0.0 0.0 1.3 2.6 5.2
  =========================================================
  ```

- **其他多维数组**

  - 前面讨论的**二维数组**相关内容都**适用**于**三维数组**或**更多维的数组**。例如可以通过`int box[10][20][30];`**声明一个三维数组**
  - 同样面对**更多维的数组**，需要**更多的循环嵌套**来**遍历**，理解好**每层循环**所**控制的元素**，才能够**准确地操控数组**
  - 实际使用中，更多维的数组**出现概率不高**，通常只需要**二维数组**就能完成**大多数需求**

##### **指针和数组**

- 第 9 章介绍过指针，指针提供一种**以符号形式使用地址**的方法。因为计算机的**硬件指令**非常**依赖地址**，指针在某种程度上把程序员想要**传达的指令**以**更接近机器**的方式表达，因此**使用指针**的程序**很有效率**。

- **指针处理数组**

  - **引入**

    > 1、**指针**能有效地**处理数组**，**数组表示法**其实是在**变相地使用指针**  
    > 2、举个简单的例子，**数组名**是数组的**首元素地址**，即`arr == &arr[0]`成立  
    > 3、两者都是**常量**，运行过程中**不会改变**。但是可以将它们**赋值**给**指针变量**，然后可以**修改指针变量的值**

  - **示例程序**

    ```c
      #include <stdio.h>
      #define SIZE 4

      int main(void)
      {
          short dates[SIZE];
          short *pti;
          double bills[SIZE];
          double *ptf;
          pti = dates; // 把数组地址赋给指针，数组名是数组首元素地址
          ptf = bills;
          printf("%23s %15s\n", "short", "double");
          for (int index = 0; index < SIZE; index++)
              printf("pointers + %d: %10p %10p\n", index, pti + index, ptf + index);
          return 0;
      }
    ```

    ```
                        short          double
      pointers + 0: 000000000061FE00 000000000061FDE0
      pointers + 1: 000000000061FE02 000000000061FDE8
      pointers + 2: 000000000061FE04 000000000061FDF0
      pointers + 3: 000000000061FE06 000000000061FDF8
    ```

  - **程序解析**

    > 1、第 2 行起打印**两个数组的地址**，下一行打印的是**指针+1 后的地址**。地址为**十六进制**，因此**DF**比**DE**大  
    > 2、系统中，地址**按字节编址**。**short**占**2 字节**，**double**占**8 字节**。在 C 中，**地址+1**指的是增加一个**存储单元**。对**数组**而言，这意味着**地址+1 后**是**下一个元素的地址**，而不是**下一个字节的地址**  
    > 3、这便是为何必须**声明指针所指向的对象类型**的原因之一。只知道**地址**不够，还需要知道**储存对象**需要**多少字节**，否则指针**无法正确取回**地址上的**值**

    ![](https://s2.loli.net/2022/07/14/96IxhpwnslqozLK.png)

  - **特性总结补充**

    > 1、**指针的值**是**它所指向对象的地址**。地址的表示方式依赖于计算机内部的硬件，大部分都是**按字节编址**，即内存中**每个字节**都**按顺序编号**。一个**较大对象**(如 double 的 8 字节)的地址通常是**第一个字节的地址**  
    > 2、在指针前面使用`*`**运算符**可以得到该指针**所指向对象的值**  
    > 3、**指针+1**，指针的值**递增**它**所指向类型的大小**(字节为单位)

##### **函数、数组与指针(声明数组形参)**

- **引入**

  > 1、假设要编写一个**处理数组的函数**，该函数**返回数组中所有元素之和**  
  > 2、此时注意，由于**数组名**是数组**首元素地址**，所以**实参**是一个**存储对应类型值的地址**而不是**数值**，因此**传参时**应把它赋给一个**指针形式参数**，即**形参**应为**指向对应类型的指针**  
  > 3、此时**函数**获得了该数组**首元素的地址**，且知道需要找出的**值的数据类型**，但并未获得**数组元素个数**，有两种方法：一种方式可以在函数中需要时直接**人为写入数组元素个数**(比如`for`遍历时的条件直接写入元素个数)来告知此信息，但这样**不利于维护**；另一种方式是**创建形参**，将**元素个数**也**传入函数**中

- **示例程序**

  ```c
  #include <stdio.h>
  #define SIZE 10

  // 此处也可写为：
  // int def(int * ar, int n)
  int def(int ar[], int n)
  {
      int sum = 0;
      for (int i = 0; i < n; i++)
          sum += ar[i];
      printf("ar的大小是 %zd bytes\n", sizeof(ar));
      return sum;
  }

  int main(void)
  {
      int arr[SIZE] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20};
      long answer;
      answer = def(arr, SIZE);
      printf("数值相加为 %d\n", answer);
      printf("arr的大小是 %zd bytes\n", sizeof(arr));
      return 0;
  }
  ```

  ```
  ar的大小是 8 bytes
  数值相加为 190
  arr的大小是 40 bytes
  ```

- **程序解析**

  > 1、函数**第 1 个形参**告诉函数**数组地址**与**数据类型**，**第 2 个形参**告诉函数数组的**元素个数**  
  > 2、只有在**函数原型**或**函数定义头**时，才可以用`int ar[]`代替`int * ar`(某些编译器可能对于前者会报警报 warning)。在这种情况下，`int * ar`与`int ar[]`都表示**ar**是一个**指向 int 的指针**，但是`int ar[]`只能用于**声明形参**。`int ar[]`提醒读者，不仅是一个**int 类型值**，还是一个**int 类型数组的元素**  
  > 3、**arr**大小是**40 字节**，因为其**内含 10 个 int 类型值**。**ar**只有**8 字节**，因为其是指向**arr**数组首元素的**指针**，**我们的系统**使用**8 字节存储地址**(其他系统可能不同)，所以**指针变量大小**是**8 字节**

- **声明数组形参**

  - 因为**数组名**是该数组**首元素的地址**，作为**实参**的**数组名**要求**形参**是一个**与之相配的指针**。只有这种情况下，C 才会把`int ar[]`和`int * ar`解释成一样

  - 注意上方**示例程序**的**函数原型**与**函数定义**写在一起，因此对于下方的解释，应按照**函数定义**标准，而非**函数原型**标准

  - 由于**函数原型**可以**省略参数名**，所以**下面 4 种原型等价**：

    ```c
    int def(int * ar, int n);
    int def(int *, int);
    int def(int ar[], int n);
    int def(int [], int);
    ```

  - **函数定义**中**不能省略参数名**，因此只有**下面 2 种的定义等价**：

    ```c
    int def(int * ar, int n){
        // 省略函数内代码
    }

    int def(int ar[], int n){
        // 省略函数内代码
    }
    ```

##### **使用指针形参**

- 函数要**处理数组**必须知道何时**开始**、何时**结束**。上节已展示一种方式**标识函数开始与元素个数**，而这并非唯一途径。第二种方式是**传递两个指针**，一个表明**数组开始处**，一个表明**数组结束处**

- **程序示例**

  ```c
  #include <stdio.h>
  #define SIZE 10

  int def(int *start, int *end)
  {
      int sum = 0;
      while (start < end)
      {
          sum += *start;
          start++;
      }
      return sum;
  }

  int main(void)
  {
      int arr[SIZE] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20};
      long answer;
      answer = def(arr, arr + SIZE);
      printf("数值相加为 %d", answer);
      return 0;
  }
  ```

- **程序解析**

  > 1、指针**start**开始指向**arr**数组的首元素地址，所以赋值表达式`sum += *start`把**首元素的值**加给**sum**(前面讲过`*指针变量`表示获取对应地址的**值**)  
  > 2、表达式`start++`**递增**指针变量**start**，使其指向数组**下一个元素**(前面讲过**指针递增 1**相当于**递增对应类型的大小**，此处即为**递增 int 类型的大小**)  
  > 3、程序的`while`循环，使用**第二个指针 end**来设定范围，告知函数**数组的大小**  
  > 4、`while`循环的条件使用了**小于**，即循环处理的**最后一个元素**是**end**所指向位置的**前一个元素**。这是由于**end**(`arr + SIZE`)指向的位置实际是**数组最后一个元素**(arr[9])的**后面**(并不存在的 arr[10])，本机测试时`arr[9]`地址尾缀**fe14**，**end**尾缀**fe18**。C 保证在给数组**分配空间**时，**指向**数组**后面第一个位置**的指针仍是**有效的指针**  
  > 5、因此结合**第 4 条**，如果按照**常规逻辑**，**end**应被传入`arr + SIZE -1`以正确**指向最后的元素**`arr[9]`。只是这种写法既不简洁也不好记，于是使用了上面的写法

##### **指针操作**

- 可以对指针进行哪些操作？C 提供一些基本的**指针操作**，下面的程序演示一些不同的操作

- **程序示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int urn[5] = {100, 200, 300, 400, 500};
      int *ptr1, *ptr2, *ptr3;

      ptr1 = urn;     // 把一个地址赋给指针
      ptr2 = &urn[2]; // 把第一个地址赋给指针

      // 1.解引用指针，以及获得指针的地址
      printf("1. ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);

      // 2.指针加法
      ptr3 = ptr1 + 4;
      printf("2. ptr1+4 = %p, *(ptr1+4) = %d\n", ptr1 + 4, *(ptr1 + 4));

      // 3.指针递增
      ptr1++;
      printf("3. ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);

      // 4.指针递减
      ptr2--;
      printf("4. ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);

      --ptr1; // 恢复初始值
      ++ptr2; // 恢复初始值

      // 5.指针减另一个指针
      printf("5. ptr2 = %p, ptr1 = %p, ptr2-ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);

      // 6.指针减一个整数
      printf("6 .ptr3 = %p, ptr3-2 = %p\n", ptr3, ptr3 - 2);

      return 0;
  }
  ```

  ```
  1. ptr1 = 000000000061FE00, *ptr1 = 100, &ptr1 = 000000000061FDF8
  2. ptr1+4 = 000000000061FE10, *(ptr1+4) = 500
  3. ptr1 = 000000000061FE04, *ptr1 = 200, &ptr1 = 000000000061FDF8
  4. ptr2 = 000000000061FE04, *ptr2 = 200, &ptr2 = 000000000061FDF0
  5. ptr2 = 000000000061FE08, ptr1 = 000000000061FE00, ptr2-ptr1 = 2
  6. ptr3 = 000000000061FE10, ptr3-2 = 000000000061FE08
  ```

- **指针变量的基本操作**

  - **赋值**

    > 1、可以把**地址**赋给**指针**。例如，用**数组名**、**带地址运算符的变量名**(&a)、**另一个指针**等进行赋值  
    > 2、该例中，urn 数组的**首地址**赋给**ptr1**，其地址编号尾号**FE00**，变量**ptr2**获得数组 urn 的**第 3 个元素的地址**，即`urn[2]`的地址

  - **解引用**

    > 1、`*`**运算符**给出指针**指向地址**上**储存的值**  
    > 2、因此，**\*ptr**的初值是**100**，该值储存在编号尾号**FE00**的**地址**上

  - **取址**

    > 1、和所有变量一样，**指针变量**也有自己的**地址**和**值**。对指针而言，`&`**运算符**给出**指针本身**的**地址**  
    > 2、该例中，**ptr1**储存在内存编号尾号**FDF8**的地址上，其**值**为编号尾号**FE00**的地址(即 urn 的地址)  
    > 3、因此，`&ptr1`是指向**ptr1**的指针，**ptr1**是指向`urn[0]`的指针

  - **指针和整数相加**

    > 1、可以使用`+`**运算符**把**指针和整数相加**，或者**整数和指针相加**  
    > 2、无论哪种情况，**整数**都会和指针**所指向类型的大小**(字节为单位)**相乘**，再与初始地址相加  
    > 3、因此`ptr1 + 4`与`&urn[4]`等价。如果结果**超出数组范围**，计算结果是**未定义的**，除非**超出数组末尾第一个位置**(前面讲过，C 保证该指针有效)

  - **指针减去一个整数**

    > 1、可以使用`-`**运算符**从一个**指针**减去一个**整数**。**指针**必须是**第 1 个运算对象**，**整数**是**第 2 个运算对象**  
    > 2、其**运算规则**与**指针+整数**相同

  - **递增指针**

    > 1、**递增**指向**数组的元素**的**指针**可以让该指针**移动**到数组**下一元素**  
    > 2、因此，`ptr1++`相当于**把 ptr1 的值+4**(因为本系统 int 为 4 字节)，**ptr1**指向`urn[1]`  
    > 3、注意程序中还输出了**ptr1 的地址**，其并**未发生变化**。，因为指针变量也是变量，变量**不会**因为**值发生变化**就**移动位置**

  - **递减指针**

    > 1、当然，除了递增指针，还可以**递减指针**  
    > 2、其**使用方法**与**递增指针**相同

  - **指针求差**

    > 1、可以计算**两个指针**的**差值**。通常，求差的两个指针分别指向**同一个数组的不同元素**，通过计算求出**两元素之间的距离**。**差值的单位**与**数组类型单位**相同  
    > 2、该例中，`ptr2 - ptr1 = 2`意为这两个指针所指向的**两个元素**相隔**2 个 int**，而**不是 2 字节**  
    > 3、只要两个指针都指向**相同的数组**，C 都能保证**运算有效**。如果指向**不同数组**，求差运算可能会**得出一个值**，或者导致**运行时错误**

  - **比较**

    > 1、使用**关系运算符**可以**比较两个指针的值**，前提是它们**指向相同类型的对象**

- **不要解引用未初始化的指针**

  - **注意事项**：千万**不要**解引用**未初始化**的指针，如下：

    ```c
    int *pt;    // 未初始化的指针
    *pt = 5;    // 严重的错误
    ```

  - **原因说明**

    > 1、为何不行？**第 2 行**的意思是**把 5 存储在 pt 指向的位置**。但**pt 未初始化**，其**值**是一个**随机值**，所以不知道 5 将**存储在何处**  
    > 2、这可能不会出什么错，也可能会**擦写数据或代码**，或者**导致程序崩溃**  
    > 3、**创建**一个**指针**时，系统只分配了**储存指针本身**的内存，并未分配**存储数据**的内存。因此**使用指针**前，必须先用**已分配**的地址**初始化**它

##### **保护数组中的数据**

- **引入**

  > 1、编写一个**处理基本类型**的**函数**时，需要选择是传递**值**还是**指针**。通常都是传递**数值**，只有程序需要在函数内**改变该值**时，才会传递**指针**  
  > 2、对于**数组**别无选择，**必须**传递**指针**。因为这样**效率更高**，如果**按值传递**，则必须分配足够空间将值**拷贝**到**新数组**中  
  > 3、C 通常**按值传递**数据，这样可以保证**数据**的**完整性**，使用的是原始数据的**副本**而非原始数据**本身**，这样便可以**保护原数据**。但对于数组，我们需要一种方式来保护数组中的数据

- **对形参使用 const**

  > 1、如果函数的意图不是**修改**数组中的**数据内容**，那么**函数原型**和**函数定义**可以使用**只读**——`const`**关键字**  
  > 2、`const`告诉编译器，函数**不能修改**指针**指向的数组**的内容。如若使用`arr[i]++`这样的表达式会**生成错误信息**  
  > 3、函数声明例如`void def(const int ar[])`，这样便可以**保护数组的数据**

- **其他 const 内容**

  - **其他 const 的使用**

    > 1、之前我们使用`const`**创建**过**变量**。虽然使用`#define`也能**创建符号常量**，但`const`更为灵活，可以创建`const`数组、`const`指针和指向`const`的指针。  
    > 2、下面举例(**默认已声明**`int arr[5];`)  
    > 3、如指向`const`的**指针**：`const int *ptr = arr;`，将**不允许通过 ptr 修改**指向数据的值。但注意**arr**并未被声明为`const`，所以仍可**通过 arr 修改**元素的值：`arr[0] = 10;`。此外也可以**让 ptr 指向别处**：`ptr++; // 指向arr[1]`  
    > 4、此外可以声明并初始化一个**不能指向别处**的`const`**指针**，特别注意`const`**的位置**：`int * const ptr = arr;`。**可以**用这种指针**修改指向的值**，但**不能更改**它**指向的地址**  
    > 5、如果创建指针时**使用两次**`const`，这样便既**不能修改指向地址的数据**也**不能修改指向的地址**：`const int * const ptr = arr;`

  - **其他 const 的规则**

    > 1、把`const`或**非**`const`数据的**地址**初始化为**指向**`const`**的指针**是**合法的**，但`const`数据的**地址**只能赋给**指向**`const`**的指针**，赋值给**普通指针**是**非法的**  
    > 2、这个规则非常合理，否则通过**普通指针**就能**修改**`const`数组的**数据**  
    > 3、因此，对函数的**形参**使用`const`不仅能**保护数据**，还能让函数**处理**`const`**数组**

    ```c
    int arr[5] = {};
    const int locked[5] = {};
    const int *ptr1;
    int *ptr2;

    ptr1 = arr;       // 有效(指向非const数据的地址)
    ptr1 = locked;    // 有效(只是不能通过ptr1改变指向的值，但可以更改ptr1指向的对象。指向const数据的地址)
    ptr1 = &arr[3];   // 有效(指向非const数据的地址)
    ptr2 = arr;       // 有效(普通指针指向普通地址)
    ptr2 = locked;    // 无效(普通指针不能指向const数据的地址，只能通过指向const的指针指向此数据)
    ```

##### **指针和多维数组**

- **引入**

  - 假设有`int arr[4][2];`的声明。**数组名 arr**是该数组的**首元素地址**。在本例中，**arr**的**首元素**是一个**内含两个 int 值**的**数组**(由 arr 声明时第二维为`[2]`表明)，所以**arr**是**这个数组**(即内含两个 int 值的数组)的**地址**

- **从指针属性进一步分析(可结合下方辅助理解示例来理解)**

  > 1、因为**arr**是**首元素地址**(即第一维首元素`arr[0]`的地址)，所以在地址上`arr = &arr[0]`，其值**相同**。而`arr[0]`本身是一个**内含两个整数**的**数组**，所以`arr[0]`的值和它的**首元素**(一个整数)**地址**(即`&arr[0][0]`)**相同**，即在地址上`arr[0] = &arr[0][0]`(此处可以像第一维一样，假设将二维数组的`arr[0]`看做一维的**arr**，将二维数组的`arr[0]`的元素`arr[0][0]`和`arr[0][1]`分别看做一维的`arr[0]`和`arr[1]`，方便理解)  
  > 2、简而言之，**arr**是一个**占用两个 int 大小对象**的**地址**(因为其一个元素(`arr[0]`)内含两个 int 值)，而`arr[0]`是一个**占用一个 int 大小对象**的**地址**。但由于内含两个整数的**数组**(`arr[0]`)和这个**整数**(`arr[0][0]`)**起始于同一个地址**，所以**arr**和`arr[0]`**地址相同**。综上，在地址上`arr = arr[0] = &arr[0] = &arr[0][0]`，因为都**指向整个二维数组的起始地址**(即最根本的第一个数值的位置`arr[0][0]`)  
  > 3、**给指针或地址+1**,其值会增加**对应类型大小**的数值。在这方面，**arr**和`arr[0]`不同，因为如上所言**arr**指向的对象**占两个 int 大小**，而`arr[0]`指向对象**占一个 int 大小**。因此`arr + 1`和`arr[0] + 1`的值不同  
  > 4、**解引用**(使用`*`符)指针或通过**数组下标**`[]`，可以**得到**引用对象的**值**。因为`arr[0]`作为**数组名**是**数组首元素**(即`arr[0][0]`)的**地址**，所以**解引用**`*(arr[0])`**得到**的是存储在`arr[0][0]`上的**值**。与此类似，**arr**作为**数组名**代表**首元素**(即`arr[0]`)的**地址**，但`arr[0]`本身还是一个**地址**，其地址是`&arr[0][0]`，所以**解引用**`*arr`就是`&arr[0][0]`(注意这里**解引用后**`*arr`的值就是**地址**，而**不是数值**)，此时**再次解引用**`**arr`就相当于`*&arr[0][0]`，即**取得**`arr[0][0]`指向的**值**  
  > 5、简而言之，**arr**作为数组名(首元素地址)，是**地址的地址**，必须**解引用两次**才能**获得原始值**。此处**地址的地址**或者**指针的指针**就是**双重间接**的例子

- **针对上述 1、2 条的辅助理解示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int arr[4][2];
      printf("%p\n", arr);        // 数组名为首元素地址，起始首元素为arr[0]，即指向&arr[0]
      printf("%p\n", &arr[0]);    // 与上者相等
      printf("%p\n", arr[0]);     // 数组名为首元素地址，起始首元素为arr[0][0]，即指向&arr[0][0]
      printf("%p\n", &arr[0][0]); // 与上者相等
      printf("%p\n", &arr[0][1]); // 从第二维递增一个下标，证明arr[0]是一个占用一个 int 大小对象的地址
      printf("%p\n", &arr[1]);    // 从第一维递增一个下标，证明arr是一个占用两个 int 大小对象的地址
      return 0;
  }
  ```

  ```
  000000000061FE00
  000000000061FE00
  000000000061FE00
  000000000061FE00
  000000000061FE04
  000000000061FE08
  ```

- **针对上述 3、4、5 条的辅助理解示例**

  ```c
  #include <stdio.h>
  int main(void)
  {
      int arr[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
      printf("%p\n", arr);
      printf("%p\n", arr + 1); // 增加对应元素类型的大小(两个int类型大小)
      printf("%p\n", arr[0]);
      printf("%p\n", arr[0] + 1); // 增加对应元素类型的大小(一个int类型大小)
      printf("=================\n", arr[0]);
      printf("%d\n", arr[0][0]); // 直接通过数组下标获取值
      printf("%d\n", *arr[0]);   // 解引用arr[0]
      printf("%p\n", *arr);      // 解引用一次arr，其值仍为地址，即arr[0][0]的地址
      printf("%d\n", **arr);     // 解引用两次，获得指向的值
      return 0;
  }
  ```

  ```
  000000000061FE00
  000000000061FE08
  000000000061FE00
  000000000061FE04
  =================
  2
  2
  000000000061FE00
  2
  ```

- **通过指针表示二维数组的值**

  - 前面我们了解过，对于`int arr[4][2]`该例：`arr + 1`，其值+8(两个 int)，而`arr[0] + 1`，其值+4(一个 int)
  - 但要注意，与`arr[2][1]`**数值等价**的指针表示法是`*(*(arr+2) + 1)`，理解如下

    | 表达式            | 相对上一步的含义                                                                                             |
    | ----------------- | ------------------------------------------------------------------------------------------------------------ |
    | arr               | 二维数组首元素地址，(每个元素都是内含两个 int 的一维数组)，即第一维首元素`arr[0]`的地址                      |
    | arr +2            | 二维数组第 3 个元素的地址，即第一维从第一个元素`arr[0]`变为第三个元素`arr[2]`，值为其地址                    |
    | \*(arr+2)         | 二维数组第 3 个元素的首元素地址，即第二维首元素`arr[2][0]`的地址                                             |
    | \*(arr+2) + 1     | 二维数组第 3 个元素的第 2 个元素的地址，即第二维从第一个元素`arr[2][0]`变为第二个元素`arr[2][1]`，值为其地址 |
    | \*(\*(arr+2) + 1) | 解引用该地址，取得`arr[2][1]`的值                                                                            |

  - 图片演示**指针表示法**

    ![](https://s2.loli.net/2022/07/21/8KCGwA3Y1lc9qWm.png)

  - 以上分析并**不是为了**说明用**指针表示法**来**代替**常用的**数组表示法**(即下标直接引用)，而是表述程序恰巧使用一个**指向二维数组的指针**，而且要通过该指针**获取值**，最好用简单的**数组表示法**

##### **数组指针与指针、多维数组深入**

- **指向多维数组的指针**

  - 如何声明一个**指针变量 pz**指向一个**二维数组**(如`int arr[4][2]`的第一层的**arr**或`arr[1]`)？

  - **声明方法**

    > 1、对于声明指向**arr**和`arr[1]`这样的数组，只声明为**指向 int 类型**还**不够**，因为这种指针指向**一个 int 类型的值**，但需要指向的**元素**为**内含两个 int 类型的值的数组**  
    > 2、因此应按照`int (*pz)[2]`**这种格式**声明，这种声明的**pz**便指向一个**内含两个 int 类型的值的数组**，将其声明为**指向数组的指针**。为什么使用**圆括号**`()`，因为`[]`的优先级高于`*`，考虑下条声明  
    > 3、对于`int *pax[2]`这条声明。按照优先级**pax**先与`[2]`结合成为一个**内含两个元素的数组**，然后`*`表示**pax 数组**内含**两个指针**。因此这条代码声明了**两个指向 int 的指针**  
    > 4、补充解释，`int (*pz)[2]`的**pz**是一个**储存一个地址**的指针，其储存的地址指向**内含两个 int 类型的值的数组**；而`int *pax[2]`的**pax**是一个**储存两个地址**的**指针数组**，其储存的地址指向**一个 int 类型的值**

  - **辅助理解示例**

    ```c
    #include <stdio.h>
    int main(void)
    {
        int arr[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
        int(*pz)[2];
        pz = arr; // 指向&arr[0]，其为内含两个int类型值的数组

        printf("%p\n", &arr[0]);
        printf("%p\n", pz);
        printf("%p\n", pz + 1);     // +1直接增加了两个int类型值的大小
        printf("%p\n", &arr[1]);    // 证明了pz+1 相当于从arr[0]指向了arr[1]
        printf("%p\n", pz[0]);      // 因为pz指向arr[0]，所以相当于&arr[0][0] (具体还需结合下方“数组指针的[]使用来理解”)
        printf("%p\n", pz[0] + 1);  // 相当于从arr[0][0] +1后指向arr[0][1]，所以增加了一个int类型值的大小
        printf("%p\n", &arr[0][1]); // 证明了pz[0]+1 指向 arr[0][1]
        printf("%p\n", *pz);        // 使用 * 解运算pz，相当于解运算arr[0]，即 *arr[0]，arr[0]指向其首元素地址，于是便得到 &arr[0][0]
        printf("%p\n", *pz + 1);    // 相当于arr[0][0] +1后指向arr[0][1]，增加一个int类型值大小
        printf("=================\n");
        printf("%d\n", *pz[0]);           // pz[0]即指向 &arr[0][0]，解运算得到arr[0][0]的值
        printf("%d\n", **pz);             // 第一次解运算 *pz得到指向arr[0][0]的地址 &arr[0][0]，解运算得到值
        printf("%d\n", pz[2][1]);         // 关于数组指针加[]的事宜，下方将详细讨论
        printf("%d\n", *(*(pz + 2) + 1)); // 按前节方法解释，相当于得到arr[3][1]的值
        return 0;
    }
    ```

    ```
    000000000061FDF0
    000000000061FDF0
    000000000061FDF8
    000000000061FDF8
    000000000061FDF0
    000000000061FDF4
    000000000061FDF4
    000000000061FDF0
    000000000061FDF4
    =================
    2
    2
    3
    3
    ```

  - **数组指针的[]使用**

    > 1、如前所述，虽然**pz 是一个指针**，不是数组名，但仍可以使用`pz[2][1]`这种写法  
    > 2、可以用**数组表示法**或**指针表示法**表示**一个数组元素**，既可以使用**数组名**，也可以使用**指针名**
    > 3、三者的**等价关系如下陈述**。需要注意数组名`[m][n]`调用到的数值与`arr[m][n]`的值是对应的，**pz 调用时**，如果 pz**不指向数组首元素地址**，则**对应的值**是`arr[指向元素 + m][指向元素 + n]`

    ```c
    arr[m][n] == *(*(arr+m) + n)
    pz[m][n] == *(*(pz+m) + n)
    ```

- **指针的兼容性**

  - **指针**之间的**赋值**比**数值类型**之间的**赋值**要**严格**。例如，不用类型转换就可以把**int 类型值**赋给**double 类型变量**，但**两个类型的指针**就**不能这样做**，如下两例：

    ```c
    int n=5;
    double x;
    int *pl = &n;
    double *pd = &x;
    /*-------------------------------*/
    x = n;      // 数值类型，隐式类型转换
    pd = pl;    // 指针，编译时错误
    ```

    ```c
    int *pt;
    int (*pa)[3];
    int arr1[2][3];
    int arr2[3][2];
    int **p2;             // 一个指向指针的指针
    /*--------------------------------*/
    pt = &arr1[0][0];     // 都是指向int的指针
    pt = arr1[0];         // 数组名是首元素地址，都是指向int的指针
    pt = arr1;            // 无效，首元素地址指向&arr[0]，是一个指向三个int类型值的数组
    pa = arr1;            // 相当于&arr[0]，都是指向内含三个int类型元素数组的指针
    pa = arr2;            // 无效，arr2为指向两个int类型值的数组
    pa = &pt;             // 都是指向int *的指针，&pt为指向指针pt的地址
    *p2 = arr2[0];        // 都是指向int的指针，p2此处进行了一次解运算，指向int类型而非指向指针
    p2 = arr2;            // 无效，p2为指向指针的指针
    ```

  - **多重解引用**注意事项：

    - **示例程序**

      ```c
      int x=20;
      const int y=23;
      int *p1 = &x;
      const int *p2 = &y;
      const int **pp2;
      p1 = p2;        // 不安全，把const指针赋给非const指针
      p2 = p1;        // 有效，把非const指针赋给const指针
      pp2 = &p1;      // 不安全，嵌套指针类型赋值
      ```

    - **示例解析**

      > 1、前面提到过，把`const`**指针**赋给**非**`const`**指针**是**不安全**的，因为这样可以**使用新的指针改变**`const`**指针指向的数据**。**编译器**在编译时，可能会给出警告，执行这样的代码是**未定义的**  
      > 2、但把**非**`const`**指针**赋给`const`**指针**没问题，前提是**只进行一级解引用**。但当进行**两级解引用**时，这样的赋值**也不安全**，如下描述

    - **非 const 赋值 const 时的两级解引用**

      ```c
      const int **pp2;
      int *p1;
      const int n=13;
      pp2 = &p1;        // 允许，但是这会导致const限定符失效(根据第一行代码，不能通过**pp2修改它所指向的内容)
      *pp2 = &n;        // 有效，两者都声明为const，但是这将导致p1指向n(*pp2已被修改)
      *p1 = 10;         // 有效，但是这将改变n的值(但是根据第三行代码，不能修改n的值)
      ```

    - **示例解析**

      > 1、发生了什么？如前所示，标准**规定了**通过**非**`const`**指针**更改`const`**数据**是**未定义的**  
      > 2、例如使用**gcc**编译包含以上代码的程序，导致**n**最终值为**13**(未更改)。但是在**相同系统下**使用**clang**来编译，**n**最终的值是**10**(已更改)。两个编译器都给出**指针类型不兼容**的**警告**  
      > 3、当然您可以忽略这些警告，但最好**不要相信程序运行的结果**，因为这些结果都是**未定义的**

- **C const 和 C++ const**

  > 1、C 和 C++中`const`**用法很相似**，但并不完全相同  
  > 2、区别之一是，C++允许**声明数组大小**时**使用**`const`**整数**，而 C**不允许**  
  > 3、区别之二是，C++的**指针赋值检查更严格**。C++**不允许**把`const`**指针**赋给**非**`const`**指针**，而 C 允许。如下例，但如果**通过 p1 更改 y**，其行为是未定义的

  ```c
  const int y;
  const int *p2 = &y;
  int *p1;
  p1 = p2;    // C++不允许这样做，C可能只发出警告
  ```

- **函数和多维数组指针**

  - **示例程序**

    ```c
    #include <stdio.h>

    #define ROWS 3
    #define COLS 4

    void sum_rows(int ar[][COLS], int rows)
    {
        int r, c, tot;
        for (r = 0; r < rows; r++)
        {
            tot = 0;
            for (c = 0; c < COLS; c++)
                tot += ar[r][c];
            printf("row %d: sum = %d\n", r, tot);
        }
    }

    void sum_cols(int ar[][COLS], int rows)
    {
        int r, c, tot;
        for (c = 0; c < COLS; c++)
        {
            tot = 0;
            for (r = 0; r < rows; r++)
                tot += ar[r][c];
            printf("col %d: sum = %d\n", c, tot);
        }
    }

    int sum2d(int ar[][COLS], int rows)
    {
        int r, c, tot = 0;
        for (r = 0; r < rows; r++)
            for (c = 0; c < COLS; c++)
                tot += ar[r][c];
        return tot;
    }

    int main(void)
    {
        int junk[ROWS][COLS] = {{2, 4, 6, 8}, {3, 5, 7, 9}, {12, 10, 8, 6}};
        sum_rows(junk, ROWS);
        sum_cols(junk, ROWS);
        printf("Sum of all elements = %d\n", sum2d(junk, ROWS));
        return 0;
    }
    ```

    ```
    row 0: sum = 20
    row 1: sum = 24
    row 2: sum = 36
    col 0: sum = 17
    col 1: sum = 19
    col 2: sum = 21
    col 3: sum = 23
    Sum of all elements = 80
    ```

  - **程序解析**

    > 1、在**函数声明**中`int ar[][COLS]`，第 1 个**方括号**`[]`是空的，空的方括号**表明 ar 是一个指针**。所以该语句等效于`int (*ar)[COLS]`，如前面**数组指针**提到的，后面的`COLS`用于告知指针指向的**元素**(子数组)内含多少个**对应数据类型**的**大小**  
    > 2、该程序把**数组名 junk**(即首元素地址，即**子数组**)和**符号常量 ROWS**作为参数**传递给函数**。由于`int ar[][COLS]`的声明，每个函数都把**ar**视为**内含数组元素**的**数组**  
    > 3、注意，**ar**和`main`中的**junk**都使用**数组表示法**。因为 ar 和 junk**类型相同**，都是指向**内含 4 个 int 值的数组的指针**  
    > 4、一般而言，声明一个**指向 N 维数组**的指针时，**只能省略最左边**的方括号中的值，因为其只用于**表明这是一个指针**，其他方括号则用于描述**指针指向**的**数据对象的类型**(内含多少个对应什么数据类型的大小)

##### **变长数组(VLA)**

- **引入**

  ```c
  /*如上节的函数示例*/
  int sum2d(int ar[][COLS], int rows)
  {
      int r, c, tot = 0;
      for (r = 0; r < rows; r++)
          for (c = 0; c < COLS; c++)
              tot += ar[r][c];
      return tot;
  }
  ```

  > 1、为什么**使用函数**操作**二维数组**时，只将**行数**(**ROWS**)作为函数的**形参**，而**列数**(**COLS**)**内置**在函数体内？  
  > 2、我们可以使用`sum2d()`函数对`int arr1[5][4]`、`int arr2[100][4]`、`int arr3[2][4]`等数组**求各元素之和**，是因为这些数组的**列数固定为 4**，**行数**被**传递**给**形参 rows**，**rows**是一个**变量**。但如果要对`int arr4[6][5]`计算，则**不能使用这个函数**，必须新建一个**COLS 为 5**的函数，因为**C 规定**，数组的维数**必须是常量**，**不能用变量代替**  
  > 3、要创建一个能**处理任意大小**二维数组的函数，比较繁琐(必须把数组**作为一位数组传递**，然后让**函数计算每行的开始处**)。鉴于此，**C99**新增了**变长数组**，允许使用**变量**表示**数组的维度**

- **变长数组**

  - **声明示例**

    ```c
    int quarters = 4;
    int regions = 5;
    double arr[regions][quarters];      // 一个变长数组
    ```

  - **变长数组的特性**

    > 1、**变长数组**有一些**限制**：变长数组**必须**是**自动储存类别**，这意味着无论在**函数中声明**还是作为**函数形参声明**都**不能使用**`static`或`extern`**储存类别说明符**(第 12 章介绍)。而且**不能在声明中初始化**它们  
    > 2、变长数组**不能改变大小**：**变长数组**的“**变**”不是指可以**修改**已创建数组的**大小**。**一旦创建**了变长数组，**其大小保持不变**。这里的“**变**”指的是在**创建数组时**，可以**使用变量指定数组的维度**  
    > 3、由于**变长数组**是 C 语言的**新特性**，目前**完全支持**这一特性的**编译器**不多

  - **示例程序(程序要求编译器支持变长数组)**

    ```c
    #include <stdio.h>

    #define ROWS 3
    #define COLS 4

    // 带变长数组形参的函数
    int sum2d(int rows, int cols, int ar[rows][cols])
    {
        int r, c, tot = 0;
        for (r = 0; r < rows; r++)
            for (c = 0; c < cols; c++)
                tot += ar[r][c];
        return tot;
    }

    int main(void)
    {
        int i, j;
        int rs = 3, cs = 10;
        int junk[ROWS][COLS] = {{2, 4, 6, 8}, {3, 5, 7, 9}, {12, 10, 8, 6}};                // 3*4数组
        int morejunk[ROWS - 1][COLS + 2] = {{20, 30, 40, 50, 60, 70}, {5, 6, 7, 8, 9, 10}}; // 2*6数组
        int varr[rs][cs];                                                                   // 3*10变长数组
        // 为变长数组赋值
        for (i = 0; i < rs; i++)
            for (j = 0; j < cs; j++)
                varr[i][j] = i * j + i;

        printf("3*4 array: sum = %d\n", sum2d(ROWS, COLS, junk));
        printf("2*6 array: sum = %d\n", sum2d(ROWS - 1, COLS + 2, morejunk));
        printf("3*10 VLA: sum = %d\n", sum2d(rs, cs, varr));
        return 0;
    }
    ```

    ```
    3*4 array: sum = 80
    2*6 array: sum = 315
    3*10 VLA: sum = 165
    ```

  - **示例解析**

    > 1、声明一个带**二维变长数组参数**的函数，需要注意**前两个形参**`rows`和`cols`用作**第三个形参**二维数组`ar[rows][cols]`的**两个维度**。**参数数组 ar**的声明需要**使用前两个参数**，因此**必须先声明**前两个参数，使用`int sum2d(int ar[rows][cols], int rows, int cols)`这种**无效的顺序**声明函数原型是**错误的**  
    > 2、体面提到过 C 标准规定，可以省略**函数原型**中的**形参名**，但这种情况下必须用**星号**`*`**代替省略的维度**：`int sum2d(int, int, int ar[*][*])`。(注意是**函数原型**不是**函数定义**，如果是**函数定义**仍必须**完整写出**类型、变量名等信息)  
    > 3、需要注意的是，在**函数定义**时的形参列表中**声明的变长数组**，**并非实际创建数组**。和传统的语法类似，**变长数组名**实际上**是一个指针**。这说明函数实际上还是在**原始数组**中处理数组，因此**可以更改传入的数据**  
    > 4、变长数组还允许**动态内存分配**，这说明可以在**程序运行时指定数组的大小**。**普通数组**都是**静态内存分配**，即在**编译时确定数组大小**(12 章将详细讨论)

##### **复合字面量**

- **引入**

  > 1、假设给带**int 类型形参**的函数**传递**一个值，应传递**int 类型的变量**，但也可以传递**int 类型的常量**，比如**5**  
  > 2、C99 之前，对于**带数组形参的函数**，可以传递数组，但没有等价的**数组常量**，于是 C99 新增了**复合字面量**  
  > 3、**字面量**是除**符号常量**以外的**常量**。如：**5**是**int**的字面量；**81.3**是**double**的字面量；**Y**是**char**的字面量；**hello**是字符串字面量  
  > 4、于是，C99 认为如果有**代表数组**和**结构内容**的**复合字面量**，会更方便

- **复合字面量**

  > 1、对于数组，**复合字面量**类似数组**初始化列表**(实际可以看做**常量数组**，类似我们给普通变量赋值时写的**5**、**81.3**这样的**字面量常量**)，前面是用**括号**`()`括起来的**类型名**。如`(int [2]){10,20};`，括号内的`int [2]`便是复合字面量的**类型名**  
  > 2、初始化**有数组名的数组**时可以**省略数组大小**，**复合字面量**也可以**省略大小**，**编译器**会**自动计算**数组当前**元素个数**：`(int []){50,20,90}`  
  > 3、因为**复合字面量**是**匿名**的，所以**不能先创建再使用**，必须在**创建的同时使用**它。使用**指针记录地址**就是一种用法，即如果有`int *pt;`，则可以通过`pt = (int [2]){10,20};`让**pt**指针**记录地址**，后通过**pt**使用这个**常量数组**(匿名只是无法通过名称调用，但仍储存在固定的内存地址上，因此可以使用指针调用)。**复合字面量**的**类型名**也代表**首元素地址**，因此和数组规则相同，`*pt`是**10**，`pt[1]`是**20**  
  > 4、还可以把**复合字面量**作为**实参**传给带有**匹配形参**的**函数**。这也是复合字面量的**典型用法**，其好处是把信息**传入函数**前**不必先创建数组**  
  > 5、注意，**复合字面量**是提供**只临时需要**的值的**一种手段**。**复合字面量**具有**块作用域**(12 章详细介绍)，一旦**离开**定义复合字面量的**块**，程序无法保证该字面量**是否存在**。也就是说，复合字面量定义在**最内层的花括号内**

- **综合应用示例**

  ```c
  #include <stdio.h>

  #define COLS 4

  // 计算一维数组各元素的和
  int sum(const int ar[], int n)
  {
      int i, total = 0;
      for (i = 0; i < n; i++)
          total += ar[i];
      return total;
  }

  // 计算二维数组各元素的和
  int sum2d(const int ar[][COLS], int rows)
  {
      int r, c, tot = 0;
      for (r = 0; r < rows; r++)
          for (c = 0; c < COLS; c++)
              tot += ar[r][c];
      return tot;
  }

  int main(void)
  {
      int total1, total2, total3;
      int *pt1;
      int(*pt2)[COLS];
      // 使用指针记录匿名的复合字面量的地址，以后续调用
      pt1 = (int[2]){10, 20};
      pt2 = (int[2][COLS]){{1, 2, 3, -9}, {4, 5, 6, -8}};

      total1 = sum(pt1, 2);
      total2 = sum2d(pt2, 2);
      // 将复合字面量作为实参传入函数形参
      total3 = sum((int[]){4, 4, 4, 5, 5, 5}, 6);
      printf("total1 = %d\n", total1);
      printf("total2 = %d\n", total2);
      printf("total3 = %d\n", total3);
      return 0;
  }
  ```

---

#### **字符串和字符串函数**

---

<div class="success">

> **章节概要**：表示字符串和字符串 I/O；在程序中定义字符串；数组表示法与指针表示法；字符串数组；字符串输入；分配空间；`gets()`函数；`fgets()`函数；`gets_s()`函数；`scanf()`函数；字符串输出；`puts()`函数；`fputs()`函数；`printf()`函数；自定义输入/输出函数；字符串函数；`strlen()`函数

</div>

##### **表示字符串和字符串 I/O**

- 第四章介绍过，**字符串**是以**空字符**(`\0`)结尾的**char 类型数组**。因此，可以把上一章学到的**数组和指针**的知识应用于**字符串**

- **在程序中定义字符串**

  - **字符串字面量**(**字符串常量**)

    > 1、用**双引号**`""`括起来的内容称为**字符串字面量**，也叫做**字符串常量**。双引号中的**字符**和编译器**自动加入末尾**的`\0`字符，都作为字符串**储存在内存中**  
    > 2、从**ANSI C**起如果**字符串字面量**之间**没有间隔**，或者用**空白字符分隔**，C 会将其视为**串联起来的**字符串字面量。如`char word[50] = "hello,"" how are" " you?"`等价于`char word[50] = "hello, how are you?"`。如果要在**字符串内部**使用**双引号**，则必须通过**反斜杠**`\`进行**转义**。如`printf("\"Hello\", Jimmy said");`  
    > 3、**字符串常量**属于**静态存储类别**，这说明如果在**函数中使用**字符串，该字符串**只会被储存一次**，并在**整个程序的生命周期内存在**，即使函数**被调用多次**  
    > 4、用**双引号括起来的内容**被视为指向**该字符串存储位置**的**指针**(该字符串**首字符地址**)，这类似于把**数组名**作为指向**该数组位置**的**指针**  
    > 5、因此，如果使用`printf()`打印`"hello"`，使用`%s`将打印**整个字符串**，使用`%p`将打印该字符串**首字符地址**。既然整个字符串表示**首字符地址**，那么使用`%c`输出解引用的`*"hello"`，结果便是**首字符 h**而**不是整个字符串**

  - **字符串数组和初始化**

    > 1、**定义字符串数组**时，必须让编译器知道**需要多少空间**  
    > 2、**声明示例**：`const char word[10] = "hello"`，其中`const`表明不会更改这个字符串(可省略)。这种形式初始化比**标准的数组初始化**简单的多：`const char word[10] = {'h', 'e', 'l', 'l', 'o', '\0'}`，注意最后的**空字符**，如果没有这个空字符，这就**不是**一个**字符串**，而是一个**字符数组**  
    > 3、在**指定数组大小**时，要确保数组的**元素个数**要**至少**比字符串长度**多 1**(为了容纳空字符)。所有**未被使用的元素**都会被自动**初始化为 0**(这里的 0 是 char 形式的空字符，不是数字字符 0)  
    > 4、通常，让**编译器**确定**数组大小**很方便。对于**字符串**(字符数组)也一样，省略数组**初始化声明**中的**大小**，编译器会**自动计算**数组的大小  
    > 5、**字符数组名**和其他**数组名**一样，是该数组**首元素的地址**

  - **数组表示法与指针表示法**

    - 前面介绍的声明为**数组表示法**，如`const char arr[] = "hello";`(`const`可省略)，此外还可以用**指针表示法**创建字符串，如`const char * pt = "hello";`(`const`不可省略)

    - **pt**和**arr**都是该字符串的**地址**，且**字符串本身**决定预留的**存储空间**，尽管如此，这两种形式**并不完全相同**

    - **数组表示法**

      > 1、**数组形式**(`arr[]`)在计算机的**内存中**分配为一个**内含 6 个元素**的数组(预留出空字符)，每个元素被**初始化**为字符串字面量**对应的字符**  
      > 2、通常**字符串**都作为**可执行文件**的一部分存储在**数据段**中，当把程序**载入内存**时，也载入了**字符串**。字符串存储在**静态存储区**中，但是程序在**开始运行时**才会为数组**分配内存**，此时才**将字符串拷贝到数组**中。这时字符串有**两个副本**，一个是**静态内存**中的**字符串字面量**，另一个是**arr 数组**中的**字符串**  
      > 3、随后，编译器将**数组名 arr**识别为数组的**首元素地址**的别名。在**数组形式**中，**arr**是**地址常量**，**不能更改 arr**，否则更改意味着**改变了**数组的**存储位置**。所以**可以进行**类似`arr+1`这样的操作，标识数组的**下一个元素**，但**不能进行**类似`++arr`这样的操作，**递增运算符**只可以用于**可修改的左值**，**不能用于常量**

    - **指针表示法**

      > 1、**指针形式**(`*pt`)也使得**编译器**为**字符串**在**静态存储区**预留 6 个元素的空间。另外**一旦开始执行**程序，他会为**指针变量 pt**留出一个储存位置，并把**字符串的地址**存储在**指针变量**中  
      > 2、该指针变量**最初指向**该**字符串首字母**，但是它的值**可以改变**。因此可以使用**递增运算符**，如`++pt;`将指向**第二个字符**(即 e)  
      > 3、**字符串字面量**被视为`const`**数据**，由于**pt 指向这个数据**，所以应该把**pt**声明为**指向**`const`**数据**的**指针**。这意味着**不能用 pt 改变**它所**指向的数据**，但**可以改变 pt 的值**(即指向的地址)  
      > 4、如果把一个字符串**拷贝**给一个**数组**(即使用数组表示法)，则可以**随意改变数据**，除非把数组**声明**为`const`

  - **字符串数组**

    - 创建一个**字符串数组**通常很方便，可以通过**数组下标**访问多个**不同的**字符串

    - **字符串数组-数组表示法**

      ```c
      const words[5][40] = {
          "Hello, my name is Lisa.",
          "I'm 16 years old.",
          "How about you?"
      };
      ```

    - **字符串数组-指针表示法**

      ```c
      const *words[5] = {
          "Hello, my name is Lisa.",
          "I'm 16 years old.",
          "How about you?"
      };
      ```

##### **字符串输入**

- 想把一个**字符串**读入程序，首先必须**预留**储存该字符串的**空间**，然后用**输入函数**获取该**字符串**

- **分配空间**

  - 第一件事便是**分配空间**，以**储存**后续读入的**字符串**。这意味着要为字符串**分配足够的空间**，**不要指望**计算机在读取时**顺便计算**它的长度，再分配空间(计算机不会这样做)

  - **错误示例**

    ```c
    char *name;
    scanf("%s",name);
    ```

    > 1、虽然**可能通过编译**(大概率会报**警报**)，但在读取**name**时，**name**很可能会**擦写**程序中的**数据或代码**，导致程序**异常终止**  
    > 2、因为`scanf()`要把信息**拷贝**到参数的**指定地址**，而**name**是个**未初始化的指针**，所以可能指向**任何地方**

  - **正确分配空间**

    > 1、**最简单**的方法是，在**声明时显式指明数组的大小**：`char name[81];`  
    > 2、还有一种方法是使用**C 库函数**来**分配内存**，第 12 章介绍

- **gets()函数**

  - `gets()`**的使用**

    ```c
    char word[81];
    gets(word);
    puts(word);
    ```

    > 1、在**读取字符**时，`scanf()`配合`%s`只能读取**一个单词**(遇到空格就停止)，但程序经常要读取**一整行输入**  
    > 2、`gets()`函数就用于**读取整行输入**，直至**遇到换行符**。然后**丢弃换行符**，**储存其他字符**，并在这些字符**末尾添加一个空字符**使其成为一个**字符串**  
    > 3、`gets()`常常与`puts()`函数**配对使用**，该函数用于**显示字符串**，并在末尾**添加换行符**

  - `gets()`**的危险性**

    > 1、某些**编译器**对于使用`gets()`的程序**报出警告**，但并非全部编译器都会这样做。其他编译器可能在**编译过程中**给出警告，但不会引起你的注意  
    > 2、问题出现在`gets()`的**唯一参数**是**字符串名**(word)，它**无法检查**数组**是否装得下**输入行  
    > 3、如果输入的**字符串过长**，会导致**缓冲区溢出**，即多余的字符**超出了**指定的**目标空间**。如果这些**多余字符**只是占用了**尚未使用的内存**，就**不会立刻出现问题**；如果它们**擦写**掉了程序中的其他数据，会导致**程序异常终止**，或者还有**其他情况**  
    > 4、如果出现上述情况，会报出`Segmentation fault`(**分段错误**)，这条消息说明**该程序试图访问未分配的内存**。该函数的**不安全行为**造成了**安全隐患**，过去有些人通过**系统编程**，利用`gets()`插入和运行一些破坏系统安全的代码

  - `gets()`**被遗弃**

    > 1、由于`gets()`的**不安全性**，不久**C 社区**许多人都建议编程时**摒弃**`gets()`。制定**C99**标准的委员会将这些建议**放入了标准**，承认`gets()`的**大量问题**并建议不要再使用它  
    > 2、尽管如此，在标准中**保留**`gets()`也合情合理，因为**现有程序**中含有**大量使用该函数**的代码。而且只要使用得当，其的确是一个**很方便**的函数  
    > 3、好景不长，**C11**采取了更强硬的手段，直接从标准中**废除了**`gets()`函数。既然标准已经发布，那么**编译器**就必须**调整支持**。然而**实际使用**中，编译器为了**兼容以前的代码**，大部分仍**继续支持**`gets()`函数，但部分编译器已**按标准废除**`gets()`

- **fgets()函数**

  - `fgets()`函数可以作为`gets()`的替代品，其通过**第二个参数**限制**读入的字符数**来解决**溢出问题**。但该函数**设计用于处理文件输入**，一般情况可能不那么好用

  - `fgets()`**和**`gets()`**的区别**

    > 1、`fgets()`函数的**第二个参数**指定了读入字符的**最大数量**。如果**该参数值**为**n**，那么`fgets()`将读取**n-1**个字符，或者读到遇到的**第一个换行符**  
    > 2、如果`fgets()`读到一个**换行符**，会把它**保存在字符串**中。而`gets()`函数会**舍弃换行符**  
    > 3、`fgets()`的**第三个参数**指明**要读入的文件**。如果读入从**键盘输入**的数据，则以`stdin`(标准输入)**作为参数**，该**标识符**定义在`stdio.h`中

  - `fgets()`**的使用**

    ```c
    char word[14];
    fgets(word, 14, stdin);
    fputs(word, stdout);
    ```

    > 1、假设**输入 17 个字符**，该程序输出仅会**输出前 13 个字符**(`fgets`只读入**第二个参数-1**个字符)  
    > 2、假设**输入 6 个字符**，`fgets()`函数会将末尾的**换行符**也**储存起来**，如果使用`puts()`函数打印则会**附带一个换行符**，如果使用`fputs()`则不会  
    > 3、`fgets()`由于**储存换行符**的特性常常与`fputs()`**配对使用**。`fputs()`**第二个参数**指明它要**写入的文件**，如果要**显示在屏幕上**，则应使用`stdout`(标准输出)**作为参数**  
    > 4、`fgets()`函数返回**指向 char**的**指针**。如果一切顺利，该函数**返回地址**与传入的**第一个参数**相同。但是，如果函数**读到文件结尾**，它将返回一个**空指针**(null pointer)，该指针**保证不会指向有效数据**,在代码中可以**用数字 0 代替**，不过 C 语言中用宏`NULL`代替**更常见**

  - **示例程序**

    ```c
    #include <stdio.h>
    int main(void)
    {
        char word[10];
        puts("输入字符串(单独换行结束):");
        // fgets输入，返回值不等于空指针(文件结尾)且判断第一个字符不为换行符
        while (fgets(word, 10, stdin) != NULL && word[0] != '\n')
            fputs(word, stdout);
        puts("Done.");
        return 0;
    }
    ```

    ```
    by the way, the gets() function
    by the way, the gets() function
    hello, world
    hello, world
    how about you?
    how about you?

    Done.
    ```

  - **示例解析**

    > 1、虽然**word**的长度被设置为**10**(即实际读入 9 个字符)，但处理**更长的字符串**时貌似并**没有问题**，原理如下  
    > 2、之前提到过，程序的输入使用了**缓冲区**，所以输入**更长的字符串**被**储存在缓冲区**内**等待处理**。第一轮`while`迭代按`fgets()`函数要求**只读入 9 个字符**(即`by the wa`，储存为`by the wa\0`)，然后**处理**(即输出)该字符串，`fputs()`打印且**不换行**  
    > 3、随后进入**第二轮迭代**，从**缓冲区**中读取**剩余未读取的字符**`y, the ge`并存储，再次**输出**，由于`fputs()`的输出**未换行**，所以与上次输入**拼接在了一起**。以此类推

  - **特殊处理**(需要对应操作时可参考处理思路)

    - **处理换行符**(查找换行符，将其替换为空字符)

      ```c
      while (word[i] != '\n')   // 假设 \n 在 word 中，while循环检测跳过非换行符的部分
          i++;
      word[i] = '\0';           // 将换行符替换为空字符
      ```

    - **处理留在缓冲区中的多余字符**(丢弃多余字符)

      ```c
      while (getchar() != '\n') // 读取但不存储输入，包括\n
          continue;
      ```

- **gets_s()函数**

  - **C11**新增的`gets_s()`函数和`fgets()`类似，用一个参数**限制读入的字符数**，其语法为`gets_s(字符串名, 字符数)`，但由于是**可选标准**，所以**某些编译器可能不支持**

  - `gets_s`**与**`fgets()`**的区别**

    > 1、`gets_s`只从`stdin`**标准输入**中读取数据，所以**不需要第三个参数**  
    > 2、如果`gets_s`读到**换行符**，会**舍弃换行符**而不是储存它  
    > 3、如果`gets_s`读到**最大字符数**都**没有读到**换行符，将会执行以下几步。首先把**目标数组**的**首字符**设置为**空字符**，**读取并丢弃随后的输入**直至**换行符**或**文件结尾**，然后**返回空指针**。接着调用依赖实现的**处理函数**(或你选择的其他函数)，可能会**终止或退出**程序  
    > 4、第二个特性说明，只要**不超过最大值**，这两个函数**几乎完全一样**；第三个特性说明，要使用`gets_s`函数还需**进一步学习**

- **scanf()函数**

  - `scanf()`**与**`gets()`、`fgets()`**的区别**

    > 1、**最主要的区别**在于它们如何**确定字符串的末尾**。`scanf()`更像**获取单词**函数，而非**获取字符串**函数  
    > 2、如果**预留的储存区**装得下输入行，`gets()`和`fgets()`会读取**第一个换行符**前**所有的字符**  
    > 3、`scnaf()`有**两种方式**确定**输入结束**，无论哪种方式，都从**第一个非空白字符**作为**字符串开始**。如果使用`%s`**转换说明**，则以**下一个空白字符**作为**字符串结束**；如果指定了**字段宽度**，如`%10s`，那么将**读取 10 个字符**或**读到第一个空白符停止**

##### **字符串输出**

- **puts()函数**

  - `puts()`**的使用**

    ```c
    char word[81] = "hello world";
    puts(word);
    ```

    > 1、`puts()`函数很容易使用，只需要把**字符串地址**传递给它即可。`puts()`**只能**用来**打印字符串**  
    > 2、`puts()`在显示字符串时会**自动**在其末尾**添加一个换行符**  
    > 3、`puts()`如何知道**在哪停止**？其在检测到**空字符**(`\0`)时就**停止输出**，所以必须确保**有空字符**。**典型错误**为打印**字符数组**`char word[81] = {'h','e','l','l','o'}`，字符数组是**没有空字符**的

- **fputs()函数**

  - `fputs()`**与**`puts()`**的区别**

    > 1、`fputs()`与`puts()`就如同`fgets()`与`gets()`相似，**前者**是**后者**的**针对文件**定制的版本  
    > 2、`fputs()`函数的**第二个参数**指明**要写入数据的文件**，如果打印在屏幕上，可以用`stdout`(标准输出)**作为参数**  
    > 3、与`puts()`不同，`fputs()`**不会**在**末尾添加换行符**

- **printf()函数**

  - 和`puts()`等函数一样，`printf()`也把**字符串地址**作为参数。`printf()`输出**字符串**虽然用起来**不如**`puts()`**方便**，但其更加**全能**和**可控**

  - `printf()`**不会**在每个字符串**末尾添加换行符**，所以必须**人为指定**(使用`\n`)在哪里使用换行符

##### **自定义输入/输出函数**

- 不一定非要使用 C 库的**标准函数**，当然我们也可以自己通过`getchar()`和`putchar()`这两个**功能更简单的函数**写一个我们**自己需求的函数**

- **打印字符串，不添加\n**

  ```c
  #include <stdio.h>
  // 因为不需要改变字符串值，所以使用const保护数据
  void put1(const char *str)
  {
      while (*str != '\0')
          // str++指的是指针指向地址递增，而不是指向的数值递增
          putchar(*str++);
  }
  ```

- **一个能统计打印字符个数的 puts()函数**

  ```c
  #include <stdio.h>
  int put2(const char *str)
  {
      int count = 0;
      // 当str指向空字符时，*str值为0，即false，循环结束
      while (*str)
      {
          putchar(*str++);
          count++;
      }
      putchar('\n'); // puts额外添加的换行符，单独输出
  }
  ```

- **优化的 fgets()函数，读取整行输入并用空字符代替换行符(即不存储换行符)，或读取一部分输入舍弃其余部分(即越界部分不存储)**

  ```c
  #include <stdio.h>
  // 声明一个函数指针
  char *s_gets(char *str, int n)
  {
      char *ret_val; // 创建指针
      int i = 0;
      ret_val = fgets(str, n, stdin); // fgets()返回指向char的指针，如果顺利的话返回地址与传入的第一个参数相同，如果读到文件结尾返回NULL
      if (ret_val)                    // 即，ret_val != NULL，判断是否读到文件结尾
      {
          while (str[i] != '\n' && str[i] != '\0') // 忽略跳过正常字符
              i++;
          if (str[i] == '\n') // 出现换行符替换为空字符，即不存储换行符
              str[i] = '\0';
          else                          // 否则就是读到了空字符
              while (getchar() != '\n') // 丢弃该输入行的其余字符
                  continue;
      }
      return ret_val;
  }
  ```

##### **字符串函数**

- **strlen()函数**

  - 码字中。。。

---

#### **页底评论**

---
