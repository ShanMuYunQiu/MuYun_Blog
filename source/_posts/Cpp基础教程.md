---
title: Cpp基础教程
author: 圣奇宝枣
description: 有关于C++的基础教程，该教程建立在学习过C语言的基础上，进行对比学习，了解不同的特性和更多新内容
sticky: 2
date: 2022-12-03
updated: 2023-07-07
readmore: true
tags:
  - C++
  - 基础语法
categories:
  - 编程语言入门
---

---

_注：该教程建立在学习过 C 语言的基础上，因此很多提过的细节会忽略，主要学习一些 C 语言没有或不同的特性，建议先学习[C 语言基础教程](https://www.shengqibaozao.eu.org/2022/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/?t=1670037021388)_

_本文中没有特殊重申的，大多语句和特性都与 C 语言相同，C++是 C 的超集，兼容了 C 的大多数特性_

---

#### **开始**

---

<div class="success">

> **章节概要**：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介

</div>

<!-- more -->

##### **编写一个简单的 C++程序**

- **简单示例**

  ```cpp
  // 相比C代码，可以省略main(void)的void
  int main()
  {
      return 0;
  }
  ```

##### **初识输入输出**

- **程序示例**

  ```cpp
  #include <iostream>
  int main()
  {
      std::cout << "Enter two numbers!" << std::endl;
      int v1, v2;
      std::cin >> v1 >> v2;
      std::cout << "The sum of them is " << v1 + v2;
      return 0;
  }
  ```

- **C++的 IO 机制**

  > 1、**C++**包含了一个全面的**标准库**来提供**IO 机制**。其中有**从 C 语言延续而来**的`cstdio`库和**新的**`iostream`库  
  > 2、`iostream`库包含**两个基础类型**：`istream`和`ostream`，分别表示**输入流**和**输出流**  
  > 3、一个**流**(stream)就是一个**字符序列**，是**从 IO 设备读出**或**写入 IO 设备**的

- **标准输入输出对象**

  > 1、标准库定义了 4 个**IO 对象**  
  > 2、为了**处理输入**，我们使用名为`cin`的`istream`类型对象，这个对象也被称为**标准输入**  
  > 3、对于**处理输出**，我们使用名为`cout`的`ostream`类型对象，这个对象也被称为**标准输出**  
  > 4、此外还有其他两个`ostream`类型对象，名为`cerr`和`clog`。其中`cerr`通常用来**输出警告和错误信息**，`clog`用来**输出程序运行时的一般性信息**

- **向流写入写出**

  > 1、如果需要使用`iostream`**库中的对象**进行**输入输出**，则需要用到**流插入符**将内容传输给**流**  
  > 2、`<<`为**输出运算符**。其**接受两个运算对象**，**左侧**必须是一个`ostream`**对象**，**右侧**的运算对象是**要打印的值**。此运算符将**给定的值写入给定的**`ostream`**对象**中  
  > 3、`>>`为**输入运算符**。其与`>>`类型，它**左侧**接受一个`istream`**对象**，**右侧**接受一个**运算对象**。它从给定的`istream`中**读入数据**，并**存入给定的对象**中

- **endl 操纵符**

  > 1、**endl**是一个被称为**操纵符**的**特殊值**  
  > 2、**endl**的效果是**结束当前行**(有换行效果)，并将与设备关联的**缓冲区**的内容**刷到设备中**  
  > 3、**缓冲刷新操作**可以保证到目前为止**程序所产生的所有输出**都**真正写入流中**，而不是仅**停留在内存**中等待写入到流中

- **命名空间**

  > 1、示例程序中使用了`std::cout`和`std::endl`，而不是直接的`cout`和`endl`。其**前缀**`std::`指出**名字**`cout`和`endl`是定义在名为`std`的**命名空间**中的  
  > 2、**命名空间**可以帮助我们避免**不经意的名字定义冲突**以及**使用库中相同名字导致的冲突**。**标准库**定义的**所有名字**都在**命名空间**`std`中  
  > 3、通过**命名空间**使用**标准库**有一个**副作用**：当使用**标准库**中的**一个名字**时，必须通过**作用域运算符**`::`来**显式声明**我们想使用来自`std`中的名字，如示例`std::cout`那样(后续将给出一个更简单的访问标准库名字的方法)

##### **使用 C++版本的 C 标准库头文件**

- **建议使用 C++版本标准库**

  > 1、C++标准库中**兼容了 C 语言的标准库**，其按照如下**命名规则**命名  
  > 2、C 语言的头文件形如`name.h`，C++将其命名为`cname`。即**去掉**`.h`**后缀**，文件名前**添加字母**`c`  
  > 3、因此`stdio.h`和`cstdio`**内容是一样的**，而且`stdio.h`也能在 C++调用，但从**命名规范**上来讲，`cstdio`更符合 C++的要求  
  > 4、特别的，在名为`cname`的**头文件**定义的**名字**从属于**命名空间**`std`，而原本`.h`的则不然  
  > 5、一般来说，C++程序**应使用名为**`cname`**的头文件**，因为这样**标准库的名字**总能在`std`找到。如果使用`.h`形式，那么程序员不得不时刻牢记哪些是从 C 语言继承过来的，哪些又是 C++独有的

##### **类简介**

- 我们将在之后详细学习**类**相关的知识，在此只**简单介绍**

- **什么是类**

  > 1、在 C++中，我们通过**定义一个类**来**定义自己的数据结构**  
  > 2、一个**类**定义了**一个类型**，以及**与之相关的一组操作**  
  > 3、**类机制**是 C++**最重要的特性之一**。实际上，C++最初的**设计焦点**就是能定义使用上像内置类型一样自然的**类类型**

- 如果要使用一个类，我们需要了解**三件事情**：

  > 1、类名是什么？  
  > 2、它在哪里定义的？  
  > 3、它支持什么操作？

---

#### **变量和基本类型**

---

<div class="success">

> **章节概要**：基本内置类型；指定字面量类型；变量；对象；列表初始化；C++关键字；复合类型；引用；指针；void\* 指针；`const`限定符；`const`的引用；`constexpr`和常量表达式；处理类型；类型别名；`auto`类型说明符；`decltype`类型指示符；自定义数据结构；定义类；使用类

</div>

##### **基本内置类型**

- **基本数据类型**

  > 1、C++定义了一套包括**算数类型**和**空类型**在内的**基本数据类型**  
  > 2、其中**算数类型**包含了**整型**、**浮点型**、**字符型**、**布尔型**  
  > 3、**空类型 void**不对应**具体的值**，仅用于一些**特殊的场合**

- C++的**基本数据类型**与 C 语言**规则相同**，但 C++中**直接支持**了**bool 类型**，且`iostream`中**直接支持**了**拓展类型**(如`int32_t`等)

- **指定字面量类型**

  - 通过添加**前缀或后缀**，可以改变不同类型**字面量**的**默认类型**

  - **指定字符和字符串字面量**

    | 前缀 |   类型   | 含义                        |
    | :--: | :------: | --------------------------- |
    |  u   | char16_t | Unicode 16 字符             |
    |  U   | char32_t | Unicode 32 字符             |
    |  L   | wchar_t  | 宽字符                      |
    |  u8  |   char   | UTF-8(仅用于字符串字面常量) |

  - **指定整型字面量**

    |   后缀   | 最小匹配类型 |
    | :------: | :----------: |
    |  u 或 U  |   unsigned   |
    |  l 或 L  |     long     |
    | ll 或 LL |  long long   |

  - **指定浮点型字面量**

    |  后缀  |    类型     |
    | :----: | :---------: |
    | f 或 F |    float    |
    | l 或 L | long double |

##### **变量**

- **变量**

  > 1、**变量**提供一个**具名的**、**可供程序操作的存储空间**  
  > 2、C++中的每个变量都有其**数据类型**，**数据类型**决定着变量所占**内存空间**的**大小及布局方式**、该空间**能存储值的范围**，以及变量**能参与的运算**  
  > 3、对于 C++程序员来说，**变量**和**对象**一般可以**互换使用**

- **对象**

  > 1、C++程序员在很多场合都会使用**对象**这个名词。通常情况下，**对象**指一块**能存储数据**并**具有某种类型**的**内存空间**  
  > 2、一部分人对**对象**的定义并不相同，比如：一些人仅在**与类有关**的场景才使用**对象**这个词；另一些人把**命名了的对象**叫做**变量**；还有一些人把**对象**和**值**区分开来，**对象**指**能被程序修改的数据**，而**值**指**只读的数据**

- **列表初始化**

  - C++定义了**初始化**的**好几种不同形式**，如下：

    ```cpp
    int units_sold = 0;
    int units_sold(0);
    int units_sold = {0}; // 列表初始化
    int units_sold{0};    // 列表初始化
    ```

  - **列表初始化**

    > 1、作为**C++11 新标准**的一部分，用**花括号**来**初始化变量**得到了全面应用。这种初始化形式被称为**列表初始化**  
    > 2、现在，无论是**初始化对象**还是某些时候**为对象赋新值**，都可以使用这样一组**由花括号括起来的初始值**了  
    > 3、当用于**内置类型**变量时，这种初始化形式有一个**重要特点**：如果我们**使用列表初始化**且**初始值存在丢失信息的风险**，**编译器将报错**(如下例)  
    > 4、这样的介绍看似无关紧要，因为我们不会故意**用 long double 值初始化 int 变量**，然而这种初始化**可能在不经意间发生**，因此这种赋值更加**保守安全**

    ```cpp
    long double ld = 3.1415926536;
    int a{ld}, b = {ld};    // 报错：转换未执行，因为存在丢失信息的风险(丢失浮点精度)
    int c(ld), d = ld;      // 正确：转换执行，且确实丢失了部分值(丢失了小数点后的浮点部分)
    ```

- **C++关键字**

  |   关键字   |    关键字    |  关键字   |      关键字      |  关键字  |
  | :--------: | :----------: | :-------: | :--------------: | :------: |
  |  alignas   |   continue   |  friend   |     register     |   true   |
  |  alignof   |   decltype   |   goto    | reinterpret_cast |   try    |
  |    asm     |   default    |    if     |      return      | typedef  |
  |    auto    |    delete    |  inline   |      short       |  typeid  |
  |    bool    |      do      |    int    |      signed      | typename |
  |   break    |    double    |   long    |      sizeof      |  union   |
  |    case    | dynamic_cast |  mutable  |      static      | unsigned |
  |   catch    |     else     | namespace |  static_assert   |  using   |
  |    char    |     enum     |    new    |   static_cast    | virtual  |
  |  char16_t  |   explicit   | noexcept  |      struct      |   void   |
  |  char32_t  |    export    |  nullptr  |      switch      | volatile |
  |   class    |    extern    | operator  |     template     | wchar_t  |
  |   const    |    false     |  private  |       this       |  while   |
  | constexpr  |    float     | protected |   thread_local   |          |
  | const_cast |     for      |  public   |      throw       |          |

##### **复合类型**

- **复合类型**是指**基于其他类型**定义的类型。C++有几种复合类型，在此主要了解其中两种：**引用**和**指针**

- **引用**

  - **示例**

    ```cpp
    int ival = 1024;
    int &refVal = ival;     // 定义引用，refVal 指向 ival
    int &refVal2;           // 报错：引用必须被初始化
    /*------------------------------------------------------------------*/
    refVal = 2;             // 实际赋值给 refVal 指向的 ival
    int &refVal3 = refVal;  // refVal3 指向 refVal 指向的 ival
    /*------------------------------------------------------------------*/
    double dval = 10;
    int &refVal4 = dval;    // 报错：refVal4 为int类型，其指向对象必须为int类型
    int &refVal5 = 10;      // 报错：引用只能绑定在对象上
    ```

  - **引用介绍**

    > 1、**引用**为对象**起了另外一个名字**，通过将声明符写成`&变量名`来**定义引用类型**  
    > 2、**定义引用时**，程序把**引用**和它的**初始值**绑定在一起。一旦初始化完成，**引用**将和它的**初始值对象**一直绑定在一起。因为**无法**令引用**重新绑定另外一个对象**，所以**引用必须初始化**  
    > 3、引用**并非对象**，它只是为一个**已经存在的对象**所起的**另外一个名字**。定义一个引用之后，**对其进行的所有操作**都是在**与之绑定的对象**上进行的  
    > 4、所有**引用的类型**都要和**与之绑定的对象**严格匹配，且**引用只能绑定在对象上**

- **指针**

  - C++的指针整体与 C 语言的指针相同，在此写出一些差异

  - **空指针**

    > 1、**空指针**不指向**任何对象**，下为三种**生成空指针**的方法  
    > 2、第一种方法是使用**字面值**`nullptr`来初始化指针。`nullptr`是一种**特殊类型**的字面值，它可以**被转换成任意其他的指针类型**  
    > 3、第二种方法是使用**字面值 0**来生成空指针(注意不是 int 值)  
    > 4、第三种方法是使用**NULL 预处理器变量**，这个变量在头文件`cstdlib`中定义，**预处理变量**不属于**命名空间**`std`。在新标准下，现在的 C++程序**最好使用**`nullptr`，同时**尽量避免使用**`NULL`

    ```cpp
    int *p1 = nullptr;
    int *pt = 0;
    // 使用 NULL 需要调用 cstdlib 头文件
    int *p3 = NULL;
    ```

- **void\* 指针**

  > 1、void\* 是一种特殊的指针类型，可用于存放**任意对象的地址**。不同的是，我们对该地址**指向对象的类型**并不了解  
  > 2、利用 void\* 指针**能做的事有限**，**不能直接操作**其所指的对象，因为并**不知道对象是什么类型**  
  > 3、概括来说，以 void\* 视角来看，**内存空间**也就仅仅是**内存空间**，**没办法访问**内存空间中的**对象**

##### **const 限定符**

- **简述**

  > 1、有时我们希望定义一种**值不能被改变**的**变量**(或直接称为**常量**)，可以用`const`关键字加以修饰  
  > 2、因为`const`对象**一旦创建**，**值就不能改变**，所以`const`对象**必须初始化**  
  > 3、`const`的用法整体与 C 语言中类似

- `const`**的引用**

  > 1、可以把**引用**绑定到`const`**对象**上，我们称之为**对常量的引用**(或**常量引用**)  
  > 2、**常量引用**仅对**引用**本身作出限定，对于**引用的对象**并未限定。如果对象本身**不是常量**，那么允许通过**其他途径**修改它的值

  ```cpp
  const int i = 1024;
  const int &r1 = i;      // 正确：引用及其对应对象都是常量
  r1 = 42;                // 错误：r1是对常量的引用
  int &r2 = i;            // 错误：r2是对非常量的引用，不能指向常量对象
  /*------------------------------------------------------------*/
  int n = 30;
  const int &r1 = n;
  r1 = 40;                // 错误：r1是对常量的引用
  n = 40;                 // 正确：n本身不是常量
  ```

- `constexpr`**和常量表达式**

  - **常量表达式**

    > 1、**常量表达式**指**值不会改变**且**在编译过程中就能确定值**的表达式  
    > 2、一个对象是不是常量表达式，由它的**数据类型**和**初始值**共同决定

    ```cpp
    const int max_file = 20;          // 是常量表达式
    const int limit = mix_file + 1;   // 是常量表达式
    int staff_size = 27;              // 不是常量表达式：数据类型只是普通 int
    const int sz = get_size();        // 不是常量表达式：不能在编译过程中确定值
    ```

  - `constexpr`**变量**

    > 1、在一个复杂系统中，很难(甚至几乎肯定不能)**分辨一个初始值**是不是**常量表达式**  
    > 2、**C++11**规定，允许将变量声明为`constexpr`类型，由**编译器**来验证**变量的值**是否为**常量表达式**  
    > 3、声明为`constexpr`的变量**一定是一个常量**，而且**必须用常量表达式初始化**  
    > 4、不能使用**普通函数**作为`constexpr`**初始值**，允许定义一种特殊的`constexpr`**函数**，后续介绍

    ```cpp
    constexpr int mf = 20;            // 编译通过
    constexpr int limit = mf + 1;     // 编译通过
    constexpr int sz = size();        // 编译错误：除非 size() 是 constexpr 函数
    ```

  - **字面值类型**

    > 1、**常量表达式**的值需要**在编译时就得到计算**，这些类型一般**比较简单**，值也显而易见，就把它们称为**字面值类型**  
    > 2、目前为止，**算数类型**、**引用**、**指针**都**是**字面值类型。**自定义类**、**IO 库**、**string 类型**都**不是**字面值类型，也就不能被定义为`constexpr`  
    > 3、尽管**指针**和**引用**都能被定义成`constexpr`，但它们的**初始值受到严格限制**。如`constexpr`**指针**的初始值只能是`nullptr`或**0**，或存储于某个**固定地址**中的**对象**

##### **处理类型**

- **类型别名**

  > 1、有两种方法可用于定义**类型别名**，第一种是使用`typedef`**关键字**，与 C 语言用法相同  
  > 2、新标准规定了一种新方法：使用**别名声明**。这种方法使用`using`**关键字**作为**别名声明**的开始，其后紧跟别名和等号，作用是把**等号左侧的名字**规定成**等号右侧的类型**的别名

  ```cpp
  typedef double wages;      // wages 是 double 的别名
  typedef wages base, *p;    // base 是 wages(即double)的别名，p 是 double* 的别名
  using SI = Sales_item;     // SI 是 Sales_item 的别名
  ```

- `auto`**类型说明符**

  > 1、编程时常常需要把**表达式的值**赋给变量，这就要求在**声明变量时**清楚地知道**表达式的类型**，然而做到这一点并不容易，甚至有时根本做不到  
  > 2、**C++11**引入了`auto`**类型说明符**，能让**编译器**替我们去**分析表达式的类型**  
  > 3、和原来**只对应一种特定类型**的说明符(如 double)不同，`auto`能让编译器**通过初始值**推算**变量的类型**。显然，`auto`定义的变量**必须有初始值**  
  > 4、使用`auto`也能在**一条语句**声明**多个变量**，但由于一条声明语句**只能有一个基本数据类型**，所以该语句中**所有变量**的**初始基本数据类型**必须**都一样**

  ```cpp
  auto item = val1 + val2;    // auto 自动判断表达式类型
  auto i = 0, *p = &i;        // 正确：i 是整数，p 是整型指针
  auto sz = 0, pi = 3.14;     // 错误：sz 和 pi 类型不一致
  ```

- `decltype`**类型指示符**

  > 1、有时我们希望从**表达式的类型**推断出要定义的**变量的类型**，但是不想用该表达式的值**初始化变量**。为此，**C++11**引入了`decltype`**说明符**  
  > 2、`delctype`可以**返回操作数的数据类型**，在此过程中，**编译器**分析表达式并**得到它的类型**，但并**不实际计算表达式的值**  
  > 3、注意`delctype`**表达式的结果**如果是**加上括号的变量**，则结果将是**引用**。即`decltype(())`(注意是双层括号)的**结果永远是引用**

  ```cpp
  int ci = 1;
  decltype(ci) x = 0;         // x 的类型就是 ci 的类型，即 int，值为 0
  decltype(def()) sum = x;    // sum的类型就是函数 def() 的返回类型，值为 x 的值
  /*--------------------------------------------------------------------*/
  int i = 1;
  decltype((i)) d;            // 错误：d 是 int& 引用类型，必须初始化
  decltype(i) e;              // 正确：e 是一个未初始化的 int 类型
  ```

##### **自定义数据结构**

- **什么是数据结构**

  > 1、从最基本的层面理解，**数据结构**是把一组**相关的数据元素**组织起来然后使用它们的**策略和方法**  
  > 2、举一个例子，我们想要创建一个`Sales_items`**类**把书本的**ISBN 编号**、**售出量**、**销售收入**等数据组织在一起，并提供诸如`isbn()`**等函数**，`<<`、`>>`、`+`、`+=`**等运算**在内的**一系列操作**，`Sales_item`**类**就是一个**数据结构**  
  > 3、C++允许用户以**类的形式**自定义**数据类型**，而**库类型**`string`、`istream`、`ostream`等也是**以类的形式定义的**

- **定义类**

  - **简单的不含运算功能的类**的定义实际就是**C 的结构体**定义，使用`struct`定义

  - 此外，C++提供**另外一个关键字**`class`定义自己的**数据结构**，后续介绍

- **使用类**：简单的**类**的使用与**C 的结构体**使用规则相似，但定义**类对象**(结构变量)时不需要再使用`struct`再次声明

---

#### **字符串、向量和数组**

---

<div class="success">

> **章节概要**：命名空间的`using`声明；标准库类型`string`；定义和初始化`string`对象；`string`对象的操作；处理`string`对象中的字符；范围 for 语句；标准库类型`vector`；模板；定义和初始化`vector`对象；向`vector`对象添加元素；其他`vector`操作；`vector`的索引；迭代器介绍；使用迭代器；泛型编程；迭代器运算；数组；`auto`与数组；指针也是迭代器；与旧代码的接口

</div>

##### **命名空间的 using 声明**

- **引入**

  > 1、目前为止，我们用到的**库函数**基本上都属于**命名空间**`std`，而程序也显式地将这一点标示了出来，如`std::cin`  
  > 2、用这种方法显得**比较繁琐**，然而幸运的是，通过更简单的途径也能使用到**命名空间的成员**  
  > 3、本节将介绍其中一种**最安全的方法**，也就是**使用**`using`**声明**，后续会介绍另一种方法

- `using`**声明**

  > 1、有了`using`声明就**无须专门的前缀**，也能使用所需的名字了  
  > 2、`using`声明具有**如下形式**`using 命名空间名::名字`，如后示例  
  > 3、按照规定，每个`using`声明只能引入**命名空间**中的**一个成员**，因此每个名字都需要**独立声明**  
  > 4、位于**头文件**的代码**不应该使用**`using`**声明**，因为引用该头文件的源代码也会**引入这个声明**，对于某些程序，可能会**产生名字冲突**

  ```cpp
  #include <iostream>
  using std::cin;
  int main()
  {
      int i;
      cin >> i;
      std::cout << i;
      return 0;
  }
  ```

##### **标准库类型 string**

- **介绍**

  > 1、**标准库类型**`string`表示**可变长的字符序列**(字符串)，使用`string`类型必须先包含`string`**头文件**  
  > 2、作为**标准库的一部分**，`string`定义在**命名空间**`std`中  
  > 3、接下来的示例都假定已包含了下述代码

  ```cpp
  #include <string>
  using std::string
  ```

- **定义和初始化 string 对象**

  > 1、如何**初始化类的对象**是由**类本身**决定的，一个类可以定义**很多种**初始化对象的方式，但这些方式之间**必须有所区别**：或者是**初始值数量不同**，或者是**初始值类型不同**  
  > 2、下为**初始化**`string`**对象**的**方式和示例**

  | 方式                | 说明                                                   |
  | ------------------- | ------------------------------------------------------ |
  | string s1           | 默认初始化，s1 是一个空串                              |
  | string s2(s1)       | 直接初始化，s2 是 s1 的副本                            |
  | string s2 = s1      | 拷贝初始化，s2 是 s1 的副本                            |
  | string s3("value")  | 直接初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s3 = "value" | 拷贝初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s4(n, 'c')   | 直接初始化，把 s4 初始化为连续 n 个字符 c 组成的字符串 |

  ```cpp
  string s1;                    // 默认初始化，s1是空字符串
  string s2 = s1;               // s2是s1的副本
  string s3("value");           // s3是字面值"value"的副本
  string s3 = "value";          // s3是字面值"value"的副本
  string s4(10, 'c');           // 直接初始化，s4内容是 cccccccccc
  string s4 = string(10, 'c');  // 拷贝初始化，s4内容是 cccccccccc
  ```

- **string 对象的操作**

  - **总览**

    > 1、一个**类**除了要规定**初始化其对象的方式**外，还要定义对象上**能执行的操作**。其中，类既能定义**通过函数名调用的操作**，也能定义**各种运算符**在**该类对象**上的**新含义**  
    > 2、下表列举了**大部分**`string`**类的操作**

    | 操作           | 含义                                                                                     |
    | -------------- | ---------------------------------------------------------------------------------------- |
    | os<<s          | 将 s 写入到输出流 os 中，返回 os                                                         |
    | is>>s          | 从 is 中读取字符串赋给 s，字符串以空格分隔，返回 is                                      |
    | getline(is, s) | 从 is 中读取一行赋给 s，返回 is                                                          |
    | s.empty()      | s 为空返回 true，否则返回 false                                                          |
    | s.size()       | 返回 s 中字符个数                                                                        |
    | s[n]           | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起                                             |
    | s1+s2          | 返回 s1 和 s2 连接后的结果                                                               |
    | s1=s2          | 用 s2 的副本代替 s1 中原来的字符                                                         |
    | s1==s2         | 如果 s1 和 s2 中的字符完全一样，则它们相等，对字母的判断依据是 ASCII 码                  |
    | s1!=s2         | 如果 s1 和 s2 中有一个字符不一样，则它们不相等，对字母的判断依据是 ASCII 码              |
    | <,<=,>,>=      | 对字符串从前向后依次比较字符的 ASCII 码，成立与否的依据是首个不相等字符的 ASCII 大小关系 |

  - **读写操作**

    ```cpp
    // 基本读写
    int main()
    {
        string s;
        cin >> s;   // 遇到空格停止
        cout << s;
        return 0;
    }
    ```

    ```cpp
    // getline整行读取
    int main()
    {
        string line;
        getline(cin, line);   // 遇到换行符停止
        cout << line << endl;
        return 0;
    }
    ```

    ```cpp
    // C语言风格EOF读写
    int main()
    {
        string word;
        // while(getline(cin, line))
        while(cin >> word)
            cout << word << endl;
        return 0;
    }
    ```

  - `empty`**和**`size`**操作**

    > 1、`empty`**函数**根据`string`**对象是否为空**返回一个**布尔值**，`size`**函数**返回`string`**对象的长度**  
    > 2、这两个函数都是`string`的**成员函数**。**调用该类函数**的方法是，使用**点操作符**指明是**哪个对象**执行成员函数即可(`对象.成员函数()`)

    ```cpp
    int main()
    {
        string line;
        while(getline(cin, line))
            // 如果字符串不为空 且 字符串长度大于10
            if(!line.empty() && line.size() > 10)
                cout << line << endl;
        return 0;
    }
    ```

  - `string::size_type`**类型**

    > 1、实际上，`size`**函数的返回值**是一个`string::size_type`**类型的值**  
    > 2、尽管我们不太清楚`string::size_type`类型的**具体细节**，但有一点是肯定的，它是一个**无符号类型值**，且**足够存放任何**`string`**对象的大小**  
    > 3、所有**用于存放**`string`**类**的`size`**函数返回值**的**变量**，都应该是**该类型**(`auto len = line.size();`中`line`的类型也**自动设为该类型**)  
    > 4、由于**该类型**是**无符号整型**，因此切记，如果在表达式中**混用**了**无符号数和有符号数**会产生意想不到的错误。如**变量 n**是一个**具有负值的 int**，则表达式`s.size() < n`几乎肯定是**true**，因为**负值 n**会**自动转换**成一个**较大的无符号值**

  - **字面值和**`string`**对象相加**

    > 1、即使一种类型**并非所需**，我们也可以使用它，不过前提是**这种类型能自动转换成所需类型**  
    > 2、因为**标准库**允许把**字符字面值**和**字符串字面值**转换成`string`**对象**，所以在**需要**`string`**对象的地方**就可以用**这两种字面值**代替  
    > 3、注意：当把`string`**对象**和**这两种字面值**混在一条语句中使用时，必须确保**每个加法运算符**的两侧的**运算对象至少有一个**是`string`

    ```cpp
    string s1 = "hello", s2 = "world";
    string s3 = s1 + "," + s2 + '\n';
    /*------------------------------*/
    // 注意按顺序结合后结果的类型
    string s4 = s1 + ",";               // 正确
    string s5 = "hello" + ",";          // 错误
    string s6 = s1 + "," + "world";     // 正确
    string s7 = "hello" + "," + s2;     // 错误
    ```

- **处理 string 对象中的字符**

  - **引入**

    > 1、我们经常需要**单独处理**`string`**对象**中的**字符**，这类处理的关键问题是**如何获取字符本身**，另一个关键问题是要知道**能改变某个字符的特性**  
    > 2、对于后者，我们可以使用**C 语言继承而来**的`cctype`(即`ctype.h`)，对于后者，我们可以通过**范围 for 语句**实现

  - **范围 for 语句**

    > 1、如果想对`string`**对象**中的**每个字符**做点什么，目前最好的操作是使用**C++11 标准**提供的**范围 for 语句**(语法形式如后附)  
    > 2、其中**变量**将被用于**访问序列中的基础元素**。每次**迭代**，**变量**都会被**初始化**为**对象序列**的**下一个元素值**

    ```cpp
    for (变量 : 对象序列)
    {
        循环体;
    }
    ```

  - **示例：统计标点数并输出标点**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        int ct = 0;
        string s;
        getline(cin, s);
        for (auto c : s)
        {
            if (ispunct(c))
            {
                ct++;
                cout << c << ' ';
            }
        }
        cout << endl << "ct: " << ct << endl;
        return 0;
    }
    ```

  - **使用范围 for 改变字符**

    > 1、如果想要**改变**`string`**对象**中**字符的值**，只需要把**循环变量**定义成**引用**类型即可  
    > 2、记住，所谓**引用**只是**给定对象的一个别名**，因此当**引用**作为**循环控制变量**时，这个变量实际**被依次绑定到**序列的**每个元素**上  
    > 3、下示例将**整个字符串**中的**小写字母**转换成**大写字母**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        string s;
        getline(cin, s);
        for (auto &c : s)
        {
            c = toupper(c);
            cout << c << ' ';
        }
        cout << endl << s << endl;
    }
    ```

  - **只处理一部分字符**

    > 1、如果只想处理**一部分**字符，那么**范围 for 语句**则**不能很好的胜任**了。通常访问`string`**对象**中的**单个字符**有两种方式：一种是使用**下标**，另一种是使用**迭代器**(后续介绍)  
    > 2、`string`**对象**的下标使用与**C 语言字符数组**规则类似，使用**for 循环遍历处理**。对象的下标必须**大于等于 0**且**小于**`s.size()`

##### **标准库类型 vector**

- **介绍**

  > 1、标准库类型`vector`表示**对象的集合**，其中**所有对象的类型都相同**  
  > 2、集合中的**每个对象**都有一个**与之对应的索引**，索引用于**访问对象**  
  > 3、因为`vector`**容纳着**其他对象，所以它也常常被称作**容器**  
  > 4、要想使用`vector`，必须包含**适当的头文件**。后续的例子中，都假设包含以下声明

  ```cpp
  #include <vector>
  using std::vector;
  ```

- **模板**

  - **模板简介**

    > 1、C++既有**类模板**，也有**函数模板**，其中`vector`是一个**类模板**。只要对 C++有深入了解后才能**写出模板**，我们将在 16 章介绍。但即使不会创建模板，我们也可以试着使用模板  
    > 2、**模板**本身不是**类或函数**，相反可以将**模板**看做**编译器生成类或函数编写**的一份**说明**。编译器**根据模板创建类或函数**的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数**实例化成何种类型**  
    > 3、对于**类模板**来说，我们通过提供一些**额外信息**来指定模板应**实例化成什么样的类**，需要**提供哪些信息**由模板决定。**提供信息的方式**总是这样：在**模板名字**后面跟**一对尖括号**，在**括号内**放上信息，`模板名<信息>;`

  - **vector 模板**

    > 1、例如`vector`模板，**需要提供的信息**是`vector`内存放的**对象类型**(示例如后附代码)  
    > 2、`vector`是**模板**而非**类型**，由`vector`**生成的类型**必须包含`vector`中**所存放元素的类型**，例如`vector<int>`  
    > 3、`vector`能容纳**绝大多数类型**的**对象**作为其**元素**，但是由于**引用不是对象**，所以**不存在包含引用的**`vector`  
    > 4、早期版本 C++中，如果`vector`**的元素**还是`vector`，必须在**外层**的**右尖括号**和**其元素类型**之间添加一个**空格**。比如应该写成`vector<vector<int> >`

    ```cpp
    vector<int> ivec;               // ivec保存int类型的对象
    vector<Sales_item> Sales_vec;   // 保存Sales_item类型的对象
    vector<vector<string>> file;    // 该向量的元素是vector对象
    ```

- **定义和初始化 vector 对象**

  - 下表列出了**初始化**`vector`**对象**的**方法**

    | 方法                       | 说明                                                    |
    | -------------------------- | ------------------------------------------------------- |
    | vector<T> v1               | v1 是一个空 vector，潜在元素为 T 类型，执行默认初始化   |
    | vector<T> v2(v1)           | v2 中包含有 v1 所有元素的副本                           |
    | vector<T> v2 = v1          | 同上等价                                                |
    | vector<T> v3(n,val)        | v3 包含 n 个重复的元素，每个元素值都是 val              |
    | vector<T> v4(n)            | v4 包含 n 个重复执行了值初始化的对象                    |
    | vector<T> v5{a,b,c,...}    | v5 包含了初始值个数的元素，每个元素被赋予了相应的初始值 |
    | vector<T> v5 = {a,b,c,...} | 同上等价                                                |

  - 区分`()`**值初始化**和`{}`**列表初始化**的含义

    > 1、`vector<int> ivec(3,-1)`含义是**ivec**存放了**3 个值为 -1 的元素**；而`vector<int> ivec{3,-1}`含义是**ivec**存放了**两个元素**，**值**分别为**3 和 -1**  
    > 2、`vector<int> ivec(10)`是指**ivec**创建了**10 个执行了值初始化的元素**(如 int 类型会被初始化为 0)  
    > 3、简单地说，想要**初始化多个相同值**就使用`()`**值初始化**，想要**初始化多个不同值**就使用`{}`**列表初始化**

- **向 vector 对象添加元素**

  > 1、经常我们会遇到，创建一个`vector`时并**不清楚**实际所需**元素个数**，元素的**值**也**无法确定**；还有些时候元素初值已知，但这些值**总量较大**且**各不相同**  
  > 2、例如我们需要`vector`**对象**存储 1-100 的数字，对此更好的办法是先创建一个**空**`vector`，然后在**运行时**利用`vector`的**成员函数**`push_back`来**添加数据**  
  > 3、`push_back`负责把**一个值**当成`vector`**对象**的**尾元素**，添加到**对象的尾端**，示例如下  
  > 4、注意：如果循环体内部含有**向**`vector`**添加元素**的语句，则不能使用**范围 for 语句**

  ```cpp
  vector<int> ivec;
  for (int i = 1; i <= 100; i++)
      ivec.push_back(i);
  ```

- **其他 vector 操作**

  - `vector`提供了一些**其他操作**，下表列出其中比较重要的一些

    | 操作             | 含义                                                          |
    | ---------------- | ------------------------------------------------------------- |
    | v.empty()        | 如果 v 不含有任何元素，返回 true，否则返回 false              |
    | v.size()         | 返回 v 中元素的个数，返回值类型是 `vector<T>::size_type` 类型 |
    | v.push_back(t)   | 将值为 t 的元素添加到 v 的尾端                                |
    | v[n]             | 返回 v 中第 n 个位置上元素的引用                              |
    | v1 = v2          | 用 v2 中的元素拷贝替换 v1 中的元素                            |
    | v1 = {a,b,c,...} | 用列表中的元素拷贝替换 v1 中的元素                            |
    | ==,!=,<,<=,>,>=  | 与 string 相同，比较字典序                                    |

- **vector 的索引**

  > 1、和`string`类似，如果需要**逐个访问全部**`vector`**元素**，也可以使用**范围 for 语句**+**引用**  
  > 2、对于需要**非顺序访问**，可以使用**下标**访问，**下标**同样**从 0 开始计算**  
  > 3、注意：只能对**确知已存在的元素**使用**下标操作**，因此**不能使用下标添加元素**，添加元素只能使用`push.back`

##### **迭代器介绍**

- **介绍**

  > 1、我们已经知道可以使用**下标**访问`string`**对象的字符**和`vector`**对象的元素**，还有另一种**更通用的机制**也能实现，就是**迭代器**  
  > 2、除了`vector`外，**标准库**还定义了**其他几种容器**。**所有标准库容器**都能使用**迭代器**，但只有**少数几种**才同时支持**下标操作**  
  > 3、类似于**指针类型**，迭代器也提供对**对象**的**间接访问**，同时迭代器也有**有效**和**无效**之分。**有效**的迭代器**指向某个元素**或指向**容器尾元素的下一位置**，其余都属于**无效**迭代器

- **使用迭代器**

  - **引入**

    > 1、**和指针不同**的是，**获取迭代器**不是使用**取地址符**，**有迭代器的类型**同时拥有**返回迭代器的成员**  
    > 2、比如**这些类型**都拥有名为**begin**和**end**的**成员**，其中**begin 成员**负责返回**指向第一个元素的迭代器**，**end 成员**负责返回**指向容器尾元素下一位置的迭代器**  
    > 3、**end 成员**返回的**迭代器**常被称作**尾后迭代器**，或简称为**尾迭代器**。这样的迭代器没什么实际含义，只是个**标记**而已，表示我们已经处理完了容器中所有元素。特殊情况下，如果**容器为空**，则**begin**和**end**返回的是**同一个迭代器**  
    > 4、一般来说，我们不清楚(也不需要在意)**迭代器的准确类型**是什么，通常使用`auto`**关键字**定义变量来**自动确定类型**

    ```cpp
    // b 表示 v 的第一个元素，e 表示 v 尾元素的下一位置
    auto b = v.begin(), e = v.end();
    ```

  - **迭代器运算符**

    > 1、下表列举了部分**迭代器支持的运算**  
    > 2、和指针类似，也能通过**解引用迭代器**来获取它**所指示的元素**，执行解引用的迭代器**必须合法**并**确实指示着某个元素**  
    > 3、举个例子，使用**迭代器**访问`string`**对象**，将字符串的**首字母大写**(如下例)

    | 运算             | 含义                                                                                                 |
    | ---------------- | ---------------------------------------------------------------------------------------------------- |
    | \*iter           | 返回迭代器 iter 所指元素的引用                                                                       |
    | iter->mem        | 解引用 iter 并获取该元素的名为 mem 的成员，等价于`(*iter).mem`                                       |
    | ++iter 或 iter++ | 令 iter 指示容器中的下一个元素                                                                       |
    | --iter 或 iter-- | 令 iter 指示容器中的上一个元素                                                                       |
    | iter1 == iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |
    | iter1 != iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |

    ```cpp
    string s("some thing");
    if (s.begin() != s.end())   // 确保 s 为非空字符串
    {
        auto it = s.begin();    // it 表示 s 的第一个字符
        *it = toupper(*it);     // 改为大写
    }
    ```

  - **将迭代器移动到另外一个元素**

    > 1、**迭代器**使用**递增运算符**`++`来移动到**下一个元素**，使用**递减运算符**`--`来移动到**上一个元素**  
    > 2、因为**end 返回的迭代器**并不实际指示**某个元素**，所以**不能**对其进行**递增**或**解引用**  
    > 3、下例为使用**迭代器**依次访问`string`**对象**的**字符**，将**整个字符串的字母大写**

    ```cpp
    string s("hello world");
    for (auto it = s.begin(); it != s.end(); it++)
        *it = toupper(*it);
    ```

  - **迭代器类型**

    > 1、就像**不知道**`string`和`vector`的`size_type`**成员**到底是**什么类型**一样，一般来说我们也**不知道**(也无需知道)**迭代器的精确类型**  
    > 2、实际上，那些**拥有迭代器**的**标准库类型**使用`iterator`和`const_iterator`来表示**迭代器的类型**，其中`const_iterator`和**常量指针**差不多

    ```cpp
    vector<int>::iterator it1;          // it1 能读写 vector<int> 的元素
    string::iterator it2;               // it2 能读写 string 对象中的字符

    vector<int>::const_iterator it3;    // it3 只能读元素，不能写元素
    string::const_iterator it4;         // it4 只能读字符，不能写字符
    ```

  - `cbegin`**和**`cend`**函数**

    > 1、`begin`和`end`返回的**具体类型**由**对象是否是常量**决定。如果对象**是常量**则返回`const_iterator`，如果**不是常量**在返回`iterator`  
    > 2、有时候这种**默认的行为**并非我们所要，如果对象**只需读无须写**最好使用**常量类型**  
    > 3、为了便于我们得到`const_iterator`**类型的返回值**，C++11 引入了两个**新函数**：`cbegin`和`cend`，其返回值一定是`const_iterator`类型

  - **组合解引用和成员访问操作**

    > 1、**解引用迭代器**可获得迭代器**所指的对象**，如果该**对象的类型**恰好是**类**，就有可能希望进一步**访问它的成员**  
    > 2、例如，对于一个由字符串组成的`vector`**对象**，要想检查其**元素是否为空**，令**it**是该`vector`的**迭代器**，只要检查**it 所指字符串是否为空**即可：`(*it).empty()`(注意前面的括号不可省略，因为关系到运算符优先级问题)  
    > 3、为了简化上述表达式，C++定义了**箭头运算符**`->`。箭头运算符把**解引用**和**成员访问**两个操作**结合在一起**，也就是说，`it->mem`等效于`(*it).mem`

  - **某些对**`vector`**对象的操作会使迭代器失效**

    > 1、虽然`vector`对象可以**动态地增长**，但是也会有一些**副作用**  
    > 2、已知的一个限制是不能在**范围 for 语句**内向`vector`**添加元素**。另外一个限制是任何一种**可能改变**`vector`**对象容量**的操作，比如`push_back`，都会使其**迭代器失效**(后续解释)  
    > 3、谨记，但凡是使用了**迭代器**的**循环体**，**都不要**向迭代器所属容器**添加元素**

- **泛型编程**

  > 1、原来使用 C 或 Java 的程序员转而使用 C++ 后，会对**for 循环**中**大量使用**`!=`而不是`<`进行判断感到奇怪  
  > 2、C++程序员**习惯性使用**`!=`，其原因和他们**更愿意用迭代器而非下标**的原因一样：这种编程风格在**标准库提供的所有容器**上都有效  
  > 3、与之类似，**所有标准库容器的迭代器**都定义了`!=`和`==`，但它们中的**大多数没有定义**`<`**运算符**  
  > 4、因此，只要我们养成使用**迭代器**和`!=`的习惯，就**不用太在意**用的到底是**哪种类型**

- **迭代器运算**

  > 1、`string`和`vector`的**迭代器**提供了更多额外的**运算符**，一方面可使得迭代器**每次移动过多个元素**，另外也支持迭代器进行**关系运算**。  
  > 2、所有这些运算都被称为**迭代器运算**，如下表

  | 运算          | 含义                                                                                                                                                                                   |
  | ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | iter + n      | 迭代器加上一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置                                                |
  | iter - n      | 迭代器减去一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置                                                |
  | iter += n     | 迭代器加法的复合赋值语句，将 iter 加 n 的结果赋给 iter                                                                                                                                 |
  | iter -= n     | 迭代器减法的复合赋值语句，将 iter 减 n 的结果赋给 iter                                                                                                                                 |
  | iter1 - iter2 | 两个迭代器相减的结果是它们之间的距离，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置                                                                                        |
  | >,>=,<,<=     | 迭代器关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则前者小于后者，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置，类型是`difference_type`的带符号整型 |

- **使用迭代器运算**

  - 使用迭代器运算的一个**经典算法**是**二分搜索**，其从**有序序列**中寻找某个**给定值**

    ```cpp
    // text 必须是有序的，sought 是要搜索的给定值
    auto beg = text.begin(), end = text.end();    // beg 和 end 表示搜索的范围
    auto mid = text.begin() + (end - bag) / 2;    // 初始中间点
    while (mid != end && *mid != sought)
    {
        if (sought < *mid)                        // 如果在前半部分
            end = mid;                            // 忽略后半部分
        else                                      // 如果在后半部分
            beg = mid + 1;                        // 在mid之后寻找
        mid = beg + (end - beg) / 2;              // 新的中间点
    }
    ```

##### **数组**

- **数组**的大部分使用规则**与 C 语言相同**

- **auto 与数组**

  > 1、由于**数组名**是数组的**首元素地址**，所以使用`auto`**关键字**时，`auto ia2(ia)`等同于`auto ia2(&ia[0])`  
  > 2、但如果使用`decltype`**关键字**，上述转换**不会发生**，`decltype(ia)`**返回类型**是由**10 个整数**构成的**数组**

  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};
  // ia2是一个整型指针，指向ia的首元素
  auto ia2(ia);
  // ia3是一个含有10个整数的数组
  decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}
  ```

- **指针也是迭代器**

  > 1、就像使用**迭代器**遍历`vector`**对象**那样，使用**指针**也能**遍历数组中的元素**。不过前提是先获取到**指向数组首元素的指针**和**指向数组尾元素下一位的指针**  
  > 2、获取**首元素地址**可以使用**数组名**，而**尾后指针**可以获取**尾元素后**那个**并不存在的元素的地址**。如假设定义`int arr[10];`，则可以`int *end = &arr[10]`  
  > 3、尽管**通过计算**可以得到**尾后指针**，但这种方法**极易出错**。为了让指针的使用更简单，C++11 新增了**两个函数**：`begin`**函数**和`end`**函数**  
  > 4、这**两个函数**与**容器中**的**两个同名成员**功能类似，不过**数组不是类类型**，所以这两个函数**不是成员函数**。正确使用的方法是将**数组**作为它们的**参数**，如下

  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};
  int *begin = begin(ia);
  int *end = end(ia);
  ```

- **与旧代码的接口**

  - **引入**

    > 1、很多 C++程序在**标准库出现之前**就已经写成了，它们肯定没用到`string`和`vector`类型；而且有一些 C++程序实际上是**与 C 语言或其他语言**的**接口程序**，当然也无法使用**C++标准库**  
    > 2、但是，现代的 C++ 程序不得不与那些**充满了数组**或**C 风格字符串**的代码衔接。为了使这一工作**简单易行**，C++专门提供了一组功能

  - **混用**`string`**对象和 C 风格字符串**

    > 1、允许使用以`\0`结束的**字符数组**(即 C 风格字符串)来对`string`**对象**进行**初始化**和**赋值**  
    > 2、在`string`**对象**的**加法运算**中允许使用**C 风格字符串**作为其中**一个运算对象**(不能两个都是)；在`string`**对象**的**复合赋值运算**中允许使用**C 风格字符串**作为**右侧运算对象**  
    > 3、上述性质**反过来**就**不成立**了：如果程序某处需要一个**C 风格字符串**，不能用`string`**对象**代替它，例如不能用`string`**对象**初始化一个**指向 char 的指针**  
    > 4、为了完成该功能，`string`专门提供了一个名为`c_str`的**成员函数**：其返回**一个指针**，指向一个**C 风格字符串**，该**字符串内容**与`string`**对象**一样；指针的类型是`const *char`，确保**不会改变字符数组的内容**

    ```cpp
    char *str = s;                // 错误，不能用string对象初始化指向char的指针
    const char *str = s.c_str();  // 正确
    ```

  - **用数组初始化**`vector`**对象**

    - 允许使用**数组**来**初始化**`vector`**对象**。要实现这一目的，只需指明要**拷贝区域**的**首元素地址**和**尾后地址**即可(最简单的方式是用`begin`和`end`函数)

      ```cpp
      int int_arr[] = {0,1,2,3,4,5};
      vector<int> ivec(begin(int_arr), end(int_arr));
      ```

---

#### **表达式**

---

<div class="success">

> **章节概要**：特性补充；**sizeof**运算符；强制类型转换

</div>

##### **特性补充**

- C++的**表达式**和**运算符**与 C 大部分相同，在此**补充**或**强调**一些特性

- **sizeof 运算符**

  > 1、对`string`或`vector`**对象**执行`sizeof`**运算符**只返回**该类型固定部分**的**大小**，**不会计算**对象中的元素占用了多少**空间**  
  > 2、因为`sizeof`的**返回值**是一个**常量表达式**`constexpr size_t`，因此可以用`sizeof`的结果**声明数组的大小**

- **强制类型转换**

  - 一个命名的**强制类型转换**具有**如下形式**：`转换模式<转换类型>(表达式)`

  - 其中，**转换模式**是`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`中的一种

  - `static_cast`**模式**

    > 1、任何具有**明确定义**的**类型转换**，只要不包含**底层**`const`，都可以使用`static_cast`，例如：`double slope = static_cast<double>(i);`  
    > 2、`static_cast`对于**编译器无法自动执行**的**类型转换**也非常有用，例如可以**找回存在于**`void*`**的指针**，转换回**原始的指针类型**，示例如后  
    > 3、但是对于**存在于**`void*`**的指针**，应确保**指针的值保持不变**，且**转换后所得类型**就是**指针所指类型**

    ```cpp
    // 任何非常量对象的地址都能存入void*
    void* p = &d;
    //将void*转换回原始的指针类型(指向double的指针)
    double *dp = static_cast<double*>(p);
    ```

  - `const_cast`**模式**

    > 1、`const_cast`**只能改变**运算对象的**底层**`const`，对于将**常量对象**转换成**非常量对象**的行为，称其为**去掉**`const`**性质**  
    > 2、一旦**去掉了**某个对象的`const`**性质**，编译器将**不再阻止**我们对该对象进行**写入操作**  
    > 3、如果对象**本身不是一个常量**，那么强制类型转换获得**写权限**是**合法的行为**；但如果对象**本身是一个常量**，则再使用`const_cast`执行**写操作**将产生**未定义的后果**

    ```cpp
    const char *pc;
    char *p = const_cast<char*>(pc);    // 正确：但是写操作是未定义的行为
    /*-----------------------------*/
    const char *cp;
    char *q = static_cast<char*>(cp);   // 错误：static_cast不能转换掉const性质
    const_cast<string>(cp);             // 错误，const_cast只能改变常量属性
    static_cast<string>(cp);            // 正确
    ```

  - `reinterpret_cast`**模式**

    > 1、`reinterpret_cast`通常为**运算对象**的**位模式**提供**较低层次**上的重新解释  
    > 2、如下例，我们必须牢记**pc**所指的**真实对象是 int 而非字符**，如果把**pc**当成普通的**字符指针**使用就可以在运行时发生错误  
    > 3、使用`reinterpret_cast`是**非常危险**的，其中关键问题是**类型改变了**，但编译器**没有给出任何警告或错误提示**。下面**使用 pc 时**就会认定它的值是**char\*类型**，**编译器没法知道**它实际存放的是**指向 int 的指针**  
    > 4、`reinterpret_cast`本质上**依赖于机器**。想要安全地使用，必须对**涉及的类型**和**编译器实现转换的过程**都相当了解

    ```cpp
    int *ip;
    char *pc = reinterpret_cast<char*>(ip);
    string str(pc);     // 错误：可能导致异常的运行时行为
    ```

  - `dynamic_cast`**模式**：支持**运行时类型识别**，后续介绍

  - 此外，C 语言的**旧式强制类型转换**仍然支持，但与 C++ 的相比，表现形式上不那么清晰明了，**出错追踪比较困难**，建议使用 C++ 的转换方式

---

#### **语句**

---

<div class="success">

> **章节概要**：`try`语句块和异常处理；C++的异常处理；`throw`表达式；`try`语句块；编写处理代码；标准异常

</div>

##### **try 语句块和异常处理**

- **引入**

  > 1、**异常**是指存在于**运行时**的**反常行为**，这些行为超出了**函数正常功能**的范畴，典型的异常包括**失去数据库连接**以及**遇到意外输入**等。处理反常行为可能是设计所有系统最难的一部分  
  > 2、当**程序的某部分**检测到一个让它**无法处理**的问题时，就需要用到**异常处理**。如果程序中含有**可能引发异常的代码**，那么通常也会有**专门的代码处理问题**  
  > 3、**异常处理机制**为程序中**异常检测**和**异常处理**这两部分的协作提供支持。C++中，异常处理包括以下部分

- **C++的异常处理**

  > 1、`throw`**表达式**：**异常检测**部分使用`throw`**表达式**来表示它**遇到了无法处理的问题**，我们说`throw`**引发了异常**  
  > 2、`try`**语句块**：**异常处理**部分使用`try`**语句块**处理异常。`try`中包含**一个或多个**`catch`**子句**，抛出的**异常**通常会**被某个**`catch`**子句处理**。因为`catch`**子句**处理异常，所以它们也被称为**异常处理代码**  
  > 3、一套**类异常**：用于在`throw`**表达式**和相关的`catch`**子句**之间**传递异常的具体信息**

- **throw 表达式**

  > 1、程序的**异常检测**部分使用`throw`**表达式**引发一个**异常**，形式如`throw 表达式;`，其中的**表达式类型**就是**抛出的异常类型**  
  > 2、如下示例，如果书籍的 ISBN 不一样就**抛出异常**，该**异常类型是**`runtime_error`**对象**。抛出异常将**终止当前的函数**，并把**控制权**转移给**能处理该异常的代码**  
  > 3、类型`runtime_error`是**标准库异常类型**的一种，定义在`stdexcept`**头文件**中，后面将介绍其他的异常类型  
  > 4、我们必须**初始化**`runtime_error`**对象**，方式是给它提供一个`string`**对象**或一个**C 风格字符串**，这个字符串中有一些关于异常的**辅助信息**

  ```cpp
  if(item1.isbn() != item2.isbn())
      throw runtime_error("数据必须具有相同的ISBN");
  cout << item1 + item2 << endl;
  ```

- **try 语句块**

  > 1、`try`**语句块**的通用语法形式如下  
  > 2、跟在`try`**块**之后的是**一个或多个**`catch`**子句**。`catch`**子句**包括三部分：**关键字**`catch`、括号内一个(可能未命名的)**对象的声明**(称作异常声明)、以及**一个块**  
  > 3、当选中了某个`catch`子句**异常处理之后**，执行**与之对应的块**。`catch`**一旦执行完成**，会**跳转到**`try`**块**中**最后一个**`catch`**子句之后**的语句继续执行  
  > 4、`try`**块**中的**程序语句**组成程序的**正常逻辑**，像其他任何块一样，可以有包括声明在内的任意 C++ 语句

  ```cpp
  try
  {
      程序语句
  }
  catch(异常声明)
  {
      处理语句
  }
  catch(异常声明)
  {
      处理语句
  }
  // ...
  ```

- **编写处理代码**

  > 1、编写**异常处理代码**，上面的程序可以按如下示例处理  
  > 2、将程序**本来要执行的任务**放在`try`**语句块**中，因为这段代码**可能抛出异常**  
  > 3、`try`对应一个`catch`**子句**，该子句负责**处理**`runtime_error`**类型的异常**。如果`try`中抛出了**此类异常**，则会执行该`catch`内的语句  
  > 4、`catch`中输出给用户的信息中，输出了`err.what()`的返回值。从`catch`**小括号的定义**能得到**err**是一个`runtime_error`**类的对象**，`what`则是该**类**的一个**成员函数**  
  > 5、`what`成员函数**没有参数**，**返回值**是**C 风格字符串**(即`const char*`)。其中，`runtime_error`的`what`**成员**返回的是**初始化一个具体对象**时所用的`string`**对象的副本**(即`try`中初始化的字符串)

  ```cpp
  while (cin >> item1 >> item2)
  {
      try
      {
          if(item1.isbn() != item2.isbn())
              throw runtime_error("数据必须具有相同的ISBN");
          cout << item1 + item2;
      }
      catch(runtime_error err)
      {
          cout << err.what() << "\n 再次尝试？输入y或n"<< endl;
          char c;
          cin >> c;
          if(!cin || c == 'n')
          {
                cout << "程序退出" << endl;
                break;          // 跳出 while 循环
          }
      }
  }
  ```

- **标准异常**

  - **标准异常类**

    > 1、C++**标准库**中定义了一组**类**，用于报告**标准库函数**遇到的问题。这些**异常类**也可以在**用户编写的程序中**使用，分别定义在**4 个头文件**  
    > 2、`exception`：定义了**最通用的异常类**`exception`，它**只报告异常的发生**，**不提供任何额外信息**  
    > 3、`stdexcept`：定义了几种**常用的异常类**，详细信息见下表  
    > 4、`new`：定义了`bad_alloc`**异常类型**，后续介绍  
    > 5、`type_info`：定义了`bad_cast`**异常类型**，后续介绍

    | stdexcept 定义的异常类 | 含义                                           |
    | ---------------------- | ---------------------------------------------- |
    | exception              | 最常见的错误                                   |
    | runtime_error          | 只有在运行时才能检测出的任务                   |
    | range_error            | 运行时错误：生成的结果超出了有意义的值域范围   |
    | overflow_error         | 运行时错误：计算上溢                           |
    | underflow_error        | 运行时错误：计算下溢                           |
    | logic_error            | 程序逻辑错误                                   |
    | domain_error           | 逻辑错误：参数对应的结果值不存在               |
    | invalid_argument       | 逻辑错误：无效参数                             |
    | length_error           | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
    | out_of_range           | 逻辑错误：使用一个超出有效范围的值             |

  - **运算与成员**

    > 1、**标准库异常类**只定义了几种运算，包括**创建或拷贝异常类型的对象**，以及**为异常类型的对象赋值**  
    > 2、我们只能以**默认初始化**的方式初始化`exception`、`bad_alloc`、`bad_cast`对象，**不允许**为这些对象**提供初始值**  
    > 3、**其他异常类型**的行为恰好相反，应该使用`string`**对象**或者**C 风格字符串**初始化这些类型的对象，**不允许**使用**默认初始化**的方式。创建此类对象时，**必须提供初始值**，该值含有**错误相关信息**  
    > 4、**异常类型**之定义了一个名为`what`的**成员函数**，返回值是**C 风格字符串**，字符串的目的是**提供关于异常的一些文本信息**。对于其他**无初始值的异常类型**，`what`返回的内容由**编译器决定**

---

#### **函数**

---

<div class="success">

> **章节概要**：含有可变形参的函数；`initializer_list`形参；函数的返回值；不要返回局部对象的引用或指针；返回数组指针的函数；函数重载；定义重载函数；重载和`const`形参；`const_cast`和重载；特殊用途语言特性；默认实参；内联函数；`constexpr`函数

</div>

##### **含有可变形参的函数**

- **简介**

  > 1、有时我们**无法提前预知**应该向函数**传递几个实参**。为了编写**能处理不同数量实参**的函数，C++11 提供了以下几种方法  
  > 2、如果所有的**实参类型相同**，可以传递一个名为`initializer_list`的**标准库类型**  
  > 3、如果**实参类型不同**，可以编写一种特殊的函数——**可变参数模板**，将在后续介绍  
  > 4、此外还有一种从**C 标准库**`stdarg.h`继承而来的**省略符形参**`...`，但有了一些限制

- **initializer_list 形参**

  - **简介**

    > 1、`initializer_list`是一种**标准库类型**，用于表示**某种特定类型的值的数组**，其定义在`initializer_list`**头文件**中  
    > 2、和`vector`一样，**该类型**也是一种**模板类型**，这意味着**定义对象**时，也必须说明列表中**所含元素的类型**：`initializer_list<int> li;`  
    > 3、和`vector`不同的是，该类型对象中的**元素永远是常量值**，我们**无法改变**该类型对象中**元素的值**

  - **使用**

    > 1、我们可以使用**该类型**作为函数的**形参**，使用**迭代器**访问**列表中的元素**  
    > 2、使用函数时，如果想向`initializer_list`**形参**中**传递一个值的序列**，则必须把**序列**放在一对**花括号**内  
    > 3、含有`initializer_list`**形参**的函数也**可以同时拥有其他形参**

    ```cpp
    // 定义函数
    void error_msg(int error_code, initializer_list<string> i1)
    {
        cout << "error code:" << error_code;
        for(auto beg = i1.begin(); beg != i1.end(); beg++)
            cout << *beg << ' ';
        cout << endl;
    }
    // 传参使用
    int error_number = 15;
    string s1("error1"), s2("error2");
    error_msg(error_number, {"function", s1, s2});
    ```

- **省略号形参**`...`

  > 1、**省略号形参**`...`沿用自**C 语言的**`stdarg.h`**库**，为了便于**C++程序**访问某些特殊的**C 代码**  
  > 2、但省略符形参应该**仅仅用于 C 和 C++ 通用的类型**。特别应该注意，C++的大多数**类类型的对象**传递时都**无法正确拷贝**

##### **函数的返回值**

- **不要返回局部对象的引用或指针**

  > 1、函数完成后，所占用的**内存空间**也会**随之释放**。由此，**局部变量的引用**和**指向局部变量的指针**将指向**不再有效的内存区域**  
  > 2、如下示例，对于两条`return`语句，都将返回**未定义的值**

  ```cpp
  // 函数返回值类型是const string &，即一个引用
  const string &manip()
  {
      string ret;
      if (!ret.empty())
          return ret;       // 错误：返回了局部对象的引用，返回的引用将指向无效区域
      return "Empty";       // 错误：Empty也是一个局部临时量，返回的引用将指向无效区域
  }
  ```

- **返回数组指针的函数**

  - **直接声明**

    > 1、如果我们想定义一个**返回数组指针的函数**，则**数组的下标数**必须**跟在函数名后**。而函数的**形参列表**也跟在**函数名后**，且应该**先于数组的下标数**  
    > 2、因此，**返回数组指针的函数**形式如：`类型 (* 函数名(形参列表))[数组下标数]`，具体的例子和解读如下(可以参考[类型声明黄金法则](https://www.shengqibaozao.eu.org/2022/08/22/%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99/?t=1674030612212))

    ```cpp
    int (*func(int i))[10];
    /*---------------------*/
    /*
    解读：
    func(int i)             ：表示函数需要一个int类型形参
    (*func(int i))          ：返回类型是一个指针
    (*func(int i))[10]      ：指针指向一个大小是10的数组
    int (*func(int i))[10]  ：指向的是一个含有10个int值的数组
    */
    ```

  - **使用尾置返回类型**

    > 1、在 C++11 新标准中还有一种可以**简化上述声明**的方法，就是使用**尾置返回类型**  
    > 2、**任何函数的定义**都能使用**尾置返回**，但这种形式对于**返回类型比较复杂**的函数最有效，比如返回类型是**数组的指针**或者**数组的引用**  
    > 3、**尾置返回类型**跟在**形参列表**后面并以一个`->`**符号开头**。为了表示函数**真正的返回类型**跟在**形参列表后**，原先**标识返回值的地方**改为`auto`

    ```cpp
    // 函数返回一个指针，指向含有10个整数的数组
    auto func(int i) -> int(*)[10];
    ```

  - **使用**`decltype`**获取类型**

    > 1、还有一种情况，**如果知道**函数返回的**指针将指向哪个数组**，可以使用`decltype`来**声明返回类型**，如下例  
    > 2、`decltype(odd)`标识了**返回类型**是一个**含有 5 个 int 值的数组**，`*`标识了**返回类型**是一个**指针**  
    > 3、有一个地方要注意，`decltype`并**不负责**把数组类型**转换成**相应的**指针**，所以如果需要返回**指向数组的指针**的函数，需要像下例中**声明时**加一个`*`

    ```cpp
    int odd[] = {1, 3, 5, 7, 9};
    int even[] = {0, 2, 4, 6, 8};
    // 使用 decltype(odd) 获取类型
    decltype(odd) *arrPtr(int i)
    {
        return (i % 2) ? &odd : &even;  // 返回一个指向数组的指针
    }
    ```

##### **函数重载**

- **简介**

  > 1、如果**同一作用域**内的几个函数**名字相同**但**形参列表不同**，我们称之为**重载函数**。如下例  
  > 2、这些函数接受的**形参类型不同**，但是执行的**操作非常相似**，使用**函数重载**可以在一定程度上减轻起名记名的负担  
  > 3、当**调用这些函数**时，编译器会**根据传递的实参**判断具体想要执行的是**哪个函数**

  ```cpp
  // 函数原型
  void print(char *cp);               // 1
  void print(int *beg, int *end);     // 2
  void print(int ia[], size_t size);  // 3
  /*--------------------------------------*/
  // 函数调用
  int j[2] = {0, 1};
  print("Hello World");         // 调用 1
  print(j, end(j) - begin(j));  // 调用 3
  print(begin(j), end(j));      // 调用 2
  ```

- **定义重载函数**

  > 1、对于定义的**重载函数**来说，它们至少应该在**形参数量**或**形参类型**上**有所不同**  
  > 2、假设有两个函数，他们的**返回类型不同**但**形参列表相同**，这种声明不是**重载函数**，是**错误的**  
  > 3、有时候两个**形参列表看起来不一样**，但实际是**相同**的。比如**省略了形参名**，或使用**类型别名**  
  > 4、**不能重载**`main()`**函数**

  ```cpp
  // 不允许两个函数除了返回类型不同其余都相同
  void lookup(Account&);
  bool lookup(Account&);    // 错误
  /*--------------------------------*/
  // 形参列表相同
  void lookup(Account &acct);
  void lookup(Account&);    // 相同，省略了形参名
  typedef Phone Telno;
  void lookup(Phone&);
  void lookup(Telno&);      // 相同，使用了类型别名
  ```

- **重载和 const 形参**

  > 1、**顶层**`const`不影响传入函数的**对象**，一个拥有**顶层**`const`**的形参**无法和另一个**没有顶层**`const`**的形参**区分开来  
  > 2、如果**形参**是某种类型的**指针或引用**，则通过**区分**其**指向**的是**常量对象**还是**非常量对象**可以实现**函数重载**，注意此时的`const`**是底层的**

  ```cpp
  void lookup(Phone);
  void lookup(const Phone);       // 重复声明了void lookup(Phone)
  void lookup(Phone*);
  void lookup(Phone* const);      // 重复声明了void lookup(Phone*)，顶层const
  /*------------------------------------------------------*/
  void lookup(Account&);          // 作用于Account的引用
  void lookup(const Account&);    // 新函数，作用于常量引用
  void lookup(Account*);          // 作用于指向Account的指针
  void lookup(const Account*);    // 新函数，作用于指向常量的指针，底层const
  ```

- **const_cast 和重载**

  > 1、`const_cast`在**重载函数**的情境中最有用，如下例  
  > 2、**原函数**的**参数**和**返回类型**都是`const string`**的引用**。虽然我们可以对两个**非常量的**`string`调用这个函数，但**返回结果**仍是`const string`，我们并**不希望返回的是常量**  
  > 3、此时我们需要一种**新的函数**，当它的**实参不是常量**时，得到的结果是一个**非常量引用**，使用`const_cast`可以很方便做到这一点  
  > 4、**新函数**内通过`const_cast`把参数先转为**常量**，调用**原函数**，再将**原函数结果**转为**非常量**

  ```cpp
  // 原函数，返回 const string 的引用
  const string &shorterString(const string &s1, const string &s2)
  {
      return s1.size() <= s2.size() ? s1 : s2;
  }
  // 重载函数，返回非 const 的引用
  string &shorterString(string &s1, string &s2)
  {
      auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
      return const_cast<string&>(r);
  }
  ```

##### **特殊用途语言特性**

- **默认实参**

  > 1、可以将**函数**的**形参列表**中的值赋予初始值，这便是**默认实参**。当**函数调用**时，如果**没有给定这个值的实参**，便会使用**默认实参**  
  > 2、我们可以为**一个或多个形参**赋予默认值。但要注意，一旦某个形参被赋予了默认值，它**后面的所有形参**都**必须有默认值**  
  > 3、**函数调用**时，实参按照**位置顺序**解析，**默认实参**负责填补函数调用**缺少的尾部实参**(即靠右侧位置的形参)。即**不能省略前面的参数值**，**只能省略尾部的参数值**

  ```cpp
  // 默认实参函数定义
  typedef string::size_type sz;
  string screen(sz ht = 24, sz wid = 24, char background = ' ');
  // 函数调用
  string window;
  window = screen();            // screen(24, 80, ' ')
  window = screen(66);          // screen(66, 80, ' ')
  window = screen(66,256,'#')   // screen(66, 256, '#')
  // 错误调用
  window = screen(, , '?');     // 错误
  window = screen('?');         // 错误，screen('?', 80, ' ')
  ```

- **内联函数**

  > 1、使用`inline`将函数指定为**内联函数**，通常就是将它在**每个调用点**上**内联地展开**，可以**避免函数调用的开销**。说明如下示例  
  > 2、**内联**只是向**编译器**发出的**一个请求**，**编译器**可以选择**忽略这个请求**  
  > 3、一般来说，**内联机制**用于**优化规模较小**、**流程直接**、**调用频繁**的函数。很多编译器不支持**内联递归函数**，而且一个**大于 75 行**的函数也不大可能在**调用点内联展开**

  ```cpp
  // 原函数即程序调用
  inline string shorterString(string &s1, string &s2)
  {
      return s1.size() <= s2.size() ? s1 : s2;
  }
  string s1 = "abcde", s2 = "abcdef";
  cout << shorterString(s1, s2);

  // 在编译过程中，函数调用将直接展开成下面形式，从而不经过shorterString，减少了函数调用的开销
  cout << (s1.size() <= s2.size() ? s1 : s2);
  ```

- **constexpr 函数**

  > 1、`constexpr`**函数**是指能用于**常量表达式**的函数。定义的方法与其他函数类似，但**有如下规定**：函数的**返回类型**及**所有形参**都必须是**字面值类型**，而且函数体中必须**有且仅有一条**`return`**语句**  
  > 2、执行**初始化任务**时，**编译器**把**对**`constexpr`**函数的调用**都替换成其**结果值**。为了能在编译过程中**随时展开**，`constexpr`**函数**被**隐式指定为内联函数**  
  > 3、`constexpr`**函数**不一定返回常量表达式

  ```cpp
  constexpr size_t scale(size_t ct)
  {
      return 3 * ct;
  }

  int arr[scale(2)];      // 正确，编译时 scale(2) 将被内联展开为 6
  int i = 2;
  int a2[scale(i)];       // 错误，i不是常量表达式
  ```

---

#### **类**

---

<div class="success">

> **章节概要**：定义抽象数据类型；设计`Sales_data`类；定义`Sales_data`类；分析与设计；`this`参数；`const`成员函数；返回`this`对象的函数；该类相关的非成员函数；构造函数；合成的默认构造函数；合成的默认构造函数的局限性；定义构造函数；`= default`的含义；构造函数初始值列表；类外定义构造函数；拷贝、赋值和析构；访问控制与封装；`public`和`private`；`class`和`struct`；友元；类的其他特性；类成员再探；`mutable`可变数据成员；返回`*this`的成员函数；从`const`成员函数返回`*this`；基于`const`的重载；友元再探；类之间的友元关系；令函数成员作为友元；友元函数重载和作用域；类的作用域；名字查找与类作用域；构造函数再探；委托构造函数；隐式类类型转换；`explicit`抑制构造函数隐式转换；聚合类；字面值常量类；`constexpr`构造函数；类的静态成员；声明、使用、定义静态成员；静态成员的类内初始化；静态成员与普通成员的区别

</div>

##### **定义抽象数据类型**

- **抽象数据类型**

  > 1、如果一个类，我们可以通过它的**接口**(例如描述的操作)来**使用该类的对象**，但**不能访问该类的数据成员**(甚至不知道该类有哪些数据成员)，我们称**这样的类**为**抽象数据类型**  
  > 2、反之，如果一个类**允许用户**直接**访问它的数据成员**，并要求**用户**来**编写操作**，**这样的类**不是一个抽象数据类型  
  > 3、对于一个**普通的数据类型**(非抽象数据类型)，如果想把它变成**抽象数据类型**，我们需要**定义一些操作**供类的用户使用。一旦**定义了自己的操作**，我们就可以**封装它的数据成员**了

- **设计 Sales_data 类**

  - **引入**

    > 1、为了方便图书管理，我们需要**设计一个类**便于**信息存储**与**操作**，需要先**分析满足下列操作**：  
    > 2、类中需要有**能读写的数据对象**，需要对这些对象**支持一些操作**  
    > 3、**操作包括**一个名为`isbn`的**成员函数**，并且支持`+`、`=`、`+=`、`<<`、`>>`**运算符**  
    > 4、我们将在后续学习**重载运算符**，现在对于**运算符运算**，我们先定义为**普通函数**的形式  
    > 5、由于特殊的原因(后续重载运算符介绍)，执行**加法**和**IO 的函数**不作为**类的成员**，我们将其定义成**普通函数**

  - **该类应包含的操作**

    > 1、一个`isbn`**成员函数**，返回**对象的 ISBN 编号**  
    > 2、一个`combine`**成员函数**，用于将一个`Sales_data`**对象加到另一个对象上**  
    > 3、一个`add`**函数**，执行两个`Sales_data`对象的**加法**  
    > 4、一个`read`**函数**，将数据从`istream`**读入到**`Sales_data`**对象中**  
    > 5、一个`print`**函数**，将`Sales_data`**对象的值输出到**`ostream`中

  - **使用类的接口**(先不考虑如何实现该类，首先看看应该如何使用这些接口函数)

    ```cpp
    Sales_data total;             // 保存当前求和结果的变量
    if(read(cin, total))          // 读入第一笔交易
    {
        Sales_data trans;         // 保存下一条交易数据的变量
        while(read(cin, trans))   // 读入剩余的交易
        {
            if(total.isbn() == trans.isbn())    // 检查 isbn
              total.combine(trans);             // 更新变量 total 当前的值
            else
            {
                print(cout, total) << endl;     // 输出结果
                total = trans;                  // 处理下一本书
            }
        }
        print(cout, total) << endl; // 输出最后一条交易
    }
    else                            // 如果没有输入
    {
        cerr << "No data?" << endl; // 通知用户
    }
    ```

- **定义 Sales_data 类**

  - **分析与设计**

    > 1、该类的**数据成员**有：`string`类型的**bookNo**，表示 ISBN 编号；`unsigned`类型的**units_sold**，表示某书的销量；`double`类型的**revenue**，表示这本书的总销售收入  
    > 2、类中将包含`combine`和`isbn`两个**成员函数**，此外，我们还需要另一个**成员函数**`avg_price`返回售出书籍的平均价格。由于`avg_price`的**目的并非通用**，所以它应该属于**类的实现的一部分**，而不是**接口的一部分**  
    > 3、**定义**和**声明**一个**成员函数**的方法与普通函数差不多。**成员函数的声明**必须在**类的内部**，而它的**定义可以在外部**。作为**接口组成部分**的**非成员函数**`add`、`read`、`print`等，它们的**定义和声明**都在**类的外部**  
    > 4、定义在**类内部的函数**是**隐式的内联函数**

    ```cpp
    struct Sales_data
    {
        // 数据成员
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
        // 成员函数
        std::string isbn() const
        {
            return bookNo;
        }
        Sales_data &combine(const Sales_data &);    // 将在类外定义
        double avg_price() const;                   // 将在类外定义
    };
    // 非成员接口函数
    Sales_data add(const Sales_data &, const Sales_data &);
    std::ostream &print(std::ostream &, const Sales_data &);
    std::istream &read(std::istream &, Sales_data &);
    ```

  - `this`**参数**

    > 1、`isbn`**成员函数**是如何获得**bookNo 成员**所依赖的**对象**的呢？  
    > 2、观察对`isbn`的**调用**：`total.isbn()`。我们使用了**点运算符**来访问**total 对象**中的`isbn`**成员函数**并调用它  
    > 3、还有一种**例外的形式**，当我们**调用成员函数**时，实际上是在**替某个对象调用它**。如果`isbn`指向`Sales_data`的**成员**(如 bookNo)，则它**隐式地**指向**调用该函数的对象的成员**。在上例中，当`isbn`返回**bookNo**时，实际上它**隐式地**返回**total.bookNo**  
    > 4、**成员函数**通过名为`this`的**额外的隐式参数**来访问和调用它的那个对象，当我们**调用成员函数**时，会用**请求该函数的对象地址**初始化`this`。例如调用`total.isbn()`时，**编译器**负责把**total 的地址**传递给`isbn`的**隐式形参**`this`  
    > 5、在**成员函数体**内部，也可以直接使用**调用该函数的对象的成员**，而无须通过**成员访问运算符**，因为`this`所指的**正是这个对象**。任何对**类成员**的**直接访问**都被看作`this`的**隐式引用**  
    > 6、对于我们来说，`this`**形参**是**隐式定义**的，我们可以在**成员函数体**内部使用`this`。尽管没有必要，但我们还是可以把`isbn`的**函数体写为**`return this->bookNo;`  
    > 7、因为`this`**总是指向这个对象**，所以`this`是一个**常量指针**，**不允许修改**`this`中保存的地址

  - `const`**成员函数**

    > 1、`isbn`函数的另一个**关键之处**是**参数列表后的**`const`，这里，`const`的作用是**修改隐式**`this`**指针的类型**  
    > 2、默认情况下，`this`的类型是**指向类类型**的**非常量版本**的**常量指针**，例如`Sales_data`**成员函数**中，`this`的类型是`Sales_data *const`。这意味着，我们不能把`this`绑定到一个**常量对象**上，这使得不能在一个**常量对象**上调用**普通的成员函数**  
    > 3、如果`isbn`是一个**普通函数**且`this`是一个**普通指针形参**，则我们**应该把**`this`**声明成**`const Sales_data *const`**类型**，毕竟`isbn`函数体内**不会改变**`this`**所指的对象**  
    > 4、然而，`this`**是隐式的**而且不会出现在**形参列表**中，在哪将`this`声明成**指向常量的指针**？C++的做法是把`const`放在成员函数的**参数列表后**  
    > 5、紧跟在**参数列表后**的`const`表示`this`是一个**指向常量的指针**，而像这样使用`const`的**成员函数**称作**常量成员函数**

  - **在类的外部定义成员函数**

    > 1、前面提过**成员函数的定义可以在类外**，我们的`avg_price`和`combine`**成员函数**就打算通过这种方式定义  
    > 2、要注意，**类外部定义的成员的名字**必须包含**所属的类名**，通过**作用域运算符**来告知**编译器**定义的这个函数是**类内的成员函数**

    ```cpp
    double Sales_data::avg_price() const
    {
        if (units_sold)
            return revenue / units_sold;
        else
            return 0;
    }
    ```

  - **返回**`this`**对象的函数**

    > 1、函数`combine`的设计初衷类似于**复合赋值运算符**`+=`，其定义如下  
    > 2、当程序调用`total.combine(trans);`时，`this`指针绑定了**total 的地址**，**rhs 引用**绑定了**实参 trans**  
    > 3、该函数值得关注的是它的**返回类型**和**返回语句**。模仿标准的**赋值运算符**把它的**左侧运算对象**当做**左值**返回，因此`combine`**必须返回引用**，而**左侧运算对象**又是`Sales_data`**对象**，因此返回类型是`Sales_data&`  
    > 4、如前所述，我们需要**把该对象当做左值返回**。我们无须使用隐式的`this`指针访问**函数调用者**的**某个具体成员**，而是要把**调用函数的对象**当做一个整体来访问，即`return *this;`，该调用**返回 total 的引用**

    ```cpp
    Sales_data &Sales_data::combine(const Sales_data &rhs)
    {
        // 把 rhs 的成员加到 this 的成员上
        units_sold += rhs.units_sold;
        revenue += rhs.revenue;
        // 返回调用该函数的对象
        return *this;
    }
    ```

  - **该类相关的非成员函数**

    - `read`和`print`函数

      > 1、`read`和`print`函数分别接受一个**各自 IO 类型的引用**作为其参数，是因为**IO 类**属于**不能被拷贝的类型**，因此只能**通过引用传递**。而且，读取和写入的操作**会改变流的内容**，所以使用**普通引用**而不是`const`**引用**  
      > 2、`print`**函数不负责换行**。一般来说，**执行输出任务的函数**应该尽量**减少对格式的控制**，这样可以确保**由用户代码决定**是否换行

      ```cpp
      // 输入的交易信息包括 ISBN、售出总数、售出单价
      std::istream &read(std::istream &is, Sales_data &item)
      {
          double price = 0;
          is >> item.bookNo >> item.units_sold >> price;
          item.revenue = price * item.units_sold;
          return is;
      }

      std::ostream &print(std::ostream &os, const Sales_data &item)
      {
          os << item.isbn() << ' ' << item.units_sold << ' ' << item.revenue << ' ' << item.avg_price();
          return os;
      }
      ```

    - `add`函数

      ```cpp
      Sales_data add(const Sales_data &lhs, const Sales_data &rsh)
      {
          Sales_data sum = lhs; // 把 lhs 的数据成员拷贝给 sum
          sum.combine(rsh);     // 把 rsh 的数据成员添加到 sum
          return sum;           // 返回新的 Sales_data 对象
      }
      ```

- **构造函数**

  - **介绍**

    > 1、每个**类**都分别定义了它的**对象被初始化的方式**，**类**通过一个或几个**特殊的成员函数**控制其对象的初始化过程，**这些函数**被称为**构造函数**  
    > 2、**构造函数**的任务是**初始化类对象**的**数据成员**，无论何时只要**有类的对象被创建**，**就会执行构造函数**  
    > 3、构造函数的**名字和类名相同**。和其他函数不同的是，构造函数**没有返回类型**，且不能被声明成`const`。类可以包含**多个构造函数**，和其他**重载函数**类似  
    > 4、当我们创建类的一个`const`**对象**时，直到**构造函数完成初始化**过程，对象才真正取得了**常量属性**。因此**构造函数**在`const`**对象**的构造过程中**可以向其写值**

  - **合成的默认构造函数**

    > 1、我们的`Sales_data`类并没有定义任何**构造函数**，可是之前**使用了**`Sales_data`**对象**的程序却没有异常，它们是如何初始化的？  
    > 2、我们没有为这些对象**提供初始值**，它们执行了**默认初始化**。**类**通过一个**特殊的构造函数**来控制**默认初始化过程**，这个函数叫做**默认构造函数**，其**无须任何实参**  
    > 3、如我们所见，**默认构造函数**在很多方面都有其**特殊性**。其中之一是，如果我们的类**没有显式定义构造函数**，编译器会为我们**隐式定义一个默认构造函数**，这样的函数有称为**合成的默认构造函数**  
    > 4、对于大多数类来说，这个**合成的默认构造函数**将按照**如下规则**初始化数据：使用**类内的初始值**(如果有的话)**初始化**成员，否则**默认初始化该成员**

  - **合成的默认构造函数的局限性**

    > 1、**合成的默认构造函数**只适合**非常简单**的类，对于一个**普通的类**来说，**必须**定义它自己的**默认构造函数**，原因有三：  
    > 2、首先，编译器只有在发现**类不包含任何构造函数时**才会替我们生成默认构造函数，一旦我们**定义了一些其他构造函数**，除非我们**再定义**一个**默认生成函数**，否则类将**没有默认构造函数**。如果一个类需要**在某种情况下控制初始化**，那么该类很可能**在所有情况下都需要控制**  
    > 3、其次，对于某些类来说，**合成的默认构造函数**可能执行**错误的操作**。如果定义在**块中的内置类型**或数组指针这类的**复合类型的对象**被**默认初始化**，它们的值是**未定义**的。因此这样的类应该在**类内初始化**这些成员，或定义一个自己的**默认构造函数**  
    > 4、最后，有时候**编译器**不能为**某些类**合成默认构造函数。对这样的类来说，**必须**自定义**默认构造函数**，否则该类将没有可用的**默认构造函数**

  - **定义构造函数**

    - **示例**

      > 1、对于我们的`Sales_data`类，我们将使用**下面的参数**定义 4 个不同的**构造函数**  
      > 2、一个`istream&`，从中读取一条交易信息  
      > 3、一个`const string&`，表示 ISBN 编号；一个`unsigned`，表示图书数量；一个`double`，表示售出单价  
      > 4、一个`const string&`，表示 ISBN 编号，编译器将赋予其他成员默认值  
      > 5、一个**空参数列表**(即默认构造函数)，如刚刚介绍，既然**已定义其他构造函数**，那么也**必须**定义一个**默认构造函数**

      ```cpp
      struct Sales_data
      {
          // 新增的构造函数
          Sales_data() = default;
          Sales_data(const std::string &s) : bookNo(s)
          {
          }
          Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
          {
          }
          Sales_data(std::istream &);   // 将在类外定义

          // 数据成员
          std::string bookNo;
          unsigned units_sold = 0;
          double revenue = 0.0;
          // 成员函数
          std::string isbn() const
          {
              return bookNo;
          }
          Sales_data &combine(const Sales_data &);
          double avg_price() const;
      };
      ```

    - `= default`的含义

      > 1、我们首先解释**默认构造函数**：`Sales_data() = default;`  
      > 2、首先请明确：因为该构造函数**不接受任何实参**，所以它是**默认构造函数**。我们定义它只是因为我们既需要**其他形式的构造函数**，又需要**默认的构造函数**，我们希望它的作用完全等同于**合成的默认构造函数**  
      > 3、在 C++11 中，如果我们需要**默认的行为**，可以通过在**参数列表后**写上`= default`来**要求编译器生成构造函数**。其中`= default`既可以和声明一起**出现在类内**，也可以作为定义**出现在类外**  
      > 4、和其他函数一样，如果`= default`在**类内**，则默认构造函数**是内联的**；反之则**不是内联的**

    - **构造函数初始值列表**

      > 1、之后的两个构造函数中，出现了**新的部分**，即**冒号**及**冒号和花括号之间**的代码。其中**花括号**定义了**空的函数体**，我们把**新出现的部分**称为**构造函数初始值列表**  
      > 2、这部分负责为**新创建的对象**的一个或几个**数据成员**赋初值。**构造函数初始值**是**成员名字**的一个列表，每个名字后紧跟**括号括起来的**或者**在花括号内的**成员初始值。不同成员初始化通过**逗号分隔**  
      > 3、例如，上例含有三个参数的**构造函数**分别用**前两个参数**初始化了成员**bookNo**和**units_sold**，而**revenue**的初始值则通过`revenue(p * n)`使用计算后的值作为初始值  
      > 4、需要注意，这两个**构造函数**的**函数体是空的**是因为这些构造函数的**唯一目的**就是**为成员赋值**，没有其他任务需要执行

    - **类外定义构造函数**

      > 1、我们将在**类外定义**以`istream`为参数的构造函数。该函数需要**执行一些实际操作**，所以在函数体内，调用了之前定义的`read`**函数**给**数据成员赋值**  
      > 2、`Sales_data::Sales_data`的含义是，我们定义的是`Sales_data`**类的成员**，其**成员名**是`Sales_data`  
      > 3、这个**构造函数**的**初始值列表为空**，但是由于执行了**构造函数体**，所以**对象的成员**依然能被初始化

      ```cpp
      Sales_data::Sales_data(std::istream &is)
      {
          read(is, *this);
      }
      ```

- **拷贝、赋值和析构**

  > 1、除了定义类的对象**如何初始化**外，类还需要控制**拷贝**、**赋值**和**销毁对象时发生的行为**  
  > 2、如果我们不**主动定义**这些操作，编译器将替我们**合成它们**。一般来说，编译器生成的版本将对对象的**每个成员**执行**拷贝**、**赋值**和**销毁操作**  
  > 3、我们将在 13 章介绍如何**自定义上述操作**

- **完整的类与使用**

  ```cpp
  #include <iostream>
  #include <string>

  struct Sales_data
  {
      // 新增的构造函数
      Sales_data() = default;
      Sales_data(const std::string &s) : bookNo(s)
      {
      }
      Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
      {
      }
      Sales_data(std::istream &);

      // 数据成员
      std::string bookNo;
      unsigned units_sold = 0;
      double revenue = 0.0;
      // 成员函数
      std::string isbn() const
      {
          return bookNo;
      }
      Sales_data &combine(const Sales_data &);
      double avg_price() const;
  };


  // 非成员接口函数
  Sales_data add(const Sales_data &, const Sales_data &);
  std::ostream &print(std::ostream &, const Sales_data &);
  std::istream &read(std::istream &, Sales_data &);

  double Sales_data::avg_price() const
  {
      if (units_sold)
          return revenue / units_sold;
      else
          return 0;
  }

  Sales_data &Sales_data::combine(const Sales_data &rhs)
  {
      // 把 rhs 的成员加到 this 的成员上
      units_sold += rhs.units_sold;
      revenue += rhs.revenue;
      // 返回调用该函数的对象
      return *this;
  }

  // 输入的交易信息包括 ISBN、售出总数、售出单价
  std::istream &read(std::istream &is, Sales_data &item)
  {
      double price = 0;
      is >> item.bookNo >> item.units_sold >> price;
      item.revenue = price * item.units_sold;
      return is;
  }

  std::ostream &print(std::ostream &os, const Sales_data &item)
  {
      os << item.isbn() << ' ' << item.units_sold << ' ' << item.revenue << ' ' << item.avg_price();
      return os;
  }

  Sales_data add(const Sales_data &lhs, const Sales_data &rsh)
  {
      Sales_data sum = lhs; // 把 lhs 的数据成员拷贝给 sum
      sum.combine(rsh);     // 把 rsh 的数据成员添加到 sum
      return sum;           // 返回新的 Sales_data 对象
  }

  // 构造函数
  Sales_data::Sales_data(std::istream &is)
  {
      read(is, *this);
  }

  int main()
  {
      Sales_data total;          // 保存当前求和结果的变量
      if (read(std::cin, total)) // 读入第一笔交易
      {
          Sales_data trans;             // 保存下一条交易数据的变量
          while (read(std::cin, trans)) // 读入剩余的交易
          {
              if (total.isbn() == trans.isbn()) // 检查 isbn
                  total.combine(trans);         // 更新变量 total 当前的值
              else
              {
                  print(std::cout, total) << std::endl; // 输出结果
                  total = trans;                        // 处理下一本书
              }
          }
          print(std::cout, total) << std::endl; // 输出最后一条交易
      }
      else // 如果没有输入
      {
          std::cerr << "No data?" << std::endl; // 通知用户
      }
      return 0;
  }
  ```

##### **访问控制与封装**

- **public 和 private**

  > 1、对目前为止，我们已经为类**定义了接口**，但没有任何机制**强制用户使用这些接口**。我们的类**还没有封装**，也就是说，用户可以**直达**`Sales_data`**对象内部**并**控制它的具体细节**  
  > 2、C++中，我们使用**访问说明符**来加强类的**封装性**，如下说明。我们可以使用这些说明符再次定义`Sales_data`类，如后示例程序  
  > 3、`public`**说明符**：定义在`publib`后的成员**可以在整个程序内被访问**，`public`成员**定义类的接口**  
  > 4、`private`**说明符**：定义在`private`后的成员**只可以被类的成员函数访问**，不能被使用该类的代码访问，`private`部分封装了**类的实现细节**  
  > 5、通常**构造函数**和**部分成员函数**跟在`public`后，而**数据成员**和**作为实现部分的函数**跟在`private`后  
  > 6、一个类可以包含**任意数量**的**访问说明符**，每个**访问说明符**指定了接下来的**成员访问级别**，其**有效范围**直到出现**下一个访问说明符**或**类的结尾**

  ```cpp
  class Sales_data
  {
      public:
          Sales_data() = default;
          Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
          {
          }
          Sales_data(const std::string &s) : bookNo(s)
          {
          }
          Sales_data(std::istream &);

          std::string isbn() const
          {
              return bookNo;
          }
          Sales_data &combine(const Sales_data &);

      private:
          double avg_price() const
          {
              return units_sold ? revenue / units_sold : 0;
          }
          unsigned units_sold = 0;
          std::string bookNo;
          double revenue = 0.0;
  };
  ```

- **class 和 struct**

  > 1、上例我们使用了`class`而非`struct`**定义类**，这种变化只是**形式上有所不同**，可以**任意选择**。**唯一区别**是它们的**默认访问权限不一样**  
  > 2、类可以在它**第一个访问说明符前**定义成员，这种成员的**访问权限**依赖于**类定义的方式**  
  > 3、使用`struct`则这种成员**默认是**`public`的，而`class`这种成员**默认是**`private`的

- **友元**

  > 1、既然`Sales_data`的**数据成员**是`private`的，那么我们的`add`、`print`、`add`函数就**无法正常编译**了。这是因为这几个函数虽然**是类接口的一部分**，但**不是类的成员**  
  > 2、类可以允许**其他类或函数**访问它的**非公有成员**，方法是令它们成为该类的**友元**。对于函数，只需要增加一条`friend`**关键字**开头的**函数声明**即可  
  > 3、**友元声明**只能出现在**类定义内部**，但友元**不是类的成员**也**不受访问控制的约束**  
  > 4、**友元声明**仅仅指定了**访问权限**，而非一个通常意义上的**函数声明**。如果我们希望**类的用户**能够调用某个**友元函数**，就必须在**友元声明外**再次专门进行一次**函数声明**

  ```cpp
  friend Sales_data add(const Sales_data &, const Sales_data &);
  friend std::istream &read(std::istream &, Sales_data &);
  friend std::ostream &print(std::ostream &, const Sales_data &);
  ```

##### **类的其他特性**

- **类成员再探**

  - 为了展示这些新特性，我们需要定义**一对相互关联的类**：`Screen`和`Window_mgr`

  - **定义类型成员**

    > 1、假设`Screen`表示显示器中的**一个窗口**，该类中包含一个用于**保存内容**的`string`成员和分别用于表示**光标位置**、**屏幕的高和宽**的`string::size_type`成员  
    > 2、除了定义**数据和函数成员**外，类还可以**自定义某种类型**在类中的**别名**。这种**类型别名**与其他成员一样存在**访问限制**，可以是`public`或`private`的一种  
    > 3、如下我们在`public`部分定义了`pos`**别名**，这样用户就可以使用这个名字。`Screen`的用户不应该知道该类使用`string`**对象**来**存放数据**，因此通过把`pos`定义成`public`可以**隐藏**`Screen`的**实现细节**

    ```cpp
    class Screen
    {
        public:
            typedef std::string::size_type pos;

        private:
            pos cursor = 0;
            pos height = 0, width = 0;
            std::string contents;
    };
    ```

  - `Screen`**类的成员函数**

    ```cpp
    class Screen
    {
        public:
            typedef std::string::size_type pos;
            Screen() = default; // 默认构造函数
            Screen(pos ht, pos wd, char c)
                : height(ht), width(wd), contents(ht * wd, c) // 构造函数，cursor 会被类内初始值初始化为 0
            {
            }
            char get() const // 读取光标处的字符
            {
                return contents[cursor]; // 隐式内联
            }
            // 重载成员函数 get
            inline char get(pos ht, pos wd) const; // 显式内联
            Screen &move(pos r, pos c);            // 能在之后被设置为内联

        private:
            pos cursor = 0;
            pos height = 0, width = 0;
            std::string contents;
    };

    // 在类内声明为 inline
    char Screen::get(pos r, pos c) const
    {
        pos row = r * width;      // 计算行的位置
        return contents[row + c]; // 返回给定列的字符
    }
    // 在定义处指定 inline
    inline Screen &Screen::move(pos r, pos c)
    {
        pos row = r * width; // 计算行的位置
        cursor = row + c;    // 在行内将光标移动到指定列
        return *this;        // 以左值形式返回对象
    }
    ```

  - `mutable`**可变数据成员**

    > 1、有时我们希望能**修改类的某个数据成员**，即使是在一个`const`**成员函数**里，对此可以通过在**变量的声明**中加入`mutable`**关键字**声明一个**可变数据成员**  
    > 2、一个**可变数据成员**永远不会是`const`，即使它是`const`**对象的成员**。因此，一个`const`**成员函数**可以改变一个可变成员的值  
    > 3、例如，我们将给`Screen`添加一个**access_ctr 可变成员**，以跟纵成员函数被调用了多少次，如下例。尽管`some_member`是一个`const`**成员函数**，但依然可以改变**access_ctr**的值

    ```cpp
    public:
        void some_member() const
        {
            ++access_ctr; // 保存一个计数值，用于记录成员函数被调用的次数
        }

    private:
        mutable size_t access_ctr; // 即使在一个 const 对象内也能被修改
    ```

  - **类数据成员的初始值**

    > 1、定义好`Screen`后，我们将继续定义一个**窗口管理类**并用它来表示显示器上的**一组**`Screen`。这个类将包含一个`Screen`**类型的**`vector`，**每个元素**表示一个特定的`Screen`  
    > 2、默认情况下，我们希望`Window_mgr`类开始时总是**拥有一个默认初始化的**`Screen`。C++11 中，最好的办法是把这个**默认值**声明成一个**类内初始值**，由`Screen`的**构造函数初始化**

    ```cpp
    class Window_mgr
    {
        private:
            // 默认情况下，一个 Window_mgr 包含一个标准尺寸的空白 Screen，通过类内初始值和 Screen 的构造函数实现
            std::vector<Screen> screens{Screen(24, 80, ' ')};
    };
    ```

- **返回 \*this 的成员函数**

  - **继续改进**

    ```cpp
    class Screen
    {
        public:
            // 添加两个新的成员函数
            Screen &set(char);
            Screen &set(pos, pos, char);
    };

    inline Screen &Screen::set(char c)
    {
        contents[cursor] = c; // 设置当前光标所在位置的新值
        return *this;         // 将 this 作为左值返回
    }
    inline Screen &Screen::set(pos r, pos col, char ch)
    {
        contents[r * width + col] = ch; // 设置给定位置的新值
        return *this;                   // 将 this 作为左值返回
    }
    ```

  - **返回**`*this`**的意义**

    > 1、和`move`操作一样，`set`的**返回值**也是**调用**`set`**对象的引用**，意味着这些函数**返回的是对象本身**而不是**对象的副本**  
    > 2、如果我们把**一系列操作**连在**一条表达式**：`myScreen.move(4,0).set('#');`，这些操作将会**在同一个对象上执行**  
    > 3、更直观的，我们将这条**语句的含义拆解**，如下：

    ```cpp
    // 如果返回 Screen &，其等价于：
    myScreen.move(4,0);
    myScreen.set('#');

    // 如果返回 Screen，其等价于：
    Screen temp = myScreen.move(4,0);     // 对返回值进行拷贝
    temp.set('#');                        // 不会改变 myScreen 的 contents
    ```

  - **从**`const`**成员函数返回**`*this`

    > 1、下面我们要添加一个`display`**操作**，负责**打印**`Screen`**的内容**。我们希望这个函数能和`move`、`set`**出现在同一序列**，因此该函数也应该**返回它的对象的引用**  
    > 2、从逻辑上说，**显示**并不需要**改变对象内容**，因此我们令`display`是一个`const`成员。此时`this`将是一个**指向**`const`**的指针**，而`*this`就是`const`**对象**  
    > 3、由此推断，`display`的**返回类型**是`const Screen&`。然而，如果真的**返回一个**`const`**的引用**，那我们就**不能**将其**嵌入到一组动作的序列**里(如后示例)  
    > 4、即使**myScreen**是个**非常量对象**，对`set`的调用也**不能通过编译**。问题在于`display`的`const`版本返回了**常量引用**，我们无权`set`一个**常量对象**

    ```cpp
    Screen myScreen;
    // 如果 display 返回常量引用，set 将无权更改常量对象的数据，因而报错
    myScreen.display(cout).set('*');
    ```

  - **基于**`const`**的重载**

    > 1、通过区分**成员函数**是否是`const`的，我们可以对其**进行重载**，其原因主要如下  
    > 2、首先，**非常量版本**的函数对于**常量对象**是不可用的，所以我们只能在**常量对象**上调用`const`**成员函数**。其次，虽然可以在**非常量对象**上使用**常量版本**的函数，但显然此时**非常量版本**是一个**更好的匹配**  
    > 3、如下例，我们将声明一个`do_display`**私有成员**，用于负责打印。**所有的**`display`**操作**都将**调用这个函数**，然后**返回自己的类型的对象**  
    > 4、当`do_display`执行完成后，这**非常量版本**的`display`函数**返回普通引用**，而**常量版本**的`display`函数**返回常量引用**

    ```cpp
    class Screen
    {
        public:
            // 普通版本 display
            Screen &display(std::ostream &os)
            {
                do_display(os);
                return *this;
            }
            // const 版本 display
            const Screen &display(std::ostream &os) const
            {
                do_display(os);
                return *this;
            }

        private:
            void do_display(std::ostream &os) const
            {
                os << contents;
            }
    };
    ```

- **完整的 Screen 类**

  ```cpp
  #include <iostream>
  #include <string>
  #include <vector>

  class Screen
  {
      public:
          typedef std::string::size_type pos;

          Screen() = default; // 默认构造函数
          Screen(pos ht, pos wd, char c)
              : height(ht), width(wd), contents(ht * wd, c) // 构造函数，cursor 会被类内初始值初始化为 0
          {
          }

          char get() const // 读取光标处的字符
          {
              return contents[cursor]; // 隐式内联
          }
          inline char get(pos ht, pos wd) const; // 显式内联
          Screen &move(pos r, pos c);            // 能在之后被设置为内联

          void some_member() const
          {
              ++access_ctr; // 保存一个计数值，用于记录成员函数被调用的次数
          }

          Screen &set(char);
          Screen &set(pos, pos, char);

          // 普通版本 display
          Screen &display(std::ostream &os)
          {
              do_display(os);
              return *this;
          }
          // const 版本 display
          const Screen &display(std::ostream &os) const
          {
              do_display(os);
              return *this;
          }

      private:
          mutable size_t access_ctr; // 即使在一个 const 对象内也能被修改
          pos cursor = 0;
          pos height = 0, width = 0;
          std::string contents;

          void do_display(std::ostream &os) const
          {
              os << contents;
          }
  };

  // 在类内声明为 inline
  char Screen::get(pos r, pos c) const
  {
      pos row = r * width;      // 计算行的位置
      return contents[row + c]; // 返回给定列的字符
  }
  // 在定义处指定 inline
  inline Screen &Screen::move(pos r, pos c)
  {
      pos row = r * width; // 计算行的位置
      cursor = row + c;    // 在行内将光标移动到指定列
      return *this;        // 以左值形式返回对象
  }

  inline Screen &Screen::set(char c)
  {
      contents[cursor] = c; // 设置当前光标所在位置的新值
      return *this;         // 将 this 作为左值返回
  }
  inline Screen &Screen::set(pos r, pos col, char ch)
  {
      contents[r * width + col] = ch; // 设置给定位置的新值
      return *this;                   // 将 this 作为左值返回
  }
  ```

- **友元再探**

  - 先前我们的`Sales_data`类把三个普通的**非成员函数**定义成了**友元**，类还可以把**其他的类**定义成**友元**，还可以把**其他类的成员函数**定义成**友元**

  - **类之间的友元关系**

    > 1、假设我们的`Window_mgr`类的**某些成员**可能需要访问它管理的`Screen`类的**内部数据**。例如我们需要为`Window_mgr`添加一个**clear 成员**，用于把指定的`Screen`**内容设为空白**  
    > 2、此时**clear**需要访问`Screen`的**私有成员**，而要使这种**访问合法**，`Screen`需要把`Window_mgr`指定成它的**友元**  
    > 3、如果一个类指定了**友元类**，则**友元类**的**成员函数**可以访问此类包括**私有成员在内**的**所有成员**  
    > 4、需要注意的是，**友元关系不存在传递性**。即如果`Window_mgr`有它自己的友元，这些友元**不能理所当然地访问**`Screen`

    ```cpp
    class Screen
    {
        friend class Window_mgr;
        // 此处省略先前的类对象
    };

    class Window_mgr
    {
        public:
            // 窗口中每个屏幕的编号
            using ScreenIndex = std::vector<Screen>::size_type;
            // 按照编号将指定的 Screen 重置为空白
            void clear(ScreenIndex i)
            {
                // s 是一个 Screen 的引用，指向我们想清空的屏幕
                Screen &s = screens[i];
                s.contents = std::string(s.height * s.width, ' ');
            }

        private:
            std::vector<Screen> screens{Screen(24, 80, ' ')};
    };
    ```

  - **令函数成员作为友元**

    > 1、除了令**整个类**作为**友元**外，还可以**只为 clear 提供访问权限**。当把一个成员**函数声明**称友元时，必须**明确指出**成员函数**属于哪个类**  
    > 2、但要想令某个**成员函数**作为**友元**，必须要按照如下方式设计程序：  
    > 3、首先定义`Window_mgr`类，其中声明**clear**函数，但**不能定义**它。在**clear**使用`Screen`成员之前必须**先声明**`Screen`；接下来定义`Screen`，包含对于**clear**的友元声明；最后定义**clear**，此时它才可以使用`Screen`成员

    ```cpp
    class Screen
    {
        friend void Window_mgr::clear(ScreenIndex);
    }
    ```

  - **友元函数重载和作用域**

    > 1、尽管**重载函数**的名字相同，但它们仍是**不同的函数**。因此如果一个类想把**一组重载函数声明**成**友元**，则需要对每一个函数**分别声明**  
    > 2、**类**和**非成员函数**的**声明**不是必须在它们的**友元声明之前**，当一个名字**第一个出现**在一个**友元声明**中，我们**隐式假定该名字在当前作用域中可见**，然而友元本身不一定真的声明在当前作用域。甚至就算在**类内定义该函数**，我们也必须在**类外提供相应的声明**，从而使得**函数可见**  
    > 3、重点在于理解**友元声明本身的作用**是**影响访问权限**，而不是**普通意义上的声明**

    ```cpp
    struct X
    {
        // 友元函数可以定义在类内，但不是真正的定义
        friend void f();
        X()
        {
          f();      // 调用 f() 函数，错误：f 还没有被声明
        }
        void g();
        void h();
    };

    void X::g()
    {
        return f(); // 调用 f() 函数，错误：f 还没有被声明
    }
    void f();       // 声明定义在 X 中的函数 f，从此时 f 才被真正声明可用
    void X::h()
    {
        return f(); // 正确：现在 f 的声明在作用域中了
    }
    ```

##### **类的作用域**

- **类的作用域**

  - **引入**

    > 1、每个类都会定义**它自己的作用域**。在**类的作用域外**，**普通数据**和**函数成员**只能由对象、引用、指针使用**成员访问运算符**来访问；对于**类类型成员**则使用**作用域运算符**来访问  
    > 2、不论哪种情况，跟在**运算符后的名字**都必须是**对应类的成员**

    ```cpp
    Screen::pos ht = 24, wd = 80;   // 使用 Screen 定义的 pos 类型
    Screen scr(ht, wd, ' ');
    Screen *p = &scr;
    char c = scr.get();             // 访问 scr 对象的 get 成员
    c = p -> get();                 // 访问 p 所指向的 scr 的 get 成员
    ```

  - **作用域和定义在类外的成员**

    > 1、一个**类**就是一个**作用域**很好的说明了为什么我们在**类外定义成员函数**时需要提供`类名::函数名`。在类外，**成员的名字被隐藏了**  
    > 2、一旦遇到了**类名**，定义的**剩余部分**就在**类的作用域内**了，这里的剩余部分包括**参数列表**和**函数体**，因而我们可以**直接使用类的其他成员**而无须再次授权  
    > 3、`Window_mgr`类的**clear 成员**用到了**该类中定义的**`ScreenIndex`**类型**：`void Window_mgr::clear(ScreenIndex i);`。这里使用`ScreenIndex`时已经在**该类的作用域下**(因为在`Window_mgr::`后)，所以**不需要额外说明**  
    > 4、有时由于**返回类型**出现在**类名前**，此时想要使用`ScreenIndex`作为**返回类型**，必须明确**指定哪个类定义了它**，如下

    ```cpp
    // 作用域::返回类型 类名::函数名(形参列表)
    window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s)
    ```

- **名字查找与类作用域**

  - **用于类成员声明的名字查找**

    ```cpp
    typedef double Money;
    std::string bal;

    class Account
    {
        public:
            Money balance()
            {
                return bal;
            }

        private:
            Money bal;
    };
    ```

    > 1、**编译器**看到`balance`函数的声明语句时，将先在`Account`**类内查找 Money 的声明**，没找到就到**类外的作用域**去查找，找到**Money**的`typedef`语句  
    > 2、`balance`函数体由于在**整个类可见后**才被处理，因此其`return`语句返回**名为 bal 的成员**而不是外层的`string`对象

  - **类型名要特殊处理**

    ```cpp
    typedef double Money;

    class Account
    {
        public:
            Money balance()
            {
                return bal;             // 已经使用了外层作用域的 Money
            }

        private:
            typedef double Money;       // 错误：不能重新定义 Money
            Money bal;
    };
    ```

    > 1、一般来说，**内层作用域**可以重新定义**外层作用域**的名字，即使该名字已经在**内层作用域**中使用过  
    > 2、然而**在类中**，如果**成员使用了外层作用域中的名字**，而该名字**代表一种类型**，则类**不能在之后重新定义**该名字  
    > 3、尽管**重新定义类型名字**是一种错误的行为，但是**编译器并不为此负责**，一些编译器将顺利通过这样的代码

  - **成员定义中的普通块作用域的名字查找**

    ```cpp
    int height; // 定义了一个名字，稍后将在 Screen 中使用

    class Screen
    {
        public:
            typedef std::string::size_type pos;
            void dummy_fcn(pos height)
            {
                cursor = width * height; // 使用的是函数的形参 height
            }

        private:
            pos cursor = 0;
            pos height = 0, width = 0;
    };
    ```

    > 1、该例中，**编译器**处理函数中的**乘法表达式**时，它首先在**函数作用域**内查找名字，即先查找**形参列表**的**同名形参**。因此该例使用的是**形参 height**而非**成员 height**或**全局 height**  
    > 2、如果要在这种情况下单独使用**其他作用域的名字**，可以使用`::height`调用**全局 height**，使用`this -> height`或`Screen::height`调用**成员 height**

##### **构造函数再探**

- **委托构造函数**

  > 1、C++11 新标准拓展了**构造函数初始值**的功能，使得我们可以定义所谓的**委托构造函数**。一个**委托构造函数**，使用它**所属类的其他构造函数**执行它自己的初始化过程  
  > 2、和其他构造函数一样，一个**委托构造函数**也有一个**成员初始值列表**和一个**函数体**。与其他成员初始值一样，**类名后面**紧跟圆括号括起来的**参数列表**，**列表必须与类中另一个构造函数匹配**

  ```cpp
  class Sales_data
  {
      public:
          // 非委托构造函数使用对应的实参初始化成员
          Sales_data(std::string s, unsigned ct, double price) : bookNo(s), units_sold(ct), revenue(ct * price)
          {
          }
          // 其余构造函数全部委托给另一个构造函数
          Sales_data() : Sales_data("", 0, 0)
          {
          }
          Sales_data(std::string s) : Sales_data(s, 0, 0)
          {
          }
          Sales_data(std::istream &is) : Sales_data()
          {
              read(is, *this); // 之前上文类中定义过的函数
          }

      private:
          std::string bookNo;
          unsigned units_sold = 0;
          double revenue = 0.0;
  };
  ```

- **隐式类类型转换**

  - **介绍**

    > 1、在类中，如果**构造函数**只接受**一个实参**，则它实际上定义了**转换为此类类型**的**隐式转换机制**，有时我们把这种构造函数称为**转换构造函数**  
    > 2、在先前的`Sales_data`类中，接受`string`的和接受`istream`的**构造函数**分别定义了**这两种类型向**`Sales_data`**隐式转换**的规则。也就是说，在需要使用`Sales_data`的地方，可以使用`string`或`istream`**代替**  
    > 3、如下例，我们用一个`string`**实参**调用了`combine`**成员函数**。该调用合法，**编译器**用给定的`string`自动创建了一个**临时**`Sales_data`**对象**，这个新生成的**临时对象**被传递给了`combine`

    ```cpp
    std::string null_book = "9-999-99999-9";
    // 构造一个临时的 Sales_data 对象，该对象的 units_sold 和 revenue 都为 0，bookNo 等于 null_book
    item.combine(null_book);
    ```

  - **只允许一步类类型转换**

    > 1、**编译器**只会自动地**执行一步类型转换**，因此下面代码隐式使用了**两种转换规则**是错误的  
    > 2、如果我们想完成上述调用，可以主动进行一步**显式转换**，如后例

    ```cpp
    // 错误：需要用户定义的两种转换，但编译器只转换一次
    // 1 把 字符串字面量 转换成 string
    // 2 把 string 转换成 Sales_data
    item.combine("9-999-99999-9");
    ```

    ```cpp
    // 正确：显式转换成 string，隐式转换成 Sales_data
    item.combine(string("9-999-99999-9"));
    // 正确：隐式转换成 string，显式转换成 Sales_data
    item.combine(Sales_data("9-999-99999-9"));
    ```

  - `explicit`**抑制构造函数隐式转换**

    > 1、我们可以通过将只有一个实参的**构造函数**声明为`explicit`来**阻止隐式转换**(多个实参的构造函数不能用于执行隐式转换，所以无须指定)，此时将**不能通过**指定了`explicit`的**构造函数**来**隐式创建类对象**  
    > 2、**只能在类内声明构造函数时**使用`explicit`，在类外定义时不应重复  
    > 3、`explicit`**构造函数**只能用于**直接初始化**，当我们执行**拷贝初始化**(`=`)不能使用`explicit`构造函数

    ```cpp
    class Sales_data
    {
        public:
            explicit Sales_data(std::istream&): bookNo(s)
            {
            }
    };
    // 错误：类外定义时不要重复使用 explicit
    explicit Sales_data::Sales_data(std::istream &is)
    {
        read(is, *this);
    }
    // 错误：不能使用拷贝初始化
    Sales_data item = null_book;
    ```

- **聚合类**

  > 1、**聚合类**使得用户可以**直接访问其成员**，当一个类满足**如下条件**时，我们说它是**聚合**的：  
  > 2、**所有成员**都是`public`的；没有定义任何**构造函数**；没有**类内初始值**；没有**基类**，也没有`virtual`**函数**(这部分后续介绍)  
  > 3、我们可以提供一个**花括号括起来**的**成员初始值列表**来初始化聚合类的**数据成员**，顺序必须与声明的顺序一致

- **字面值常量类**

  - **介绍**

    > 1、之前我们提到过`constexpr`**函数**的**参数**和**返回值**都必须是**字面值类型**。除了算数类型、引用、指针外，**某些类也是字面值类型**  
    > 2、和其他类不同，这样的类可能含有`constexpr`**构造函数**，这样的成员必须**符合**`constexpr`**函数的所有要求**，它们是**隐式**`const`的  
    > 3、**数据成员都是字面值类型**的**聚合类**都是**字面值常量类**，此外，如果一个类满足**以下要求**，也是一个**字面值常量类**：  
    > 4、**数据成员**都必须是**字面值类型**；类必须包含**至少一个**`constexpr`**函数**；数据成员的**类内初始值**必须是**常量表达式**，如果成员属于某种类类型，**初始值**必须使用成员自己的`constexpr`**构造函数**；类必须使用**析构函数**的**默认定义**，该成员负责销毁类的对象

  - `constexpr`**构造函数**

    > 1、`constexpr`**构造函数**可以声明成`=default`。否则，该函数就必须既满足**构造函数的要求**(不包含返回语句)，又满足`constexpr`**函数的要求**(唯一可执行的语句就是返回语句)  
    > 2、综合这两点，`constexpr`**构造函数体**一般来说是**空的**  
    > 3、`constexpr`**构造函数**必须**初始化所有数据成员**，**初始值**要么使用`constexpr`**构造函数**，要么是**一条常量表达式**

    ```cpp
    class Debug
    {
        public:
            constexpr Debug(bool b = true) : hw(b), io(b), other(b)
            {
            }
            constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o)
            {
            }
            constexpr bool any()
            {
                return hw || io || other;
            }

        private:
            bool hw;
            bool io;
            bool other;
    };
    ```

##### **类的静态成员**

- **引入**

  > 1、有的时候类需要它的**一些成员**与**类本身**直接相关，而不是与类的**各个对象**保持关联  
  > 2、例如，一个**银行账户类**可能需要一个**数据成员**来表示当前的**基准利率**，我们希望**利率与类关联**，没必要**每个对象**都**存储利率信息**  
  > 3、一旦利率浮动，我们希望**所有的对象**都能**使用新值**

- **声明静态成员**

  > 1、我们通过在**成员的声明前**加上关键字`static`使其**与类关联在一起**。下例为我们模拟实现的银行账户类  
  > 2、**静态成员**存在于任何对象之外，对象中**不包含**任何**与数据成员有关**的数据  
  > 3、**静态成员函数**也**不与任何对象绑定**在一起，它们**不包含**`this`**指针**，且静态成员函数**不能声明成**`const`

  ```cpp
  class Account
  {
      public:
          void calculate()
          {
              amount += amount * interesRate;
          }
          static double rate()
          {
              return interesRate;
          }
          static void rate(double);

      private:
          std::string owner;
          double amount;
          static double interesRate;
          static double initRate();
  };
  ```

- **使用静态成员**

  ```cpp
  // 使用作用域运算符直接访问静态成员
  double r;
  r = Account::rate();

  // 使用类的对象、引用或指针来访问静态成员
  Account ac1;
  Account *ac2 = &ac1;
  r = ac1.rate();
  r = ac2 -> rate();

  // 成员函数不通过作用域运算符就能直接使用静态成员
  class Account
  {
      public:
          void calculate()
          {
              ammout += amount * interestRate;    // 直接使用
          }
      private:
          static double interestRate;
  };
  ```

- **定义静态成员**

  > 1、和其他**成员函数**一样，我们在**类内和类外**都可以定义**静态成员函数**。当在**类外定义时**，不要重复`static`关键字  
  > 2、因为**静态数据成员**不属于类的任何一个对象，所以它们并不是在**创建类的时候**被定义的，这意味着它们**不是由构造函数初始化的**  
  > 3、我们**不能在类内初始化静态成员**，相反，我们必须**在类外定义和初始化**每个静态成员

  ```cpp
  // 类外定义静态成员函数
  void Account::rate(double newRate)
  {
      interestRate = newRate;
  }

  // 定义并初始化一个静态成员
  double Account::interestRate = initRate();
  ```

- **静态成员的类内初始化**

  > 1、通常情况下，类的**静态成员**不应该在类内初始化  
  > 2、然而，我们可以为**静态成员**提供`const`**整型**的**类内初始值**，不过要求**静态成员**必须是**字面值常量类型**的`constexpr`  
  > 3、如果在**类内提供了一个初始值**，则静态成员的定义**不能再指定一个初始值**

  ```cpp
  class Account
  {
      public:
          static double rate()
          {
              return interestRate;
          }
          static void rate(double);

      private:
          static constexpr int period = 30; // period 是常量表达式
          double daily_tbl[period];
  };
  ```

- **静态成员与普通成员的区别**

  > 1、**静态成员**能用于**某些场景**，而**普通成员不能**。静态成员**独立于任何对象**，因此，在某些**普通成员可能非法**的场合，**静态成员**可以**正常使用**。比如**静态数据成员**可以是**不完全类型**(后续介绍)  
  > 2、特别的，**静态数据成员的类型**可以是它**所属的类类型**，而**普通成员**只能声明成它**所属类的指针或引用**  
  > 3、此外，我们可以使用**静态成员**作为**默认实参**，而**普通成员不能**，这是因为**普通成员的值**本身**属于对象的一部分**

---

#### **IO 库**

---

<div class="success">

> **章节概要**：`IO`类；`IO`库类型；`IO`类型间的关系；`IO`对象；无拷贝或赋值；条件状态；查询流的状态；管理条件状态；管理输出缓冲；缓冲刷新的原因；刷新输出缓冲区；`unitbuf`操作符；`tie`关联输入和输出流；文件输入输出；`fstream`操作；`fstream`对象；`open`和`close`；文件模式；指定文件模式的限制；阻止丢弃已有数据；`string`流；`stringstream`操作；使用`istringstream`；使用`ostringstream`

</div>

##### **IO 类**

- **IO 库类型**

  > 1、目前为止，我们已使用过的`IO`**类型和对象**都是操纵**char**数据的。但现实场景下，我们不能限制**实际应用程序**仅从**控制台窗口**进行**IO 操作**  
  > 2、**应用程序**常常需要**读写命名文件**，而且使用`IO`**操作**处理`string`中的字符很方便。此外，还可能读写**需要宽字符支持的语言**  
  > 3、为了支持这些不同种类的**IO 操作**，在`istream`和`ostream`之外，**标准库**还定义了其他一些`IO`**库类型**，下表列出其中部分  
  > 4、`iostream`定义了用于**读写流的基本类型**；`fstream`定义了**读写命名文件的类型**；`sstream`定义了**读写内存**`string`**对象的类型**  
  > 5、为了支持**使用宽字符的语言**，标准库定义了一组类型和对象来**操纵**`wchat_t`**类型数据**。宽字符版本的**类型和函数名**以`w`开头，如`wcin`、`wcout`、`wcerr`等

  | 头文件   | 类型                          | 描述               |
  | -------- | ----------------------------- | ------------------ |
  | iostream | istream，wistream             | 从流中读取数据     |
  | iostream | ostream，wostream             | 向流中写入数据     |
  | iostream | iostream，wiostream           | 读写流             |
  | fstream  | ifstream，wifstream           | 从文件读取数据     |
  | fstream  | ofstream，wofstream           | 向文件写入数据     |
  | fstream  | fstream，wfstream             | 读写文件           |
  | sstream  | istringstream，wistringstream | 从`string`读取数据 |
  | sstream  | ostringstream，wostringstream | 向`string`写入数据 |
  | sstream  | stringstream，wstringstream   | 读写`string`       |

- **IO 类型间的关系**

  > 1、概念上，**设备类型**和**字符大小**都不会影响我们要执行的**IO 操作**。比如我们可以使用`>>`**读取数据**，却**不必管**是从控制台，磁盘文件，或是`string`中读取；也**不必管**读取的字符能存入一个**char 对象**内，还是需要一个`wchar_t`**对象**  
  > 2、**标准库**使我们能**忽略**这些**不同类型流之间的差异**，是通过**继承机制**实现的。我们可以使用**具有继承关系的类**，而不必了解**继承机制如何工作**的细节  
  > 3、简单地说，**继承机制**使我们可以声明一个**特定的类**继承自**另一个类**。我们通常可以将一个**派生类对象**(继承类对象)当做其**基类对象**(被继承的类对象)来使用  
  > 4、比如，`ifstream`和`istringstream`都**继承自**`istream`。因此，我们可以像**使用**`istream`**对象**那样，**使用**`ifstream`和`istringstream`**对象**。这意味着，我们如何使用`cin`的，就可以**同样使用这些类型的对象**

- **IO 对象**

  - **无拷贝或赋值**

    > 1、我们**不能拷贝**或**对**`IO`**对象赋值**  
    > 2、由于**不能拷贝**，因此我们不能将**形参**或**返回类型**设置为**流类型**。进行**IO 操作**的**函数**通常**以引用的方式传递和返回流**  
    > 3、由于**读写一个 IO 对象**会**改变其状态**，所以**传递和返回的引用**也不能是`const`的

    ```cpp
    #include <fstream>

    std::ofstream out1, out2;
    out1 = out2;                          // 错误：不能对流对象赋值
    std::ofstream print(std::ofstream);   // 错误：不能初始化 ofstream 参数
    out2 = print(out2);                   // 错误：不能拷贝流对象
    ```

  - **条件状态**

    > 1、**IO 操作**一个与生俱来的问题是**可能发生错误**。一些错误是**可恢复的**，而其他错误**可能发生在系统深处**，已经超出了应用程序**可修正的范围**  
    > 2、下表列出了`IO`**类**所定义的一些**函数和标志**，可以帮助我们**访问和操纵**流的**条件状态**

    | 函数和标志       | 描述                                                                                              |
    | ---------------- | ------------------------------------------------------------------------------------------------- |
    | strm::iostate    | 是一种机器相关的类型，提供了表达条件状态的完整功能                                                |
    | strm::badbit     | 用来指出流已崩溃                                                                                  |
    | strm::failbit    | 用来指出一个 IO 操作失败了                                                                        |
    | strm::eofbit     | 用来指出流到达了文件结束                                                                          |
    | strm::goodbit    | 用来指出流未处于错误状态，此值保证为 0                                                            |
    | s.eof()          | 若流 s 的 eofbit 置位，则返回 true                                                                |
    | s.fail()         | 若流 s 的 failbit 或 badbit 置位，则返回 true                                                     |
    | s.bad()          | 如流 s 的 badbit 置位，则返回 true                                                                |
    | s.good()         | 若流 s 处于有效状态，则返回 true                                                                  |
    | s.clear()        | 将流 s 中所有条件状态位复位，将流的状态设置为有效，返回 void                                      |
    | s.clear(flag)    | 根据给定的 flag 标志位，将流 s 中对应条件状态位复位，其中 flag 的类型为`strm::iostate`，返回 void |
    | s.setstate(flag) | 根据给定的 flag 标志位，将流 s 中对应条件状态位置位，其中 flag 的类型为`strm::iostate`，返回 void |
    | s.rdstate()      | 返回流 s 的当前条件状态，返回值类型为`strm::iostate`                                              |

  - **查询流的状态**

    > 1、`IO`**库**定义了**与机器无关的**`iostate`**类型**，它提供了**表达流状态的完整功能**，该类型应作为一个**位集合**来使用  
    > 2、该类型包含如上表中的**四个**`constexpr`**值**，这些值用来表示**特定类型的 IO 条件**，可以与**位运算符**一起使用来**一次性检测或设置多个标志位**  
    > 3、`badbit`表示**系统级错误**，如不可恢复的读写操作，通常如果`badbit`**被置位**，流就**无法再使用**了；`failbit`在发生**可恢复错误**后**被置位**，如读取类型不对应等错误，通常这种问题是可修正的，流**还可以继续使用**；如果到达**文件结束位置**，`eofbit`和`failbit`**都会被置位**；`goodbit`**值为 0**表示**流未发生错误**  
    > 4、同样，如上表所列，**标准库**还定义了一组函数来**查询标志位的状态**

  - **管理条件状态**

    > 1、如上表，**标准库**中还有一些用来**管理条件状态**的函数  
    > 2、**流对象的成员**`rdstate`返回一个`iostate`**值**，对应**当前流的状态**；`setstate`操作将给定的**条件位置位**，表示发生了对应错误；`clear`是一个**重载成员函数**，它分别有一个**不接受参数**的版本和**接受一个**`iostate`**参数**的版本，用于将**条件位复位**

    ```cpp
    auto old_state = cin.rdstate(); // 记住 cin 的当前状态
    cin.clear();                    // 复位，使 cin 有效
    process_input(cin);             // 使用 cin
    cin.setstate(old_state);        // 将 cin 置为原有状态
    ```

- **管理输出缓冲**

  - 每个**输出流**都管理一个**缓冲区**，用来保存**程序读写的数据**。如果需要**打印一串文本**，**文本串**可能会**立即打印**出来，也可能被操作系统**保存在缓冲区中**，之后**再打印**

  - **缓冲刷新的原因**

    > 1、程序**正常结束**，作为`main`函数的`return`**操作的一部分**，**缓冲刷新**被执行  
    > 2、**缓冲区满时**，需要**刷新缓冲**，而后新的数据才能继续写入缓冲区  
    > 3、我们可以使用**操纵符**(如`endl`)来**显式刷新缓冲区**  
    > 4、在每个**输出操作之后**，我们可以用**操纵符**`unitbuf`**设置流的内部状态**，来**清空缓冲区**。默认情况下，对`cerr`是设置`unitbuf`的，因此**写到**`cerr`**的内容**都是**立即刷新**的  
    > 5、一个**输出流**可能**被关联到另一个流**，这种情况下，当读写**被关联的流**时，**关联到的流**的**缓冲区会被刷新**。例如默认情况下，`cin`和`cerr`都关联到`cout`，因此，读`cin`或写`cerr`都会导致`cout`**的缓冲区被刷新**

  - **刷新输出缓冲区**

    > 1、我们已经使用过**操纵符**`endl`，它完成**换行并刷新缓冲区**的工作  
    > 2、`IO`**库**中还有两个**类似的操纵符**：`flush`和`ends`。其中`flush`**只刷新缓冲区**，不输出任何额外字符；`ends`向缓冲区**插入一个空字符**，然后**刷新缓冲区**

    ```cpp
    cout << "hi!" << endl;
    cout << "hi!" << flush;
    cout << "hi!" << ends;
    ```

  - `unitbuf`**操作符**

    > 1、如果想在接下来**每次输出操作后**都**刷新缓冲区**，我们可以使用`unitbuf`**操纵符**  
    > 2、它告诉**流**在接下来的**每次写操作之后**都**执行一次**`flush`**操作**  
    > 3、而使用`nounitbuf`可以**重置流**，使其恢复使用正常的**系统管理**的**缓冲区刷新机制**

    ```cpp
    cout << unitbuf;        // 此后所有输出操作后都会立即刷新缓冲区
    cout << nounitbuf;      // 此后回到正常的缓冲机制
    ```

  - `tie`**关联输入和输出流**

    > 1、当一个**输入流**被**关联到**一个**输出流**时，任何试图**从输入流读取数据**的操作将会导致**关联的输出流被刷新**  
    > 2、`tie`有**两个重载的版本**。**不带参数**的`tie`返回**指向输出流的指针**。如果本对象当前关联到一个**输出流**，则返回的就是**这个流的指针**；如果对象**未关联**到其他流，则返回**空指针**  
    > 3、接受一个**指向**`ostream`**的指针**作为**参数**的`tie`，**将自己关联到此**`ostream`。即`x.tie(&o)`返回**指向原输出流的指针**，并将**流**`x`关联到**新输出流**`o`  
    > 4、我们既可以将`istream`**关联到**`ostream`，也可以将`ostream`**关联到**`ostream`。**每个流**同时最多**关联到一个流**，但**多个流**可以同时关联到**同一个**`ostream`

    ```cpp
    cin.tie(&cout);                       // 将 cin 和 cout 关联在一起
    // old_tie 指向当前关联到 cin 的流(如果有的话)
    ostream *old_tie = cin.tie(nullptr);  // cin 不再与其他流关联
    // 将 cin 和 cerr 关联，这不是一个好主意，因为 cin 应该关联到 cout
    cin.tie(&cerr);                       // 读取 cin 会刷新 cerr 而不是 cout
    cin.tie(old_tie);                     // 重建 cin 和 cout 间的正常关联
    ```

##### **文件输入输出**

- `fstream`**操作**

  > 1、**头文件**`fstream`定义了**三个类型**来支持**文件 IO**：`ifstream`、`ofstream`、`fstream`，这些类型**提供的操作**与我们之前是用过的对象`cin`和`cout`**操作一样**  
  > 2、特别是，我们可以用`IO`**运算符**(流插入符`<<`和`>>`)来**读写文件**，可以用`getline`从一个`ifstream`**读取数据**  
  > 3、除了**继承自**`iostream`**类型**的行为外，`fstream`还增加了一些新成员来**管理与流关联的文件**，如下表

  | fstream 操作           | 描述                                                                                                                                                             |
  | ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | fstream fstrm          | 创建一个未绑定的文件流，此处的 fstream 是头文件 fstream 中定义的一个类型                                                                                         |
  | fstream fstrm(s)       | 创建一个 fstream，并打开名为 s 的文件。s 可以是 string 类型或指向字符数组形式字符串的指针。这些构造函数都是 explicit 的，默认文件模式 mode 依赖于 fstream 的类型 |
  | fstream fstrm(s, mode) | 与前一个构造函数类似，但按照指定模式 mode 打开文件                                                                                                               |
  | fstrm.open(s)          | 打开名为 s 的文件，并将文件与 fstrm 绑定，返回 void。默认文件模式 mode 依赖于 fstream 的类型                                                                     |
  | fstrm.close()          | 关闭与 fstrm 绑定的文件，返回 void                                                                                                                               |
  | fstrm.is_open()        | 返回一个 bool 值，指出与 fstrm 关联的文件是否成功打开且尚未关闭                                                                                                  |

- `fstream`**对象**

  - **创建对象**

    > 1、当我们想要**读写一个文件**时，可以定义一个**文件流对象**，并**将对象与文件关联起来**  
    > 2、每个文件流都定义了一个名为`open`的**成员函数**，它完成一些系统相关的操作，来**定位给定的文件**，并视情况打开为**读或写模式**  
    > 3、创建**文件流对象**时，可以**直接提供文件名**(可选)，如果直接提供了文件名，则`open`**会被自动调用**

    ```cpp
    ifstream in(ifile);         // 构造一个 ifstream 并打开 ifile 文件
    ofstream out;               // 输出文件流未关联到任何文件
    ```

  - **可以用**`fstream`**替代**`iostream&`

    > 1、之前提到过，在要求使用**基类类型对象**的地方，我们可以使用**继承类型对象**来**替代**  
    > 2、这意味着，接受一个`iostream`**类型引用或指针**的参数的函数，也可以用一个对应的`fstream`或`sstream`**类型**来**调用**

  - `open`**和**`close`

    > 1、如果我们定义了一个**空文件流对象**，可以随后**调用**`open`来**将它与文件关联**起来，如下示例  
    > 2、如果**调用**`open`**失败**，`failbit`将被置位。由于**调用可能失败**，所以使用类似`if(out)`的方式**进行检测**是好习惯  
    > 3、一旦一个**文件流已经打开**，它就会一直**保持关联**。如果对一个**已打开的文件流**调用`open`**会失败**，并会导致`failbit`被置位，随后试图**使用该文件流**的操作**都会失败**  
    > 4、为了**将文件流关联到另一个文件**，必须先`close`**关闭已关联的文件**，成功关闭后才可以**打开新的文件**。如果`open`成功，则`open`会**设置流的状态**，使得`good()`为**true**

    ```cpp
    ifstream in(ifile);         // 构造一个 ifstream 并打开 ifile 文件
    ofstream out;               // 输出文件流未关联到任何文件
    out.open(ifile + ".copy");  // 打开指定文件

    in.close();                 // 关闭文件
    in.open(ifile + "2");       // 打开另一个文件
    ```

- **文件模式**

  - **文件模式**

    > 1、每个流都有一个**关联的文件模式**，用来指出**如何使用文件**，如下表  
    > 2、无论用哪种方法打开文件(调用`open`或文件名初始化流等)，都可以**指定文件模式**  
    > 3、默认情况下，`ifstream`以`in`打开，`ofstream`以`out`打开，`fstream`以`in`和`out`打开

    | 文件模式 | 含义                               |
    | :------: | ---------------------------------- |
    |    in    | 只读(输入)模式                     |
    |   out    | 只写(输出)模式                     |
    |   app    | 只写，每次写操作前均定位到文件末尾 |
    |   ate    | 打开文件后立刻定位到文件末尾       |
    |  trunc   | 阶段文件                           |
    |  binary  | 二进制模式                         |

  - **指定文件模式的限制**

    > 1、只可以对`ofstream`或`fstream`设定`out`模式  
    > 2、只可以对`ifstream`或`fstream`设定`in`模式  
    > 3、只有当`out`**被设定时**才能设定`trunc`模式  
    > 4、只要`trunc`**没被设定**，就可以设定`app`模式  
    > 5、默认情况下，即使我们**没有设定**`trunc`，以`out`打开的文件**也会被阶段**。为了**保留以**`out`**打开的文件的内容**，我们必须**同时指定**`app`模式，这样只会将数据**追加到文件末尾**；或者**同时指定**`in`模式，即**打开文件同时进行读写操作**  
    > 6、`ate`和`binary`可用于**任何类型**的文件流对象，且可以与其他任何类型模式**组合使用**

  - **阻止丢弃已有数据**

    > 1、默认情况下，当我们**打开一个**`ofstream`时，**文件的内容会被丢弃**  
    > 2、**阻止清空**`ostream`**给定文件**的方式是**同时指定**`app`**模式**

    ```cpp
    // 下列语句中，file 都会被截断
    ofstream out1("file");
    ofstream out2("file", ofstream::out);
    ofstream out3("file", ofstream::out | ofstream::trunc);
    // 下列语句，通过 app 保留了文件内容
    ofstream app1("file", ofstream::app);
    ofstream app2("file", ofstream::out | ofstream::app);
    ```

##### **string 流**

- `stringstream`**操作**

  > 1、**头文件**`sstream`定义了**三个类型**来支持**内存 IO**：`istringstream`、`ostringstream`、`stringstream`  
  > 2、与`fstream`类似，`sstream`**定义的类型**也都**继承自**`iostream`  
  > 3、除了**继承**得来的操作，`sstream`还定义了一些成员来**管理与流相关联的**`string`，如下表

  | stringstream 操作 | 描述                                                                             |
  | ----------------- | -------------------------------------------------------------------------------- |
  | sstream strm      | 创建一个未绑定的 stringstream 对象，此处的 sstream 是头文件 sstream 中的一个类型 |
  | sstream strm(s)   | 创建一个 sstream，保存字符串 s 的一个拷贝。此构造函数是 explicit 的              |
  | strm.str()        | 返回 strm 保存的 string 的拷贝                                                   |
  | strm.str(s)       | 将字符串 s 拷贝到 strm 中，返回 void                                             |

- **使用**`istringstream`

  - 当我们的某些工作是**对整行文本进行处理**，而其他一些工作是**处理行内的单个单词**，通常可以使用`istringstream`(在理解上，可以认为该类型对象类似于一个单独的`string`输入缓冲区)

  - **示例**

    > 1、假定有一个文件，列出了一些人和他们的电话号码，某些人只有**一个号码**，另一些人有**多个号码**，文件中每条记录都**以人名开始**，后面跟随**一个或多个电话号码**，不同记录之间换行。通过程序实现这些内容的存储  
    > 2、我们在程序中使用一个`istringstream`**与读入的文本行绑定**，这样就可以在**该类型对象**上使用**输入运算符**`>>`来**读取每个元素**

    ```cpp
    #include <iostream>
    #include <sstream>
    #include <string>
    #include <vector>

    struct PersonInfo
    {
        public:
            std::string name;
            std::vector<std::string> phones;
    };

    int main()
    {
        std::string line, word;         // 分别保存来自输入的一行和单词
        std::vector<PersonInfo> people; // 保存来自输入的所有记录
        // 逐行从输入读取数据
        while (std::getline(std::cin, line))
        {
            PersonInfo info;                 // 创建一个保存此记录数据的对象
            std::istringstream record(line); // 将记录绑定到刚读入的行
            record >> info.name;             // 读取名字(到空格停止)
            while (record >> word)           // 读取电话号码(到空格停止并再次循环)
                info.phones.push_back(word); // 保持它们
            people.push_back(info);          // 将此记录追加到 people 末尾
        }
        return 0;
    }
    ```

- **使用**`ostringstream`

  - 当我们**逐步构造输出**，希望**最后一起打印**时，`ostringstream`是很有用的(在理解上，可以认为该类型对象类似于一个单独的`string`输出缓冲区)

  - **示例**

    > 1、假定对于`istringstream`的上例，我们想**逐个验证电话**再**改变其格式**输出，对于有无效号码的人，我们不会将其输出，而是打印一条包含**人名和无效号码**的**错误信息**。通过程序实现这些内容的格式化与转存  
    > 2、由于我们**不希望输出有无效号码的人**，因此对每个人，直到**验证完所有号码**才能进行输出。这种情况下，我们可以将输出内容先写入到一个`ostringstream`中更加方便

    ```cpp
    #include <iostream>
    #include <sstream>
    #include <string>
    #include <vector>

    struct PersonInfo
    {
        public:
            std::string name;
            std::vector<std::string> phones;
    };

    int main()
    {
        std::string line, word;         // 分别保存来自输入的一行和单词
        std::vector<PersonInfo> people; // 保存来自输入的所有记录
        // 逐行从输入读取数据
        while (std::getline(std::cin, line))
        {
            PersonInfo info;                 // 创建一个保存此记录数据的对象
            std::istringstream record(line); // 将记录绑定到刚读入的行
            record >> info.name;             // 读取名字
            while (record >> word)           // 读取电话号码
                info.phones.push_back(word); // 保持它们
            people.push_back(info);          // 将此记录追加到 people 末尾
        }

        // 假定已有两个函数：
        // valid() 完成电话号码验证；format() 完成格式化
        for (const auto &entry : people) // 对于 people 的每一项
        {
            std::ostringstream formatted, badNums; // 每个循环创建的对象
            for (const auto &nums : entry.phones)  // 对每个数
            {
                if (!valid(nums))                     // 如果无效
                    badNums << " " << nums;           // 将数的字符存入 badNums
                else                                  // 如果有效
                    formatted << " " << format(nums); // 进行格式化
            }
            if (badNums.str().empty()) // 如果没有错误的数，打印名字和格式化的数
                std::cout << entry.name << " " << formatted.str() << std::endl;
            else // 如果有错误，打印错误信息
                std::cerr << "input error: " << entry.name << " invalid number(s): " << badNums.str() << std::endl;
        }
        return 0;
    }
    ```

---

#### **顺序容器**

---

<div class="success">

> **章节概要**：顺序容器概述；顺序容器类型；选择容器；容器库概览；容器操作；迭代器范围；容器类型成员；`begin`和`end`成员；容器定义与初始化；`assign`和`swap`；顺序容器操作；添加元素；添加元素的操作；使用`insert`添加元素；使用`insert`的返回值；使用`emplace`；访问元素；删除元素；特殊的`forward_list`操作；改变容器大小；有关迭代器失效；`vector`对象如何增长；操作原理描述；管理容量的成员函数；额外的`string`操作；构造`string`的其他方法；其他构造函数；`substr`操作；改变`string`的其他方法；特殊版本函数；`append`和`replace`函数；`string`搜索操作；`compare`函数；数值转换；容器适配器；适配器类型；定义适配器；栈适配器；队列适配器

</div>

##### **顺序容器概述**

- **顺序容器类型**

  > 1、下表中列出了**标准库**中的**顺序容器**，其中大部分类型都提供**高效灵活的内存管理**，我们可以**添加删除元素**、**扩张收缩容器大小**  
  > 2、容器**保存元素的策略**对**容器操作**有着**固有且重大的影响**。某些情况下，**存储策略**还会影响特定容器**是否支持特定操作**  
  > 3、`forward_list`和`array`是**C++新标准**增加的类型。与**内置数组**相比，`array`是一种**更安全易用**的数组类型  
  > 4、**新标准库的容器**比旧版本**快得多**，其性能几乎与**最精心优化过**的**同类数据结构**一样好，甚至过之  
  > 5、现代**C++程序**应该尽可能多使用**标准库容器**，而不是像**内置数组**这样的**原始数据结构**

  | 顺序容器类型 | 描述                                                                   |
  | ------------ | ---------------------------------------------------------------------- |
  | vector       | 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 |
  | deque        | 双端队列，支持快速随机访问，在头尾插入删除速度很快                     |
  | list         | 双向链表，只支持双向顺序访问，在任何位置插入删除速度都很快             |
  | forward_list | 单向链表，只支持单向顺序访问，在任何位置插入删除速度都很快             |
  | array        | 固定大小数组，支持快速随机访问，不能添加删除元素                       |
  | string       | 与 vector 类似，专门用来保存字符，随机访问快，尾部插入删除速度快       |

- **选择容器**

  > 1、通常，使用`vector`是**最好的选择**，除非你有**很好的理由**选择其他容器  
  > 2、如果你的程序有**很多小的元素**，且**空间的额外开销**很重要，则不要使用`list`或`forward_list`  
  > 3、如果程序要求**随机访问元素**，应使用`vector`或`deque`  
  > 4、如果程序要求**在容器的中间插入或删除**元素，应使用`list`或`forward_list`  
  > 5、如果程序需要**在头尾插入或删除**元素，但不会在中间插入或删除，则使用`deque`  
  > 6、如果程序只在**输入时**才**在容器中间位置插入**元素，随后需要**随机访问元素**，则最好在**输入阶段**使用`list`，完成后**拷贝到**`vector`(但最好确定是否真的一定要在中间位置插入元素，大多情况可以输入到`vector`再通过`sort`函数排序)

##### **容器库概览**

- 一般来说，每个**容器**都定义在一个**头文件**中，**头文件名与类型名相同**

- **容器操作**

  - **类型别名**

    | 类型别名        | 描述                                                   |
    | --------------- | ------------------------------------------------------ |
    | iterator        | 此容器类型的迭代器类型                                 |
    | const_iterator  | 可以读取元素但不能修改元素的迭代器类型                 |
    | size_type       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
    | difference_type | 带符号整数类型，足够保存两个迭代器之间的距离           |
    | value_type      | 元素类型                                               |
    | reference       | 元素的左值类型，与 value_type&含义相同                 |
    | const_reference | 元素的 const 左值类型，即 cosnt value_type&            |

  - **构造函数**

    | 构造函数       | 描述                                                                 |
    | -------------- | -------------------------------------------------------------------- |
    | C c            | 默认构造函数，构造空容器                                             |
    | C c1(c2)       | 构造 c2 的拷贝 c1                                                    |
    | C c(b,e)       | 构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c，但不适用于 array |
    | C c{a,b,c,...} | 列表初始化 c                                                         |

  - **赋值和 swap**(assign 不适用于关联容器和 array)

    | 赋值和 swap      | 描述                                                                                |
    | ---------------- | ----------------------------------------------------------------------------------- |
    | c1 = c2          | 将 c1 的元素替换为 c2 的元素                                                        |
    | c1 = {a,b,c,...} | 将 c1 的元素替换为列表中的元素，但不适用于 array                                    |
    | a.swap(b)        | 交换 a 和 b 的元素                                                                  |
    | swap(a,b)        | 交换 a 和 b 的元素                                                                  |
    | seq.assign(b,e)  | 将 seq 中的元素替换为迭代器 b 和 e 所表示范围中的元素，b 和 e 不能指向 seq 中的元素 |
    | seq.assign(il)   | 将 seq 中的元素替换为初始化列表 il 中的元素                                         |
    | seq.assign(n,t)  | 将 seq 中的元素替换为 n 个值为 t 的元素                                             |

  - **大小**

    | 大小         | 描述                                  |
    | ------------ | ------------------------------------- |
    | c.size()     | c 中元素的数目，但不支持 forward_list |
    | c.max_size() | c 可保存的最大元素数目                |
    | c.empty()    | 若 c 为空，返回 true，否则返回 false  |

  - **增删元素**(不适用于 array，且在不同容器中这些操作的接口都不同)

    | 增删元素         | 描述                           |
    | ---------------- | ------------------------------ |
    | c.insert(args)   | 将 args 中的元素拷贝进 c       |
    | c.emplace(inits) | 使用 inits 构造 c 中的一个元素 |
    | c.erase(args)    | 删除 args 指定的元素           |
    | c.clear()        | 删除 c 中所有元素，返回 void   |

  - **关系运算符**

    | 关系运算符   | 描述                           |
    | ------------ | ------------------------------ |
    | ==，!=       | 所有容器都支持相等和不等运算符 |
    | <，<=，>，>= | 关系运算符，无序关联容器不支持 |

  - **获取迭代器**

    | 获取迭代器           | 描述                                        |
    | -------------------- | ------------------------------------------- |
    | c.begin()，c.end()   | 返回指向 c 的首元素与尾元素之后位置的迭代器 |
    | c.cbegin()，c.cend() | 返回 const_interator                        |

  - **反向容器的额外成员**(不支持 forward_list)

    | 反向容器的额外成员      | 描述                                        |
    | ----------------------- | ------------------------------------------- |
    | reverse_iterator        | 按逆序寻址元素的迭代器                      |
    | const_reverse_interator | 不能修改元素的逆序迭代器                    |
    | c.rbegin()，c.rend()    | 返回指向 c 的尾元素与首元素之前位置的迭代器 |
    | c.crbegin()，c.crend()  | 返回 const_reverse_interator                |

- **迭代器范围**

  > 1、一个**迭代器范围**由一对迭代器表示，**两个迭代器**分别指向**同一个容器**中的**元素位置**或**尾元素之后位置**，这**两个迭代器**通常被称为**begin**和**end**  
  > 2、这种元素范围被称为**左闭合区间**，数学描述为`[begin, end)`，表示**自 begin 开始**，**于 end 前结束**  
  > 3、标准库使用**左闭合范围**是因为这种范围有**三种方便的特性**，假定**begin**和**end**构成合法的迭代器范围，则有：  
  > 4、如果**begin**和**end**相等，则范围为空；如果**begin**和**end**不等，则范围至少包含一个元素，且**begin**指向首元素；我们可以对**begin**递增若干次，使`begin==end`，过程中进行迭代

- **容器类型成员**

  > 1、每个容器都定义了**多个类型**，我们已经使用过**其中三种**：`size_type`、`iterator`、`const_iterator`  
  > 2、除了已经使用过的**迭代器类型**，大多容器还提供**反向迭代器**，简单说，**反向迭代器**就是一种**反向遍历容器**的迭代器  
  > 3、剩下还有一些**类型别名**，通过别名我们可以在**不了解容器中元素类型**的情况下**使用它**。比如**元素类型**`value_type`；**元素类型引用**`reference`或`const_reference`

- **begin 和 end 成员**

  > 1、`begin`和`end`**操作**生成指向容器**首元素位置**和**尾后位置**的迭代器，这两个迭代器**最常见的用途**是形成一个**包含容器所有元素**的**迭代器范围**  
  > 2、`begin`和`end`有**多个版本**，带`r`的版本(`rbegin`)返回**反向迭代器**，带`c`的版本(`cbegin`)返回`const`**迭代器**，二者可叠加(`crbegin`)

- **容器定义与初始化**

  - **将一个容器初始化为另一个容器的拷贝**

    > 1、将一个**新容器**创建为**另一个容器的拷贝**有两种方法：可以**直接拷贝整个容器**，或者可以拷贝由一个**迭代器对指定的元素范围**  
    > 2、为了创建一个**容器**为**另一个容器的拷贝**(即第一种方法)，两个**容器的类型**及其**元素的类型**必须匹配  
    > 3、而使用**迭代器对**(即第二种方法)本质上是**拷贝迭代器指向的数据**，就不要求**容器类型相同**了，但**元素类型**需要**能转换成相应的类型**

  - `array`**具有固定大小**

    > 1、与**内置数组**一样，`array`**的大小**也是**类型的一部分**，即定义一个`array`时，除了指定**元素类型**，还要指定**容器大小**：`array<int, 42>`、`array<int, 42>::size_type`  
    > 2、由于**大小**是`array`**类型的一部分**，所以`array`不支持**普通的容器构造函数**，`array`**大小固定**的特性也影响了它所定义的**构造函数的行为**  
    > 3、一个**默认构造**的`array`是**非空**的，它包含**与其大小一样多的元素**，这些**元素**都被**默认初始化**  
    > 4、虽然我们不能对**内置数组**进行**拷贝**或**对象赋值操作**，但对于`array`来说**并无此限制**

- **assign 和 swap**

  - **使用**`assgin`(仅顺序容器)

    > 1、使用**赋值运算符**赋值要求左边和右边的**运算对象类型相同**，而**除**`array`**外的顺序容器**还定义了一个`assign`**成员函数**，允许我们从**不同但相容的类型**赋值，或从**容器的一个子序列**赋值  
    > 2、`assign`操作用**迭代器参数**所**指定的元素**替换**左边容器的所有元素**，比如我们可以用`assign`实现将`vector`**中的一段**`char*`赋值给一个`list`**中的**`string`，如下例

    ```cpp
    list<string> names;
    vector<const char*> oldstyle;
    names = oldstyle;                                   // 错误：容器类型不匹配
    names.assign(oldstyle.cbegin(), oldstyle.cend());   // 正确：可以将 const char* 转换成 string
    ```

  - **使用**`swap`

    > 1、`swap`操作**交换两个相同类型容器**的**内存**，调用`swap`后，两个容器中的**元素将会交换**  
    > 2、除`array`外，`swap`**不对任何元素**进行**拷贝**、**删除**、**插入**操作，**不会真正移动元素**，因此可以保证在`O(1)`**常数时间**内完成；而`array`会**真正交换它们的元素**，因此所需时间是`O(n)`**级别**的  
    > 3、**元素不会被移动**意味着除`string`外，指向容器的**迭代器**、**引用**、**指针**在`swap`**之后不会失效**，它们仍**指向**`swap`**之前所指向的那些元素**，只是`swap`之后这些元素已经**属于不同的容器**了(即`swap`前指向`vec1[3]`，`swap`后指向`vec2[3]`，而`vec2`实际就是交换前的`vec1`)。不同的是，对一个`string`调用`swap`会导致**迭代器**、**引用**、**指针失效**

##### **顺序容器操作**

- **添加元素**

  - **添加元素的操作**

    > 1、除`array`外，所有**标准库容器**都提供**灵活的内存管理**，在运行时可以**动态添加或删除元素**来**改变容器大小**，如下表  
    > 2、这些操作**会改变容器大小**，因此`array`**不支持这些操作**  
    > 3、`forward_list`有自己**专有版本的**`insert`和`emplace`，且**不支持**`push_back`和`emplace_back`  
    > 4、`vector`和`string`**不支持**`push_front`和`emplace_front`

    | 添加元素的操作                         | 描述                                                                                                                                                  |
    | -------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
    | c.push_back(t)，c.emplace_back(args)   | 在 c 的尾部创建一个值为 t 或由 args 创建的元素，返回 void                                                                                             |
    | c.push_front(t)，c.emplace_front(args) | 在 c 的头部创建一个值为 t 或由 args 创建的元素，返回 void                                                                                             |
    | c.insert(p,t)，c.emplace(p,args)       | 在迭代器 p 指向的元素之前创建一个值为 t 或由 args 创建的元素，返回指向新添加元素的迭代器                                                              |
    | c.insert(p,n,t)                        | 在迭代器 p 指向的元素之前插入 n 个值为 t 的元素，返回指向新添加的第一个元素的迭代器                                                                   |
    | c.insert(p,b,e)                        | 将迭代器 b 和 e 指定的范围内的元素插入到迭代器 p 指向的元素之前，b 和 e 不能指向 c 中的元素，返回指向新添加的第一个元素的迭代器，若范围为空，则返回 p |
    | c.insert(p,il)                         | il 是一个花括号包裹的元素值列表列表，将这些给定值插入到迭代器 p 指向的元素之前，返回指向新添加的第一个元素的迭代器，若列表为空，则返回 p              |

  - **使用**`insert`**添加元素**

    > 1、`push_back`和`push_front`操作能够快捷**添加元素**到**容器头尾**，而`insert`允许我们在容器**任意位置插入元素**  
    > 2、每个`insert`**函数**都接受一个**迭代器**作为**第一个参数**，指出在容器**什么位置放置新元素**，它可以指向容器**任何位置**，包括**尾后位置**，`insert`会将元素**插入到这个位置之前**  
    > 3、虽然某些容器**不支持**`push_front`，但对`insert`操作**插入开始位置并无限制**，因此我们可以将元素**插入到容器开始位置**，而不必关心容器是否支持`push_front`，但这样操作需要**注意运行效率**  
    > 4、此外`insert`还可以**接受更多参数**来**添加多个相同值**或**添加一个迭代器范围内的值**，使用方法见上表格

    ```cpp
    vector<string> svec;
    list<string> slist;

    // 等价于调用 slist.push_front("Hello!");
    slist.insert(slist.begin(), "Hello!");

    // vector 不支持 push_front，但可以 insert 到 begin() 之前
    // 警告：插入到 vector 末尾之外的任何位置都可能很慢
    svec.insert(svec.begin(), "Hello!");
    ```

  - **使用**`insert`**的返回值**

    > 1、`insert`返回**指向新添加的第一个元素**的**迭代器**  
    > 2、通过使用`insert`的返回值，可以在容器中一个**特定位置反复插入元素**，如下例

    ```cpp
    string word;
    list<string> lst;
    auto iter = lst.begin();
    while(cin >> word)
        iter = list.insert(iter, word);   // 每次执行后 iter 都赋值为返回值，即每次 iter 都指向开头位置
    ```

  - **使用**`emplace`

    > 1、**新标准**引入了**三个新成员**：`emplace_front`、`emplace`、`emplace_back`，这些操作将会**构造元素**(而不是拷贝元素)，分别对应`push_front`、`insert`、`push_back`  
    > 2、当调用`push`或`insert`**成员函数**时，我们将**元素类型的对象**传递给它们，这些**对象**被**拷贝到容器中**。而当我们调用`emplace`时，则是将**参数**传递给**元素类型的构造函数**，`emplace`使用这些参数在**容器管理的内存空间中**直接**构造元素**  
    > 3、`emplace`函数在容器中**直接构造元素**，所以传递给`emplace`函数的**参数**必须与**元素类型的构造函数**相匹配

- **访问元素**

  > 1、下表列出了**顺序容器**中**访问元素**的**操作**，如果容器**没有元素**，则访问操作是**未定义的**  
  > 2、`at`和**下标操作**只适用于`string`、`vector`、`deque`、`array`，此外`back`不适用于`forward_list`  
  > 3、此外，使用时有一些注意事项，如下示例

  | 访问元素的操作 | 描述                                                                                 |
  | -------------- | ------------------------------------------------------------------------------------ |
  | c.back()       | 返回 c 中尾元素的引用                                                                |
  | c.front()      | 返回 c 中首元素的引用                                                                |
  | c[n]           | 返回 c 中下标为 n 的元素的引用，n 是一个无符号整数。如 n>=c.size()，则函数行为未定义 |
  | c.at(n)        | 返回 c 中下标为 n 的元素的引用。如果下标越界，则抛出一个`out_of_range`异常           |

  ```cpp
  // 在解引用一个迭代器或调用 front 或 back 之前检查是否有元素
  if(!c.empty())
  {
      // val1 和 val2 是 c 中第一个元素值的拷贝
      auto val1 = *c.begin();   // 解引用迭代器
      auto val2 = c.front();    // front 获取首元素的引用
      // val3 和 val4 是 c 中最后一个元素值的拷贝(但此处操作对 forward_list 不适用)
      auto last = c.end();      // 注意迭代器指向尾后位置
      auto val3 = *(--last);    // 注意不能递减 forward_list
      auto val4 = c.back();     // forward_list 不支持
  }
  ```

- **删除元素**

  > 1、与**添加元素**的操作类似，非`array`的容器也有多种**删除元素**的方式，如下表。需要注意，删除元素的函数**不检查其参数**，程序员必须**确保待删除的元素存在**  
  > 2、这些操作**会改变容器大小**，所以**不适用于**`array`  
  > 3、`forward_list`有**特殊版本的**`erase`，且**不支持**`pop_back`  
  > 4、`vector`和`string`**不支持**`pop_front`

  | 删除元素的操作 | 描述                                                                                                                    |
  | -------------- | ----------------------------------------------------------------------------------------------------------------------- |
  | c.pop_back()   | 删除 c 中尾元素，函数返回 void                                                                                          |
  | c.pop_front()  | 删除 c 中首元素，函数返回 void                                                                                          |
  | c.erase(p)     | 删除迭代器 p 所指定的元素，返回一个指向被删除元素之后元素的迭代器。若 p 是尾后迭代器，则函数行为未定义                  |
  | c.erase(b,e)   | 删除迭代器 b 和 e 所指范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器。若 e 本身是尾后迭代器，返回尾后迭代器 |
  | c.clear()      | 删除 c 中所有元素，返回 void                                                                                            |

- **特殊的 forward_list 操作**

  - **单向链表的操作**

    > 1、为了理解`forward_list`为什么有**特殊版本**的**添加和删除操作**，考虑当我们从一个**单向链表**删除一个元素会发生什么。当**删除一个元素**时，会**改变序列中的链接**，如**删除**`elem3`会**改变**`elem2`**指向**`elem4`  
    > 2、当**添加或删除一个元素**时，**该元素之前的元素**的**后继**会**发生改变**。为了执行这一操作，我们需要**访问其前驱**，以**改变前驱的链接**。但是`forward_list`是**单向链表**，没有简单的办法**获取一个元素的前驱**  
    > 3、由于这个原因，在一个`forward_list`中的**增删操作**是通过**改变给定元素后的元素**来完成的，这样，我们总是可以访问到**被增删操作所影响的元素**

  - `forward_list`**增删操作**

    > 1、由于`forward_list`**操作**与**其他容器上的操作**的**实现方式不同**，所以定义了**一套特殊的函数**，如下表  
    > 2、为了**支持这些操作**，`forward_list`也定义了`before_begin`，它是一个**首前迭代器**，它将允许我们在**链表首元素之前**的不存在的元素**之后**执行**增删操作**

    | forward_list 增删操作                                                                           | 描述                                                                                                                                                                                                                                      |
    | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | lst.before_begin()，lst.cbefore_begin()                                                         | 返回指向链表首前元素的迭代器，此迭代器不能解引用。cbefore_begin 返回一个 const_iterator                                                                                                                                                   |
    | lst.insert_after(p,t)，lst.insert_after(p,n,t)，lst.insert_after(p,b,e)，lst.insert_after(p,il) | 在迭代器 p 之后的位置插入元素。t 是一个对象，n 是数量，b 和 e 是表示范围的一对迭代器(但不能指向 lst 内)，il 是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果 b 和 e 的范围为空，则返回 p。若 p 为尾后迭代器，则函数行为未定义 |
    | emplace_after(p,args)                                                                           | 使用 args 在 p 指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数行为未定义                                                                                                                            |
    | lst.erase_after(p)，lst.erase_after(b,e)                                                        | 删除 p 指向的位置之后的元素，或删除[b,e)之间的元素。返回一个指向被删元素之后元素的迭代器或尾后迭代器。如果 p 指向 lst 的尾元素或是一个尾后迭代器，则函数行为未定义                                                                        |

  - **示例程序**

    ```cpp
    forward_list<int> flst = {0,1,2,3,4,5,6,7,8,9};
    auto prev = flst.before_begin();        // 表示 flst 的首前元素
    auto curr = flst.begin();               // 表示 flst 的第一个元素
    while(curr != flst.end())               // 表示仍有元素要处理
    {
        if(*curr % 2)                       // 若元素为奇数
            curr = flst.erase_after(prev);  // 删除它并移动 curr
        else
        {
            prev = curr;                    // prev 指向 curr，即移动 prev 指向了下一个元素
            ++curr;                         // 移动迭代器 curr，指向 curr 下一个元素
        }
    }
    ```

- **改变容器大小**

  > 1、下标列出了**改变容器大小的操作**，但**不适用于**`array`  
  > 2、注意：如果`resize`**缩小容器**，则**指向被删除元素**的**迭代器**、**引用**、**指针**都会**失效**；对`vector`、`string`、`deque`进行`resize`可能导致**迭代器**、**指针**、**引用失效**

  | 改变容器大小的操作 | 描述                                                                                                    |
  | ------------------ | ------------------------------------------------------------------------------------------------------- |
  | c.resize(n)        | 调整 c 的大小为 n 个元素，如 n < c.size()，则多出的元素被丢弃；若必须添加新元素，则对新元素进行值初始化 |
  | c.resize(n,t)      | 调整 c 的大小为 n 个元素，任何新添加的元素都初始化值为 t                                                |

  ```cpp
  list<int> ilist(10, 42);      // 10 个 int，每个的值都是 42
  ilist.resize(15);             // 再将 5 个值为 0 的元素添加到 ilist 的末尾
  ilist.resize(25, -1);         // 再将 10 个值为 -1 的元素添加到 ilist 的末尾
  ilist.resize(5);              // 再从 ilist 末尾删除 20 个元素
  ```

- **有关迭代器失效**

  - **迭代器失效**

    > 1、向**容器**中**添加元素**和**删除元素**的操作可能使**指向容器元素**的**指针**、**引用**、**迭代器失效**  
    > 2、一个**失效的指针**、**引用**、**迭代器**将**不再表示任何元素**，使用它们是一种**严重的程序设计错误**，可能引起与**使用未初始化指针一样的问题**  
    > 3、有关**迭代器失效**的具体说明如下

  - **向容器添加元素时**

    > 1、如果**容器**是`vector`或`string`，且**存储空间被重新分配**，则**上述三者都会失效**；如果**存储空间未重新分配**，则**指向插入位置之前**的**三者仍然有效**，但**指向插入位置之后**的**三者将失效**  
    > 2、对于`deque`，插入到**除首尾位置之外**的任何位置都会**导致三者失效**；如果**在首尾插入元素**，**迭代器会失效**，但**指针引用不会失效**  
    > 3、对于`list`和`forward_list`，指向容器的**三者仍然有效**

  - **从容器删除元素时**

    > 1、对于`vector`和`string`，指向**被删元素之前**元素的**三者仍然有效**，**之后部分**的**三者将失效**  
    > 2、对于`deque`，如果在**首尾之外**的任何位置**删除元素**，那么**指向被删除元素外**的其他元素的**三者也会失效**；如果**删除尾元素**，则**尾后迭代器也会失效**，**其他位置三者不受影响**；如果**删除首元素**，**三者也不会受影响**  
    > 3、对于`list`和`forward_list`，**指向容器其他位置**的**三者仍然有效**  
    > 4、注意，当我们**删除元素时**，**被删除元素**的**三者一定失效**，**尾后迭代器**也**一定失效**

  - **编写改变容器的循环程序**

    > 1、**添加删除**`vector`、`string`、`deque`元素的**循环程序**必须考虑**上述三者可能失效**的问题。程序必须保证**每个循环步中**都**更新三者**  
    > 2、如果循环中**调用的是**`insert`或`erase`，那么**更新迭代器很容易**，我们可以利用**这些操作**的**返回值**来更新，如下示例

    ```cpp
    vector<int> vi = {0,1,2,3,4,5,6,7,8,9};
    auto iter = vi.begin();
    while(iter != vi.end())
    {
        if(*iter % 2)
        {
            iter = vi.insert(iter, *iter);    // 复制当前元素
            iter += 2;                        // 向前移动迭代器，跳过当前元素以及插入到它之前的元素
        }
        else
            iter = vi.erase(iter);            // 删除偶数元素
            // 不应向前移动迭代器，iter 指向我们删除的元素之后的元素
    }
    ```

  - **不要保存**`end`**返回的迭代器**

    > 1、当我们在`vector`、`string`或在`deque`**首元素之外**的任何位置**增删元素**时，原来`end`返回的**迭代器总是会失效的**  
    > 2、因此，**增删元素**的循环程序必须**反复调用**`end`，而**不能在循环之前保存**`end`**返回的迭代器**来**一直当做容器末尾使用**  
    > 3、通常**C++标准库**的实现中`end()`**都很快**，部分原因就是因为**需要经常反复调用**

##### **vector 对象如何增长**

- **操作原理描述**

  > 1、为了支持**快速随机访问**，`vector`将元素**连续存储**(每个元素紧挨着前一个元素存储)。通常情况下，我们**不关心**一个**标准库类型如何实现**，**只需要关心**它**如何使用**。然而对于`vector`和`string`，其**部分实现渗透到了接口上**  
  > 2、假定容器中**元素是连续存储的**，且**容器大小可变**，考虑向`vector`或`string`**添加元素**会发生什么：如果**没有空间容纳新元素**，容器**不可能**简单将它**添加到内存中其他位置**，因为**元素必须连续存储**  
  > 3、假如如此，容器必须**分配新的内存空间**来**保存已有元素和新元素**，将**已有元素移动到新空间**，然后**添加新元素**，再**释放旧空间**。如果我们**每添加一个新元素**就执行一次这样的操作，性能会**慢到不可接受**  
  > 4、为了**避免这种代价**，**标准库实现者**采用了可以**减少容器空间重新分配次数**的策略。当不得不重新**获取新的空间**时，`vector`和`string`通常会分配**比新的空间需求更大的空间**。容器预留这些空间**作为备用**，可用来**保存更多新元素**，并**减少重新分配次数**

- **管理容量的成员函数**

  > 1、`vector`和`string`类型提供了一些**成员函数**，它们允许我们**与实现中内存分配的部分互动**，如下表  
  > 2、`shrink_to_fit`只适用于`vector`、`string`、`deque`。新标准中可以使用`shrink_to_fit`要求容器**退回不需要的内存空间**，但具体的实现**可以选择忽略此请求**  
  > 3、`capacity`和`reserve`只适用于`vector`和`string`。注意`reserve`并**不改变元素的数量**，它**仅影响预先分配多大的内存**

  | 容器大小管理操作  | 描述                                               |
  | ----------------- | -------------------------------------------------- |
  | c.shrink_to_fit() | 将 capacity() 减少为与 size() 相同大小             |
  | c.capacity()      | 返回不重新分配内存空间的情况下，c 还能保存多少元素 |
  | c.reserve(n)      | 分配至少能容纳 n 个元素的内存空间                  |

##### **额外的 string 操作**

- **构造 string 的其他方法**

  - **其他构造函数**

    > 1、除了之前介绍过的**构造函数**，以及**与其他顺序容器相同**的**构造函数**，`string`还支持**另外三个构造函数**，如下表  
    > 2、**n**、**len2**、**pos2**都是**无符号值**

    | string 构造函数        | 描述                                                                                                                                         |
    | ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
    | string s(cp,n)         | s 是 cp 指向数组中前 n 个字符的拷贝。此数组应至少包含 n 个字符                                                                               |
    | string s(s2,pos2)      | s 是 string s2 从下标 pos2 开始的字符的拷贝。若 pos2>s2.size()，则行为未定义                                                                 |
    | string s(s2,pos2,len2) | s 是 string s2 从下标 pos2 开始 len2 个字符的拷贝。若 pos2>s2.size()，则行为未定义。不管 len2 值是多少，函数至多拷贝 s2.size() - pos2 个字符 |

  - `substr`**操作**

    > 1、`s.substr(pos,n)`：返回一个`string`，包含**s**中从**pos**开始的**n**个字符的拷贝。**pos**默认为**0**，**n**默认为`s.size() - pos`，即所有字符  
    > 2、`substr`**返回一个**`string`，它是原始`string`的**一部分或全部**的**拷贝**，可以传递给`substr`一个**可选的开始位置**、**计数值**作为参数  
    > 3、如果**开始位置**超过了`string`**大小**，则会抛出一个`out_of_range`**异常**；如果**开始位置+计数值**大于`string`**大小**，则函数会**自动调整计数值**，只拷贝到`string`**末尾**

    ```cpp
    string s("hello world");
    string s2 = s.substr(0, 5);   // hello
    string s3 = s.substr(6);      // world
    string s4 = s.substr(6,11);   // 自动调整 11，拷贝到末尾，world
    string s5 = s.substr(12);     // 抛出 out_of_range 异常
    ```

- **改变 string 的其他方法**

  - **特殊版本函数**

    > 1、`string`**类型支持**顺序容器的**赋值运算符**、`assign`、`insert`、`erase`操作。此外它还定义了**这些函数**的一些**特殊版本**  
    > 2、除了**接受迭代器**的`insert`和`erase`外，`string`还提供了**接受下标的版本**，如后例  
    > 3、**标准库**`string`还提供了**接受 C 风格字符数组**的`insert`和`assign`，如后例

    | 修改 string 的操作 | 描述                                                                                                                                         |
    | ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------- |
    | s.insert(pos,args) | 在 pos 之前插入 args 指定的字符。pos 可以是一个下标或迭代器。接受下标的版本返回指向 s 的引用；接受迭代器的版本返回指向第一个插入字符的迭代器 |
    | s.erase(pos,len)   | 删除从 pos 开始的 len 个字符。如果 len 被省略，则删除 pos 开始直至末尾的所有字符。返回指向 s 的引用                                          |
    | s.assign(args)     | 将 s 中的字符替换为 args 指定的字符。返回指向 s 的引用                                                                                       |

    ```cpp
    s.insert(s.size(), 5, '!');   // 在 s 末尾插入 5 个 !
    s.erase(s.size() - 5, 5);     // 从 s 删除最后的 5 个字符

    const char *cp = "Stately, plump Buck";
    s.assign(cp, 7);              // 调用 assign 替换 s 的内容为 "Stately"
    s.insert(s.size(), cp + 7);   // s = "Stately, plump duck";
    ```

  - `append`**和**`replace`**函数**

    > 1、`string`**类**定义了两个额外的**成员函数**：`append`和`replace`，这两个函数可以**改变**`string`**内容**，如下表  
    > 2、`append`是在`string`**末尾**进行**插入操作**的一种简写；`replace`是**调用**`erase`**和**`insert`的一种简写

    | 修改 string 的操作    | 描述                                                                                                                               |
    | --------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
    | s.append(args)        | 将 args 追加到 s。返回指向 s 的引用                                                                                                |
    | s.replace(range,args) | 删除 s 中范围 range 内的字符，替换为 args 指定的字符。range 或者是一个下标和一个长度，或者是一对指向 s 的迭代器。返回指向 s 的引用 |

- **string 搜索操作**

  > 1、`string`**类**提供了一些**6 种搜索函数**，每种都有**4 种重载函数**，下表中描述了这些成员函数及其参数  
  > 2、每个**搜索操作**都返回一个`string::size_type`**值**，表示**匹配发生位置的下标**。如果**搜索失败**，则返回一个名为`string::npos`的`static`**成员**  
  > 3、**标准库**将`string::npos`**定义为**`const string::size_type`**类型**，并**初始化为-1**。由于**npos**是`unsigned`**类型**，**初始值-1**意味着**npos**等于**任何**`string`**最大的可能大小**

  | string 搜索操作           | 描述                                              |
  | ------------------------- | ------------------------------------------------- |
  | s.find(args)              | 查找 s 中 args 第一次出现的位置                   |
  | s.rfind(args)             | 查找 s 中 args 最后一次出现的位置                 |
  | s.find_first_of(args)     | 在 s 中查找 args 中任何一个字符第一次出现的位置   |
  | s.find_last_of(args)      | 在 s 中查找 args 中任何一个字符最后一次出现的位置 |
  | s.find_first_not_of(args) | 在 s 中查找第一个不在 args 中的字符               |
  | s.find_first_not_of(args) | 在 s 中查找最后一个不在 args 中的字符             |

  | args 的重载形式 | 描述                                                                       |
  | --------------- | -------------------------------------------------------------------------- |
  | c,pos           | 从 s 中位置 pos 开始查找字符 c 。pos 默认为 0                              |
  | s2,pos          | 从 s 中位置 pos 开始查找字符串 s2 。pos 默认为 0                           |
  | cp,pos          | 从 s 中位置 pos 开始查找指针 cp 指向的 C 风格字符串。pos 默认为 0          |
  | cp,pos,n        | 从 s 中位置 pos 开始查找指针 cp 指向的数组的前 n 个字符。pos 和 n 无默认值 |

- `compare`**函数**

  > 1、除了**关系运算符**外，**标准库**`string`还提供了一组`compare`**函数**，其与**C 标准库**的`strcmp`**很相似**，如下表  
  > 2、类似`strcmp`，根据**s**是**等于**、**大于**、**小于**参数指定的字符串，`s.compare`**分别返回 0**、**正数**、**负数**

  | compare 函数                  | 描述                                                                    |
  | ----------------------------- | ----------------------------------------------------------------------- |
  | s.compare(s2)                 | 比较 s 和 s2                                                            |
  | s.compare(pos1,n1,s2)         | 将 s 中从 pos1 开始的 n1 个字符与 s2 进行比较                           |
  | s.compare(pos1,n1,s2,pos2,n2) | 将 s 中从 pos1 开始的 n1 个字符与 s2 中从 pos2 开始的 n2 个字符进行比较 |
  | s.compare(cp)                 | 比较 s 与 cp 指向的 C 风格字符串                                        |
  | s.compare(pos1,n1,cp)         | 将 s 中从 pos1 开始的 n1 个字符与 cp 指向的 C 风格字符串进行比较        |
  | s.compare(pos1,n1,cp,pos2)    | 将 s 中从 pos1 开始的 n1 个字符与 cp 指向的地址开始的 n2 个字符进行比较 |

- **数值转换**

  > 1、**字符串**中常常包含**表示数值的字符**，有时我们需要将其**转换为数值**。**新标准**引入了**多个函数**，可以实现**数值数据与**`string`**之间的转换**，如下表  
  > 2、`string`**参数中第一个非空白符**必须是**正负符号或数字**，它可以**以 0x 或 0X 开头**表示**十六进制数**；对那些将**字符串**转换成**浮点值**的函数，参数还可以**以小数点开头**，并可以**包含 e 或 E**表示**指数部分**；对那些将**字符串**转换为**整型值**的函数，根据**基数不同**，`string`参数还可以包含**字母字符**对于**大于数字 9 的数**  
  > 3、如果`string`**不能转换**为**一个数值**，函数会抛出`invalid_argument`**异常**；如果**转换得到的数值**不能用**任何类型表示**，函数会抛出`out_of_range`**异常**

  | 数值转换函数                                                        | 描述                                                                                                                                                                                                                                   |
  | ------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | to_string(val)                                                      | 一组重载函数，返回数值 val 的 string 表示                                                                                                                                                                                              |
  | stoi(s,p,b)，stol(s,p,b)，stoul(s,p,b)，stoll(s,p,b)，stoull(s,p,b) | 返回 s 的起始子串(表示整数内容)的数值，返回值类型对应函数名 sto 后的类型名缩写，如 i 为 int，ul 为 unsigned long。b 表示转换所用的基数(进制)，默认为 10。p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标，默认为 0，即不保存下标 |
  | stof(s,p)，stod(s,p)，stold(s,p)                                    | 返回 s 的起始子串(表示浮点数内容)的数值，返回值类型对应函数名 sto 后的类型名缩写。p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标，默认为 0，即不保存下标                                                                        |

  ```cpp
  string s2 = "pi = 3.14";
  // 转换 s 中以数字开始的第一个子串，结果 d = 3.14
  // 先使用 find_first_of 找到数值部分，再用 substr 截取子串，再用 stod 转换
  double d = stod(s2.substr(s2.find_first_of("+-.0123456789")));
  ```

##### **容器适配器**

- **适配器类型**

  > 1、除了**顺序容器**外，**标准库**还定义了三个**顺序容器适配器**：`stack`、`queue`、`priority_queue`，此外下表列出了它们支持的操作  
  > 2、**适配器**是**标准库**中的一个**通用概念**，**容器**、**迭代器**、**函数**都有**适配器**。本质上，一个**适配器**是一种**机制**，能使**某种事物的行为**看起来像**另外一种事物**一样  
  > 3、一个**容器适配器**接受一种**已有的容器类型**，使其**行为看起来像**一种**不同的类型**。例如`stack`接受一个**顺序容器**，使其操作看起来像一个`stack`

  | 适配器操作           | 描述                                           |
  | -------------------- | ---------------------------------------------- |
  | size_type            | 一种类型，足以保存当前类型的最大对象的大小     |
  | value_type           | 元素类型                                       |
  | container_type       | 实现适配器的底层容器类型                       |
  | A a;                 | 创建一个名为 a 的空适配器                      |
  | A a(c)               | 创建一个名为 a 的适配器，带有容器 c 的一个拷贝 |
  | 关系运算符           | 每个适配器都支持所有关系运算符                 |
  | a.empty()            | 若 a 为空，则返回 true，否则返回 false         |
  | a.size()             | 返回 a 中的元素数目                            |
  | a.swap(b)，swap(a,b) | 交换 a 和 b 的内容，a 和 b                     |

- **定义适配器**

  > 1、每个**适配器**都定义了**两个构造函数**：**默认构造函数**创建一个**空对象**，**接受一个容器**的构造函数**拷贝该容器**来**初始化适配器**  
  > 2、默认情况下，`stack`和`queue`是**基于**`deque`**实现的**，`priority_queue`是**基于**`vector`**实现的**。我们可以在**创建适配器时**将一个**命名的顺序容器**作为**第二个类型参数**，来**重载默认容器类型**  
  > 3、对于一个**给定的适配器**，可以使用**哪些容器**是有限制的。**所有适配器**都要求容器具有**增删元素**和**访问尾元素**的能力，因此**不能构造在**`array`和`forward_list`上；此外`queue`**不能构造在**`vector`上，`priority_queue`**不能构造在**`list`上

  ```cpp
  stack<int> stk(deq);                            // 从 deq 拷贝元素到 stk

  stack<string, vector<string>> str_stk;          // 在 vector 上实现的空栈
  stack<string, vector<string>> str_stk2(svec);   // 在 vector 上实现，初始化时保存 svec 的拷贝
  ```

- **栈适配器**

  > 1、`stack`**类型**定义在`stack`**头文件**中，下表列出了**栈特有的操作**，并举出了一个示例  
  > 2、**栈**默认基于`deque`实现，也可以在`list`或`vector`上实现  
  > 3、每个**容器适配器**都基于**底层容器类型**的操作定义了自己的**特殊操作**，但我们**只能使用适配器操作**，而**不能使用底层容器类型的操作**

  | 栈特有的操作                  | 描述                                                                     |
  | ----------------------------- | ------------------------------------------------------------------------ |
  | s.pop()                       | 删除栈顶元素，但不返回元素值                                             |
  | s.push(item)，s.emplace(args) | 创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来，或者由 args 构造 |
  | s.top()                       | 返回栈顶元素，但不将元素弹出栈                                           |

  ```cpp
  stack<int> intStack;

  for(size_t ix = 0; ix != 10; ix++)
    intStack.push(ix);

  while(!intStack.empty())
  {
      int value = intStack.top();
      intStack.pop();
  }
  ```

- **队列适配器**

  > 1、`queue`和`priority_queue`**类型**定义在`queue`**头文件**中，下标列出了**队列特有的操作**  
  > 2、`queue`默认基于`deque`实现，`priority_queue`默认基于`vector`实现。`queue`也可以用`list`或`vector`实现，`priority_queue`也可以用`deque`实现  
  > 3、`priority_queue`允许我们**为队列中的元素建立优先级**，**新加入的元素**会排在**所有优先级比他低的已有元素**之前。饭店按照客人预定时间而不是到店时间来安排座位就是一个例子

  | 队列特有的操作                | 描述                                                                               |
  | ----------------------------- | ---------------------------------------------------------------------------------- |
  | q.pop()                       | 返回 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回元素值            |
  | q.front()，q.back()           | 返回首元素或尾元素，但不删除此元素，只适用于 queue                                 |
  | q.top()                       | 返回最高优先级的元素，但不删除此元素，只适用于 priority_queue                      |
  | q.push(item)，q.emplace(args) | 在 queue 末尾或 priority_queue 中恰当位置创建一个元素，其值为 item，或由 args 构造 |

---

#### **泛型算法**

---

<div class="success">

> **章节概要**：概述；算法如何工作；算法不执行容器操作；初识泛型算法；只读算法；`accumulate`；算法和元素类型；操作两个序列的`equal`；写容器元素的算法；`fill`；算法不检查写操作；介绍`back_inserter`；`copy`；`replace`；重排容器元素的算法；`sort`和`unique`；定制操作；谓词与向算法传参；`lambda`表达式；向`lambda`传参；使用捕获列表；`lambda`捕获和返回；`lambda`捕获列表；可变`lambda`；指定`lambda`返回类型；参数绑定；`bind`；使用`placeholders`名字；`bind`重排参数顺序；绑定引用参数；再探迭代器；标准库迭代器；插入迭代器；`iostream`迭代器；`istream_iterator`操作；使用算法操作流迭代器；`ostream_iterator`操作；反向迭代器；泛型算法结构；五类迭代器；算法参数规范；算法命名规范；特定容器算法；链表类型的成员算法；`splice`成员

</div>

##### **概述**

- **引入**

  > 1、**大多数算法**都定义在**头文件**`algorithm`中。**标准库**还在**头文件**`numeric`中定义了一组**数值泛型算法**  
  > 2、一般情况下，这些算法并**不直接操作容器**，而是遍历由**两个迭代器**指定的**一个元素范围**来进行操作。通常情况下，算法**遍历范围**，对其中**每个元素**进行**操作**  
  > 3、例如，假设我们有一个**int**的`vector`，希望知道其中**是否包含某个特定值**，可以使用`find`算法，如下

  ```cpp
  int val = 42;     // 要查找的值
  // 如果在 vec 中找到想要的元素，则返回结果指向它，否则返回结果为 vec.cend()
  auto result = find(vec.cbegin(), vec.cend(), val);
  // 报告结果
  cout << "The value" << val << (result == vec.cend() ? "is not present" : "is present") << endl;
  ```

- **算法如何工作**

  > 1、为了弄清这些**算法**如何用于**不同类型的容器**，让我们更近距离观察一下`find`**如何工作**。概念上，`find`应执行**如下步骤**  
  > 2、访问序列中的**首元素**；比较此元素与我们**要查找的值**匹配；如果此元素与我们**要查找的值**匹配，就**返回标识此元素的值**；否则`find`前进到**下一元素**，**重复步骤 2 和 3**；如果**到达序列尾**，`find`**应停止**；如果**到达序列末尾**，返回一个指出**元素未找到**的值  
  > 3、**迭代器**令**算法**不依赖于**容器**，但**算法**依赖于**元素类型的操作**

- **算法不执行容器操作**

  > 1、**泛型算法**本身**不会执行容器操作**，它们只会运行于**迭代器**之上，**执行迭代器的操作**，该特性说明**算法永远不会改变底层容器的大小**  
  > 2、算法**可能改变**容器中**保存的元素的值**，也可能在容器内**移动元素**，但**永远不会**直接**增删元素**  
  > 3、**标准库**定义了一类**特殊的迭代器**，称为**插入器**。与**普通迭代器只能遍历**所绑定的容器相比，**插入器**能做更多的事情，后续介绍

##### **初识泛型算法**

- **介绍**

  > 1、**标准库**提供了**超过 100 个算法**，幸运的是，与容器类似，这些**算法有一致的结构**，**附录**中**按操作方式**列出了**所有算法**  
  > 2、除了**少数例外**，**标准库算法**都对一个**范围内的元素**进行操作。我们将此**元素范围**称为**输入范围**，接受**输入范围**的算法总是使用**前两个参数**来表示此范围(范围`[a, b)`)  
  > 3、虽然大多算法**遍历输入范围的方式相似**，但它们**使用范围内的元素的方式不同**。**理解算法**最基本的方法就是了解它们**是否读取元素**、**改变元素**或**重排元素顺序**

- **只读算法**

  - `accumulate`

    > 1、一些**算法**只会**读取输入范围内的元素**，而**不改变元素**，称为**只读算法**，`find`就是这样一种**算法**  
    > 2、另一个**只读算法**是`accumulate`，它定义在**头文件**`numeric`中。该**函数接受三个参数**，前两个**表示范围**，第三个参数是**和的初值**  
    > 3、假定**vec**是一个**整数序列**，则有下例**对 vec 中元素求和**  
    > 4、`accumulate`的**第三个参数的类型**决定了函数中**使用哪个加法运算符**以及**返回值的类型**

    ```cpp
    // 对 vec 中元素求和，和初始值为 0
    int sum = accumulate(vec.cbegin(), vec.cend(), 0);
    ```

  - **算法和元素类型**

    > 1、`accumulate`将**第三个参数**作为**求和起点**，这蕴含着一个**编程假定**：将**元素类型**加到**和的类型**上的**操作**必须是可行的  
    > 2、即，序列中**元素的类型**必须与**第三个参数匹配**，或者**能转换为第三个参数的类型**  
    > 3、下例中，由于`string`定义了`+`**运算符**，所以我们可以**通过调用**`accumulate`将`vector`中所有`string`元素**连接起来**。但注意，必须**显式创建一个**`string`，**不可以**将**空串**当成**第三个参数**传给函数，原因在于空串表示**保存和的类型**将是`const char*`，而此类型**没有定义**`+`**运算符**

    ```cpp
    string sum = accumulate(v.cbegin(), v.cend(), string(""));

    // 错误：const char* 没有定义 + 运算符
    string sum = accumulate(v.cbegin(), v.cend(), "");
    ```

  - **操作两个序列的**`equal`

    > 1、另一个**只读算法**是`equal`，用于确定**两个序列**是否保存**相同的值**。它将**第一个序列**中的**每个元素**与**第二个序列**中的**对应元素**进行比较，如果**对应元素都相等**，则返回**true**，否则返回**false**  
    > 2、此算法**接受三个迭代器**，前两个表示**第一个序列中的元素范围**，第三个表示**第二个序列的首元素**。但要注意，`equal`假定**第二个序列**至少**与第一个序列一样长**，且默认**只接受一个单一迭代器**来表示**第二个序列**的**其他算法**，也**都有此假定**  
    > 3、由于`equal`**利用迭代器完成操作**，因此可以调用`equal`比较两个**不同类型容器中的元素**，而且**元素类型也不必一样**，只要能用`==`来**比较两个元素类型**即可  
    > 4、如下例，`roster1`可以是`vector<string>`，而`roster2`可以是`list<const char*>`

    ```cpp
    // roster2 中元素数目应至少与 roster1 中一样多
    equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
    ```

- **写容器元素的算法**

  - `fill`

    > 1、一些**算法**将**新值**赋予**序列中的元素**。当我们**使用这类算法时**，必须注意**确保序列原大小**大于等于我们要**写入的元素数目**，这是因为**算法不会执行容器操作**，因此它们自己**不能改变容器大小**  
    > 2、一些算法会**自己向输入范围写入元素**，这些算法本质上**并不危险**，它们**最多写入与给定序列一样多的元素**  
    > 3、例如**算法**`fill`接受**一对迭代器**表示**一个范围**，还接受**一个值**作为**第三个参数**，`fill`将给定的**这个值**赋予序列中的**每个元素**。由于`fill`向给定**输入序列**中**写入数据**，所以只要传递一个**有效的输入序列**，**写入操作**就是**安全**的

    ```cpp
    fill(vec.begin(), vec.end(), 0);                    // 将每个元素重置为 0
    fill(vec.begin(), vec.begin() + vec.size()/2, 10);  // 将容器的一个子序列设置为 10
    ```

  - **算法不检查写操作**

    > 1、一些**算法**接受一个**迭代器**来指出一个**单独的目的位置**，这些算法将**新值**赋予一个**序列中的元素**，该**序列**从**目的位置迭代器指向的元素**开始  
    > 2、例如，函数`fill_n`接受一个**单迭代器**、一个**计数值**、一个**值**。它将**给定值**赋予迭代器**指向元素开始**的**指定个元素**。我们可以用`fill_n`将一个新值赋予`vector`中的元素，如下例  
    > 3、**函数**`fill_n`会**假定写入指定个元素是安全的**，即**假定从指定元素起有指定个元素**，如果**越界**，会出现严重错误，**行为未定义**

    ```cpp
    vector<int> vec;                      // 空 vector
    fill_n(dest.begin(), vec.size(), 0);  // 将所有元素重置为 0
    fill_n(dest.begin(), 10, 50);         // 错误：vec 为空，没有 10 个元素，行为未定义
    ```

  - **介绍**`back_inserter`

    > 1、一种**保证算法**有**足够元素空间**来容纳**输出数据**的方法是使用**插入迭代器**，这是一种**向容器中添加元素**的**迭代器**  
    > 2、通常情况，我们通过一个**普通迭代器向容器元素赋值时**，**值**被赋予**迭代器指向的元素**；而通过**插入迭代器赋值时**，一个与`=`**右侧值**相等的**元素**被**添加到容器**中  
    > 3、后续还会再详细介绍**插入迭代器**，现在我们简要介绍**插入迭代器**中的`back_inserter`，它定义在`iterator`**头文件**中  
    > 4、`back_inserter`接受一个**指向容器的引用**，返回一个**与该容器绑定**的**插入迭代器**。我们常常使用`back_inserter`**创建迭代器**作为算法的**目的位置**来使用，如下例

    ```cpp
    vector<int> vec;                    // 空 vector
    auto it = back_inserter(vec);       // 创建插入迭代器，通过 it 赋值会将元素添加到 vec 中
    *it = 42;                           // vec 中现在有一个元素，值为 42
    fill_n(back_inserter(vec), 10, 0);  // 添加 10 个 0 到 vec 中
    ```

  - `copy`

    > 1、`copy`**算法**是另一个向**目的位置迭代器**指定的**输出序列中的元素**写入数据的算法。它接受**三个迭代器**，**前两个**表示一个**输入范围**，**第三个**表示**目的序列的起始位置**  
    > 2、此算法将**输入范围**中的**元素**拷贝到**目的序列**中，注意传递的**目的序列**至少要包含**与输入序列一样多的元素**。我们可以用`copy`实现**内置数组的拷贝**，如下例  
    > 3、`copy`返回的是其**目的位置迭代器**(递增后)的**值**，即**ret**指向拷贝到**a2**的**尾后位置**  
    > 4、**多个算法**都提供所谓的**拷贝版本**，这些算法**计算新元素的值**，但不会将它们放在**输入序列的末尾**，而是**创建一个新序列保存这些结果**  
    > 5、例如`replace`**读取一个序列**(前两个参数迭代器表示)，将其中**等于给定值**(第三个参数)的值**更改为另一个值**(第四个参数)。如果我们希望**保留原序列不变**，可以使用`replace_copy`，它**接受额外的第三个参数**表示调整后**序列的保存位置**，如下例

    ```cpp
    int a1[] = {0,1,2,3,4,5,6,7,8,9};
    int a2[sizeof(a1) / sizeof(*a1)];         // a2 与 a1 大小一样
    // ret 指向拷贝到 a2 的尾元素之后的位置
    auto ret = copy(begin(a1), end(a1), a2);  // 把 a1 的内容拷贝给 a2
    ```

    ```cpp
    // 将所有值为 0 的元素改为 42
    replace(ilst.begin(), ilst.end(), 0, 42);

    // 使用 back_inserter 按需要增长目标序列，序列保存至 back_inserter(ivec)
    replace_copy(ilst.begin(), ilst.cend(), back_inserter(ivec), 0, 42)
    ```

- **重排容器元素的算法**

  - **引入**

    > 1、某些算法会**重排容器**中**元素的顺序**，比如`sort`。调用`sort`会**重排输入序列中的元素**，**使之有序**，它是利用**元素类型**的`<`**运算符**来实现排序的  
    > 2、现在假定我们要分析一段文章所用的词汇。假定已有一个`vector`**保存了文本**，我们希望**简化**`vector`使**每个单词只出现一次**

  - `sort`**和**`unique`

    > 1、为了**消除重复单词**，首先使用`sort`将`vector`**排序**，使**重复单词相邻出现**  
    > 2、排序完成后，可以使用**标准库算法**`unique`来**重排**`vector`，使**不重复的元素**出现在`vector`**的开始部分**  
    > 3、由于算法**不能执行容器的操作**，我们将使用`vector`的`erase`来真正完成**删除操作**

    ```cpp
    void elimDups(vector<string> &words)
    {
        // 按字典序排序 words，以便查找重复单词
        sort(words.begin(), words.end());
        // unique 重排输入范围，使每个单词只出现一次，重复的单词置后
        // 返回指向不重复区域之后一个位置的迭代器
        auto end_unique = unique(words.begin(), words.end());
        // 使用向量操作 erase 删除重复单词
        words.erase(end_unique, words.end());
    }
    ```

##### **定制操作**

- **引入**

  > 1、很多**算法**都会比较**输入序列**中的**元素**，默认情况下，这类算法使用**元素类型**的`<`或`==`**运算符**来完成比较  
  > 2、**标准库**还为这些算法定义了**额外的版本**，允许我们提供**自定义的操作**来代替**默认运算符**  
  > 3、例如`sort`默认使用**元素类型**的`<`来比较，但可能我们**希望的顺序**与`<`**定义的顺序**不同，或者序列保存的是**未定义**`<`**运算符**的**元素类型**，这些情况都需要**重载**`sort`的**默认行为**

- **谓词与向算法传参**

  > 1、**谓词**是一个**可调用的表达式**，其返回结果是一个**能用作条件的值**，**标准库**所使用的**谓词**分两类：**一元谓词**和**二元谓词**  
  > 2、**接受谓词参数**的算法对**输入序列中的元素**调用**谓词**，因此，**元素类型**必须能转换为**谓词的参数类型**  
  > 3、例如，接受一个**二元谓词参数**的`sort`**版本**，用这个**谓词**来**代替**`<`**比较元素**。我们可以按长度排序单词，如下例  
  > 4、在我们将**words**按长短排序后，还希望**相同长度的元素**按**字典序排序**，可以使用`stable_sort`，如下

  ```cpp
  vector<string> words{"abc", "yy", "bbbb", "zzz", "aaaaa", "za"};

  // 比较函数
  bool isShorter(const string &s1, const string &s2)
  {
      return s1.size() < s2.size();
  }

  // 按长度由短至长排序
  sort(words.begin(), words.end(), isShorter);
  for (auto it : words)
      cout << it << ' ';

  // 按长度排序，且相同长度按字典序排序
  stable_sort(words.begin(), words.end(), isShorter);
  for (auto it : words)
      cout << it << ' ';
  ```

- **lambda 表达式**

  - **引入**

    > 1、根据**算法**接受**一元谓词**还是**二元谓词**，我们**传递给算法的谓词**也必须严格**接受一个或两个参数**，但有时我们希望进行的**操作需要更多参数**，会**超出算法对谓词的限制**  
    > 2、例如我们要计算**大于等于一个给定长度的单词有多少**，且**只打印这些单词**，我们能设计出一个**大体框架**，如下  
    > 3、我们可以使用**标准库算法**`find_if`来查找。其接受**一对迭代器**，表示**范围**，**第三个参数**接受一个**一元谓词**。返回**第一个使谓词返回非 0 值**的**元素**，如果不存在则返回**尾后迭代器**  
    > 4、但是，`find_if`只接受**一元谓词**，我们会使用**一个参数表示当前元素**，**没有任何办法**能传递**第二个参数表示长度**。为此，需要使用另外一些**语言特性**

    ```cpp
    void biggie(vector<string> &words, vector<string>::size_type sz)
    {
        // 之前自定义的函数，将 words 按字典序排序，删除重复单词
        elimDups(words);
        // 先前定义的 isShorter
        stable_sort(words.begin(), words.end(), isShorter);
        // 获取一个迭代器，指向第一个满足 size() >= sz 的元素，即此后的都符合条件
        // 计算数目
        // 输出
    }
    ```

  - `lambda`**介绍**

    > 1、我们可以**向一个算法**传递**任何类别**的**可调用对象**。对于一个**对象**或**表达式**，如果可以对其使用**调用运算法**`()`，则称它为**可调用的**  
    > 2、到目前为止，我们使用过的**两种可调用对象**：**函数**和**函数指针**，此外还有两种**可调用对象**：**重载了函数调用运算符的类**(后续介绍)和`lambda`**表达式**  
    > 3、一个`lambda`**表达式**表示一个**可调用的代码单元**，我们可以将其理解为一个**未命名的内联函数**。**与任何函数类似**，一个`lambda`具有一个**返回类型**、**形参列表**和**函数体**；但**与函数不同**的是，`lambda`**可能定义在函数内部**  
    > 4、一个`lambda`形式如：`[捕获列表](参数列表) -> 返回类型{函数体}`。其中，**捕获列表**是一个`lambda`**所在函数中定义的局部变量**的列表(通常为空)，**其余三者与函数一样**，但是`lambda`必须使用**尾置返回**来**指定返回类型**  
    > 5、我们可以**忽略参数列表**和**返回类型**，但必须永远包含**捕获列表**和**函数体**，如`auto f = []{ return 42; };`。当**忽略返回类型**时，如果**函数体**只有`return`语句，则**自动推断返回类型**，否则返回`void`

  - **向**`lambda`**传参**

    > 1、可以像**给普通函数传参**那样**给**`lambda`**传参**，但注意**不同的是**，`lambda`不能有**默认形参**  
    > 2、如下例，我们可以编写一个**与**`isShorter()`**函数功能相同的**`lambda`

    ```cpp
    vector<string> words{"abc", "yy", "bbbb", "zzz", "aaaaa", "za"};

    auto lam = [](const string &a, const string &b) { return a.size() < b.size(); };

    // 此处 lam 也可以直接写上述 lambda 表达式
    stable_sort(words.begin(), words.end(), lam);
    for (auto it : words)
        cout << it << ' ';
    ```

  - **使用捕获列表**

    > 1、虽然一个`lambda`可以**出现在一个函数中**，**使用其局部变量**，但**只能使用**那些**明确指明的变量**  
    > 2、一个`lambda`通过将**局部变量**包含在其**捕获列表**中来**指出将使用这些变量**，**捕获列表**指引`lambda`在其内部**访问局部变量**所需的信息  
    > 3、如下例，该`lambda`会**捕获 sz**，并只有单一的`string`**参数**

    ```cpp
    [sz](const string &a) { return a.size() >= sz; };
    ```

  - **完整的**`biggies()`

    ```cpp
    void biggies(vector<string> &words, vector<string>::size_type sz)
    {
        // 自定义的 elimDups，按字典序排序并删除重复单词
        elimDups(words);

        // 按长度排序
        auto sort_length = [](const string &a, const string &b) { return a.size() < b.size(); };
        stable_sort(words.begin(), words.end(), sort_length);

        // 获取一个迭代器，指向第一个满足 size() >= sz 的元素
        auto find_first = [sz](const string &a) { return a.size() >= sz; };
        auto wc = find_if(words.begin(), words.end(), find_first);

        // 计算数目
        auto count = words.end() - wc;
        cout << count << endl;

        // 打印单词
        auto print = [](const string &s) { cout << s << ' '; };
        for_each(wc, words.end(), print);   // 标准库算法，接受一个可调用对象，并对输入序列中每个元素调用此对象
    }
    ```

- **lambda 捕获和返回**

  - `lambda`**对象**

    > 1、当**定义一个**`lambda`时，**编译器**生成一个**与**`lambda`**对应的**新的**类类型**，后续会介绍这种类如何生成  
    > 2、目前，可以认为当**向一个函数传递**`lambda`时，同时定义了一个**新类型**和**该类型的一个对象**，**传递的参数**就是编译器生成的**类类型的未命名对象**  
    > 3、类似的，当使用`auto`定义一个**用**`lambda`**初始化的变量**时，定义了一个**从**`lambda`**生成的类型的对象**

  - `lambda`**捕获列表**

    | 捕获列表             | 描述                                                                                                                                                                                          |
    | -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | [ ]                  | 空捕获列表，lambda 不能使用所在函数中的变量                                                                                                                                                   |
    | [names]              | names 是一个逗号分隔的名字列表，这些名字都是 lambda 所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝，名字前如果使用了&，则采用引用捕获方式                                           |
    | [&]                  | 隐式捕获列表，采用引用捕获方式。lambda 中所使用的来自所在函数的实体都采用引用方式使用                                                                                                         |
    | [=]                  | 隐式捕获列表，采用值捕获方式。lambda 将拷贝所使用的来自所在函数的实体的值                                                                                                                     |
    | [&, identifier_list] | identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list 名字前不能使用&                      |
    | [=, identifier_list] | identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。这些变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。identifier_list 名字不能包括 this，而名字前必须使用& |

  - **可变**`lambda`

    > 1、默认情况下，对于一个**值被拷贝的变量**，`lambda`**不会改变其值**  
    > 2、如果我们希望能**改变一个被捕获的变量的值**，就必须在**参数列表首**加上**关键字**`mutable`。因此，**可变**`lambda`可以**省略参数列表**

    ```cpp
    void func()
    {
        size_t v1 = 42;
        // f 可以改变它所捕获的变量的值
        auto f = [v1] () mutable { return ++v1; };
        v1 = 0;
        auto j = f();   // j 为 43
    }
    ```

  - **指定**`lambda`**返回类型**

    > 1、默认情况下，如果一个`lambda`包含`return`**之外的任何语句**，则**编译器**将假定其**返回**`void`  
    > 2、如下例，我们可以用**标准库算法**`transform`和一个`lambda`**表达式**来实现**转换数字为其绝对值**，`transform`**第三个参数**表示**目的位置**  
    > 3、使用**三目运算符**的版本由于是**只有一条**`return`，被解析为**返回**`int`；而使用`if`的版本则被解析为`void`因此**编译错误**，必须**显式指定返回类型**  
    > 4、当我们需要为一个`lambda`**定义返回类型**时，必须使用**尾置返回类型**

    ```cpp
    // 三目运算符版本，正确
    transform(vi.begin(), vi.end(), vi.begin(), [](int i) { return i < 0 ? -i : i; });

    // if 版本，错误
    transform(vi.begin(), vi.end(), vi.begin(), [](int i) { if (i < 0) return -i; else return i; });
    // if 版本，正确
    transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int { if (i < 0) return -i; else return i; });
    ```

- **参数绑定**

  - **引入**

    > 1、对于那种只在**一两个地方**使用的**简单操作**，`lambda`**表达式**是最有用的。如果我们需要在很多地方使用**相同的操作**，通常应该**定义一个函数**，而不是**多次编写相同的**`lambda`。类似的，如果一个操作需要**很多语句才能完成**，通常使用**函数**更好  
    > 2、如果`lambda`**捕获列表为空**，通常可以**用函数来代替**，既可以用`lambda`也可以用**函数**来实现  
    > 3、但是对于**捕获局部变量**的`lambda`，**用函数代替**就**没那么容易**了。例如如果**调用的一个函数**接受一个**一元谓词**，`lambda`可以**通过捕获列表从形参获取额外信息**，而**函数**必须解决如何作为**一元谓词**的问题

  - `bind`

    > 1、为了解决**向作为一元谓词的函数传递多个参数**的问题，方法是使用一个名为`bind`的**标准库函数**，它定义在**头文件**`functional`中  
    > 2、可以将`bind`看作一个**通用的函数适配器**，它接受一个**可调用对象**，生成一个**新的可调用对象**来**适应原对象的形参列表**  
    > 3、调用`bind`的一般形式如：`auto newCallable = bind(callable, arg_list)`。其中，`newCallable`本身是一个**可调用对象**，`arg_list`是**形参列表**。当**调用**`newCallable`时，会**调用**`callable`，并**使用**`arg_list`**作为**`callable`**的形参**  
    > 4、`arg_list`中可能出现**形如**`_n`**的名字**，其中**n**是一个**整数**，这些参数是**占位符**，它们占据了**传递给**`newCallable`**的参数的位置**：`_1`为`newCallable`**第一个参数**，`_2`为**第二个参数**，以此类推

  - **使用**`bind`**绑定参数**

    > 1、一个简单的例子，我们将**使用**`bind`生成一个**调用**`check_size`**的对象**，如下  
    > 2、此`bind`调用**只有一个占位符**，表示`check6`**接受一个参数**；**占位符**出现在`arg_list`**第一个位置**上，表示`check6`**的此参数**对应`check_size`**的第一个参数**

    ```cpp
    // 原函数
    bool check_size(const string &s, string::size_type sz)
    {
        return s.size() >= sz;
    }

    // 绑定参数
    auto check6 = bind(check_size, _1, 6);

    // 调用
    string s = "hello";
    bool b1 = check6(s);    // 即调用 check_size(s, 6)

    // 作为一元谓词
    auto wc = find_if(words.begin(), words.end(), check6);
    auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));
    ```

  - **使用**`placeholders`**名字**

    > 1、**名字**`_n`都定义在**命名空间**`placeholders`中(定义在头文件`functional`中)，而这个**命名空间**定义在`std`**命名空间**中，因此为了**使用这些名字**，两个命名空间都要写上(如`std::placeholders::_1`)  
    > 2、为了**更方便的使用**，我们通常使用`using`声明：`using std::placeholders::_1`。但这样对于**每个占位符名字**都要**单独声明**，不仅繁琐还易出错  
    > 3、我们可以使用**另一种**`using`**声明形式**：`using namespace namespace_name`，表示希望**所有来自**`namespace_name`**的名字**都可以在我们的程序中**直接使用**，如此处可写作`using namespace std::placeholders`

  - `bind`**重排参数顺序**

    > 1、如前文所述，我们可以用`bind`**修正参数的值**，更一般的，可以用`bind`**绑定**给定可调用对象中的**参数**或是**重新安排其顺序**  
    > 2、例如，`func`是一个**可调用对象**，它有**5 个参数**，则允许下面的调用

    ```cpp
    auto g = bind(func, a, b, _2, c, _1);

    g(d, e);    // 等同于 func(a, b, e, c, d)
    ```

  - **绑定引用参数**

    > 1、默认情况下，`bind`的那些**不是占位符的参数**被**拷贝**到**返回的可调用对象**中。但与`lambda`类似，有时对于有些**绑定的参数**我们希望**以引用方式传递**，或是希望**绑定参数的类型无法拷贝**  
    > 2、如下例，为了替换一个**引用方式捕获**`ostream`的`lambda`，可以很容易编写一个函数**完成相同工作**，但不能直接用`bind`来**代替对**`os`**的捕获**。原因在于`bind`**拷贝其参数**，而我们**不能拷贝一个**`ostream`  
    > 3、如果我们希望**传给**`bind`**一个对象**而**不拷贝它**，必须使用**标准库函数**`ref`，它定义在**头文件**`functional`中。`ref`**返回一个对象**，包含**给定的引用**，此对象是**可以拷贝的**；**标准库**还有一个`cref`，生成一个**保存**`const`**引用的类**

    ```cpp
    // os 是一个局部变量，引用一个输出流
    // c 是一个局部变量，类型为 char
    for_each(words.begin(), words.end(), [&os, c](const string &s) { os << s << c; });

    // 同功能函数
    ostream &print(ostream &os, char c, const string &s)
    {
        return os << s << c;
    }
    // 错误：不能拷贝 os
    for_each(words.begin(), words.end(), bind(print, os, ' ', _1));

    // 使用 ref
    for_each(words.begin(), words.end(), bind(print, ref(os), ' ', _1));
    ```

##### **再探迭代器**

- **标准库迭代器**(头文件`iterator`)

  | 迭代器类型 | 描述                                                                       |
  | ---------- | -------------------------------------------------------------------------- |
  | 插入迭代器 | 这些迭代器被绑定到一个容器上，可用来向容器插入元素                         |
  | 流迭代器   | 这些迭代器被绑定到输入或输出流上，可用来遍历所有关联的 IO 流               |
  | 反向迭代器 | 这些迭代器向后而不是向前移动。除了 forward_list 外标准库容器都有反向迭代器 |
  | 移动迭代器 | 这些专用的迭代器不是拷贝其中的元素，而是移动它们(将在后续介绍)             |

- **插入迭代器**

  - **插入迭代器操作**

    > 1、**插入器**是一种**迭代器适配器**，它**接受一个容器**，**生成一个迭代器**  
    > 2、当我们通过一个**插入迭代器进行赋值**时，该迭代器**调用容器操作**来向给定容器的指定位置**插入一个元素**，下表列出了**插入迭代器**支持的操作

    | 操作             | 描述                                                                                                                                         |
    | ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
    | it = t           | 在 it 指定的当前位置插入值 t。假定 c 是 it 绑定的容器，依赖于插入迭代器不同种类，赋值分别调用 c.push_back(t)、c.push_front(t)、c.insert(t,p) |
    | \*it，++it，it++ | 虽然这些操作存在，但不会对 it 做任何事情，每个操作都返回 it                                                                                  |

  - **插入迭代器类型**

    > 1、**插入迭代器**有**三种类型**，差异在于**元素插入的位置**  
    > 2、只有在**容器支持**`push_front`操作时**才能使用**`front_inserter`；只有在**容器支持**`push_back`操作时才能使用`back_inserter`

    | 类型           | 描述                                                                                                                                     |
    | -------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
    | back_inserter  | 创建一个使用 push_back 的迭代器，元素插入到容器末尾                                                                                      |
    | front_inserter | 创建一个使用 push_front 的迭代器，元素插入到容器首端                                                                                     |
    | inserter       | 创建一个使用 insert 的迭代器，此函数接受第二个参数，其必须是指向给定容器的一个迭代器，表示插入位置，元素将插入到给定迭代器表示的元素之前 |

- **iostream 迭代器**

  - **引入**

    > 1、虽然`iostream`类型**不是容器**，但**标准库**定义了可以用于这些**IO 类型对象**的**迭代器**  
    > 2、`istream_iterator`**读取输入流**，`ostream_iterator`**向一个输出流写数据**  
    > 3、这些**迭代器**将它们**对应的流**当做一个**特定类型的元素序列**来处理，通过使用**流迭代器**，我们可以用**泛型算法**从**流对象**中**读写数据**

  - `istream_iterator`**操作**

    > 1、当创建一个**流迭代器**时，必须**指定迭代器**将要读写的**对象类型**。一个`istream_iterator`使用`>>`来**读取流**，所以**要读取的类型**必须定义了`>>`**运算符**。下表列出了`istream_iterator`的操作  
    > 2、当创建一个`istream_iterator`时，我们可以**将它绑定到一个流**。此外还可以**默认初始化迭代器**，这样就创建了一个**可以当做尾后值使用的迭代器**，如下  
    > 3、如下例，使用`istream_iterator`**从标准输入读取数据**，**存入一个**`vector`。此外我们还可以重写这部分代码，以体现**流迭代器**更有用的地方，即**构造容器**

    | istream_iterator 操作      | 描述                                                                                                         |
    | -------------------------- | ------------------------------------------------------------------------------------------------------------ |
    | istream_iterator<T> in(is) | in 从输入流 is 读取类型为 T 的值                                                                             |
    | istream_iterator<T> end    | 读取类型为 T 的值的 istream_iterator 迭代器，表示尾后位置                                                    |
    | in1 == in2，in1 != in2     | in1 和 in2 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同输入，则两者相等                            |
    | \*in                       | 返回从流中读取的值                                                                                           |
    | in->mem                    | 与(\*in).mem 含义相同                                                                                        |
    | ++in，in++                 | 使用元素类型所定义的>>运算符从输入流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值 |

    ```cpp
    // 使用示例
    istream_iterator<int> int_it(cin);        // 从 cin 读取 int
    istream_iterator<int> int_eof;            // 尾后迭代器
    ifstream in("afile");                     // 创建一个文件输入流与 afile 绑定
    istream_iterator<string> str_it(in);      // 从 afile 读取字符串

    // 从 istream_iterator 读入数据存入 vector
    istream_iterator<int> in_iter<cin>;       // 从 cin 读取 int
    istream_iterator<int> eof;                // istream 尾后迭代器
    while(in_iter != eof)                     // 当有数据可供读取时
        // 后值递增运算读取流，返回迭代器的旧值
        // 解引用迭代器，获得从流读取的前一个值
        vec.push_back(*in_iter++);

    // 重写优化
    istream_iterator<int> in_iter(cin), eof;  // 从 cin 读取 int
    vector<int> vec(in_iter, eof);            // 从迭代器范围构造 vec
    ```

  - **使用算法操作流迭代器**

    > 1、由于**算法**使用**迭代器**来**处理数据**，而**流迭代器**又至少**支持某些迭代器操作**，因此我们可以**用某些算法**来**操作流迭代器**  
    > 2、如下例，我们可以**用一对**`istream_iterator`**来调用**`accumulate`，该调用会**计算从标准输入读取的值的和**

    ```cpp
    istream_iterator<int> in(cin), eof;
    cout << accumulate(in, eof, 0) << endl;
    ```

  - `ostream_iterator`**操作**

    > 1、我们可以对任何**具有**`<<`**运算符**的**类型**定义`ostream_iterator`，下表列出了`ostream_iterator`的操作  
    > 2、当创建一个`ostream_iterator`时，可以提供**可选的第二参数**，它是一个**C 风格字符串**，在**输出每个元素后**都会**打印此字符串**  
    > 3、**必须将**`ostream_iterator`**绑定到一个指定流**，不允许**空的**或**表示尾后位置的**`ostream_iterator`  
    > 4、如下例，我们可以用`ostream_iterator`来**输出值的序列**。由于**解引用**和**递增运算**没有实意，**可以省略**。我们还可以**调用**`copy`**算法**更方便地打印元素

    | ostream_iterator 操作          | 描述                                                                                   |
    | ------------------------------ | -------------------------------------------------------------------------------------- |
    | ostream_iterator<T> out(os)    | out 将 类型为 T 的值写到输出流 os 中                                                   |
    | ostream_iterator<T> out(os, d) | out 将 类型为 T 的值写到输出流 os 中，每个值后都输出一个 d，d 必须是 C 风格字符串      |
    | out = val                      | 用 << 运算符将 val 写入到 out 所绑定的 ostream 中，val 的类型必须与 out 可写的类型兼容 |
    | \*out，++out，out++            | 虽然存在这些运算符，但不对 out 做任何事情，每个运算符都返回 out                        |

    ```cpp
    ostream_iterator<int> out_iter(cout, " ");
    for(auto e : vec)
        // 也可以直接写为：
        // out_iter = e;
        *out_iter++ = e;

    // 使用算法操作
    copy(vec.begin(), vec.end(), out_iter);
    ```

- **反向迭代器**

  > 1、**反向迭代器**就是在**容器**中从**尾元素向首元素**反向移动的**迭代器**。对于**反向迭代器**，**递增**(或递减)操作的含义**会颠倒过来**(即`++`移动到前一个元素)  
  > 2、除了`forward_list`外，**其他容器**都支持**反向迭代器**，我们可以通过**调用**`rbegin`、`rend`、`crbegin`、`crend`**成员函数**来获得**反向迭代器**，它们返回指向**容器尾元素**和**首前元素**位置的**迭代器**

##### **泛型算法结构**

- **引入**

  > 1、任何算法**最基本的特性**是它要求其**迭代器**提供**哪些操作**。**算法要求**的**迭代器操作**可以分为**五个迭代器类型**，**每个算法**都会对它的**每个迭代器参数**指明须提供**哪类迭代器**  
  > 2、第二种算法分类的方式是**按照是否读写**或**重排序列元素**
  > 3、**算法**还共享一组**参数传递规范**和一组**命名规范**，我们将在后续介绍

- **五类迭代器**

  - **介绍**

    > 1、类似**容器**，**迭代器**也定义了一组**公共操作**。一些操作**所有迭代器都支持**，另外一些**只有特定迭代器才支持**  
    > 2、**迭代器**是按照它们**所提供的操作**来**分类**的，分为**五类迭代器**，如下表。这种分类**形成了一种层次**，除了**输出迭代器**外，一个**高层类型的迭代器**能完全支持**低层类别的迭代器**的所有操作  
    > 3、**C++标准**指明了**泛型和数值算法**的每个**迭代器参数**的**最小类别**，即对每个**迭代器参数**来说，其**能力**必须与**规定的最小类别**至少相当。向算法传递一个**能力更差的迭代器**会**产生错误**，对于这类错误，很多**编译器不会给出任何警告**

    | 迭代器类别     | 描述                                 |
    | -------------- | ------------------------------------ |
    | 输入迭代器     | 只读不写，单遍扫描，只能递增         |
    | 输出迭代器     | 只写不读，单遍扫描，只能递增         |
    | 前向迭代器     | 可读写，多遍扫描，只能递增           |
    | 双向迭代器     | 可读写，多遍扫描，可递增递减         |
    | 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 |

  - **输入迭代器**

    - **介绍**

      > 1、**输入迭代器**可以**读取序列的元素**，且**输入迭代器**只用于**顺序访问**  
      > 2、对于一个**输入迭代器**，`*it++`**保证是有效的**，但**递增它**可能导致所有**其他指向流的迭代器失效**，其结果就是**不能保证输入迭代器的状态可以保存**并**用来访问元素**。因此，**输入迭代器**只能用于**单遍扫描算法**  
      > 3、`istream_iterator`是一种**输入迭代器**

    - **输入迭代器必须支持的操作**

      > 1、用于**比较两个迭代器**的`==`和`!=`**运算符**  
      > 2、用于**推进迭代器**的前置和后置**递增运算符**`++`  
      > 3、用于**读取元素**的**解引用运算符**`*`，**解引用**只会出现在**赋值运算符右侧**  
      > 4、**箭头运算符**`->`，等价于`(*it).mem`

  - **输出迭代器**

    - **介绍**

      > 1、**输出迭代器**的特点是**只写不读元素**，且我们**只能向输出迭代器赋值一次**  
      > 2、类似**输入迭代器**，**输出迭代器**也只能用于**单遍扫描算法**。**用作目的位置**的**迭代器**通常都是**输出迭代器**，如`copy`第三个**表示目的位置的迭代器参数**就是**输出迭代器**  
      > 3、`ostream_iterator`是一种**输出迭代器**

    - **输出迭代器必须支持的操作**

      > 1、用于**推进迭代器**的前置和后置**递增运算符**`++`  
      > 2、**解引用运算符**`*`，**解引用**只会出现在**赋值运算符左侧**(向一个已经解引用的输出迭代器赋值，就是将值写入它所指的元素)

  - **前向迭代器**

    > 1、**前向迭代器**可以**读写元素**，这类**迭代器**只能在序列中**沿一个方向移动**  
    > 2、**前向迭代器**支持所有**输入输出迭代器的操作**，而且可以**多次读写同一个元素**，因此我们**可以保存前向迭代器的状态**，**算法**可以**对序列多次扫描**  
    > 3、**算法**`replace`要求**前向迭代器**，`forward_list`**上的迭代器**是**前向迭代器**

  - **双向迭代器**

    > 1、**双向迭代器**可以**正向反向读写元素**  
    > 2、除了支持所有**前向迭代器的操作**外，还支持前置和后置**递减运算符**`--`  
    > 3、**算法**`reverse`要求**双向迭代器**，除了`forward_list`外，**其他标准库**都提供**符合双向迭代器要求**的**迭代器**

  - **随机访问迭代器**

    - **介绍**

      > 1、**随机访问迭代器**提供在**常量时间**`O(1)`内**访问任意元素**的能力  
      > 2、此类**迭代器**除了支持**双向迭代器的操作**，还支持一些其他操作  
      > 3、**算法**`sort`要求**随机访问迭代器**，`array`、`deque`、`string`、`vector`的**迭代器**都是**随机访问迭代器**，用于**访问内置数组元素**的**指针**也是

    - **随机访问迭代器额外支持的操作**

      > 1、用于**比较两个迭代器相对位置**的**关系运算符**`<`、`<=`、`>`、`>=`  
      > 2、**迭代器**和一个**整数值**的**加减运算**，计算结果是在序列中**前进**(或后退)**给定整数个元素**的位置  
      > 3、用于**两个迭代器**上的**减法运算**，得到**两个迭代器的距离**  
      > 4、**下标运算符**`iter[n]`，与`*(iter[n])`等价

- **算法参数规范**

  > 1、在**任何其他算法分类之上**，还有一组**参数规范**。理解**参数规范**可以更方便得知**算法需要的参数及操作**，**大多算法**都具有**如下四种形式之一**  
  > 2、`alg`是**算法的名字**，`beg`和`end`表示算法**所操作的输入范围**。**几乎所有算法**都接受一个**输入范围**，**是否有其他参数**依赖于**要执行的操作**，`dest`、`beg2`、`end2`都是可以顾名思义的**迭代器参数**  
  > 3、除了这些**迭代器参数**，一些算法还接受**额外的**、**非迭代器**的**特定参数**

  ```cpp
  alg(beg, end, other_args);
  alg(beg, end, dest, other_args);
  alg(beg, end, beg2, other_args);
  alg(beg, end, beg2, end2, other_args);
  ```

- **算法命名规范**

  > 1、除了**参数规范**，算法还遵循一套**命名和重载规范**  
  > 2、一些算法使用**重载形式**传递一个**谓词**。接受**谓词参数**来代替`<`或`==`**运算符**的算法，以及**不接受额外参数**的算法，通常都是**重载的函数**，如`unique`  
  > 3、一些算法有`_if`**版本**。**接受一个元素值**的算法通常有另一个**不同名的版本**(非重载版本)，其接受一个**谓词**代替**元素值**，这些算法都有`_if`**后缀**，如`find`  
  > 4、一些算法有**区分拷贝和不拷贝的版本**。默认情况下，**重排元素**的算法将重排后的元素**写回给定输入序列中**，这些算法还提供另一个版本**将元素写到指定输出目的位置**，其名字后附加`_copy`**后缀**，如`reverse`

  ```cpp
  unique(beg, end);             // 使用 == 运算符比较元素
  unique(beg, end, comp);       // 使用 comp 比较元素

  find(beg, end, val);          // 查找输入范围中 val 第一次出现的位置
  find_if(beg, end, pred);      // 查找第一个令 pred 为真的元素

  reverse(beg, end);            // 反转输入范围中元素的顺序
  reverse_copy(beg, end, dest); // 将元素按逆序拷贝到 dest
  ```

##### **特定容器算法**

- **链表类型的成员算法**

  > 1、与**其他容器**不同，**链表类型**`list`和`forward_list`定义了几个**成员函数**形式的**算法**，这些算法都**返回**`void`，如下表  
  > 2、**链表类型**定义的**其他算法的通用版本**也可以**用于链表**，但**代价太高**。这些**通用版本算法**需要**交换元素**，而链表可以通过**改变元素间的链接**来**快速交换元素**。因此，**链表版本**的算法比**通用版本**的算法**性能好得多**，应当优先使用**成员函数版本**的算法

  | list 和 forward_list 的成员算法        | 描述                                                                                                                                                            |
  | -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | lst.merge(lst2)，lst.merge(lst2, comp) | 将来自 lst2 的元素合并入 lst。lst 和 lst2 都必须是有序的，元素将从 lst2 中删除，合并后 lst2 变为空。第一个版本使用`<`运算符，第二个版本使用 comp 给定的比较操作 |
  | lst.remove(val)，lst.remove_if(pred)   | 调用 erase 删除与给定值相等或令一元谓词 pred 为真的每个元素                                                                                                     |
  | lst.reverse()                          | 反转 lst 中元素的顺序                                                                                                                                           |
  | lst.sort()，lst.sort(comp)             | 使用`<`或 comp 给定的比较操作排序元素                                                                                                                           |
  | lst.unique()，lst.unique(pred)         | 调用 erase 删除同一个值的连续拷贝。第一个版本使用`==`，第二个版本使用 pred 给定的二元谓词                                                                       |

- **splice 成员**

  > 1、**链表类型**还定义了`splice`**算法**，其形式如`lst.splice(args)`或`flst.splice_after(args)`，参数描述如下表  
  > 2、此算法是**链表数据结构特有的**，因此**不需要通用版本**

  | splice 的 args 参数 | 描述                                                                                                                                                                                                     |
  | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | (p, lst2)           | p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。函数将 lst2 的所有元素移动到 lst 中 p 之前的位置或是 flst 中 p 之后的位置，将元素从 lst2 中删除。lst2 不能是与 lst 或 flst 相同的链表 |
  | (p, lst2, p2)       | p2 是一个指向 lst2 中位置的有效迭代器。函数将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中。lst2 可以是与 lst 或 flst 相同的链表                                                         |
  | (p, lst2, b, e)     | b 和 e 表示 lst2 中的合法范围。函数将给定范围中的元素从 lst2 移动到 lst 或 flst。lst2 可以是与 lst 或 flst 相同的链表，但 p 不能指向给定范围中的元素                                                     |

- **链表特有的操作会改变容器**

  > 1、**多数链表特有的算法**与其**通用版本**很相似，但不完全相同，二者至关重要的**区别是链表版本会改变底层的容器**  
  > 2、例如，**通用版本**的`merge`将**合并的序列**写入到一个**给定的目的迭代器**，**两个输入序列不变**；而**链表版本**的`merge`会**销毁给定的链表**，**元素**将**从指定链表中删除**，被**合并到调用**`merge`**的链表中**

---

#### **关联容器**

---

<div class="success">

> **章节概要**：使用关联容器;`map`；`set`；关联容器概述；通用操作；重复关联容器；关键字类型要求；关键字类型的比较函数；`pair`类型；创建`pair`的函数；关联容器操作；关联容器迭代器；迭代器解引用；关联容器和算法；添加元素；`insert`操作；`insert`返回值；删除元素；`erase`操作；`map`下标操作；下标操作的返回值；访问元素；在`multimap`或`multiset`中查找元素；示例：单词转换程序；无序容器；使用无序容器；管理桶；关键字类型要求

</div>

##### **使用关联容器**

- **关联容器类型**

  > 1、**关联容器**支持高效的**关键字查找和访问**。两个主要的**关联容器**是**map**和**set**  
  > 2、**map**中的元素是一些**键值对**，其中**关键字**起到**索引作用**，**值**则表示与索引**相关联的数据**。**set**每个元素**只包含一个关键字**，可以**快速检查**一个给定**关键字是否在 set 中**  
  > 3、**类型**`map`和`multimap`定义在**头文件**`map`中，类型`set`和`multiset`定义在**头文件**`set`中，相对应的**无序容器**定义在**头文件**`unordered_map`和`unordered_set`中

  | 关联容器类型       | 描述                                       |
  | ------------------ | ------------------------------------------ |
  | map                | 关联数组，保存键值对                       |
  | set                | 只保存关键字的容器                         |
  | multimap           | 关键字可重复出现的 map                     |
  | multiset           | 关键字可重复出现的 set                     |
  | unordered_map      | 用哈希函数组织的无序 map                   |
  | unordered_set      | 用哈希函数组织的无序 set                   |
  | unordered_multimap | 用哈希函数组织的无序 map，关键字可重复出现 |
  | unordered_multiset | 用哈希函数组织的无序 set，关键字可重复出现 |

- **使用 map**

  > 1、`map`是**键值对**的集合。例如，可以将**人名**作为**关键字**，将**电话号码**作为**值**，我们称这样的数据结构为**将名字映射到电话号码**  
  > 2、`map`常被称为**关联数组**，**关联数组**与**普通数组**类似，不同之处在于**其下标不必是整数**，我们**通过关键字**而不是位置来**查找值**  
  > 3、类似**顺序容器**，**关联容器**也是**模板**。因此**定义一个**`map`，必须**指定关键字和值的类型**  
  > 4、从`map`**提取元素**时，会得到一个`pair`**类型对象**(一个模板类型，保存名为 first 和 second 的公有数据成员)，`map`所使用的`pair`用`first`保存**关键字**，`second`保存**值**

  ```cpp
  // 统计每个单词出现的次数
  map<string, int> word_count;   // 创建 string 到 int 的空 map
  string word;
  while(cin >> word)
      word_count[word]++;           // 提取关键字 word 的计数器并累加
  // 打印结果
  for(const auto &w : word_count)
      cout << w.first << ":  " << w.second << endl;
  ```

- **使用 set**

  > 1、`set`是**关键字**的集合。当只是想知道**一个值是否存在**时，`set`是最有用的  
  > 2、`set`也是一个**模板**，**定义一个**`set`必须指定其**元素类型**  
  > 3、`find`**成员**返回一个**迭代器**，如果**给定关键字在**`set`**中**，则迭代器**指向该关键字**，否则指向**尾后迭代器**  
  > 4、对于上面使用`map`的例子，我们可以**额外使用**`set`实现**忽略统计某些单词**，如下

  ```cpp
  // 统计每个单词出现的次数
  map<string, int> word_count;  // 创建 string 到 int 的空 map
  set<string> exclude = {"the", "but", "and", "or", "an", "a"};
  string word;

  while(cin >> word)
      // 只统计不在 exclude 中的单词
      if(exclude.find(word) == exclude.end())
          word_count[word]++;   // 提取关键字 word 的计数器并累加
  ```

##### **关联容器概述**

- **通用操作**

  > 1、**关联容器**支持所有的**普通容器操作**(见 9.2 节)  
  > 2、但**不支持顺序容器的位置相关的操作**，例如`push_front`或`push_back`，原因是**关联容器中的元素**是**根据关键字存储**的，**这些操作**对关联容器**没有意义**  
  > 3、此外，**关联容器**也**不支持构造函数或插入操作**这些接受一个**元素值**和一个**数量值**的操作

- **重复关联容器**

  > 1、一个`map`或`set`的**关键字必须唯一**，即对于一个给定**关键字**，**只能有一个元素与之对应**。而`multimap`和`multiset`**没有此限制**，即**多个元素**都可以具有**相同的关键字**  
  > 2、下例展示了**具有唯一关键字的容器**与**允许重复关键字的容器**的区别

  ```cpp
  // 定义有 20 个元素的 vector，保存 0-9 每个整数的两个拷贝
  vector<int> ivec;
  for(vector<int>::size_type i = 0; i != 10; i++)
  {
      ivec.push_back(i);
      ivec.push_back(i);            // 重复保存一次
  }
  // iset 包含来自 ivec 的不重复的元素，miset 包含所有 20 个元素
  set<int> iset(ivec.begin(), ivec.end());
  multiset<int> miset(ivec.begin(), ivec.end());
  cout << ivec.size() << endl;      // 打印出 20
  cout << iset.size() << endl;      // 打印出 10
  cout << miset.size() << endl;     // 打印出 20
  ```

- **关键字类型要求**

  - **有序容器的关键字类型**

    > 1、对于**有序容器**，**关键字类型**必须定义**元素比较的方法**。默认情况下，**标准库**使用**关键字类型**的`<`**运算符**来比较两个关键字  
    > 2、在**集合类型**(`set`)中，**元素类型**就是**关键字类型**；在**映射类型**(`map`)中，**元素的第一部分的类型**就是**关键字类型**  
    > 3、先前可以向一个**算法**提供我们**自定义的比较操作**，与之类似，也可以提供**自定义的操作**来代替**关键字**上的`<`**运算符**  
    > 4、但**所定义的操作**必须在**关键字类型**上定义一个**严格弱序**(可以看做`<=`)，无论我们怎样定义**比较函数**，它必须具备**下列性质**  
    > 5、实际编程中，如果**一个类型**定义了**行为正常的**`<`**运算符**，则它**可以用作关键字类型**

  - **比较函数所需的性质**

    > 1、两个关键字**不能同时**`<=`**对方**  
    > 2、如果**k1**`<=`**k2**，且**k2**`<=`**k3**，那么必须也有**k1**`<=`**k3**  
    > 3、如果存在两个关键字，**任何一个都不**`<=`**对方**，那么称这两个关键字**等价**(容器将它们视作相等)。如果**k1 等价于 k2**，且**k2 等价于 k3**，那么必须也有**k1 等价于 k3**

  - **关键字类型的比较函数**

    > 1、用来**组织一个容器中元素操作的类型**也是**容器类型**的一部分。为了**指定使用自定义的操作**，必须在**定义关联容器类型**时提供**操作的类型**，在**尖括号**中紧跟**元素类型**给出  
    > 2、如下例，我们定义了一个**比较函数**，我们希望**创建一个**`multiset`**使用该函数为元素排序**。定义`multiset`时必须**提供两种类型**：一个**关键字类型**和一个**函数指针类型**  
    > 3、`bookstore(compareIsbn)`使用**传入函数地址初始化对象**，表示当我们**向**`bookstore`**添加元素**时，通过**调用**`compareIsbn`**为这些元素排序**

    ```cpp
    // 比较函数
    bool compareIsbn(Sales_data &lhs, Sales_data &rhs)
    {
        return lhs.isbn() < rhs.isbn();
    }

    // bookstore 中的多条记录可以有相同的 ISBN
    // bookstore 中的元素以 ISBN 的顺序进行排列
    // 尖括号中 Sales_data 为关键字类型，decltype(compareIsbn)* 为指向 compareIsbn() 的函数指针
    multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
    ```

- **pair 类型**

  - `pair`**类型与操作**

    > 1、在介绍**关联容器操作**之前，我们需要了解名为`pair`的**标准库类型**，它定义在**头文件**`utility`中  
    > 2、一个`pair`**保存两个数据成员**。类似**容器**，`pair`是一个用来**生成特定类型**的**模板**。因此当**创建一个**`pair`时，必须**提供两个类型名**，其**两个数据成员**将分别具有**对应的类型**，两个类型**不要求一致**：`pair<string, vector<int>> line`  
    > 3、`pair`的**默认构造函数**对**数据成员**进行**值初始化**，我们也可以为每个成员提供**初始化器**：`pair<string, string> author{"James", "Joyce"}`  
    > 4、与其他**标准库类型**不同，`pair`的**数据成员**是`public`的，我们可以**通过成员访问符直接访问**  
    > 5、**标准库**定义了如下几个`pair`**操作**

    | pair 操作                | 描述                                                                                |
    | ------------------------ | ----------------------------------------------------------------------------------- |
    | pair<T1,T2> p;           | p 是一个 pair，两个类型分别为 T1 和 T2 的成员都进行了值初始化                       |
    | pair<T1,T2> p(v1,v2);    | p 是一个成员类型为 T1 和 T2 的 pair，first 和 second 成员分别用 v1 和 v2 进行初始化 |
    | pair<T1,T2> p = {v1,v2}; | 等价于 p(v1,v2)                                                                     |
    | make_pair(v1,v2)         | 返回一个用 v1 和 v2 初始化的 pair，pair 类型由 v1 和 v2 的类型推断                  |
    | p.first                  | 返回 p 的名为 first 的公有数据成员                                                  |
    | p.second                 | 返回 p 的名为 second 的公有数据成员                                                 |
    | p1 < p2                  | 关系运算符按字典序定义，利用元素的 < 运算符来实现                                   |
    | p1 == p2，p1 != p2       | 当 first 和 second 分别相等时，则 pair 相等                                         |

  - **创建 pair 的函数**

    > 1、如果一个**函数**需要**返回一个**`pair`。在**新标准**下，我们可以对**返回值**进行**列表初始化**  
    > 2、在早期版本中，**不允许**使用花括号包裹的**初始化器**来**返回**`pair`**类型对象**，必须**显式构造返回值**

    ```cpp
    // 返回 pair 的函数
    pair<string, int> process(vector<string> &v)
    {
        // 处理 v
        if(!v.empty())
            return {v.back(), v.back().size()};                   // 列表初始化
            return make_pair(v.back(), v.back().size());          // 使用 make_pair
            return pair<string, int>(v.back(), v.back().size());  // 早期版本
        else
            return pair<string, int>();                           // 隐式构造返回值
    }
    ```

##### **关联容器操作**

- **关联容器迭代器**

  - **额外的类型别名**

    | 类型别名    | 描述                                                                       |
    | ----------- | -------------------------------------------------------------------------- |
    | key_type    | 此容器类型的关键字类型                                                     |
    | mapped_type | 每个关键字关联的类型，只适用于 map                                         |
    | value_type  | 对于 map，为 pair<const key_type, mapped_type>，对于 set，与 key_type 相同 |

  - **迭代器解引用**

    > 1、当**解引用**一个**关联容器迭代器**时，会得到一个类型为**容器**`value_type`的**值的引用**  
    > 2、如下例，对`map`而言，`value_type`是一个`pair`类型，但要注意`map`的`value_type`中的`key_type`是`const`的(即表示索引名的`first`不可改变)  
    > 3、`set`的**迭代器**类型同时定义了`iterator`和`const_interator`，但**两种类型都只允许只读访问**(即索引名不可改变)  
    > 4、**遍历关联容器**的方法与先前**遍历顺序容器**的方法类似，使用`begin`和`end`成员完成

    ```cpp
    // 获得指向 word_count 中一个元素的迭代器
    map<string, int> word_count;
    auto map_it = word_count.begin();
    // *map_it 是一个指向 pair<const string, int> 对象的引用
    cout << map_it->first << ' ' << map_it->second;
    map_it->first = "new key";        // 错误：关键字是 const 的，不能改变索引名
    map_it->second++;                 // 正确：可以通过迭代器改变元素的值
    ```

  - **关联容器和算法**

    > 1、我们通常不对**关联容器**使用**泛型算法**，因为**关键字**是`const`意味着不能将**关联容器**传递给**修改或重排容器元素的算法**  
    > 2、虽然**关联容器**可用于**只读元素的算法**，但是很多这类算法都要**搜索序列**。由于关联容器的元素**不能通过它们的关键字快速查找**，因此使用**搜索算法**几乎总是个坏主意  
    > 3、**关联容器**定义了一个名为`find`的**成员函数**，通过一个**给定的关键字**直接获取元素。**泛型算法库**中也有一个`find`**算法**，但此算法会进行**顺序搜索**，因此使用**关联容器定义的**`find`**成员函数**比**调用泛型**`find`好得多  
    > 4、实际编程中，如果我们真要**对一个关联容器使用算法**，要么是将它**当做一个源序列**，要么是**当做一个目的位置**

- **添加元素**

  - `insert`**操作**

    > 1、**关联容器**的`insert`**成员**向容器中**添加一个元素**或**一个元素范围**  
    > 2、由于`map`和`set`包含**不重复的关键字**，因此**插入已存在的元素**对容器**没有任何影响**  
    > 3、对一个`map`进行`insert`操作时，必须记住**元素类型**是`pair`，我们可以在`insert`**参数列表**中创建一个`pair`，此外还另有如下三种方法

    ```cpp
    // 重复元素对容器没有影响
    vector<int> ivec = {2,4,6,8,2,4,6,8};     // ivec 有 8 个元素
    set<int> set2;                            // 空集合
    set2.insert(ivec.cbegin(), ivec.cend());  // set2 有 4 个元素
    set2.insert({1,3,5,7,1,3,5,7});           // set2 现在有 8 个元素

    // 向 map 添加元素的 4 种方法
    map<string, size_t> word_count;
    word_count.insert({word, 1});
    word_count.insert(make_pair(word, 1));
    word_count.insert(pair<string, size_t>(word, 1));
    word_count.insert(map<string, size_t>::value_type(word, 1));
    ```

    | insert 操作                     | 描述                                                                                                                                                                                                                                                                                                    |
    | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | c.insert(v)，c.emplace(args)    | v 是 value_type 类型的对象，args 用来构造一个元素。对于 map 和 set，只有当元素的关键字不在 c 中时才插入(或构造)元素，函数返回一个 pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的 bool 值。对于 multimap 和 multiset，总会插入(或构造)给定元素，并返回一个指向新元素的迭代器 |
    | c.insert(b,e)，c.insert(il)     | b 和 e 是迭代器，表示一个 c::value_type 类型值的范围，il 是这种值的花括号列表。函数返回 void                                                                                                                                                                                                            |
    | c.insert(p,v)，c.insert(p,args) | 类似 insert(v) 或 emplace(v)，但将迭代器 p 作为一个指示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素                                                                                                                                                               |

  - `insert`**返回值**

    > 1、`insert`和`emplace`的**返回值**依赖于**容器类型和参数**。对于**不包含重复关键字**的容器，它们返回一个`pair`，其`first`指向**具有给定关键字的元素**，`second`为一个`bool`值，如果**关键字已在容器中**则为**false**  
    > 2、作为一个例子，我们用`insert`重写**单词计数程序**，如下例

    ```cpp
    map<string, size_t> word_count;
    string word;
    while(cin >> word)
    {
        // 插入一个元素，关键字等于 word，值为 1
        // ret 记录返回值
        auto ret = word_count.insert({word, 1});
        // 如果已经存在，则 insert 什么也没做，手动 +1
        if(!ret.second)
            ret.first->second++;    // 递增计数器，等价于 word_count[word]++
            // ret.first 是指向具有该关键字的元素的迭代器
            // ret.first->second 该元素的计数器部分(second)
    }
    ```

- **删除元素**

  - `erase`**操作**

    | erase 操作   | 描述                                                                                                                                               |
    | ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------- |
    | c.erase(k)   | 从 c 中删除每个关键字为 k 的元素。返回一个 size_type 值，指出删除的元素的数量                                                                      |
    | c.erase(p)   | 从 c 中删除迭代器 p 指定的元素。p 必须指向 c 中一个真实元素，不能等于 c.end()。返回指向 p 之后元素的迭代器，若 p 指向 c 中的尾元素，则返回 c.end() |
    | c.erase(b,e) | 删除迭代器对 b 和 e 所表示的范围中的元素。返回 e                                                                                                   |

- **map 下标操作**

  - **下标操作**

    > 1、`map`和`unordered_map`提供了**下标运算符**和一个对应的`at`**函数**  
    > 2、`set`类型**不支持下标**，因为`set`中没有**与关键字相关联**的**值**  
    > 3、我们不能对一个`multimap`或一个`unordered_multimap`进行**下标操作**，因为这些容器中可能有**多个值与一个关键字相关联**  
    > 4、下标和`at`操作只适用于非`const`的`map`和`unordered_map`

    | 下标操作 | 描述                                                                                 |
    | -------- | ------------------------------------------------------------------------------------ |
    | c[k]     | 返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化 |
    | c.at(k)  | 访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出一个 out_of_range 异常        |

  - **下标操作的返回值**

    > 1、`map`的**下标运算符**与我们用过的**其他下标运算符**的一个**不同之处**是**返回类型**。通常，**解引用一个迭代器**返回的类型和**下标运算符**返回的类型是**一样**的，但对`map`则不然  
    > 2、当对一个`map`**进行下标操作**时，会获得一个`mapped_type`**对象**；当**解引用一个**`map`时，会得到一个`value_type`对象  
    > 3、相同的是，`map`的**下标运算符**返回一个**左值**，这意味着我们**既可以读也可以写**元素  
    > 4、如果**关键字还未在**`map`**中**，**下标运算符**会**添加一个新元素**，这一特性允许我们编写出十分简洁的程序

    ```cpp
    cout << word_count["Anna"];
    ++word_count["Anna"];
    cout << word_count["Anna"];
    ```

- **访问元素**

  - **访问操作**

    > 1、**关联容器**提供多种**查找一个指定元素**的方法，如下表。具体应该使用哪个操作依赖于我们要解决什么问题  
    > 2、对于**不允许重复关键字**的容器，使用`find`和`count`**没什么区别**；对于**允许重复关键字**的容器，`count`额外还会统计**有多少个元素有相同的关键字**  
    > 3、`lower_bound`和`upper_bound`不适用于**无序容器**

    ```cpp
    set<int> iset = {0,1,2,3,4,5,6,7,8,9};
    iset.find(1);       // 返回一个迭代器，指向 key == 1 的元素
    iset.find(11);      // 返回一个迭代器，其值等于 iset.end()
    iset.count(1);      // 返回 1
    iset.count(11);     // 返回 0

    // 使用 find 检查一个元素是否存在
    if(word_count.find("foobar") == word_count.end())
    ```

    | 访问操作         | 描述                                                                                           |
    | ---------------- | ---------------------------------------------------------------------------------------------- |
    | c.find(k)        | 返回一个迭代器，指向第一个关键字为 k 的元素，若 k 不在容器中，则返回尾后迭代器                 |
    | c.count(k)       | 返回关键字等于 k 的元素的数量                                                                  |
    | c.lower_bound(k) | 返回一个迭代器，指向第一个关键字不小于 k 的元素(首个具有给定关键字的元素的位置)                |
    | c.upper_bound(k) | 返回一个迭代器，指向第一个关键字大于 k 的元素(最后一个匹配给定关键字的元素之后的位置)          |
    | c.equal_range(k) | 返回一个迭代器 pair，表示关键字等于 k 的元素的范围。若 k 不存在，pair 的两个成员均等于 c.end() |

  - **在**`multimap`**或**`multiset`**中查找元素**

    > 1、在一个**不允许重复关键字**的关联容器中**查找一个元素**是一件**很简单**的事情——**元素要么在**容器中，**要么不在**；但对于**允许重复关键字**的容器过程**更为复杂**：在容器中可能有**很多元素**具有**给定的关键字**  
    > 2、如果一个`multimap`或`multiset`中有**多个元素**具有**给定关键字**，则**这些元素**在容器中会**相邻储存**  
    > 3、例如，给定一个**从作者到书籍**的映射，我们可能想**打印一个特定作者的所有著作**，共有**三种方法**解决这个问题

    ```cpp
    // 最直观的方法：使用 find 和 count

    string search_item("Alain de Botton");        // 要查找的作者
    auto entries = authors.count(search_item);    // 元素的数量
    auto iter = authors.find(search_item);        // 作者的第一本书
    // 用一个循环来查找此作者的所有著作
    while(entries)
    {
        cout << iter->second << endl;             // 打印书籍名
        ++iter;                                   // 前进到下一本书
        --entries;                                // 记录已经打印了多少本书
    }
    ```

    ```cpp
    // 面向迭代器的解决方法：使用 lower_bound 和 upper_bound

    string search_item("Alain de Botton");        // 要查找的作者
    // beg 和 end 表示对应此作者的元素的范围
    for(auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; beg++)
        cout << beg->second << endl;              // 打印书籍名
    ```

    ```cpp
    // 最直接的方法：使用 euqal_range

    string search_item("Alain de Botton");        // 要查找的作者
    // pos 保存迭代器时，表示与关键字匹配的元素范围，是一个 pair
    for(auto pos = authors.equal_range(search_item); pos.first != pos.second; pos.first++)
        cout << pos.first->second << endl;        // 打印书籍名
    ```

- **示例：单词转换程序**

  - **需求描述**：向程序输入一段文字，将如下单词转换成对应单词

    ```
    where r u
    y dont u send me a pic
    k thk 18r
    ```

    ```
    where are you
    why dont you send me a picture
    okay? thanks! later
    ```

  - **单词转换程序**

    > 1、我们的程序将使用**三个函数**来实现这些功能  
    > 2、函数`word_transform`**管理整个过程**，它接受**两个**`ifstream`**参数**：第一个参数绑定到**单词转换规则文件**，第二个参数绑定到**要转换的文本文件**  
    > 3、函数`buildMap`会**读取转换规则文件**，并**创建一个**`map`，用于保存每个**单词到其转换内容**的**映射**  
    > 4、函数`transform`接受一个`string`，如果存在转换规则，**返回转换后的内容**

    ```cpp
    void word_transform(ifstream &map_file, ifstream &input)
    {
        auto trans_map = buildMap(map_file);        // 调用 buildMap，保存转换规则
        string text;                                // 保存输入中的每一行
        while(getline(input, text))                 // 读取一行输入
        {
            istringstream stream(text);             // 字符输入流，用于读取每个单词
            string word;
            bool firstword = true;                  // 控制是否打印空格
            while(stream >> word)                   // 读取一个单词
            {
                if(firstword)
                    firstword = false;
                else
                    cout << ' ';                    // 单词之间打印一个空格
                cout << transform(word, trans_map); // 调用 transform，翻译并输出
            }
            cout << endl;                           // 完成一行的转换，打印换行
        }
    }
    ```

    ```cpp
    map<string, string> buildMap(ifstream &map_file)
    {
        map<string, string> trans_map;              // 保存转换规则
        string key;                                 // 要转换的单词
        string value;                               // 替换后的内容
        // 读取第一个单词存入 key 中，行中剩余内容存入 value
        while(map_file >> key && getline(map_file, value))
            if(value.size() > 1)                    // 检查是否有转换规则
                trans_map[key] = value.substr(1);   // 跳过前导空格
            else
                throw runtime_error("no rule for" + key);
        return trans_map;
    }
    ```

    ```cpp
    const string &transform(const string &s, const map<string, string> &m)
    {
        // 实际的转换工作；此部分是程序的核心
        auto map_it = m.find(s);
        // 如果单词在转换规则 map 中
        if(map_it != m.cend())
            return map_it->second;                  // 使用替换短语
        else
            return s;                               // 否则返回原 string
    }
    ```

##### **无序容器**

- **介绍**

  > 1、新标准定义了**4 个无序关联容器**，这些容器**不使用比较运算符**来**组织元素**，而是使用一个**哈希函数**和**关键字类型的**`==`**运算符**  
  > 2、在关键字类型的元素**没有明显的序关系**的情况下，**无序容器**是非常有用的。在某些应用中，**维护元素的序代价非常高**时，**无序容器**也很有用  
  > 3、理论上**哈希技术**能获得**更好的平均性能**，但实际中还需要进行**性能测试和调优**。不过因此，使用**无序容器通常更为简单**，也有**更好的性能**

- **使用无序容器**

  > 1、除了**哈希管理**操作之外，**无序容器**还提供了**与有序容器相同的操作**(如`find`、`insert`等)  
  > 2、这意味着我们曾**用于**`map`**和**`set`**的操作也能用于**`unordered_map`**和**`unordered_set`。类似的，**无序容器**也有**允许重复关键字的版本**  
  > 3、因此，通常可以用一个**无序容器**替换对应的**有序容器**，反之亦然。但是由于元素**未按顺序存储**，其**输出**会**与有序容器的版本不同**

- **管理桶**

  > 1、**无序容器**在存储上组织为**一组桶**，**每个桶**保存**零个或多个元素**。**无序容器**使用一个**哈希函数**将**元素**映射到**桶**，为了**访问一个元素**，容器首先计算元素的**哈希值**，它指出**应该搜索哪个桶**  
  > 2、容器将具有**特定哈希值**的**所有元素**保存在**相同桶中**。如果容器**允许重复关键字**，所有**具有相同关键字的元素**也都会保存在**相同桶中**。因此，**无序容器的性能**依赖于**哈希函数的质量**和**桶的数量与大小**  
  > 3、对于**相同的参数**，**哈希函数**必须**总是产生相同结果**。理想情况下，**哈希函数**还能将每个**特定的值**映射到**唯一的桶**，但将**不同关键字的元素**映射到**相同的桶**也是**允许的**。当**一个桶保存多个元素时**，需要**顺序搜索**这些元素来**查找目标元素**  
  > 4、**无序容器**提供了一组**管理桶的函数**，如下表。它们将允许我们**查询容器状态**及必要时**强制容器进行重组**

  | 无序容器管理操作       | 描述                                                                                                 |
  | ---------------------- | ---------------------------------------------------------------------------------------------------- |
  | c.bucket_count()       | 正在使用的桶的数量                                                                                   |
  | c.max_bucket_count()   | 容器能容纳的最多的桶的数量                                                                           |
  | c.bucket_size(n)       | 第 n 个桶有多少个元素                                                                                |
  | c.bucket(k)            | 关键字为 k 的元素在哪个桶里                                                                          |
  | local_iterator         | 可以用来访问桶中元素的迭代器类型                                                                     |
  | const_local_iterator   | 桶迭代器的 const 版本                                                                                |
  | c.begin(n)，c.end(n)   | 桶 n 的首元素迭代器和尾后迭代器                                                                      |
  | c.cbegin(n)，c.cend(n) | 与前两个函数类型，返回 const_local_iterator                                                          |
  | c.load_factor()        | 每个桶的平均元素数量，返回 float 值                                                                  |
  | c.max_load_factor()    | c 试图维护的平均桶大小，返回 float 值。c 会在需要时添加新的桶，以使得 load_factor <= max_load_factor |
  | c.rehash(n)            | 重组存储，使得 bucket_count >= n 且 bucket_count > size/max_load_factor                              |
  | c.reserve(n)           | 重组存储，使得 c 可以保存 n 个元素且不必 rehash                                                      |

- **关键字类型要求**

  - **描述**

    > 1、默认情况下，**无序容器**使用**关键字类型的**`==`**运算符**来**比较元素**，他们还使用一个`hash<key_type>`**类型对象**来生成每个元素的**哈希值**  
    > 2、**标准库**为**内置类型**(包括指针)提供了`hash`**模板**，还为一些**标准库类型**(如`string`、智能指针等)定义了`hash`。因此，我们可以直接定义**关键字类型**是**内置类型**和**标准库类型**的**无序容器**  
    > 3、但是，我们**不能**直接定义**关键字类型**为**自定义类类型**的**无序容器**。与**容器**不同，不能直接使用**哈希模板**，而是**必须提供**我们**自己的**`hash`**模板版本**，我们将在后续介绍如何做到这点

  - **定义重载函数**

    > 1、我们**不使用默认的**`hash`，而是用另一种办法，类似于为**有序容器**重载**关键字类型的默认比较操作**  
    > 2、为了能将`Sales_data`**用作关键字**，我们需要**提供函数**来代替`==`**运算符**和**哈希值计算函数**。我们从定义这些**重载函数**开始，如下例  
    > 3、我们的`hasher`使用一个**标准库**`hash`**类型对象**来计算`ISBN`**成员**的**哈希值**，该`hash`**类型**建立在`string`**类型**之上。类似的，`eq0p`通过**比较**`ISBN`号来**比较两个**`Sales_data`  
    > 4、接着如下，我们使用**这些函数**来**定义一个**`unordered_multiset`

    ```cpp
    size_t hasher(const Sales_data &sd)
    {
        return hash<string>()(sd.isbn());
    }
    bool eq0p(const Sales_data &lhs, const Sales_data &rhs)
    {
        return lhs.isbn() == rhs.isbn();
    }

    using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eq0p)*>;
    // 参数是桶大小、哈希函数指针 和 相等性判断运算符指针
    SD_multiset bookstore(42, hasher, eq0p);
    ```

---

#### **动态内存**

---

<div class="success">

> **章节概要**：动态内存与智能指针；`shared_ptr`类(智能指针)；定义与使用智能指针；智能指针操作；`make_shared`函数；`shared_ptr`的拷贝与赋值；`shared_ptr`的销毁与释放；设计使用动态生存期资源的类；直接管理内存(动态内存指针)；`new`动态分配和初始化对象；`delete`释放内存；结合使用与异常；`shared_ptr`和`new`结合使用；智能指针和异常；自定义的释放；其他智能指针；`unique_ptr`类；

</div>

##### **动态内存与智能指针**

- **引入**

  > 1、我们的程序到目前为止只使用过**静态内存**或**栈内存**。**静态内存**用来保存**局部**`static`**对象**、**类**`static`**数据成员**以及**定义在任何函数外的变量**；**栈内存**用来保存**定义在函数内**的**非**`static`**对象**  
  > 2、分配在**静态内存**或**栈内存**中的对象**由编译器自动创建和销毁**。对于**栈对象**，仅在其**定义的程序块运行时**才存在；而`static`**对象**在**使用之前分配**，**程序结束时销毁**  
  > 3、除了**静态内存**和**栈内存**，每个程序还拥有一个**内存池**，这部分内存被称作**自由空间**或**堆**。程序用**堆**来存储**动态分配的对象**(即程序运行时分配的对象)  
  > 4、**动态对象**的**生存期由程序控制**，也就是说，当**动态对象不使用时**，代码必须**显式地销毁它们**。虽然使用**动态内存**有时是必要的，但正确地**管理动态内存**是非常棘手的

- **动态内存**

  > 1、**动态内存的管理**是通过**一对运算符**来完成的：`new`在**动态内存**中为对象**分配空间**并**返回指向该对象的指针**，我们可以选择对对象进行**初始化**；`delete`接受一个**动态对象指针**，**销毁该对象**并**释放关联的内存**  
  > 2、**动态内存的使用**很容易出问题，因为确保**在正确的时机释放内存**是十分困难的。有时我们会**忘记释放内存**，就会产生**内存泄漏**；有时在**尚有指针引用内存时释放**，就会产生**引用非法内存的指针**

- **智能指针**

  > 1、为了**更安全便捷**地使用**动态内存**，新的标准库提供了两种**智能指针类型**来**管理动态对象**，它们都定义在`memory`**头文件**中  
  > 2、**智能指针**的行为**类似常规指针**，重要的区别是它负责**自动释放所指向的对象**  
  > 3、新标准库提供的**两种智能指针**区别在于**管理底层指针的方式**：`shared_ptr`允许**多个指针指向同个对象**，`unique_ptr`则**独占所指向的对象**  
  > 4、标准库还定义了一个**名为**`weak_ptr`**的伴随类**，它是一种**弱引用**，**指向**`shared_ptr`**所管理的对象**

##### **shared_ptr 类(智能指针)**

- **定义与使用智能指针**

  > 1、类似于`vector`，**智能指针**也是**模板**。因此，当我们**创建智能指针**时，必须**在尖括号内**提供**额外的信息**，即提供**指针指向的类型**  
  > 2、**默认初始化**的**智能指针**中保存着一个**空指针**，我们将在后续介绍**初始化智能指针**的其他方法  
  > 3、智能指针**使用方式与普通指针类似**，**解引用**一个智能指针**返回它指向的对象**。如果在一个**条件判断中使用智能指针**，效果为**检测它是否为空**

  ```cpp
  shared_ptr<string> p1;        // shared_ptr，可以指向 string
  shared_ptr<list<int>> p2;     // shared_ptr，可以指向 int 的 list

  if(p1 && p1 -> empty())       // 如果智能指针 p1 不为空，其指向的 string 对象也不为空
    *p1 = "hi";                 // 解引用 p1，将一个新值赋予 string 对象
  ```

- **智能指针操作**

  | 智能指针通用的操作                 | 描述                                                                                                    |
  | ---------------------------------- | ------------------------------------------------------------------------------------------------------- |
  | shared_ptr<T> sp，unique_ptr<T> up | 空智能指针，可以指向类型为 T 的对象                                                                     |
  | p                                  | 将 p 用作一个条件判断，若 p 指向一个对象(即 p 不为空)，则为 true                                        |
  | \*p                                | 解引用 p，得到它指向的对象                                                                              |
  | p->mem                             | 等价于(\*p).mem                                                                                         |
  | p.get()                            | 返回 p 中保存的指针(内置指针类型)。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
  | swap(p, q)，p.swap(q)              | 交换 p 和 q 中的指针                                                                                    |

  | shared_ptr 独有的操作 | 描述                                                                                                                                            |
  | --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
  | make_shared<T>(args)  | 返回一个 shared_ptr，指向一个动态分配的类型为 T 的对象。使用 args 初始化此对象                                                                  |
  | shared_ptr<T> p(q)    | p 是 shared_ptr q 的拷贝；此操作会递增 q 中的引用计数器。q 中的指针必须能转换为 T\*                                                             |
  | p = q                 | p 和 q 都是 shared_ptr，所保存的指针必须能相互转换。此操作会递减 p 的引用计数，递增 q 的引用计数；若 p 的引用计数变为 0，则将其管理的原内存释放 |
  | p.use_count()         | 返回与 p 共享对象的智能指针的数量；可能很慢，主要用于调试                                                                                       |
  | p.unique()            | 若 p.use_count() 为 1，返回 true，否则返回 false                                                                                                |

- **make_shared 函数**

  > 1、**最安全**的**分配和使用动态内存**的方法是调用`memory`**头文件**中定义的`make_shared`函数：`make_shared<T>(args)`  
  > 2、该函数在**动态内存**中**分配一个对象**并**初始化**，返回**指向此对象的**`shared_ptr`  
  > 3、当要用`make_shared`时，必须**指定要创建的对象的类型**，定义方式与**模板**类似  
  > 4、类似于**顺序容器**的`emplace`**成员函数**，`make_shared`也可以用其参数来**构造给定类型的对象**，在其后面的**小括号**中**给出参数**调用该类的**构造函数**。如果不传递任何参数，则会进行**值初始化**  
  > 5、我们通常用`auto`**定义一个对象**保存`make_shared`的结果，这种定义方法比较简单

  ```cpp
  // 指向一个值为 42 的 int 的 shared_ptr
  shared_ptr<int> p1 = make_shared<int>(42);
  // 指向一个值为 "9999999999" 的 string
  shared_ptr<string> p2 = make_shared<string>(10, '9');
  // 指向一个值初始化的 int，即值为 0
  shared_ptr<int> p3 = make_shared<int>();

  // 使用 auto 定义对象更方便地保存结果
  // p4 指向一个动态分配的空 vector<string>
  auto p4 = make_shared<vector<string>>();
  ```

- **shared_ptr 的拷贝与赋值**

  > 1、当进行**拷贝或赋值**操作时，每个`shared_ptr`都会**记录有多少个其他**`shared_ptr`**指向相同的对象**  
  > 2、我们可以认为，每个`shared_ptr`都有一个**关联的计数器**，通常称其为**引用计数**。无论何时我们**拷贝一个**`shared_ptr`，**计数器就会递增**  
  > 3、例如，当用一个`shared_ptr`**初始化另一个**`shared_ptr`时，或将它**作为参数传递**给一个函数时，或**作为函数返回值**时，它所关联的**计数器就会递增**。反之，当我们给`shared_ptr`**赋予新值**，或者**某个**`shared_ptr`**被销毁**，**计数器就会递减**  
  > 4、一旦一个`shared_ptr`的**计数器变为 0**，它就会**自动释放自己所管理的对象**

  ```cpp
  auto p = make_shared<int>(42);    // p 指向的对象只有 1 个引用者
  auto q(p);                        // q 和 p 指向相同对象，此对象有 2 个引用者

  auto r = make_shared<int>(30);    // r 指向的对象只有 1 个引用者
  r = q;                            // 给 r 赋值，令它指向另一个地址
  // 此时，将递增 q 指向对象的引用计数，递减 r 原先指向对象的引用计数
  // 而 r 原先指向的对象的引用计数变为 0，没有引用者，将自动释放内存
  ```

- **shared_ptr 的销毁与释放**

  - **析构函数与销毁对象**

    > 1、当**指向一个对象**的**最后一个**`shared_ptr`**被销毁**时，`shared_ptr`会**自动销毁此对象**。它是通过另一个**特殊的成员函数**——**析构函数**完成**销毁工作**的  
    > 2、类似于**构造函数**，**每个类**都有一个**析构函数**。就像**构造函数**控制**对象初始化**一样，**析构函数**控制**对象销毁时做的操作**  
    > 3、**析构函数**一般用来**释放对象所分配的资源**。例如`string`的**构造函数**会**分配内存**来保存字符，而`string`的**析构函数**就负责**释放这些内存**  
    > 4、`shared_ptr`的**析构函数**会**递减**它指向的对象的**引用计数**，当**引用计数变为 0**，**析构函数**就会**销毁对象**，并**释放内存**

  - `shared_ptr`**能自动释放相关联的内存**

    > 1、当**动态内存不再使用时**，`shared_ptr`**类**会**自动释放动态对象**，这一特性使得**动态内存的使用**变得十分容易，如下例  
    > 2、由于**最后一个**`shared_ptr`**销毁前**内存都**不会释放**，所以**保证**`shared_ptr`**无用后销毁**十分重要。如果**忘记销毁无用的**`shared_ptr`，程序仍能**正确执行**，但会**浪费内存**  
    > 3、`shared_ptr`**无用后仍保留**的一种可能情况是：将`shared_ptr`**存放在一个容器中**，随后**重排了容器**，从而**不再需要某些元素**。这种情况下，应确保及时手动**用**`erase`**删除无用的**`shared_ptr`

    ```cpp
    // 该函数返回一个 shared_ptr，指向一个 Foo 类型的动态分配对象，对象通过一个类型为 T 的参数 arg 初始化
    shared_ptr<Foo> factory(T arg)
    {
        return make_shared<Foo>(arg);
    }

    void use_factory(T arg)
    {
        shared_ptr<Foo> p = factory(arg);
        // ...此处省略使用 p 的代码
    }   // p 离开了作用域，它指向的内存会被自动释放

    shared_ptr<Foo> use_factory2(T arg)
    {
        shared_ptr<Foo> p = factory(arg);
        // ...此处省略使用 p 的代码
        return p;     // 返回 p 时，引用计数递增
    }   // p 离开了作用域，但引用递增不为 0，不会被销毁
    ```

- **设计使用动态生存期资源的类**

  - **使用动态内存的场景**

    > 1、程序不知道**自己需要使用多少对象**  
    > 2、程序不知道**所需对象的准确类型**  
    > 3、程序需要在**多个对象间共享数据**

  - **因共享数据而使用动态内存的情景**

    > 1、**容器类**是出于上述**第一种原因**而使用**动态内存**的典型例子；我们还将在**第 15 章**见到出于**第二种原因**而使用**动态内存**的例子；而在此，我们将举出因**第三种原因**而使用**动态内存**的例子  
    > 2、到目前为止，我们**使用过的类**中，**分配的资源**具有**与原对象一致的生存期**。例如每个`vector`都**拥有**自己的**元素**，当我们**拷贝**`vector`时，**原**`vector`和**副本**`vector`中的**元素是相互分离的**。此外，一个`vector`**的元素**只有当这个`vector`**还存在时才存在**，当`vector`**被销毁**，则**对应元素也销毁**  
    > 3、但**某些类**中，**分配的资源**具有**与原对象相独立的生存期**。例如，假设我们希望**定义一个名为**`Blob`**的类**，保存一组元素。与容器不同，我们希望`Blob`**对象**的**不同拷贝**之间**共享相同的元素**。即，当我们**拷贝一个**`Blob`**元素**时，**原**`Blob`和**副本**`Blob`应该**引用相同的底层元素**  
    > 4、一般而言，如果**两个对象共享底层的数据**，当**某个对象被销毁**时，不能**单方面销毁底层数据**。此外，**允许多个对象共享相同的状态**是**使用动态内存**的一个很常见的原因

    ```cpp
    Blob<string> b1;                              // 空 blob
    // 任意一个新作用域
    {
        Blob<string> b2 = {"a", "an", "the"};
        b1 = b2;                                  // b1 和 b2 共享相同的元素
    }
    // 此时 b2 由于离开作用域而被销毁，但其元素不能被销毁，因为 b1 仍指向这些元素
    ```

  - **定义**`StrBlob`**类**

    > 1、由于后续才会学习**模板**有关内容，因此现在我们先定义一个**管理**`string`**的类**，命名为`StrBlob`，如下例  
    > 2、实现一个新的**集合类型**的最简单方法是**使用某个标准库容器来管理元素**。采用这种方法，我们可以借助**标准库类型**管理**元素所使用的内存**。本例中，我们将**使用**`vector`**保存元素**。但是，我们不能在一个`Blob`**对象**内**直接保存**`vector`，因为一个**对象的成员**在**对象销毁时**也会**被销毁**。为了保证**元素继续存在**，我们将`vector`保存在**动态内存**中  
    > 3、为了实现我们希望的**数据共享**，我们为每个`StrBlob`设置了一个`shared_ptr`来**管理动态分配的**`vector`，使用**动态指针**能自动完成对`vector`的**管理与释放**。此外，我们还需要为**类**定义一些**操作**和**构造函数**

    ```cpp
    #include <initializer_list>
    #include <iostream>
    #include <memory>
    #include <string>
    #include <vector>

    using std::initializer_list;
    using std::make_shared;
    using std::shared_ptr;
    using std::string;
    using std::vector;

    class StrBlob
    {
        public:
            // 定义类型
            using size_type = vector<string>::size_type;

            // 构造函数(使用初始化列表构造)
            StrBlob() : data(make_shared<vector<string>>())
            {
            }
            StrBlob(initializer_list<string> il) : data(make_shared<vector<string>>(il))
            {
            }

            // 成员函数，其中 data-> 实际上就是使用 vector 的成员函数
            size_type size() const
            {
                return data->size();
            }
            bool empty() const
            {
                return data->empty();
            }
            // 添加或删除元素
            void push_back(const string &t)
            {
                data->push_back(t);
            }
            void pop_back();
            // 元素访问
            string &front();
            string &back();

        private:
            // 动态指针操控的动态内存数据成员
            shared_ptr<vector<string>> data;
            // 检查操作，如果 data[i] 不合法，抛出一个异常
            void check(size_type i, const string &msg) const;
    };
    ```

  - **元素访问成员函数**

    > 1、由于要使用`pop_back`、`front`、`back`**操作访问**`vector`**中的元素**，且它们在**访问元素前**都必须**检查元素是否存在**，因此我们定义了一个名为`check`的`private`**工具函数**，用于**检查给定索引是否在合法范围内**。该函数还**接受一个**`string`，会将此参数传递给**异常处理程序**，`string`用于**描述错误内容**  
    > 2、`pop_back`和**元素访问成员函数**首先调用`check`，如果`check`成功，再继续**利用底层**`vector`**的操作**完成自己的工作

    ```cpp
    void StrBlob::check(size_type i, const string &msg) const
    {
        if (i >= data->size())
            throw std::out_of_range(msg);
    }

    string &StrBlob::front()
    {
        // 如果 vector 为空，check 会抛出一个异常
        check(0, "front on empty StrBlob");
        return data->front();
    }

    string &StrBlob::back()
    {
        // 如果 vector 为空，check 会抛出一个异常
        check(0, "back on empty StrBlob");
        return data->back();
    }

    void StrBlob::pop_back()
    {
        // 如果 vector 为空，check 会抛出一个异常
        check(0, "pop_back on empty StrBlob");
        data->pop_back();
    }
    ```

  - `StrBlob`**的拷贝、赋值和销毁**

    > 1、类似先前设计的`Sales_data`**类**，`StrBlob`**类**也使用**默认版本**的拷贝、赋值和销毁**成员函数**来对**此类对象**进行**这些操作**  
    > 2、我们的`StrBlob`只有一个**数据成员**，它是`shared_ptr`类型。因此当我们对`StrBlob`**对象**执行这些操作时，它的`shared_ptr`**成员**就会被执行这些操作  
    > 3、如前所述，使用了**智能指针**，其会**自动统计引用计数**，且会在**引用计数为 0**时**自动销毁**

##### **直接管理内存(动态内存指针)**

- **new 动态分配和初始化对象**

  - `new`**的使用**

    > 1、**C++**定义了两个运算符来**分配和释放动态内存**：`new`**分配内存**，`delete`**释放内存**。但相对于**智能指针**，这两个运算符**非常容易出错**；而且，**自己直接管理内存的类**和**使用智能指针的类**不同，它们**不能依赖类对象**进行拷贝、赋值和销毁操作的**任何默认定义**  
    > 2、在**自由空间**分配的内存是**无名的**，因此`new`**无法为其分配的对象命名**，而是返回一个**指向该对象的指针**(动态内存指针/内置指针)。默认情况下，**动态分配**的对象是**默认初始化**的，此外我们也可以用其他一些通用的初始化方式  
    > 3、对于**定义了自己的构造函数**的**类类型**，要求**值初始化**是**没有意义**的，不管采用什么形式，对象都会通过**默认构造函数**来**初始化**；但对于**内置类型**，两种形式就差别较大了，**值初始化**的**内置类型对象**有着**已定义良好的值**，而**默认初始化**的对象的**值是未定义的**；类似的，对于类中依赖于**编译器合成的默认构造函数**的**内置类型成员**，如果它们**未在类内初始化**，那么它们的**值也是未定义的**  
    > 4、出于与**变量初始化**相同的原因，对**动态分配的对象**进行**初始化**通常总是个好主意

    ```cpp
    int *pi = new int;                    // pi 指向一个动态分配的、未初始化的无名 int 对象
    string *ps = new string;              // 初始化为空 string

    int *pi2 = new int(1024);             // pi2 指向的对象的值为 1024
    string *ps2 = new string(10, '9');    // ps2 指向的对象的值为 "9999999999"
    vector<int> *pv2 = new vector<int>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    string *ps3 = new string;             // 默认初始化为空的 string
    string *ps4 = new string();           // 值初始化为空的 string
    int *pi3 = new int;                   // 默认初始化，但 *pi3 的值未定义
    int *pi4 = new int();                 // 值初始化为 0，即 *pi4 的值为 0
    ```

  - **有关**`auto`**和**`const`

    > 1、如果我们提供了一个**小括号包括**的**初始化器**，就可以使用`auto`从该**初始化器**来推断我们**想要分配的对象的类型**  
    > 2、由于编译器要用**初始化器的类型**来推断**分配的类型**，只有当括号中**仅有单一初始化器**时才可以使用`auto`  
    > 3、用`new`分配`const`**对象**是**合法的**。类似于其他任何`const`**对象**，一个**动态分配**的`const`**对象必须进行初始化**，且由于**分配的对象**是`const`的，其返回的指针也是**指向**`const`**的指针**  
    > 4、对于一个定义了**默认构造函数**的**类类型**，其`const`**动态对象**可以**隐式初始化**，而**其他类型的对象**必须**显式初始化**

    ```cpp
    // p 指向一个与 obj 类型相同的对象，该对象用 obj 进行值初始化
    auto p1 = new auto(obj);
    // 错误：括号中只能有单个初始化器
    auto p2 = new auto(a, b, c);

    // 分配并初始化一个 const int
    const int *pci = new const int(1024);
    // 分配并默认初始化一个 const 的空 string
    const string *pcs = new const string;
    ```

  - **内存耗尽**

    > 1、虽然现代计算机通常都配备了大容量内存，但**自由空间被耗尽**的情况还是**有可能发生**。一旦一个程序**用光了所有可用内存**，`new`**就会失败**，并且默认情况下**抛出类型为**`bad_alloc`**的异常**  
    > 2、我们可以改变使用`new`的方式来**阻止它抛出异常**(如下)，我们称**这种形式**的`new`为**定位 new**，**定位 new**允许我们**向**`new`**传递额外的参数**  
    > 3、在此例中，我们传递给它一个**标准库定义的**`nothrow`**对象**，意图是告诉它**不抛出异常**。这种形式的`new`如果**不能分配内存**，就会**返回一个空指针**  
    > 4、`bad_alloc`和`nothrow`都定义在**头文件**`new`中

    ```cpp
    int *p1 = new int;                // 如果分配失败，抛出 std::bad_alloc 异常
    int *p2 = new (nothrow) int;      // 如果分配失败，不抛出异常，返回空指针
    ```

- **delete 释放内存**

  - **释放动态内存**

    > 1、为了防止**内存耗尽**，在**动态内存使用完毕**后，必须将其**归还给系统**。我们通过`delete`来将**动态内存归还**  
    > 2、`delete`接受一个**指针**，指向我们想要**释放的对象**：`delete p;`(p 必须指向动态分配对象或空指针)  
    > 3、与`new`类似，`delete`也执行**两个动作**：**销毁对象**和**释放内存**

  - **指针值与**`delete`

    > 1、我们传递给`delete`的指针必须指向**动态分配的内存**或是**空指针**。释放一块并非`new`分配的内存，或者将相同指针值释放多次，其**行为未定义**  
    > 2、如下例，对于`delete i;`的请求，**编译器**会**生成错误信息**，因为**编译器知道 i 不是一个指针**。但对于`pi1`**和**`pi2`**所产生的错误**却更具有**潜在危害**：  
    > 3、通常情况下，**编译器不能分辨**一个指针指向的是**静态分配**还是**动态分配**的对象，类似的，它**也不能分辨**一个指针所指向的**内存是否已经释放**了。对于这些`delete`，大多数**编译器**会**编译通过**，但它们**本身是错误的**  
    > 4、虽然一个`const`对象的值**不能被改变**，但它本身**可以被销毁**

    ```cpp
    // i 是整型，pi1 是整型静态指针，pi2 是空指针
    int i, *pi1 = &i, *pi2 = nullptr;
    // pd 指向动态分配的 double 对象，pd2 与 pd 指向相同动态对象
    double *pd = new double(33), *pd2 = pd;

    delete i;               // 错误：i 不是一个指针
    delete pi1;             // 未定义：pi1 指向一个局部变量(不是动态对象)
    delete pi2;             // 正确，可以释放空指针
    delete pd;              // 正确
    delete pd2;             // 未定义：pd2 指向的内存已经被释放了

    const int *pci = new const int(1024);
    delete pci;             // 正确，可以释放 const 动态对象
    ```

  - **生存期直到被释放**

    > 1、如前所述，由`shared_ptr`**管理的内存**在最后一个`shared_ptr`销毁时**会自动释放**，但对于**动态内存指针**来说就不是这样了，其在被**显式释放**之前**始终存在**  
    > 2、返回**指向动态内存的指针**的**函数**给其调用者增加了一个**额外负担**——调用者必须记得**释放内存**  
    > 3、如下例，我们**重写**之前已定义的`factory`和`use_factory`**函数**，必须做如下修改

    ```cpp
    // factory 返回一个指针，指向一个动态分配的对象
    Foo *factory(T arg)
    {
        // ...此处省略处理 arg 的代码
        return new Foo(arg);                // 调用者必须负责释放此内存
    }

    void use_factory(T arg)
    {
        Foo *p = factory(arg);              // 调用了 factory，就必须记得释放 p 的内存
        // ... 此处省略使用 p 的代码
        delete p;                           // 如果已经不再需要 p，必须释放掉 p 的内存
    }   // 如果忘记 delete 的话，即使离开了作用域，p 的内存仍然没有被释放
    ```

  - `delete`**后重置指针值**

    > 1、当我们`delete`一个指针后，**指针值**就变得**无效**了。虽然指针已经无效，但在很多机器上**指针仍然保存着动态内存的地址**，这被称为**空悬指针**  
    > 2、**未初始化指针**的所有缺点**空悬指针**都有(例如由于数据被释放，地址指向的数据未定义，但指针仍可能被不知情地调用)。有一种办法可以**避免空悬指针**的问题：在指针即将**离开作用域之前释放内存**，这样在**关联内存被释放**后就没有机会继续使用指针了  
    > 3、如果我们需要**保留指针**，可以在`delete`后将`nullptr`**赋予指针**，这样就清楚地指出**指针不指向任何对象**  
    > 4、**动态内存**的一个基本问题是**可能多个指针指向相同内存**。在`delete`后**重置指针**的方法只对**被直接操作重置的指针**有效，对于其他**指向相同内存的指针**无效。在实际系统中，查找**指向相同内存**的**所有指针**是**异常困难**的，因此**查找所有指针**再依次**重置指针值**也是很难实现的

    ```cpp
    int *p(new int(42));        // p 指向动态内存
    auto q = p;                 // q 和 p 指向相同内存
    delete p;                   // p 和 q 都变得无效
    p = nullptr;                // 重置 p 指出其不再绑定到任何对象
    // q 并没有被重置，q 仍然是一个空悬指针
    ```

##### **结合使用与异常**

- **shared_ptr 和 new 结合使用**

  - **有关结合使用**

    > 1、如前所述，如果我们**不初始化**一个**智能指针**，它就会被初始化为一个**空指针**，借此我们还可以用`new`**返回的指针**来**初始化智能指针**  
    > 2、**接受指针参数**的**智能指针构造函数**是`explicit`的，因此我们不能将一个**内置指针**通过**隐式转换**变成**智能指针**，必须使用**直接初始化**来**初始化智能指针**  
    > 3、出于相同的原因，也不能在一个**返回**`shared_ptr`**的函数**的返回语句中**隐式转换普通指针**，必须将`shared_ptr`**显式绑定**到一个**想要返回的指针**上

    ```cpp
    shared_ptr<double> p1;                      // p1 可以指向一个 double，目前指向空指针
    shared_ptr<int> p2(new int(42));            // 正确：使用直接初始化，p2 指向一个值为 42 的 int
    shared_ptr<int> p3 = new int(1024);         // 错误：必须使用直接初始化形式

    shared_ptr<int> clone(int p)
    {
        return new int(p);                      // 错误：不能隐式转换为 shared_ptr<int>
        return shared_ptr<int>(new int(p));     // 正确：显式地用 int* 创建 shared_ptr<int>
    }
    ```

    | 定义和改变 shared_ptr 的方法         | 描述                                                                                                                                                               |
    | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | shared_ptr<T> p(q)                   | p 管理内置指针 q 所指向的对象。q 必须要指向 new 分配的内存，且能够转换为 T\* 类型                                                                                  |
    | shared_ptr<T> p(u)                   | p 从 unique_ptr u 那里接管了对象的所有权，将 u 置空                                                                                                                |
    | shared_ptr<T> p(q, d)                | p 接管了内置指针 q 所指向对象的所有权。q 必须能转换为 T\* 类型，p 将使用可调用对象 d(`lambda`表达式或对象)来代替 delete                                            |
    | shared_ptr<T> p(p2, d)               | 与 p(p2) 类似，p 是 p2 的拷贝，但 p 将用可调用对象 d 代替 delete                                                                                                   |
    | p.reset()，p.reset(q)，p.reset(q, d) | 若 p 是唯一指向其对象的 shared_ptr，reset 会释放此对象。若传递了可选的参数内置指针 q，会令 p 指向 q，否则将 p 置空。若还传递了参数 d，将用可调用对象 d 代替 delete |

  - **不要混合使用普通指针和智能指针**

    > 1、`shared_ptr`可以**协调对象的析构**，但仅限于其**自身的拷贝**，这也是**推荐使用**`make_shared`**而不是**`new`的原因。这样，我们就能在**分配对象**同时将`shared_ptr`**与之绑定**，避免无意中将**同一块内存**绑定到**多个独立创建的**`shared_ptr`上  
    > 2、考虑下例的函数。虽然**不能传递给**`process`**内置指针**，但可以传递一个**临时的**`shared_ptr`，它是用一个**内置指针显式构造**的，但是这样做**可能会导致错误**。当**调用结束**，**临时对象**会**被销毁**，但**原先的指针**仍指向**已释放的内存地址**，成为**空悬指针**

    ```cpp
    void process(shared_ptr<int> ptr)
    {
        // 使用 ptr
    }   // ptr 离开作用域，被销毁

    shared_ptr<int> p(make_shared<int>(42));  // 创建 p，此时引用计数为 1
    process(p);                               // 拷贝 p 会递增它的引用计数，在 process 中引用计数为 2
    int i = *p;                               // 正确：离开函数时引用计数为 1，没有被销毁

    // 显式构造临时的 shared_ptr
    int *x(new int(1024));                    // 危险：x 是一个普通指针，不是一个智能指针
    process(x);                               // 错误：不能将 int* 转换成一个 shared_ptr<int>
    process(shared_ptr<int>(x));              // 合法，但内存会被释放
    int j = *x;                               // 未定义：x 是一个空悬指针
    ```

  - **不要用**`get`**初始化另一个智能指针或为其赋值**

    > 1、**智能指针**类型定义了一个`get`**函数**(前表中提过)，它返回一个**内置指针**，指向智能指针**管理的对象**  
    > 2、此函数是为了向**不能使用智能指针的代码**中传递一个**内置指针**的情况而设计的，使用`get`返回的指针的代码**不能**`delete`**此指针**  
    > 3、虽然**编译器不会给出错误**，但将**另一个智能指针**也**绑定到**`get`**返回的指针**上是**错误**的

    ```cpp
    shared_ptr<int> p(new int(42));           // 此时引用计数为 1
    int *q = p.get();                         // 正确：q 是内置指针，但使用 q 时要注意，不要让它被管理的指针被释放
    // 新程序块
    {
        shared_ptr<int>(q);                   // 未定义：两个独立的 shared_ptr 指向相同的内存
    }   // 程序块结束，q 被销毁，它指向的内存被释放
    int foo = *p;                             // 未定义：p 指向的内存已经被释放了
    ```

  - **其他**`shared_ptr`**操作**

    > 1、`shared_ptr`还定义了**其他一些操作**(具体看前表)，比如我们可以**用**`reset`**将一个新指针赋予一个**`shared_ptr`  
    > 2、与赋值类型，`reset`会**更新引用计数**，需要时会**释放 p 指向的对象**。因此，`reset`常常和`unique`一起使用，`unique`检查**智能指针**的**引用计数是否为 1**，这样便可以**控制多个**`shared_ptr`**共享的对象**  
    > 3、在**改变底层对象**之前，我们检查自己是否是**当前对象仅有的用户**(使用`unique`)；如果不是，在改变之前要**制作一份新的拷贝**以**保证其他用户正常指向当前内存**

    ```cpp
    shared_ptr<int> p;
    p = new int(1024);                        // 错误：不能将一个指针赋予 shared_ptr
    p.reset(new int(1024));                   // 正确：p 指向一个新对象

    if(!p.unique())
        p.reset(new int(*p));                 // 我们不是唯一用户，分配新的拷贝(通过 new 拷贝 p 的值到新的地址)
    *p += newVal;                             // 现在我们知道自己是唯一用户，可以改变对象的值
    ```

- **智能指针和异常**

  - **发生异常时的内存释放**

    > 1、先前介绍过**异常处理程序**能在**异常发生后**令**程序流程继续**，我们注意到这种程序**需要确保**异常发生后**资源能够被正确释放**  
    > 2、一个简单的**确保资源被释放**的方式是**使用智能指针**，这样即使**程序块过早结束**，**智能指针类**也能确保**内存不再需要时被释放**。如下函数，无论函数**正常处理退出**，还是**发生异常退出**，**局部对象**都会**被销毁**  
    > 3、与之相对，**发生异常时**我们**直接管理的内存**是**不会自动释放**的。如果**在**`new`**和**`delete`**之间发生异常**，且异常**未被捕获**，则内存就**永远不会被释放**了。在函数`f2`之外**没有指针指向这块内存**，因此就**无法释放**了

    ```cpp
    void f1()
    {
        shared_ptr<int> sp(new int(42));      // 分配一个新对象
        // 这段代码抛出异常，且在 f1 中未被捕获
    }   // 函数结束后，shared_ptr自动释放内存

    void f2()
    {
        int *ip = new int(42);                // 动态分配一个新对象
        // 这段代码抛出异常，且在 f2 中未被捕获
        delete ip;                            // 在退出之前释放内存
    }
    ```

  - **智能指针和哑类**

    > 1、包括所有**标准库类**在内的很多**C++类**都定义了**析构函数**，负责**清理对象使用的资源**，但并**不是所有类都有**这样的**良好定义**。特别是那些为**C**和**C++**两种语言设计的类，通常都要求用户**显式地释放所使用的任何资源**  
    > 2、那些**分配了资源**，却**没有定义析构函数**释放资源的类，可能遇到与**使用动态内存**相同的错误——**忘记释放资源**。类似的，如果**资源分配和释放**之间**发生异常**，也会发生**资源泄露**  
    > 3、与**管理动态内存**类似，我们可以使用**类似的技术**来**管理这些类**。例如下面一段**使用网络库**的代码，如果`connection`有**析构函数**，就可以在`f`结束时**自动关闭链接**，但它没有  
    > 4、这个问题与**上一个程序**中使用`shared_ptr`**避免内存泄漏**等价，**使用**`shared_ptr`**来保证**`connection`**被正确关闭**，已被证明是一种**有效的方法**

    ```cpp
    struct destination;                       // 表示正在连接什么
    struct connection;                        // 使用连接所需的信息
    connection connect(destination*);         // 打开链接
    void disconnect(connection);              // 关闭给定链接

    void f(destination &d /* 其他参数 */)
    {
        connection c = connect(&d);           // 获得链接，但要使用后关闭
        // ...使用连接
        // 如果退出 f 前忘记调用 disconnect，就无法关闭 c 了
    }
    ```

  - **使用自定义的释放操作**

    > 1、默认情况下，`shared_ptr`假定它们指向的是**动态内存**，因此**当其被销毁时**默认对它管理的内存**执行**`delete`**操作**  
    > 2、为了用`shared_ptr`管理一个`connection`，必须**自定义一个函数**来代替`delete`。这个**删除器函数**必须能完成**对**`shared_ptr`**中保存的指针进行释放**的操作  
    > 3、在本例中，我们的**删除器**必须接受**单个类型为**`connection`**的参数**。改写`f`函数，当创建一个`shared_ptr`时，可以传递一个可选的**指向删除器函数**的**参数**

    ```cpp
    void end_connection(connection *p)
    {
        disconnect(*p);                                 // 调用上面写好的关闭函数
    }

    void f(destination &d /* 其他参数 */)
    {
        connection c = connect(&d);
        shared_ptr<connection> p(&c, end_connection);   // 传递第二个指向删除器函数的参数
        // ...使用连接
        // 当 f 退出时(即使因为异常)，connection 会被正确关闭
    }
    ```

##### **其他智能指针**

- **unique_ptr 类** 

---

#### **页底评论**

---
