---
title: Cpp基础教程
author: 圣奇宝枣
description: 有关于C++的基础教程，该教程建立在学习过C语言的基础上，进行对比学习，了解不同的特性和更多新内容
sticky: 2
date: 2022-12-03
updated: 2023-01-25
readmore: true
tags:
  - C++
  - 基础语法
categories:
  - 编程语言入门
---

---

_注：该教程建立在学习过 C 语言的基础上，因此很多提过的细节会忽略，主要学习一些 C 语言没有或不同的特性，建议先学习[C 语言基础教程](https://www.shengqibaozao.eu.org/2022/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/?t=1670037021388)_

_此外本文章中没有特殊重申的，大多语句和特性都与 C 语言相同，C++是 C 的超集，兼容了 C 的大多数特性_

---

#### **开始**

---

<div class="success">

> **章节概要**：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介

</div>

<!-- more -->

##### **编写一个简单的 C++程序**

- **简单示例**

  ```cpp
  // 相比C代码，可以省略main(void)的void
  int main()
  {
      return 0;
  }
  ```

##### **初识输入输出**

- **程序示例**

  ```cpp
  #include <iostream>
  int main()0
  {
      std::cout << "Enter two numbers!" << std::endl;
      int v1, v2;
      std::cin >> v1 >> v2;
      std::cout << "The sum of them is " << v1 + v2;
      return 0;
  }
  ```

- **C++的 IO 机制**

  > 1、**C++**包含了一个全面的**标准库**来提供**IO 机制**。其中有**从 C 语言延续而来**的`cstdio`库和**新的**`iostream`库  
  > 2、`iostream`库包含**两个基础类型**：`istream`和`ostream`，分别表示**输入流**和**输出流**  
  > 3、一个**流**(stream)就是一个**字符序列**，是**从 IO 设备读出**或**写入 IO 设备**的

- **标准输入输出对象**

  > 1、标准库定义了 4 个**IO 对象**  
  > 2、为了**处理输入**，我们使用名为`cin`的`istream`类型对象，这个对象也被称为**标准输入**  
  > 3、对于**处理输出**，我们使用名为`cout`的`ostream`类型对象，这个对象也被称为**标准输出**  
  > 4、此外还有其他两个`ostream`类型对象，名为`cerr`和`clog`。其中`cerr`通常用来**输出警告和错误信息**，`clog`用来**输出程序运行时的一般性信息**

- **向流写入写出**

  > 1、如果需要使用`iostream`**库中的对象**进行**输入输出**，则需要用到**流插入符**将内容传输给**流**  
  > 2、`<<`为**输出运算符**。其**接受两个运算对象**，**左侧**必须是一个`ostream`**对象**，**右侧**的运算对象是**要打印的值**。此运算符将**给定的值写入给定的**`ostream`**对象**中  
  > 3、`>>`为**输入运算符**。其与`>>`类型，它**左侧**接受一个`istream`**对象**，**右侧**接受一个**运算对象**。它从给定的`istream`中**读入数据**，并**存入给定的对象**中

- **endl 操纵符**

  > 1、**endl**是一个被称为**操纵符**的**特殊值**  
  > 2、**endl**的效果是**结束当前行**(有换行效果)，并将与设备关联的**缓冲区**的内容**刷到设备中**  
  > 3、**缓冲刷新操作**可以保证到目前为止**程序所产生的所有输出**都**真正写入流中**，而不是仅**停留在内存**中等待写入到流中

- **命名空间**

  > 1、示例程序中使用了`std::cout`和`std::endl`，而不是直接的`cout`和`endl`。其**前缀**`std::`指出**名字**`cout`和`endl`是定义在名为`std`的**命名空间**中的  
  > 2、**命名空间**可以帮助我们避免**不经意的名字定义冲突**以及**使用库中相同名字导致的冲突**。**标准库**定义的**所有名字**都在**命名空间**`std`中  
  > 3、通过**命名空间**使用**标准库**有一个**副作用**：当使用**标准库**中的**一个名字**时，必须通过**作用域运算符**`::`来**显式声明**我们想使用来自`std`中的名字，如示例`std::cout`那样(后续将给出一个更简单的访问标准库名字的方法)

##### **使用 C++版本的 C 标准库头文件**

- **建议使用 C++版本标准库**

  > 1、C++标准库中**兼容了 C 语言的标准库**，其按照如下**命名规则**命名  
  > 2、C 语言的头文件形如`name.h`，C++将其命名为`cname`。即**去掉**`.h`**后缀**，文件名前**添加字母**`c`  
  > 3、因此`stdio.h`和`cstdio`**内容是一样的**，而且`stdio.h`也能在 C++调用，但从**命名规范**上来讲，`cstdio`更符合 C++的要求  
  > 4、特别的，在名为`cname`的**头文件**定义的**名字**从属于**命名空间**`std`，而原本`.h`的则不然  
  > 5、一般来说，C++程序**应使用名为**`cname`**的头文件**，因为这样**标准库的名字**总能在`std`找到。如果使用`.h`形式，那么程序员不得不时刻牢记哪些是从 C 语言继承过来的，哪些又是 C++独有的

##### **类简介**

- 我们将在之后详细学习**类**相关的知识，在此只**简单介绍**

- **什么是类**

  > 1、在 C++中，我们通过**定义一个类**来**定义自己的数据结构**  
  > 2、一个**类**定义了**一个类型**，以及**与之相关的一组操作**  
  > 3、**类机制**是 C++**最重要的特性之一**。实际上，C++最初的**设计焦点**就是能定义使用上像内置类型一样自然的**类类型**

- 如果要使用一个类，我们需要了解**三件事情**：

  > 1、类名是什么？  
  > 2、它在哪里定义的？  
  > 3、它支持什么操作？

---

#### **变量和基本类型**

---

<div class="success">

> **章节概要**：基本内置类型；指定字面量类型；变量；对象；列表初始化；C++关键字；复合类型；引用；指针；void\* 指针；`const`限定符；`const`的引用；`constexpr`和常量表达式；处理类型；类型别名；`auto`类型说明符；`decltype`类型指示符；自定义数据结构；定义类；使用类

</div>

##### **基本内置类型**

- **基本数据类型**

  > 1、C++定义了一套包括**算数类型**和**空类型**在内的**基本数据类型**  
  > 2、其中**算数类型**包含了**整型**、**浮点型**、**字符型**、**布尔型**  
  > 3、**空类型 void**不对应**具体的值**，仅用于一些**特殊的场合**

- C++的**基本数据类型**与 C 语言**规则相同**，但 C++中**直接支持**了**bool 类型**，且`iostream`中**直接支持**了**拓展类型**(如`int32_t`等)

- **指定字面量类型**

  - 通过添加**前缀或后缀**，可以改变不同类型**字面量**的**默认类型**

  - **指定字符和字符串字面量**

    | 前缀 |   类型   | 含义                        |
    | :--: | :------: | --------------------------- |
    |  u   | char16_t | Unicode 16 字符             |
    |  U   | char32_t | Unicode 32 字符             |
    |  L   | wchar_t  | 宽字符                      |
    |  u8  |   char   | UTF-8(仅用于字符串字面常量) |

  - **指定整型字面量**

    |   后缀   | 最小匹配类型 |
    | :------: | :----------: |
    |  u 或 U  |   unsigned   |
    |  l 或 L  |     long     |
    | ll 或 LL |  long long   |

  - **指定浮点型字面量**

    |  后缀  |    类型     |
    | :----: | :---------: |
    | f 或 F |    float    |
    | l 或 L | long double |

##### **变量**

- **变量**

  > 1、**变量**提供一个**具名的**、**可供程序操作的存储空间**  
  > 2、C++中的每个变量都有其**数据类型**，**数据类型**决定着变量所占**内存空间**的**大小及布局方式**、该空间**能存储值的范围**，以及变量**能参与的运算**  
  > 3、对于 C++程序员来说，**变量**和**对象**一般可以**互换使用**

- **对象**

  > 1、C++程序员在很多场合都会使用**对象**这个名词。通常情况下，**对象**指一块**能存储数据**并**具有某种类型**的**内存空间**  
  > 2、一部分人对**对象**的定义并不相同，比如：一些人仅在**与类有关**的场景才使用**对象**这个词；另一些人把**命名了的对象**叫做**变量**；还有一些人把**对象**和**值**区分开来，**对象**指**能被程序修改的数据**，而**值**指**只读的数据**

- **列表初始化**

  - C++定义了**初始化**的**好几种不同形式**，如下：

    ```cpp
    int units_sold = 0;
    int units_sold(0);
    int units_sold = {0}; // 列表初始化
    int units_sold{0};    // 列表初始化
    ```

  - **列表初始化**

    > 1、作为**C++11 新标准**的一部分，用**花括号**来**初始化变量**得到了全面应用。这种初始化形式被称为**列表初始化**  
    > 2、现在，无论是**初始化对象**还是某些时候**为对象赋新值**，都可以使用这样一组**由花括号括起来的初始值**了  
    > 3、当用于**内置类型**变量时，这种初始化形式有一个**重要特点**：如果我们**使用列表初始化**且**初始值存在丢失信息的风险**，**编译器将报错**(如下例)  
    > 4、这样的介绍看似无关紧要，因为我们不会故意**用 long double 值初始化 int 变量**，然而这种初始化**可能在不经意间发生**，因此这种赋值更加**保守安全**

    ```cpp
    long double ld = 3.1415926536;
    int a{ld}, b = {ld};    // 报错：转换未执行，因为存在丢失信息的风险(丢失浮点精度)
    int c(ld), d = ld;      // 正确：转换执行，且确实丢失了部分值(丢失了小数点后的浮点部分)
    ```

- **C++关键字**

  |   关键字   |    关键字    |  关键字   |      关键字      |  关键字  |
  | :--------: | :----------: | :-------: | :--------------: | :------: |
  |  alignas   |   continue   |  friend   |     register     |   true   |
  |  alignof   |   decltype   |   goto    | reinterpret_cast |   try    |
  |    asm     |   default    |    if     |      return      | typedef  |
  |    auto    |    delete    |  inline   |      short       |  typeid  |
  |    bool    |      do      |    int    |      signed      | typename |
  |   break    |    double    |   long    |      sizeof      |  union   |
  |    case    | dynamic_cast |  mutable  |      static      | unsigned |
  |   catch    |     else     | namespace |  static_assert   |  using   |
  |    char    |     enum     |    new    |   static_cast    | virtual  |
  |  char16_t  |   explicit   | noexcept  |      struct      |   void   |
  |  char32_t  |    export    |  nullptr  |      switch      | volatile |
  |   class    |    extern    | operator  |     template     | wchar_t  |
  |   const    |    false     |  private  |       this       |  while   |
  | constexpr  |    float     | protected |   thread_local   |          |
  | const_cast |     for      |  public   |      throw       |          |

##### **复合类型**

- **复合类型**是指**基于其他类型**定义的类型。C++有几种复合类型，在此主要了解其中两种：**引用**和**指针**

- **引用**

  - **示例**

    ```cpp
    int ival = 1024;
    int &refVal = ival;     // 定义引用，refVal 指向 ival
    int &refVal2;           // 报错：引用必须被初始化
    /*------------------------------------------------------------------*/
    refVal = 2;             // 实际赋值给 refVal 指向的 ival
    int &refVal3 = refVal;  // refVal3 指向 refVal 指向的 ival
    /*------------------------------------------------------------------*/
    double dval = 10;
    int &refVal4 = dval;    // 报错：refVal4 为int类型，其指向对象必须为int类型
    int &refVal5 = 10;      // 报错：引用只能绑定在对象上
    ```

  - **引用介绍**

    > 1、**引用**为对象**起了另外一个名字**，通过将声明符写成`&变量名`来**定义引用类型**  
    > 2、**定义引用时**，程序把**引用**和它的**初始值**绑定在一起。一旦初始化完成，**引用**将和它的**初始值对象**一直绑定在一起。因为**无法**令引用**重新绑定另外一个对象**，所以**引用必须初始化**  
    > 3、引用**并非对象**，它只是为一个**已经存在的对象**所起的**另外一个名字**。定义一个引用之后，**对其进行的所有操作**都是在**与之绑定的对象**上进行的  
    > 4、所有**引用的类型**都要和**与之绑定的对象**严格匹配，且**引用只能绑定在对象上**

- **指针**

  - C++的指针整体与 C 语言的指针相同，在此写出一些差异

  - **空指针**

    > 1、**空指针**不指向**任何对象**，下为三种**生成空指针**的方法  
    > 2、第一种方法是使用**字面值**`nullptr`来初始化指针。`nullptr`是一种**特殊类型**的字面值，它可以**被转换成任意其他的指针类型**  
    > 3、第二种方法是使用**字面值 0**来生成空指针(注意不是 int 值)  
    > 4、第三种方法是使用**NULL 预处理器变量**，这个变量在头文件`cstdlib`中定义，**预处理变量**不属于**命名空间**`std`。在新标准下，现在的 C++程序**最好使用**`nullptr`，同时**尽量避免使用**`NULL`

    ```cpp
    int *p1 = nullptr;
    int *pt = 0;
    // 使用 NULL 需要调用 cstdlib 头文件
    int *p3 = NULL;
    ```

- **void\* 指针**

  > 1、void\* 是一种特殊的指针类型，可用于存放**任意对象的地址**。不同的是，我们对该地址**指向对象的类型**并不了解  
  > 2、利用 void\* 指针**能做的事有限**，**不能直接操作**其所指的对象，因为并**不知道对象是什么类型**  
  > 3、概括来说，以 void\* 视角来看，**内存空间**也就仅仅是**内存空间**，**没办法访问**内存空间中的**对象**

##### **const 限定符**

- **简述**

  > 1、有时我们希望定义一种**值不能被改变**的**变量**(或直接称为**常量**)，可以用`const`关键字加以修饰  
  > 2、因为`const`对象**一旦创建**，**值就不能改变**，所以`const`对象**必须初始化**  
  > 3、`const`的用法整体与 C 语言中类似

- `const`**的引用**

  > 1、可以把**引用**绑定到`const`**对象**上，我们称之为**对常量的引用**(或**常量引用**)  
  > 2、**常量引用**仅对**引用**本身作出限定，对于**引用的对象**并未限定。如果对象本身**不是常量**，那么允许通过**其他途径**修改它的值

  ```cpp
  const int i = 1024;
  const int &r1 = i;      // 正确：引用及其对应对象都是常量
  r1 = 42;                // 错误：r1是对常量的引用
  int &r2 = i;            // 错误：r2是对非常量的引用，不能指向常量对象
  /*------------------------------------------------------------*/
  int n = 30;
  const int &r1 = n;
  r1 = 40;                // 错误：r1是对常量的引用
  n = 40;                 // 正确：n本身不是常量
  ```

- `constexpr`**和常量表达式**

  - **常量表达式**

    > 1、**常量表达式**指**值不会改变**且**在编译过程中就能确定值**的表达式  
    > 2、一个对象是不是常量表达式，由它的**数据类型**和**初始值**共同决定

    ```cpp
    const int max_file = 20;          // 是常量表达式
    const int limit = mix_file + 1;   // 是常量表达式
    int staff_size = 27;              // 不是常量表达式：数据类型只是普通 int
    const int sz = get_size();        // 不是常量表达式：不能在编译过程中确定值
    ```

  - `constexpr`**变量**

    > 1、在一个复杂系统中，很难(甚至几乎肯定不能)**分辨一个初始值**是不是**常量表达式**  
    > 2、**C++11**规定，允许将变量声明为`constexpr`类型，由**编译器**来验证**变量的值**是否为**常量表达式**  
    > 3、声明为`constexpr`的变量**一定是一个常量**，而且**必须用常量表达式初始化**  
    > 4、不能使用**普通函数**作为`constexpr`**初始值**，允许定义一种特殊的`constexpr`**函数**，后续介绍

    ```cpp
    constexpr int mf = 20;            // 编译通过
    constexpr int limit = mf + 1;     // 编译通过
    constexpr int sz = size();        // 编译错误：除非 size() 是 constexpr 函数
    ```

  - **字面值类型**

    > 1、**常量表达式**的值需要**在编译时就得到计算**，这些类型一般**比较简单**，值也显而易见，就把它们称为**字面值类型**  
    > 2、目前为止，**算数类型**、**引用**、**指针**都**是**字面值类型。**自定义类**、**IO 库**、**string 类型**都**不是**字面值类型，也就不能被定义为`constexpr`  
    > 3、尽管**指针**和**引用**都能被定义成`constexpr`，但它们的**初始值受到严格限制**。如`constexpr`**指针**的初始值只能是`nullptr`或**0**，或存储于某个**固定地址**中的**对象**

##### **处理类型**

- **类型别名**

  > 1、有两种方法可用于定义**类型别名**，第一种是使用`typedef`**关键字**，与 C 语言用法相同  
  > 2、新标准规定了一种新方法：使用**别名声明**。这种方法使用`using`**关键字**作为**别名声明**的开始，其后紧跟别名和等号，作用是把**等号左侧的名字**规定成**等号右侧的类型**的别名

  ```cpp
  typedef double wages;      // wages 是 double 的别名
  typedef wages base, *p;    // base 是 wages(即double)的别名，p 是 double* 的别名
  using SI = Sales_item;     // SI 是 Sales_item 的别名
  ```

- `auto`**类型说明符**

  > 1、编程时常常需要把**表达式的值**赋给变量，这就要求在**声明变量时**清楚地知道**表达式的类型**，然而做到这一点并不容易，甚至有时根本做不到  
  > 2、**C++11**引入了`auto`**类型说明符**，能让**编译器**替我们去**分析表达式的类型**  
  > 3、和原来**只对应一种特定类型**的说明符(如 double)不同，`auto`能让编译器**通过初始值**推算**变量的类型**。显然，`auto`定义的变量**必须有初始值**  
  > 4、使用`auto`也能在**一条语句**声明**多个变量**，但由于一条声明语句**只能有一个基本数据类型**，所以该语句中**所有变量**的**初始基本数据类型**必须**都一样**

  ```cpp
  auto item = val1 + val2;    // auto 自动判断表达式类型
  auto i = 0, *p = &i;        // 正确：i 是整数，p 是整型指针
  auto sz = 0, pi = 3.14;     // 错误：sz 和 pi 类型不一致
  ```

- `decltype`**类型指示符**

  > 1、有时我们希望从**表达式的类型**推断出要定义的**变量的类型**，但是不想用该表达式的值**初始化变量**。为此，**C++11**引入了`decltype`**说明符**  
  > 2、`delctype`可以**返回操作数的数据类型**，在此过程中，**编译器**分析表达式并**得到它的类型**，但并**不实际计算表达式的值**  
  > 3、注意`delctype`**表达式的结果**如果是**加上括号的变量**，则结果将是**引用**。即`decltype(())`(注意是双层括号)的**结果永远是引用**

  ```cpp
  int ci = 1;
  decltype(ci) x = 0;         // x 的类型就是 ci 的类型，即 int，值为 0
  decltype(def()) sum = x;    // sum的类型就是函数 def() 的返回类型，值为 x 的值
  /*--------------------------------------------------------------------*/
  int i = 1;
  decltype((i)) d;            // 错误：d 是 int& 引用类型，必须初始化
  decltype(i) e;              // 正确：e 是一个未初始化的 int 类型
  ```

##### **自定义数据结构**

- **什么是数据结构**

  > 1、从最基本的层面理解，**数据结构**是把一组**相关的数据元素**组织起来然后使用它们的**策略和方法**  
  > 2、举一个例子，我们想要创建一个`Sales_items`**类**把书本的**ISBN 编号**、**售出量**、**销售收入**等数据组织在一起，并提供诸如`isbn()`**等函数**，`<<`、`>>`、`+`、`+=`**等运算**在内的**一系列操作**，`Sales_item`**类**就是一个**数据结构**  
  > 3、C++允许用户以**类的形式**自定义**数据类型**，而**库类型**`string`、`istream`、`ostream`等也是**以类的形式定义的**

- **定义类**

  - **简单的不含运算功能的类**的定义实际就是**C 的结构体**定义，使用`struct`定义

  - 此外，C++提供**另外一个关键字**`class`定义自己的**数据结构**，后续介绍

- **使用类**：简单的**类**的使用与**C 的结构体**使用规则相似，但定义**类对象**(结构变量)时不需要再使用`struct`再次声明

---

#### **字符串、向量和数组**

---

<div class="success">

> **章节概要**：命名空间的`using`声明；标准库类型`string`；定义和初始化`string`对象；`string`对象的操作；处理`string`对象中的字符；范围 for 语句；标准库类型`vector`；模板；定义和初始化`vector`对象；向`vector`对象添加元素；其他`vector`操作；`vector`的索引；迭代器介绍；使用迭代器；泛型编程；迭代器运算；数组；`auto`与数组；指针也是迭代器；与旧代码的接口

</div>

##### **命名空间的 using 声明**

- **引入**

  > 1、目前为止，我们用到的**库函数**基本上都属于**命名空间**`std`，而程序也显式地将这一点标示了出来，如`std::cin`  
  > 2、用这种方法显得**比较繁琐**，然而幸运的是，通过更简单的途径也能使用到**命名空间的成员**  
  > 3、本节将介绍其中一种**最安全的方法**，也就是**使用`using`声明**，后续会介绍另一种方法

- `using`**声明**

  > 1、有了`using`声明就**无须专门的前缀**，也能使用所需的名字了  
  > 2、`using`声明具有**如下形式**`using 命名空间名::名字`，如后示例  
  > 3、按照规定，每个`using`声明只能引入**命名空间**中的**一个成员**，因此每个名字都需要**独立声明**  
  > 4、位于**头文件**的代码**不应该使用**`using`**声明**，因为引用该头文件的源代码也会**引入这个声明**，对于某些程序，可能会**产生名字冲突**

  ```cpp
  #include <iostream>
  using std::cin;
  int main()
  {
      int i;
      cin >> i;
      std::cout << i;
      return 0;
  }
  ```

##### **标准库类型 string**

- **介绍**

  > 1、**标准库类型**`string`表示**可变长的字符序列**(字符串)，使用`string`类型必须先包含`string`**头文件**  
  > 2、作为**标准库的一部分**，`string`定义在**命名空间**`std`中  
  > 3、接下来的示例都假定已包含了下述代码

  ```cpp
  #include <string>
  using std::string
  ```

- **定义和初始化 string 对象**

  > 1、如何**初始化类的对象**是由**类本身**决定的，一个类可以定义**很多种**初始化对象的方式，但这些方式之间**必须有所区别**：或者是**初始值数量不同**，或者是**初始值类型不同**  
  > 2、下为**初始化**`string`**对象**的**方式和示例**

  | 方式                | 说明                                                   |
  | ------------------- | ------------------------------------------------------ |
  | string s1           | 默认初始化，s1 是一个空串                              |
  | string s2(s1)       | 直接初始化，s2 是 s1 的副本                            |
  | string s2 = s1      | 拷贝初始化，s2 是 s1 的副本                            |
  | string s3("value")  | 直接初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s3 = "value" | 拷贝初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s4(n, 'c')   | 直接初始化，把 s4 初始化为连续 n 个字符 c 组成的字符串 |

  ```cpp
  string s1;                    // 默认初始化，s1是空字符串
  string s2 = s1;               // s2是s1的副本
  string s3("value");           // s3是字面值"value"的副本
  string s3 = "value";          // s3是字面值"value"的副本
  string s4(10, 'c');           // 直接初始化，s4内容是 cccccccccc
  string s4 = string(10, 'c');  // 拷贝初始化，s4内容是 cccccccccc
  ```

- **string 对象的操作**

  - **总览**

    > 1、一个**类**除了要规定**初始化其对象的方式**外，还要定义对象上**能执行的操作**。其中，类既能定义**通过函数名调用的操作**，也能定义**各种运算符**在**该类对象**上的**新含义**  
    > 2、下表列举了**大部分**`string`**类的操作**

    | 操作           | 含义                                                                                     |
    | -------------- | ---------------------------------------------------------------------------------------- |
    | os<<s          | 将 s 写入到输出流 os 中，返回 os                                                         |
    | is>>s          | 从 is 中读取字符串赋给 s，字符串以空格分隔，返回 is                                      |
    | getline(is, s) | 从 is 中读取一行赋给 s，返回 is                                                          |
    | s.empty()      | s 为空返回 true，否则返回 false                                                          |
    | s.size()       | 返回 s 中字符个数                                                                        |
    | s[n]           | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起                                             |
    | s1+s2          | 返回 s1 和 s2 连接后的结果                                                               |
    | s1=s2          | 用 s2 的副本代替 s1 中原来的字符                                                         |
    | s1==s2         | 如果 s1 和 s2 中的字符完全一样，则它们相等，对字母的判断依据是 ASCII 码                  |
    | s1!=s2         | 如果 s1 和 s2 中有一个字符不一样，则它们不相等，对字母的判断依据是 ASCII 码              |
    | <,<=,>,>=      | 对字符串从前向后依次比较字符的 ASCII 码，成立与否的依据是首个不相等字符的 ASCII 大小关系 |

  - **读写操作**

    ```cpp
    // 基本读写
    int main()
    {
        string s;
        cin >> s;   // 遇到空格停止
        cout << s;
        return 0;
    }
    ```

    ```cpp
    // getline整行读取
    int main()
    {
        string line;
        getline(cin, line);   // 遇到换行符停止
        cout << line << endl;
        return 0;
    }
    ```

    ```cpp
    // C语言风格EOF读写
    int main()
    {
        string word;
        // while(getline(cin, line))
        while(cin >> word)
            cout << word << endl;
        return 0;
    }
    ```

  - `empty`**和**`size`**操作**

    > 1、`empty`**函数**根据`string`**对象是否为空**返回一个**布尔值**，`size`**函数**返回`string`**对象的长度**  
    > 2、这两个函数都是`string`的**成员函数**。**调用该类函数**的方法是，使用**点操作符**指明是**哪个对象**执行成员函数即可(`对象.成员函数()`)

    ```cpp
    int main()
    {
        string line;
        while(getline(cin, line))
            // 如果字符串不为空 且 字符串长度大于10
            if(!line.empty() && line.size() > 10)
                cout << line << endl;
        return 0;
    }
    ```

  - `string::size_type`**类型**

    > 1、实际上，`size`**函数的返回值**是一个`string::size_type`**类型的值**  
    > 2、尽管我们不太清楚`string::size_type`类型的**具体细节**，但有一点是肯定的，它是一个**无符号类型值**，且**足够存放任何**`string`**对象的大小**  
    > 3、所有**用于存放**`string`**类**的`size`**函数返回值**的**变量**，都应该是**该类型**(`auto len = line.size();`中`line`的类型也**自动设为该类型**)  
    > 4、由于**该类型**是**无符号整型**，因此切记，如果在表达式中**混用**了**无符号数和有符号数**会产生意想不到的错误。如**变量 n**是一个**具有负值的 int**，则表达式`s.size() < n`几乎肯定是**true**，因为**负值 n**会**自动转换**成一个**较大的无符号值**

  - **字面值和**`string`**对象相加**

    > 1、即使一种类型**并非所需**，我们也可以使用它，不过前提是**这种类型能自动转换成所需类型**  
    > 2、因为**标准库**允许把**字符字面值**和**字符串字面值**转换成`string`**对象**，所以在**需要**`string`**对象的地方**就可以用**这两种字面值**代替  
    > 3、注意：当把`string`**对象**和**这两种字面值**混在一条语句中使用时，必须确保**每个加法运算符**的两侧的**运算对象至少有一个**是`string`

    ```cpp
    string s1 = "hello", s2 = "world";
    string s3 = s1 + "," + s2 + '\n';
    /*------------------------------*/
    // 注意按顺序结合后结果的类型
    string s4 = s1 + ",";               // 正确
    string s5 = "hello" + ",";          // 错误
    string s6 = s1 + "," + "world";     // 正确
    string s7 = "hello" + "," + s2;     // 错误
    ```

- **处理 string 对象中的字符**

  - **引入**

    > 1、我们经常需要**单独处理**`string`**对象**中的**字符**，这类处理的关键问题是**如何获取字符本身**，另一个关键问题是要知道**能改变某个字符的特性**  
    > 2、对于后者，我们可以使用**C 语言继承而来**的`cctype`(即`ctype.h`)，对于后者，我们可以通过**范围 for 语句**实现

  - **范围 for 语句**

    > 1、如果想对`string`**对象**中的**每个字符**做点什么，目前最好的操作是使用**C++11 标准**提供的**范围 for 语句**(语法形式如后附)  
    > 2、其中**变量**将被用于**访问序列中的基础元素**。每次**迭代**，**变量**都会被**初始化**为**对象序列**的**下一个元素值**

    ```cpp
    for (变量 : 对象序列)
    {
        循环体;
    }
    ```

  - **示例：统计标点数并输出标点**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        int ct = 0;
        string s;
        getline(cin, s);
        for (auto c : s)
        {
            if (ispunct(c))
            {
                ct++;
                cout << c << ' ';
            }
        }
        cout << endl << "ct: " << ct << endl;
        return 0;
    }
    ```

  - **使用范围 for 改变字符**

    > 1、如果想要**改变**`string`**对象**中**字符的值**，只需要把**循环变量**定义成**引用**类型即可  
    > 2、记住，所谓**引用**只是**给定对象的一个别名**，因此当**引用**作为**循环控制变量**时，这个变量实际**被依次绑定到**序列的**每个元素**上  
    > 3、下示例将**整个字符串**中的**小写字母**转换成**大写字母**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        string s;
        getline(cin, s);
        for (auto &c : s)
        {
            c = toupper(c);
            cout << c << ' ';
        }
        cout << endl << s << endl;
    }
    ```

  - **只处理一部分字符**

    > 1、如果只想处理**一部分**字符，那么**范围 for 语句**则**不能很好的胜任**了。通常访问`string`**对象**中的**单个字符**有两种方式：一种是使用**下标**，另一种是使用**迭代器**(后续介绍)  
    > 2、`string`**对象**的下标使用与**C 语言字符数组**规则类似，使用**for 循环遍历处理**。对象的下标必须**大于等于 0**且**小于**`s.size()`

##### **标准库类型 vector**

- **介绍**

  > 1、标准库类型`vector`表示**对象的集合**，其中**所有对象的类型都相同**  
  > 2、集合中的**每个对象**都有一个**与之对应的索引**，索引用于**访问对象**  
  > 3、因为`vector`**容纳着**其他对象，所以它也常常被称作**容器**  
  > 4、要想使用`vector`，必须包含**适当的头文件**。后续的例子中，都假设包含以下声明

  ```cpp
  #include <vector>
  using std::vector;
  ```

- **模板**

  - **模板简介**

    > 1、C++既有**类模板**，也有**函数模板**，其中`vector`是一个**类模板**。只要对 C++有深入了解后才能**写出模板**，我们将在 16 章介绍。但即使不会创建模板，我们也可以试着使用模板  
    > 2、**模板**本身不是**类或函数**，相反可以将**模板**看做**编译器生成类或函数编写**的一份**说明**。编译器**根据模板创建类或函数**的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数**实例化成何种类型**  
    > 3、对于**类模板**来说，我们通过提供一些**额外信息**来指定模板应**实例化成什么样的类**，需要**提供哪些信息**由模板决定。**提供信息的方式**总是这样：在**模板名字**后面跟**一对尖括号**，在**括号内**放上信息，`模板名<信息>;`

  - **vector 模板**

    > 1、例如`vector`模板，**需要提供的信息**是`vector`内存放的**对象类型**(示例如后附代码)  
    > 2、`vector`是**模板**而非**类型**，由`vector`**生成的类型**必须包含`vector`中**所存放元素的类型**，例如`vector<int>`  
    > 3、`vector`能容纳**绝大多数类型**的**对象**作为其**元素**，但是由于**引用不是对象**，所以**不存在包含引用的**`vector`  
    > 4、早期版本 C++中，如果`vector`**的元素**还是`vector`，必须在**外层**的**右尖括号**和**其元素类型**之间添加一个**空格**。比如应该写成`vector<vector<int> >`

    ```cpp
    vector<int> ivec;               // ivec保存int类型的对象
    vector<Sales_item> Sales_vec;   // 保存Sales_item类型的对象
    vector<vector<string>> file;    // 该向量的元素是vector对象
    ```

- **定义和初始化 vector 对象**

  - 下表列出了**初始化**`vector`**对象**的**方法**

    | 方法                       | 说明                                                    |
    | -------------------------- | ------------------------------------------------------- |
    | vector<T> v1               | v1 是一个空 vector，潜在元素为 T 类型，执行默认初始化   |
    | vector<T> v2(v1)           | v2 中包含有 v1 所有元素的副本                           |
    | vector<T> v2 = v1          | 同上等价                                                |
    | vector<T> v3(n,val)        | v3 包含 n 个重复的元素，每个元素值都是 val              |
    | vector<T> v4(n)            | v4 包含 n 个重复执行了值初始化的对象                    |
    | vector<T> v5{a,b,c,...}    | v5 包含了初始值个数的元素，每个元素被赋予了相应的初始值 |
    | vector<T> v5 = {a,b,c,...} | 同上等价                                                |

  - 区分`()`**值初始化**和`{}`**列表初始化**的含义

    > 1、`vector<int> ivec(3,-1)`含义是**ivec**存放了**3 个值为 -1 的元素**；而`vector<int> ivec{3,-1}`含义是**ivec**存放了**两个元素**，**值**分别为**3 和 -1**  
    > 2、`vector<int> ivec(10)`是指**ivec**创建了**10 个执行了值初始化的元素**(如 int 类型会被初始化为 0)  
    > 3、简单地说，想要**初始化多个相同值**就使用`()`**值初始化**，想要**初始化多个不同值**就使用`{}`**列表初始化**

- **向 vector 对象添加元素**

  > 1、经常我们会遇到，创建一个`vector`时并**不清楚**实际所需**元素个数**，元素的**值**也**无法确定**；还有些时候元素初值已知，但这些值**总量较大**且**各不相同**  
  > 2、例如我们需要`vector`**对象**存储 1-100 的数字，对此更好的办法是先创建一个**空**`vector`，然后在**运行时**利用`vector`的**成员函数**`push_back`来**添加数据**  
  > 3、`push_back`负责把**一个值**当成`vector`**对象**的**尾元素**，添加到**对象的尾端**，示例如下  
  > 4、注意：如果循环体内部含有**向**`vector`**添加元素**的语句，则不能使用**范围 for 语句**

  ```cpp
  vector<int> ivec;
  for (int i = 1; i <= 100; i++)
      ivec.push_back(i);
  ```

- **其他 vector 操作**

  - `vector`提供了一些**其他操作**，下表列出其中比较重要的一些

    | 操作             | 含义                                                          |
    | ---------------- | ------------------------------------------------------------- |
    | v.empty()        | 如果 v 不含有任何元素，返回 true，否则返回 false              |
    | v.size()         | 返回 v 中元素的个数，返回值类型是 `vector<T>::size_type` 类型 |
    | v.push_back(t)   | 将值为 t 的元素添加到 v 的尾端                                |
    | v[n]             | 返回 v 中第 n 个位置上元素的引用                              |
    | v1 = v2          | 用 v2 中的元素拷贝替换 v1 中的元素                            |
    | v1 = {a,b,c,...} | 用列表中的元素拷贝替换 v1 中的元素                            |
    | ==,!=,<,<=,>,>=  | 与 string 相同，比较字典序                                    |

- **vector 的索引**

  > 1、和`string`类似，如果需要**逐个访问全部**`vector`**元素**，也可以使用**范围 for 语句**+**引用**  
  > 2、对于需要**非顺序访问**，可以使用**下标**访问，**下标**同样**从 0 开始计算**  
  > 3、注意：只能对**确知已存在的元素**使用**下标操作**，因此**不能使用下标添加元素**，添加元素只能使用`push.back`

##### **迭代器介绍**

- **介绍**

  > 1、我们已经知道可以使用**下标**访问`string`**对象的字符**和`vector`**对象的元素**，还有另一种**更通用的机制**也能实现，就是**迭代器**  
  > 2、除了`vector`外，**标准库**还定义了**其他几种容器**。**所有标准库容器**都能使用**迭代器**，但只有**少数几种**才同时支持**下标操作**  
  > 3、类似于**指针类型**，迭代器也提供对**对象**的**间接访问**，同时迭代器也有**有效**和**无效**之分。**有效**的迭代器**指向某个元素**或指向**容器尾元素的下一位置**，其余都属于**无效**迭代器

- **使用迭代器**

  - **引入**

    > 1、**和指针不同**的是，**获取迭代器**不是使用**取地址符**，**有迭代器的类型**同时拥有**返回迭代器的成员**  
    > 2、比如**这些类型**都拥有名为**begin**和**end**的**成员**，其中**begin 成员**负责返回**指向第一个元素的迭代器**，**end 成员**负责返回**指向容器尾元素下一位置的迭代器**  
    > 3、**end 成员**返回的**迭代器**常被称作**尾后迭代器**，或简称为**尾迭代器**。这样的迭代器没什么实际含义，只是个**标记**而已，表示我们已经处理完了容器中所有元素。特殊情况下，如果**容器为空**，则**begin**和**end**返回的是**同一个迭代器**  
    > 4、一般来说，我们不清楚(也不需要在意)**迭代器的准确类型**是什么，通常使用`auto`**关键字**定义变量来**自动确定类型**

    ```cpp
    // b 表示 v 的第一个元素，e 表示 v 尾元素的下一位置
    auto b = v.begin(), e = v.end();
    ```

  - **迭代器运算符**

    > 1、下表列举了部分**迭代器支持的运算**  
    > 2、和指针类似，也能通过**解引用迭代器**来获取它**所指示的元素**，执行解引用的迭代器**必须合法**并**确实指示着某个元素**  
    > 3、举个例子，使用**迭代器**访问`string`**对象**，将字符串的**首字母大写**(如下例)

    | 运算             | 含义                                                                                                 |
    | ---------------- | ---------------------------------------------------------------------------------------------------- |
    | \*iter           | 返回迭代器 iter 所指元素的引用                                                                       |
    | iter->mem        | 解引用 iter 并获取该元素的名为 mem 的成员，等价于`(*iter).mem`                                       |
    | ++iter 或 iter++ | 令 iter 指示容器中的下一个元素                                                                       |
    | --iter 或 iter-- | 令 iter 指示容器中的上一个元素                                                                       |
    | iter1 == iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |
    | iter1 != iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |

    ```cpp
    string s("some thing");
    if (s.begin() != s.end())   // 确保 s 为非空字符串
    {
        auto it = s.begin();    // it 表示 s 的第一个字符
        *it = toupper(*it);     // 改为大写
    }
    ```

  - **将迭代器移动到另外一个元素**

    > 1、**迭代器**使用**递增运算符**`++`来移动到**下一个元素**，使用**递减运算符**`--`来移动到**上一个元素**  
    > 2、因为**end 返回的迭代器**并不实际指示**某个元素**，所以**不能**对其进行**递增**或**解引用**  
    > 3、下例为使用**迭代器**依次访问`string`**对象**的**字符**，将**整个字符串的字母大写**

    ```cpp
    string s("hello world");
    for (auto it = s.begin(); it != s.end(); it++)
        *it = toupper(*it);
    ```

  - **迭代器类型**

    > 1、就像**不知道**`string`和`vector`的`size_type`**成员**到底是**什么类型**一样，一般来说我们也**不知道**(也无需知道)**迭代器的精确类型**  
    > 2、实际上，那些**拥有迭代器**的**标准库类型**使用`iterator`和`const_iterator`来表示**迭代器的类型**，其中`const_iterator`和**常量指针**差不多

    ```cpp
    vector<int>::iterator it1;          // it1 能读写 vector<int> 的元素
    string::iterator it2;               // it2 能读写 string 对象中的字符

    vector<int>::const_iterator it3;    // it3 只能读元素，不能写元素
    string::const_iterator it4;         // it4 只能读字符，不能写字符
    ```

  - `cbegin`**和**`cend`**函数**

    > 1、`begin`和`end`返回的**具体类型**由**对象是否是常量**决定。如果对象**是常量**则返回`const_iterator`，如果**不是常量**在返回`iterator`  
    > 2、有时候这种**默认的行为**并非我们所要，如果对象**只需读无须写**最好使用**常量类型**  
    > 3、为了便于我们得到`const_iterator`**类型的返回值**，C++11 引入了两个**新函数**：`cbegin`和`cend`，其返回值一定是`const_iterator`类型

  - **组合解引用和成员访问操作**

    > 1、**解引用迭代器**可获得迭代器**所指的对象**，如果该**对象的类型**恰好是**类**，就有可能希望进一步**访问它的成员**  
    > 2、例如，对于一个由字符串组成的`vector`**对象**，要想检查其**元素是否为空**，令**it**是该`vector`的**迭代器**，只要检查**it 所指字符串是否为空**即可：`(*it).empty()`(注意前面的括号不可省略，因为关系到运算符优先级问题)  
    > 3、为了简化上述表达式，C++定义了**箭头运算符**`->`。箭头运算符把**解引用**和**成员访问**两个操作**结合在一起**，也就是说，`it->mem`等效于`(*it).mem`

  - **某些对**`vector`**对象的操作会使迭代器失效**

    > 1、虽然`vector`对象可以**动态地增长**，但是也会有一些**副作用**  
    > 2、已知的一个限制是不能在**范围 for 语句**内向`vector`**添加元素**。另外一个限制是任何一种**可能改变**`vector`**对象容量**的操作，比如`push_back`，都会使其**迭代器失效**(后续解释)  
    > 3、谨记，但凡是使用了**迭代器**的**循环体**，**都不要**向迭代器所属容器**添加元素**

- **泛型编程**

  > 1、原来使用 C 或 Java 的程序员转而使用 C++ 后，会对**for 循环**中**大量使用**`!=`而不是`<`进行判断感到奇怪  
  > 2、C++程序员**习惯性使用**`!=`，其原因和他们**更愿意用迭代器而非下标**的原因一样：这种编程风格在**标准库提供的所有容器**上都有效  
  > 3、与之类似，**所有标准库容器的迭代器**都定义了`!=`和`==`，但它们中的**大多数没有定义**`<`**运算符**  
  > 4、因此，只要我们养成使用**迭代器**和`!=`的习惯，就**不用太在意**用的到底是**哪种类型**

- **迭代器运算**

  > 1、`string`和`vector`的**迭代器**提供了更多额外的**运算符**，一方面可使得迭代器**每次移动过多个元素**，另外也支持迭代器进行**关系运算**。  
  > 2、所有这些运算都被称为**迭代器运算**，如下表

  | 运算          | 含义                                                                                                                                                                                   |
  | ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | iter + n      | 迭代器加上一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置                                                |
  | iter - n      | 迭代器减去一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置                                                |
  | iter += n     | 迭代器加法的复合赋值语句，将 iter 加 n 的结果赋给 iter                                                                                                                                 |
  | iter -= n     | 迭代器减法的复合赋值语句，将 iter 减 n 的结果赋给 iter                                                                                                                                 |
  | iter1 - iter2 | 两个迭代器相减的结果是它们之间的距离，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置                                                                                        |
  | >,>=,<,<=     | 迭代器关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则前者小于后者，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置，类型是`difference_type`的带符号整型 |

- **使用迭代器运算**

  - 使用迭代器运算的一个**经典算法**是**二分搜索**，其从**有序序列**中寻找某个**给定值**

    ```cpp
    // text 必须是有序的，sought 是要搜索的给定值
    auto beg = text.begin(), end = text.end();    // beg 和 end 表示搜索的范围
    auto mid = text.begin() + (end - bag) / 2;    // 初始中间点
    while (mid != end && *mid != sought)
    {
        if (sought < *mid)                        // 如果在前半部分
            end = mid;                            // 忽略后半部分
        else                                      // 如果在后半部分
            beg = mid + 1;                        // 在mid之后寻找
        mid = beg + (end - beg) / 2;              // 新的中间点
    }
    ```

##### **数组**

- **数组**的大部分使用规则**与 C 语言相同**

- **auto 与数组**

  > 1、由于**数组名**是数组的**首元素地址**，所以使用`auto`**关键字**时，`auto ia2(ia)`等同于`auto ia2(&ia[0])`  
  > 2、但如果使用`decltype`**关键字**，上述转换**不会发生**，`decltype(ia)`**返回类型**是由**10 个整数**构成的**数组**

  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};
  // ia2是一个整型指针，指向ia的首元素
  auto ia2(ia);
  // ia3是一个含有10个整数的数组
  decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}
  ```

- **指针也是迭代器**

  > 1、就像使用**迭代器**遍历`vector`**对象**那样，使用**指针**也能**遍历数组中的元素**。不过前提是先获取到**指向数组首元素的指针**和**指向数组尾元素下一位的指针**  
  > 2、获取**首元素地址**可以使用**数组名**，而**尾后指针**可以获取**尾元素后**那个**并不存在的元素的地址**。如假设定义`int arr[10];`，则可以`int *end = &arr[10]`  
  > 3、尽管**通过计算**可以得到**尾后指针**，但这种方法**极易出错**。为了让指针的使用更简单，C++11 新增了**两个函数**：`begin`**函数**和`end`**函数**  
  > 4、这**两个函数**与**容器中**的**两个同名成员**功能类似，不过**数组不是类类型**，所以这两个函数**不是成员函数**。正确使用的方法是将**数组**作为它们的**参数**，如下

  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};
  int *begin = begin(ia);
  int *end = end(ia);
  ```

- **与旧代码的接口**

  - **引入**

    > 1、很多 C++程序在**标准库出现之前**就已经写成了，它们肯定没用到`string`和`vector`类型；而且有一些 C++程序实际上是**与 C 语言或其他语言**的**接口程序**，当然也无法使用**C++标准库**  
    > 2、但是，现代的 C++ 程序不得不与那些**充满了数组**或**C 风格字符串**的代码衔接。为了使这一工作**简单易行**，C++专门提供了一组功能

  - **混用**`string`**对象和 C 风格字符串**

    > 1、允许使用以`\0`结束的**字符数组**(即 C 风格字符串)来对`string`**对象**进行**初始化**和**赋值**  
    > 2、在`string`**对象**的**加法运算**中允许使用**C 风格字符串**作为其中**一个运算对象**(不能两个都是)；在`string`**对象**的**复合赋值运算**中允许使用**C 风格字符串**作为**右侧运算对象**  
    > 3、上述性质**反过来**就**不成立**了：如果程序某处需要一个**C 风格字符串**，不能用`string`**对象**代替它，例如不能用`string`**对象**初始化一个**指向 char 的指针**  
    > 4、为了完成该功能，`string`专门提供了一个名为`c_str`的**成员函数**：其返回**一个指针**，指向一个**C 风格字符串**，该**字符串内容**与`string`**对象**一样；指针的类型是`const *char`，确保**不会改变字符数组的内容**

    ```cpp
    char *str = s;                // 错误，不能用string对象初始化指向char的指针
    const char *str = s.c_str();  // 正确
    ```

  - **用数组初始化**`vector`**对象**

    - 允许使用**数组**来**初始化**`vector`**对象**。要实现这一目的，只需指明要**拷贝区域**的**首元素地址**和**尾后地址**即可(最简单的方式是用`begin`和`end`函数)

      ```cpp
      int int_arr[] = {0,1,2,3,4,5};
      vector<int> ivec(begin(int_arr), end(int_arr));
      ```

---

#### **表达式**

---

<div class="success">

> **章节概要**：特性补充；**sizeof**运算符；强制类型转换

</div>

##### **特性补充**

- C++的**表达式**和**运算符**与 C 大部分相同，在此**补充**或**强调**一些特性

- **sizeof 运算符**

  > 1、对`string`或`vector`**对象**执行`sizeof`**运算符**只返回**该类型固定部分**的**大小**，**不会计算**对象中的元素占用了多少**空间**  
  > 2、因为`sizeof`的**返回值**是一个**常量表达式**`constexpr size_t`，因此可以用`sizeof`的结果**声明数组的大小**

- **强制类型转换**

  - 一个命名的**强制类型转换**具有**如下形式**：`转换模式<转换类型>(表达式)`

  - 其中，**转换模式**是`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`中的一种

  - `static_cast`**模式**

    > 1、任何具有**明确定义**的**类型转换**，只要不包含**底层**`const`，都可以使用`static_cast`，例如：`double slope = static_cast<double>(i);`  
    > 2、`static_cast`对于**编译器无法自动执行**的**类型转换**也非常有用，例如可以**找回存在于**`void*`**的指针**，转换回**原始的指针类型**，示例如后  
    > 3、但是对于**存在于**`void*`**的指针**，应确保**指针的值保持不变**，且**转换后所得类型**就是**指针所指类型**

    ```cpp
    // 任何非常量对象的地址都能存入void*
    void* p = &d;
    //将void*转换回原始的指针类型(指向double的指针)
    double *dp = static_cast<double*>(p);
    ```

  - `const_cast`**模式**

    > 1、`const_cast`**只能改变**运算对象的**底层**`const`，对于将**常量对象**转换成**非常量对象**的行为，称其为**去掉**`const`**性质**  
    > 2、一旦**去掉了**某个对象的`const`**性质**，编译器将**不再阻止**我们对该对象进行**写入操作**  
    > 3、如果对象**本身不是一个常量**，那么强制类型转换获得**写权限**是**合法的行为**；但如果对象**本身是一个常量**，则再使用`const_cast`执行**写操作**将产生**未定义的后果**

    ```cpp
    const char *pc;
    char *p = const_cast<char*>(pc);    // 正确：但是写操作是未定义的行为
    /*-----------------------------*/
    const char *cp;
    char *q = static_cast<char*>(cp);   // 错误：static_cast不能转换掉const性质
    const_cast<string>(cp);             // 错误，const_cast只能改变常量属性
    static_cast<string>(cp);            // 正确
    ```

  - `reinterpret_cast`**模式**

    > 1、`reinterpret_cast`通常为**运算对象**的**位模式**提供**较低层次**上的重新解释  
    > 2、如下例，我们必须牢记**pc**所指的**真实对象是 int 而非字符**，如果把**pc**当成普通的**字符指针**使用就可以在运行时发生错误  
    > 3、使用`reinterpret_cast`是**非常危险**的，其中关键问题是**类型改变了**，但编译器**没有给出任何警告或错误提示**。下面**使用 pc 时**就会认定它的值是**char\*类型**，**编译器没法知道**它实际存放的是**指向 int 的指针**  
    > 4、`reinterpret_cast`本质上**依赖于机器**。想要安全地使用，必须对**涉及的类型**和**编译器实现转换的过程**都相当了解

    ```cpp
    int *ip;
    char *pc = reinterpret_cast<char*>(ip);
    string str(pc);     // 错误：可能导致异常的运行时行为
    ```

  - `dynamic_cast`**模式**：支持**运行时类型识别**，后续介绍

  - 此外，C 语言的**旧式强制类型转换**仍然支持，但与 C++ 的相比，表现形式上不那么清晰明了，**出错追踪比较困难**，建议使用 C++ 的转换方式

---

#### **语句**

---

<div class="success">

> **章节概要**：`try`语句块和异常处理；C++的异常处理；`throw`表达式；`try`语句块；编写处理代码；标准异常

</div>

##### **try 语句块和异常处理**

- **引入**

  > 1、**异常**是指存在于**运行时**的**反常行为**，这些行为超出了**函数正常功能**的范畴，典型的异常包括**失去数据库连接**以及**遇到意外输入**等。处理反常行为可能是设计所有系统最难的一部分  
  > 2、当**程序的某部分**检测到一个让它**无法处理**的问题时，就需要用到**异常处理**。如果程序中含有**可能引发异常的代码**，那么通常也会有**专门的代码处理问题**  
  > 3、**异常处理机制**为程序中**异常检测**和**异常处理**这两部分的协作提供支持。C++中，异常处理包括以下部分

- **C++的异常处理**

  > 1、`throw`**表达式**：**异常检测**部分使用`throw`**表达式**来表示它**遇到了无法处理的问题**，我们说`throw`**引发了异常**  
  > 2、`try`**语句块**：**异常处理**部分使用`try`**语句块**处理异常。`try`中包含**一个或多个**`catch`**子句**，抛出的**异常**通常会**被某个**`catch`**子句处理**。因为`catch`**子句**处理异常，所以它们也被称为**异常处理代码**  
  > 3、一套**类异常**：用于在`throw`**表达式**和相关的`catch`**子句**之间**传递异常的具体信息**

- **throw 表达式**

  > 1、程序的**异常检测**部分使用`throw`**表达式**引发一个**异常**，形式如`throw 表达式;`，其中的**表达式类型**就是**抛出的异常类型**  
  > 2、如下示例，如果书籍的 ISBN 不一样就**抛出异常**，该**异常类型是**`runtime_error`**对象**。抛出异常将**终止当前的函数**，并把**控制权**转移给**能处理该异常的代码**  
  > 3、类型`runtime_error`是**标准库异常类型**的一种，定义在`stdexcept`**头文件**中，后面将介绍其他的异常类型  
  > 4、我们必须**初始化**`runtime_error`**对象**，方式是给它提供一个`string`**对象**或一个**C 风格字符串**，这个字符串中有一些关于异常的**辅助信息**

  ```cpp
  if(item1.isbn() != item2.isbn())
      throw runtime_error("数据必须具有相同的ISBN");
  cout << item1 + item2 << endl;
  ```

- **try 语句块**

  > 1、`try`**语句块**的通用语法形式如下  
  > 2、跟在`try`**块**之后的是**一个或多个**`catch`**子句**。`catch`**子句**包括三部分：**关键字**`catch`、括号内一个(可能未命名的)**对象的声明**(称作异常声明)、以及**一个块**  
  > 3、当选中了某个`catch`子句**异常处理之后**，执行**与之对应的块**。`catch`**一旦执行完成**，会**跳转到**`try`**块**中**最后一个**`catch`**子句之后**的语句继续执行  
  > 4、`try`**块**中的**程序语句**组成程序的**正常逻辑**，像其他任何块一样，可以有包括声明在内的任意 C++ 语句

  ```cpp
  try
  {
      程序语句
  }
  catch(异常声明)
  {
      处理语句
  }
  catch(异常声明)
  {
      处理语句
  }
  // ...
  ```

- **编写处理代码**

  > 1、编写**异常处理代码**，上面的程序可以按如下示例处理  
  > 2、将程序**本来要执行的任务**放在`try`**语句块**中，因为这段代码**可能抛出异常**  
  > 3、`try`对应一个`catch`**子句**，该子句负责**处理**`runtime_error`**类型的异常**。如果`try`中抛出了**此类异常**，则会执行该`catch`内的语句  
  > 4、`catch`中输出给用户的信息中，输出了`err.what()`的返回值。从`catch`**小括号的定义**能得到**err**是一个`runtime_error`**类的对象**，`what`则是该**类**的一个**成员函数**  
  > 5、`what`成员函数**没有参数**，**返回值**是**C 风格字符串**(即`const char*`)。其中，`runtime_error`的`what`**成员**返回的是**初始化一个具体对象**时所用的`string`**对象的副本**(即`try`中初始化的字符串)

  ```cpp
  while (cin >> item1 >> item2)
  {
      try
      {
          if(item1.isbn() != item2.isbn())
              throw runtime_error("数据必须具有相同的ISBN");
          cout << item1 + item2;
      }
      catch(runtime_error err)
      {
          cout << err.what() << "\n 再次尝试？输入y或n"<< endl;
          char c;
          cin >> c;
          if(!cin || c == 'n')
          {
                cout << "程序退出" << endl;
                break;          // 跳出 while 循环
          }
      }
  }
  ```

- **标准异常**

  - **标准异常类**

    > 1、C++**标准库**中定义了一组**类**，用于报告**标准库函数**遇到的问题。这些**异常类**也可以在**用户编写的程序中**使用，分别定义在**4 个头文件**  
    > 2、`exception`：定义了**最通用的异常类**`exception`，它**只报告异常的发生**，**不提供任何额外信息**  
    > 3、`stdexcept`：定义了几种**常用的异常类**，详细信息见下表  
    > 4、`new`：定义了`bad_alloc`**异常类型**，后续介绍  
    > 5、`type_info`：定义了`bad_cast`**异常类型**，后续介绍

    | stdexcept 定义的异常类 | 含义                                           |
    | ---------------------- | ---------------------------------------------- |
    | exception              | 最常见的错误                                   |
    | runtime_error          | 只有在运行时才能检测出的任务                   |
    | range_error            | 运行时错误：生成的结果超出了有意义的值域范围   |
    | overflow_error         | 运行时错误：计算上溢                           |
    | underflow_error        | 运行时错误：计算下溢                           |
    | logic_error            | 程序逻辑错误                                   |
    | domain_error           | 逻辑错误：参数对应的结果值不存在               |
    | invalid_argument       | 逻辑错误：无效参数                             |
    | length_error           | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
    | out_of_range           | 逻辑错误：使用一个超出有效范围的值             |

  - **运算与成员**

    > 1、**标准库异常类**只定义了几种运算，包括**创建或拷贝异常类型的对象**，以及**为异常类型的对象赋值**  
    > 2、我们只能以**默认初始化**的方式初始化`exception`、`bad_alloc`、`bad_cast`对象，**不允许**为这些对象**提供初始值**  
    > 3、**其他异常类型**的行为恰好相反，应该使用`string`**对象**或者**C 风格字符串**初始化这些类型的对象，**不允许**使用**默认初始化**的方式。创建此类对象时，**必须提供初始值**，该值含有**错误相关信息**  
    > 4、**异常类型**之定义了一个名为`what`的**成员函数**，返回值是**C 风格字符串**，字符串的目的是**提供关于异常的一些文本信息**。对于其他**无初始值的异常类型**，`what`返回的内容由**编译器决定**

---

#### **函数**

---

<div class="success">

> **章节概要**：含有可变形参的函数；`initializer_list`形参；函数的返回值；不要返回局部对象的引用或指针；返回数组指针的函数；函数重载；定义重载函数；重载和`const`形参；`const_cast`和重载；特殊用途语言特性；默认实参；内联函数；`constexpr`函数

</div>

##### **含有可变形参的函数**

- **简介**

  > 1、有时我们**无法提前预知**应该向函数**传递几个实参**。为了编写**能处理不同数量实参**的函数，C++11 提供了以下几种方法  
  > 2、如果所有的**实参类型相同**，可以传递一个名为`initializer_list`的**标准库类型**  
  > 3、如果**实参类型不同**，可以编写一种特殊的函数——**可变参数模板**，将在后续介绍  
  > 4、此外还有一种从**C 标准库**`stdarg.h`继承而来的**省略符形参**`...`，但有了一些限制

- **initializer_list 形参**

  - **简介**

    > 1、`initializer_list`是一种**标准库类型**，用于表示**某种特定类型的值的数组**，其定义在`initializer_list`**头文件**中。后表是它的一些操作  
    > 2、和`vector`一样，**该类型**也是一种**模板类型**，这意味着**定义对象**时，也必须说明列表中**所含元素的类型**：`initializer_list<int> li;`  
    > 3、和`vector`不同的是，该类型对象中的**元素永远是常量值**，我们**无法改变**该类型对象中**元素的值**

  - **使用**

    > 1、我们可以使用**该类型**作为函数的**形参**，使用**迭代器**访问**列表中的元素**  
    > 2、使用函数时，如果想向`initializer_list`**形参**中**传递一个值的序列**，则必须把**序列**放在一对**花括号**内  
    > 3、含有`initializer_list`**形参**的函数也**可以同时拥有其他形参**

    ```cpp
    // 定义函数
    void error_msg(int error_code, initializer_list<string> i1)
    {
        cout << "error code:" << error_code;
        for(auto beg = i1.begin(); beg != i1.end(); beg++)
            cout << *beg << ' ';
        cout << endl;
    }
    // 传参使用
    int error_number = 15;
    string s1("error1"), s2("error2");
    error_msg(error_number, {"function", s1, s2});
    ```

- **省略号形参**`...`

  > 1、**省略号形参**`...`沿用自**C 语言的**`stdarg.h`**库**，为了便于**C++程序**访问某些特殊的**C 代码**  
  > 2、但省略符形参应该**仅仅用于 C 和 C++ 通用的类型**。特别应该注意，C++的大多数**类类型的对象**传递时都**无法正确拷贝**

##### **函数的返回值**

- **不要返回局部对象的引用或指针**

  > 1、函数完成后，所占用的**内存空间**也会**随之释放**。由此，**局部变量的引用**和**指向局部变量的指针**将指向**不再有效的内存区域**  
  > 2、如下示例，对于两条`return`语句，都将返回**未定义的值**

  ```cpp
  // 函数返回值类型是const string &，即一个引用
  const string &manip()
  {
      string ret;
      if (!ret.empty())
          return ret;       // 错误：返回了局部对象的引用，返回的引用将指向无效区域
      return "Empty";       // 错误：Empty也是一个局部临时量，返回的引用将指向无效区域
  }
  ```

- **返回数组指针的函数**

  - **直接声明**

    > 1、如果我们想定义一个**返回数组指针的函数**，则**数组的下标数**必须**跟在函数名后**。而函数的**形参列表**也跟在**函数名后**，且应该**先于数组的下标数**  
    > 2、因此，**返回数组指针的函数**形式如：`类型 (* 函数名(形参列表))[数组下标数]`，具体的例子和解读如下(可以参考[类型声明黄金法则](https://www.shengqibaozao.eu.org/2022/08/22/%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99/?t=1674030612212))

    ```cpp
    int (*func(int i))[10];
    /*---------------------*/
    /*
    解读：
    func(int i)             ：表示函数需要一个int类型形参
    (*func(int i))          ：返回类型是一个指针
    (*func(int i))[10]      ：指针指向一个大小是10的数组
    int (*func(int i))[10]  ：指向的是一个含有10个int值的数组
    */
    ```

  - **使用尾置返回类型**

    > 1、在 C++11 新标准中还有一种可以**简化上述声明**的方法，就是使用**尾置返回类型**  
    > 2、**任何函数的定义**都能使用**尾置返回**，但这种形式对于**返回类型比较复杂**的函数最有效，比如返回类型是**数组的指针**或者**数组的引用**  
    > 3、**尾置返回类型**跟在**形参列表**后面并以一个`->`**符号开头**。为了表示函数**真正的返回类型**跟在**形参列表后**，原先**标识返回值的地方**改为`auto`

    ```cpp
    // 函数返回一个指针，指向含有10个整数的数组
    auto func(int i) -> int(*)[10];
    ```

  - **使用**`decltype`**获取类型**

    > 1、还有一种情况，**如果知道**函数返回的**指针将指向哪个数组**，可以使用`decltype`来**声明返回类型**，如下例  
    > 2、`decltype(odd)`标识了**返回类型**是一个**含有 5 个 int 值的数组**，`*`标识了**返回类型**是一个**指针**  
    > 3、有一个地方要注意，`decltype`并**不负责**把数组类型**转换成**相应的**指针**，所以如果需要返回**指向数组的指针**的函数，需要像下例中**声明时**加一个`*`

    ```cpp
    int odd[] = {1, 3, 5, 7, 9};
    int even[] = {0, 2, 4, 6, 8};
    // 使用 decltype(odd) 获取类型
    decltype(odd) *arrPtr(int i)
    {
        return (i % 2) ? &odd : &even;  // 返回一个指向数组的指针
    }
    ```

##### **函数重载**

- **简介**

  > 1、如果**同一作用域**内的几个函数**名字相同**但**形参列表不同**，我们称之为**重载函数**。如下例  
  > 2、这些函数接受的**形参类型不同**，但是执行的**操作非常相似**，使用**函数重载**可以在一定程度上减轻起名记名的负担  
  > 3、当**调用这些函数**时，编译器会**根据传递的实参**判断具体想要执行的是**哪个函数**

  ```cpp
  // 函数原型
  void print(char *cp);               // 1
  void print(int *beg, int *end);     // 2
  void print(int ia[], size_t size);  // 3
  /*--------------------------------------*/
  // 函数调用
  int j[2] = {0, 1};
  print("Hello World");         // 调用 1
  print(j, end(j) - begin(j));  // 调用 3
  print(begin(j), end(j));      // 调用 2
  ```

- **定义重载函数**

  > 1、对于定义的**重载函数**来说，它们至少应该在**形参数量**或**形参类型**上**有所不同**  
  > 2、假设有两个函数，他们的**返回类型不同**但**形参列表相同**，这种声明不是**重载函数**，是**错误的**  
  > 3、有时候两个**形参列表看起来不一样**，但实际是**相同**的。比如**省略了形参名**，或使用**类型别名**  
  > 4、**不能重载**`main()`**函数**

  ```cpp
  // 不允许两个函数除了返回类型不同其余都相同
  void lookup(Account&);
  bool lookup(Account&);    // 错误
  /*--------------------------------*/
  // 形参列表相同
  void lookup(Account &acct);
  void lookup(Account&);    // 相同，省略了形参名
  typedef Phone Telno;
  void lookup(Phone&);
  void lookup(Telno&);      // 相同，使用了类型别名
  ```

- **重载和 const 形参**

  > 1、**顶层**`const`不影响传入函数的**对象**，一个拥有**顶层**`const`**的形参**无法和另一个**没有顶层**`const`**的形参**区分开来  
  > 2、如果**形参**是某种类型的**指针或引用**，则通过**区分**其**指向**的是**常量对象**还是**非常量对象**可以实现**函数重载**，注意此时的`const`**是底层的**

  ```cpp
  void lookup(Phone);
  void lookup(const Phone);       // 重复声明了void lookup(Phone)
  void lookup(Phone*);
  void lookup(Phone* const);      // 重复声明了void lookup(Phone*)，顶层const
  /*------------------------------------------------------*/
  void lookup(Account&);          // 作用于Account的引用
  void lookup(const Account&);    // 新函数，作用于常量引用
  void lookup(Account*);          // 作用于指向Account的指针
  void lookup(const Account*);    // 新函数，作用于指向常量的指针，底层const
  ```

- **const_cast 和重载**

  > 1、`const_cast`在**重载函数**的情境中最有用，如下例  
  > 2、**原函数**的**参数**和**返回类型**都是`const string`**的引用**。虽然我们可以对两个**非常量的**`string`调用这个函数，但**返回结果**仍是`const string`，我们并**不希望返回的是常量**  
  > 3、此时我们需要一种**新的函数**，当它的**实参不是常量**时，得到的结果是一个**非常量引用**，使用`const_cast`可以很方便做到这一点  
  > 4、**新函数**内通过`const_cast`把参数先转为**常量**，调用**原函数**，再将**原函数结果**转为**非常量**

  ```cpp
  // 原函数，返回 const string 的引用
  const string &shorterString(const string &s1, const string &s2)
  {
      return s1.size() <= s2.size() ? s1 : s2;
  }
  // 重载函数，返回非 const 的引用
  string &shorterString(string &s1, string &s2)
  {
      auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
      return const_cast<string&>(r);
  }
  ```

##### **特殊用途语言特性**

- **默认实参**

  > 1、可以将**函数**的**形参列表**中的值赋予初始值，这便是**默认实参**。当**函数调用**时，如果**没有给定这个值的实参**，便会使用**默认实参**  
  > 2、我们可以为**一个或多个形参**赋予默认值。但要注意，一旦某个形参被赋予了默认值，它**后面的所有形参**都**必须有默认值**  
  > 3、**函数调用**时，实参按照**位置顺序**解析，**默认实参**负责填补函数调用**缺少的尾部实参**(即靠右侧位置的形参)。即**不能省略前面的参数值**，**只能省略尾部的参数值**

  ```cpp
  // 默认实参函数定义
  typedef string::size_type sz;
  string screen(sz ht = 24, sz wid = 24, char background = ' ');
  // 函数调用
  string window;
  window = screen();            // screen(24, 80, ' ')
  window = screen(66);          // screen(66, 80, ' ')
  window = screen(66,256,'#')   // screen(66, 256, '#')
  // 错误调用
  window = screen(, , '?');     // 错误
  window = screen('?');         // 错误，screen('?', 80, ' ')
  ```

- **内联函数**

  > 1、使用`inline`将函数指定为**内联函数**，通常就是将它在**每个调用点**上**内联地展开**，可以**避免函数调用的开销**。说明如下示例  
  > 2、**内联**只是向**编译器**发出的**一个请求**，**编译器**可以选择**忽略这个请求**  
  > 3、一般来说，**内联机制**用于**优化规模较小**、**流程直接**、**调用频繁**的函数。很多编译器不支持**内联递归函数**，而且一个**大于 75 行**的函数也不大可能在**调用点内联展开**

  ```cpp
  // 原函数即程序调用
  inline string shorterString(string &s1, string &s2)
  {
      return s1.size() <= s2.size() ? s1 : s2;
  }
  string s1 = "abcde", s2 = "abcdef";
  cout << shorterString(s1, s2);

  // 在编译过程中，函数调用将直接展开成下面形式，从而不经过shorterString，减少了函数调用的开销
  cout << (s1.size() <= s2.size() ? s1 : s2);
  ```

- **constexpr 函数**

  > 1、`constexpr`**函数**是指能用于**常量表达式**的函数。定义的方法与其他函数类似，但**有如下规定**：函数的**返回类型**及**所有形参**都必须是**字面值类型**，而且函数体中必须**有且仅有一条**`return`**语句**  
  > 2、执行**初始化任务**时，**编译器**把**对**`constexpr`**函数的调用**都替换成其**结果值**。为了能在编译过程中**随时展开**，`constexpr`**函数**被**隐式指定为内联函数**  
  > 3、`constexpr`**函数**不一定返回常量表达式

  ```cpp
  constexpr size_t scale(size_t ct)
  {
      return 3 * ct;
  }

  int arr[scale(2)];      // 正确，编译时 scale(2) 将被内联展开为 6
  int i = 2;
  int a2[scale(i)];       // 错误，i不是常量表达式
  ```

---

#### **类**

---

<div class="success">

> **章节概要**：定义抽象数据类型；设计`Sales_data`类；定义`Sales_data`类；分析与设计；`this`参数；`const`成员函数；返回`this`对象的函数；该类相关的非成员函数；构造函数；合成的默认构造函数；合成的默认构造函数的局限性；定义构造函数；`= default`的含义；构造函数初始值列表；类外定义构造函数；拷贝、赋值和析构；访问控制与封装；`public`和`private`；`class`和`struct`；友元；类的其他特性；类成员再探；`mutable`可变数据成员；返回`*this`的成员函数；从`const`成员函数返回`*this`；基于`const`的重载；友元再探；类之间的友元关系；令函数成员作为友元；友元函数重载和作用域；类的作用域；名字查找与类作用域

</div>

##### **定义抽象数据类型**

- **抽象数据类型**

  > 1、如果一个类，我们可以通过它的**接口**(例如描述的操作)来**使用该类的对象**，但**不能访问该类的数据成员**(甚至不知道该类有哪些数据成员)，我们称**这样的类**为**抽象数据类型**  
  > 2、反之，如果一个类**允许用户**直接**访问它的数据成员**，并要求**用户**来**编写操作**，**这样的类**不是一个抽象数据类型  
  > 3、对于一个**普通的数据类型**(非抽象数据类型)，如果想把它变成**抽象数据类型**，我们需要**定义一些操作**供类的用户使用。一旦**定义了自己的操作**，我们就可以**封装它的数据成员**了

- **设计 Sales_data 类**

  - **引入**

    > 1、为了方便图书管理，我们需要**设计一个类**便于**信息存储**与**操作**，需要先**分析满足下列操作**：  
    > 2、类中需要有**能读写的数据对象**，需要对这些对象**支持一些操作**  
    > 3、**操作包括**一个名为`isbn`的**成员函数**，并且支持`+`、`=`、`+=`、`<<`、`>>`**运算符**  
    > 4、我们将在后续学习**重载运算符**，现在对于**运算符运算**，我们先定义为**普通函数**的形式  
    > 5、由于特殊的原因(后续重载运算符介绍)，执行**加法**和**IO 的函数**不作为**类的成员**，我们将其定义成**普通函数**

  - **该类应包含的操作**

    > 1、一个`isbn`**成员函数**，返回**对象的 ISBN 编号**  
    > 2、一个`combine`**成员函数**，用于将一个`Sales_data`**对象加到另一个对象上**  
    > 3、一个`add`**函数**，执行两个`Sales_data`对象的**加法**  
    > 4、一个`read`**函数**，将数据从`istream`**读入到**`Sales_data`**对象中**  
    > 5、一个`print`**函数**，将`Sales_data`**对象的值输出到**`ostream`中

  - **使用类的接口**(先不考虑如何实现该类，首先看看应该如何使用这些接口函数)

    ```cpp
    Sales_data total;             // 保存当前求和结果的变量
    if(read(cin, total))          // 读入第一笔交易
    {
        Sales_data trans;         // 保存下一条交易数据的变量
        while(read(cin, trans))   // 读入剩余的交易
        {
            if(total.isbn() == trans.isbn())    // 检查 isbn
              total.combine(trans);             // 更新变量 total 当前的值
            else
            {
                print(cout, total) << endl;     // 输出结果
                total = trans;                  // 处理下一本书
            }
        }
        print(cout, total) << endl; // 输出最后一条交易
    }
    else                            // 如果没有输入
    {
        cerr << "No data?" << endl; // 通知用户
    }
    ```

- **定义 Sales_data 类**

  - **分析与设计**

    > 1、该类的**数据成员**有：`string`类型的**bookNo**，表示 ISBN 编号；`unsigned`类型的**units_sold**，表示某书的销量；`double`类型的**revenue**，表示这本书的总销售收入  
    > 2、类中将包含`combine`和`isbn`两个**成员函数**，此外，我们还需要另一个**成员函数**`avg_price`返回售出书籍的平均价格。由于`avg_price`的**目的并非通用**，所以它应该属于**类的实现的一部分**，而不是**接口的一部分**  
    > 3、**定义**和**声明**一个**成员函数**的方法与普通函数差不多。**成员函数的声明**必须在**类的内部**，而它的**定义可以在外部**。作为**接口组成部分**的**非成员函数**`add`、`read`、`print`等，它们的**定义和声明**都在**类的外部**  
    > 4、定义在**类内部的函数**是**隐式的内联函数**

    ```cpp
    struct Sales_data
    {
        // 数据成员
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
        // 成员函数
        std::string isbn() const
        {
            return bookNo;
        }
        Sales_data &combine(const Sales_data &);    // 将在类外定义
        double avg_price() const;                   // 将在类外定义
    };
    // 非成员接口函数
    Sales_data add(const Sales_data &, const Sales_data &);
    std::ostream &print(std::ostream &, const Sales_data &);
    std::istream &read(std::istream &, Sales_data &);
    ```

  - `this`**参数**

    > 1、`isbn`**成员函数**是如何获得**bookNo 成员**所依赖的**对象**的呢？  
    > 2、观察对`isbn`的**调用**：`total.isbn()`。我们使用了**点运算符**来访问**total 对象**中的`isbn`**成员函数**并调用它  
    > 3、还有一种**例外的形式**，当我们**调用成员函数**时，实际上是在**替某个对象调用它**。如果`isbn`指向`Sales_data`的**成员**(如 bookNo)，则它**隐式地**指向**调用该函数的对象的成员**。在上例中，当`isbn`返回**bookNo**时，实际上它**隐式地**返回**total.bookNo**  
    > 4、**成员函数**通过名为`this`的**额外的隐式参数**来访问和调用它的那个对象，当我们**调用成员函数**时，会用**请求该函数的对象地址**初始化`this`。例如调用`total.isbn()`时，**编译器**负责把**total 的地址**传递给`isbn`的**隐式形参**`this`  
    > 5、在**成员函数体**内部，也可以直接使用**调用该函数的对象的成员**，而无须通过**成员访问运算符**，因为`this`所指的**正是这个对象**。任何对**类成员**的**直接访问**都被看作`this`的**隐式引用**  
    > 6、对于我们来说，`this`**形参**是**隐式定义**的，我们可以在**成员函数体**内部使用`this`。尽管没有必要，但我们还是可以把`isbn`的**函数体写为**`return this->bookNo;`  
    > 7、因为`this`**总是指向这个对象**，所以`this`是一个**常量指针**，**不允许修改**`this`中保存的地址

  - `const`**成员函数**

    > 1、`isbn`函数的另一个**关键之处**是**参数列表后的**`const`，这里，`const`的作用是**修改隐式**`this`**指针的类型**  
    > 2、默认情况下，`this`的类型是**指向类类型**的**非常量版本**的**常量指针**，例如`Sales_data`**成员函数**中，`this`的类型是`Sales_data *const`。这意味着，我们不能把`this`绑定到一个**常量对象**上，这使得不能在一个**常量对象**上调用**普通的成员函数**  
    > 3、如果`isbn`是一个**普通函数**且`this`是一个**普通指针形参**，则我们**应该把**`this`**声明成**`const Sales_data *const`**类型**，毕竟`isbn`函数体内**不会改变**`this`**所指的对象**  
    > 4、然而，`this`**是隐式的**而且不会出现在**形参列表**中，在哪将`this`声明成**指向常量的指针**？C++的做法是把`const`放在成员函数的**参数列表后**  
    > 5、紧跟在**参数列表后**的`const`表示`this`是一个**指向常量的指针**，而像这样使用`const`的**成员函数**称作**常量成员函数**

  - **在类的外部定义成员函数**

    > 1、前面提过**成员函数的定义可以在类外**，我们的`avg_price`和`combine`**成员函数**就打算通过这种方式定义  
    > 2、要注意，**类外部定义的成员的名字**必须包含**所属的类名**，通过**作用域运算符**来告知**编译器**定义的这个函数是**类内的成员函数**

    ```cpp
    double Sales_data::avg_price() const
    {
        if (units_sold)
            return revenue / units_sold;
        else
            return 0;
    }
    ```

  - **返回**`this`**对象的函数**

    > 1、函数`combine`的设计初衷类似于**复合赋值运算符**`+=`，其定义如下  
    > 2、当程序调用`total.combine(trans);`时，`this`指针绑定了**total 的地址**，**rhs 引用**绑定了**实参 trans**  
    > 3、该函数值得关注的是它的**返回类型**和**返回语句**。模仿标准的**赋值运算符**把它的**左侧运算对象**当做**左值**返回，因此`combine`**必须返回引用**，而**左侧运算对象**又是`Sales_data`**对象**，因此返回类型是`Sales_data&`  
    > 4、如前所述，我们需要**把该对象当做左值返回**。我们无须使用隐式的`this`指针访问**函数调用者**的**某个具体成员**，而是要把**调用函数的对象**当做一个整体来访问，即`return *this;`，该调用**返回 total 的引用**

    ```cpp
    Sales_data &Sales_data::combine(const Sales_data &rhs)
    {
        // 把 rhs 的成员加到 this 的成员上
        units_sold += rhs.units_sold;
        revenue += rhs.revenue;
        // 返回调用该函数的对象
        return *this;
    }
    ```

  - **该类相关的非成员函数**

    - `read`和`print`函数

      > 1、`read`和`print`函数分别接受一个**各自 IO 类型的引用**作为其参数，是因为**IO 类**属于**不能被拷贝的类型**，因此只能**通过引用传递**。而且，读取和写入的操作**会改变流的内容**，所以使用**普通引用**而不是`const`**引用**  
      > 2、`print`**函数不负责换行**。一般来说，**执行输出任务的函数**应该尽量**减少对格式的控制**，这样可以确保**由用户代码决定**是否换行

      ```cpp
      // 输入的交易信息包括 ISBN、售出总数、售出单价
      std::istream &read(std::istream &is, Sales_data &item)
      {
          double price = 0;
          is >> item.bookNo >> item.units_sold >> price;
          item.revenue = price * item.units_sold;
          return is;
      }

      std::ostream &print(std::ostream &os, const Sales_data &item)
      {
          os << item.isbn() << ' ' << item.units_sold << ' ' << item.revenue << ' ' << item.avg_price();
          return os;
      }
      ```

    - `add`函数

      ```cpp
      Sales_data add(const Sales_data &lhs, const Sales_data &rsh)
      {
          Sales_data sum = lhs; // 把 lhs 的数据成员拷贝给 sum
          sum.combine(rsh);     // 把 rsh 的数据成员添加到 sum
          return sum;           // 返回新的 Sales_data 对象
      }
      ```

- **构造函数**

  - **介绍**

    > 1、每个**类**都分别定义了它的**对象被初始化的方式**，**类**通过一个或几个**特殊的成员函数**控制其对象的初始化过程，**这些函数**被称为**构造函数**  
    > 2、**构造函数**的任务是**初始化类对象**的**数据成员**，无论何时只要**有类的对象被创建**，**就会执行构造函数**  
    > 3、构造函数的**名字和类名相同**。和其他函数不同的是，构造函数**没有返回类型**，且不能被声明成`const`。类可以包含**多个构造函数**，和其他**重载函数**类似  
    > 4、当我们创建类的一个`const`**对象**时，直到**构造函数完成初始化**过程，对象才真正取得了**常量属性**。因此**构造函数**在`const`**对象**的构造过程中**可以向其写值**

  - **合成的默认构造函数**

    > 1、我们的`Sales_data`类并没有定义任何**构造函数**，可是之前**使用了**`Sales_data`**对象**的程序却没有异常，它们是如何初始化的？  
    > 2、我们没有为这些对象**提供初始值**，它们执行了**默认初始化**。**类**通过一个**特殊的构造函数**来控制**默认初始化过程**，这个函数叫做**默认构造函数**，其**无须任何实参**  
    > 3、如我们所见，**默认构造函数**在很多方面都有其**特殊性**。其中之一是，如果我们的类**没有显式定义构造函数**，编译器会为我们**隐式定义一个默认构造函数**，这样的函数有称为**合成的默认构造函数**  
    > 4、对于大多数类来说，这个**合成的默认构造函数**将按照**如下规则**初始化数据：使用**类内的初始值**(如果有的话)**初始化**成员，否则**默认初始化该成员**

  - **合成的默认构造函数的局限性**

    > 1、**合成的默认构造函数**只适合**非常简单**的类，对于一个**普通的类**来说，**必须**定义它自己的**默认构造函数**，原因有三：  
    > 2、首先，编译器只有在发现**类不包含任何构造函数时**才会替我们生成默认构造函数，一旦我们**定义了一些其他构造函数**，除非我们**再定义**一个**默认生成函数**，否则类将**没有默认构造函数**。如果一个类需要**在某种情况下控制初始化**，那么该类很可能**在所有情况下都需要控制**  
    > 3、其次，对于某些类来说，**合成的默认构造函数**可能执行**错误的操作**。如果定义在**块中的内置类型**或数组指针这类的**复合类型的对象**被**默认初始化**，它们的值是**未定义**的。因此这样的类应该在**类内初始化**这些成员，或定义一个自己的**默认构造函数**  
    > 4、最后，有时候**编译器**不能为**某些类**合成默认构造函数。对这样的类来说，**必须**自定义**默认构造函数**，否则该类将没有可用的**默认构造函数**

  - **定义构造函数**

    - **示例**

      > 1、对于我们的`Sales_data`类，我们将使用**下面的参数**定义 4 个不同的**构造函数**  
      > 2、一个`istream&`，从中读取一条交易信息  
      > 3、一个`const string&`，表示 ISBN 编号；一个`unsigned`，表示图书数量；一个`double`，表示售出单价  
      > 4、一个`const string&`，表示 ISBN 编号，编译器将赋予其他成员默认值  
      > 5、一个**空参数列表**(即默认构造函数)，如刚刚介绍，既然**已定义其他构造函数**，那么也**必须**定义一个**默认构造函数**

      ```cpp
      struct Sales_data
      {
          // 新增的构造函数
          Sales_data() = default;
          Sales_data(const std::string &s) : bookNo(s)
          {
          }
          Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
          {
          }
          Sales_data(std::istream &);   // 将在类外定义

          // 数据成员
          std::string bookNo;
          unsigned units_sold = 0;
          double revenue = 0.0;
          // 成员函数
          std::string isbn() const
          {
              return bookNo;
          }
          Sales_data &combine(const Sales_data &);
          double avg_price() const;
      };
      ```

    - `= default`的含义

      > 1、我们首先解释**默认构造函数**：`Sales_data() = default;`  
      > 2、首先请明确：因为该构造函数**不接受任何实参**，所以它是**默认构造函数**。我们定义它只是因为我们既需要**其他形式的构造函数**，又需要**默认的构造函数**，我们希望它的作用完全等同于**合成的默认构造函数**  
      > 3、在 C++11 中，如果我们需要**默认的行为**，可以通过在**参数列表后**写上`= default`来**要求编译器生成构造函数**。其中`= default`既可以和声明一起**出现在类内**，也可以作为定义**出现在类外**  
      > 4、和其他函数一样，如果`= default`在**类内**，则默认构造函数**是内联的**；反之则**不是内联的**

    - **构造函数初始值列表**

      > 1、之后的两个构造函数中，出现了**新的部分**，即**冒号**及**冒号和花括号之间**的代码。其中**花括号**定义了**空的函数体**，我们把**新出现的部分**称为**构造函数初始值列表**  
      > 2、这部分负责为**新创建的对象**的一个或几个**数据成员**赋初值。**构造函数初始值**是**成员名字**的一个列表，每个名字后紧跟**括号括起来的**或者**在花括号内的**成员初始值。不同成员初始化通过**逗号分隔**  
      > 3、例如，上例含有三个参数的**构造函数**分别用**前两个参数**初始化了成员**bookNo**和**units_sold**，而**revenue**的初始值则通过`revenue(p * n)`使用计算后的值作为初始值  
      > 4、需要注意，这两个**构造函数**的**函数体是空的**是因为这些构造函数的**唯一目的**就是**为成员赋值**，没有其他任务需要执行

    - **类外定义构造函数**

      > 1、我们将在**类外定义**以`istream`为参数的构造函数。该函数需要**执行一些实际操作**，所以在函数体内，调用了之前定义的`read`**函数**给**数据成员赋值**  
      > 2、`Sales_data::Sales_data`的含义是，我们定义的是`Sales_data`**类的成员**，其**成员名**是`Sales_data`  
      > 3、这个**构造函数**的**初始值列表为空**，但是由于执行了**构造函数体**，所以**对象的成员**依然能被初始化

      ```cpp
      Sales_data::Sales_data(std::istream &is)
      {
          read(is, *this);
      }
      ```

- **拷贝、赋值和析构**

  > 1、除了定义类的对象**如何初始化**外，类还需要控制**拷贝**、**赋值**和**销毁对象时发生的行为**  
  > 2、如果我们不**主动定义**这些操作，编译器将替我们**合成它们**。一般来说，编译器生成的版本将对对象的**每个成员**执行**拷贝**、**赋值**和**销毁操作**  
  > 3、我们将在 13 章介绍如何**自定义上述操作**

- **完整的类与使用**

  ```cpp
  #include <iostream>
  #include <string>

  struct Sales_data
  {
      // 新增的构造函数
      Sales_data() = default;
      Sales_data(const std::string &s) : bookNo(s)
      {
      }
      Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
      {
      }
      Sales_data(std::istream &);

      // 数据成员
      std::string bookNo;
      unsigned units_sold = 0;
      double revenue = 0.0;
      // 成员函数
      std::string isbn() const
      {
          return bookNo;
      }
      Sales_data &combine(const Sales_data &);
      double avg_price() const;
  };


  // 非成员接口函数
  Sales_data add(const Sales_data &, const Sales_data &);
  std::ostream &print(std::ostream &, const Sales_data &);
  std::istream &read(std::istream &, Sales_data &);

  double Sales_data::avg_price() const
  {
      if (units_sold)
          return revenue / units_sold;
      else
          return 0;
  }

  Sales_data &Sales_data::combine(const Sales_data &rhs)
  {
      // 把 rhs 的成员加到 this 的成员上
      units_sold += rhs.units_sold;
      revenue += rhs.revenue;
      // 返回调用该函数的对象
      return *this;
  }

  // 输入的交易信息包括 ISBN、售出总数、售出单价
  std::istream &read(std::istream &is, Sales_data &item)
  {
      double price = 0;
      is >> item.bookNo >> item.units_sold >> price;
      item.revenue = price * item.units_sold;
      return is;
  }

  std::ostream &print(std::ostream &os, const Sales_data &item)
  {
      os << item.isbn() << ' ' << item.units_sold << ' ' << item.revenue << ' ' << item.avg_price();
      return os;
  }

  Sales_data add(const Sales_data &lhs, const Sales_data &rsh)
  {
      Sales_data sum = lhs; // 把 lhs 的数据成员拷贝给 sum
      sum.combine(rsh);     // 把 rsh 的数据成员添加到 sum
      return sum;           // 返回新的 Sales_data 对象
  }

  // 构造函数
  Sales_data::Sales_data(std::istream &is)
  {
      read(is, *this);
  }

  int main()
  {
      Sales_data total;          // 保存当前求和结果的变量
      if (read(std::cin, total)) // 读入第一笔交易
      {
          Sales_data trans;             // 保存下一条交易数据的变量
          while (read(std::cin, trans)) // 读入剩余的交易
          {
              if (total.isbn() == trans.isbn()) // 检查 isbn
                  total.combine(trans);         // 更新变量 total 当前的值
              else
              {
                  print(std::cout, total) << std::endl; // 输出结果
                  total = trans;                        // 处理下一本书
              }
          }
          print(std::cout, total) << std::endl; // 输出最后一条交易
      }
      else // 如果没有输入
      {
          std::cerr << "No data?" << std::endl; // 通知用户
      }
      return 0;
  }
  ```

##### **访问控制与封装**

- **public 和 private**

  > 1、对目前为止，我们已经为类**定义了接口**，但没有任何机制**强制用户使用这些接口**。我们的类**还没有封装**，也就是说，用户可以**直达**`Sales_data`**对象内部**并**控制它的具体细节**  
  > 2、C++中，我们使用**访问说明符**来加强类的**封装性**，如下说明。我们可以使用这些说明符再次定义`Sales_data`类，如后示例程序  
  > 3、`public`**说明符**：定义在`publib`后的成员**可以在整个程序内被访问**，`public`成员**定义类的接口**  
  > 4、`private`**说明符**：定义在`private`后的成员**只可以被类的成员函数访问**，不能被使用该类的代码访问，`private`部分封装了**类的实现细节**  
  > 5、通常**构造函数**和**部分成员函数**跟在`public`后，而**数据成员**和**作为实现部分的函数**跟在`private`后  
  > 6、一个类可以包含**任意数量**的**访问说明符**，每个**访问说明符**指定了接下来的**成员访问级别**，其**有效范围**直到出现**下一个访问说明符**或**类的结尾**

  ```cpp
  class Sales_data
  {
      public:
          Sales_data() = default;
          Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
          {
          }
          Sales_data(const std::string &s) : bookNo(s)
          {
          }
          Sales_data(std::istream &);

          std::string isbn() const
          {
              return bookNo;
          }
          Sales_data &combine(const Sales_data &);

      private:
          double avg_price() const
          {
              return units_sold ? revenue / units_sold : 0;
          }
          unsigned units_sold = 0;
          std::string bookNo;
          double revenue = 0.0;
  };
  ```

- **class 和 struct**

  > 1、上例我们使用了`class`而非`struct`**定义类**，这种变化只是**形式上有所不同**，可以**任意选择**。**唯一区别**是它们的**默认访问权限不一样**  
  > 2、类可以在它**第一个访问说明符前**定义成员，这种成员的**访问权限**依赖于**类定义的方式**  
  > 3、使用`struct`则这种成员**默认是**`public`的，而`class`这种成员**默认是**`private`的

- **友元**

  > 1、既然`Sales_data`的**数据成员**是`private`的，那么我们的`add`、`print`、`add`函数就**无法正常编译**了。这是因为这几个函数虽然**是类接口的一部分**，但**不是类的成员**  
  > 2、类可以允许**其他类或函数**访问它的**非公有成员**，方法是令它们成为该类的**友元**。对于函数，只需要增加一条`friend`**关键字**开头的**函数声明**即可  
  > 3、**友元声明**只能出现在**类定义内部**，但友元**不是类的成员**也**不受访问控制的约束**  
  > 4、**友元声明**仅仅指定了**访问权限**，而非一个通常意义上的**函数声明**。如果我们希望**类的用户**能够调用某个**友元函数**，就必须在**友元声明外**再次专门进行一次**函数声明**

  ```cpp
  friend Sales_data add(const Sales_data &, const Sales_data &);
  friend std::istream &read(std::istream &, Sales_data &);
  friend std::ostream &print(std::ostream &, const Sales_data &);
  ```

##### **类的其他特性**

- **类成员再探**

  - 为了展示这些新特性，我们需要定义**一对相互关联的类**：`Screen`和`Window_mgr`

  - **定义类型成员**

    > 1、假设`Screen`表示显示器中的**一个窗口**，该类中包含一个用于**保存内容**的`string`成员和分别用于表示**光标位置**、**屏幕的高和宽**的`string::size_type`成员  
    > 2、除了定义**数据和函数成员**外，类还可以**自定义某种类型**在类中的**别名**。这种**类型别名**与其他成员一样存在**访问限制**，可以是`public`或`private`的一种  
    > 3、如下我们在`public`部分定义了`pos`**别名**，这样用户就可以使用这个名字。`Screen`的用户不应该知道该类使用`string`**对象**来**存放数据**，因此通过把`pos`定义成`public`可以**隐藏**`Screen`的**实现细节**

    ```cpp
    class Screen
    {
        public:
            typedef std::string::size_type pos;

        private:
            pos cursor = 0;
            pos height = 0, width = 0;
            std::string contents;
    };
    ```

  - `Screen`**类的成员函数**

    ```cpp
    class Screen
    {
        public:
            typedef std::string::size_type pos;
            Screen() = default; // 默认构造函数
            Screen(pos ht, pos wd, char c)
                : height(ht), width(wd), contents(ht * wd, c) // 构造函数，cursor 会被类内初始值初始化为 0
            {
            }
            char get() const // 读取光标处的字符
            {
                return contents[cursor]; // 隐式内联
            }
            // 重载成员函数 get
            inline char get(pos ht, pos wd) const; // 显式内联
            Screen &move(pos r, pos c);            // 能在之后被设置为内联

        private:
            pos cursor = 0;
            pos height = 0, width = 0;
            std::string contents;
    };

    // 在类内声明为 inline
    char Screen::get(pos r, pos c) const
    {
        pos row = r * width;      // 计算行的位置
        return contents[row + c]; // 返回给定列的字符
    }
    // 在定义处指定 inline
    inline Screen &Screen::move(pos r, pos c)
    {
        pos row = r * width; // 计算行的位置
        cursor = row + c;    // 在行内将光标移动到指定列
        return *this;        // 以左值形式返回对象
    }
    ```

  - `mutable`**可变数据成员**

    > 1、有时我们希望能**修改类的某个数据成员**，即使是在一个`const`**成员函数**里，对此可以通过在**变量的声明**中加入`mutable`**关键字**声明一个**可变数据成员**  
    > 2、一个**可变数据成员**永远不会是`const`，即使它是`const`**对象的成员**。因此，一个`const`**成员函数**可以改变一个可变成员的值  
    > 3、例如，我们将给`Screen`添加一个**access_ctr 可变成员**，以跟纵成员函数被调用了多少次，如下例。尽管`some_member`是一个`const`**成员函数**，但依然可以改变**access_ctr**的值

    ```cpp
    public:
        void some_member() const
        {
            ++access_ctr; // 保存一个计数值，用于记录成员函数被调用的次数
        }

    private:
        mutable size_t access_ctr; // 即使在一个 const 对象内也能被修改
    ```

  - **类数据成员的初始值**

    > 1、定义好`Screen`后，我们将继续定义一个**窗口管理类**并用它来表示显示器上的**一组**`Screen`。这个类将包含一个`Screen`**类型的**`vector`，**每个元素**表示一个特定的`Screen`  
    > 2、默认情况下，我们希望`Window_mgr`类开始时总是**拥有一个默认初始化的**`Screen`。C++11 中，最好的办法是把这个**默认值**声明成一个**类内初始值**，由`Screen`的**构造函数初始化**

    ```cpp
    class Window_mgr
    {
        private:
            // 默认情况下，一个 Window_mgr 包含一个标准尺寸的空白 Screen，通过类内初始值和 Screen 的构造函数实现
            std::vector<Screen> screens{Screen(24, 80, ' ')};
    };
    ```

- **返回 \*this 的成员函数**

  - **继续改进**

    ```cpp
    class Screen
    {
        public:
            // 添加两个新的成员函数
            Screen &set(char);
            Screen &set(pos, pos, char);
    };

    inline Screen &Screen::set(char c)
    {
        contents[cursor] = c; // 设置当前光标所在位置的新值
        return *this;         // 将 this 作为左值返回
    }
    inline Screen &Screen::set(pos r, pos col, char ch)
    {
        contents[r * width + col] = ch; // 设置给定位置的新值
        return *this;                   // 将 this 作为左值返回
    }
    ```

  - **返回**`*this`**的意义**

    > 1、和`move`操作一样，`set`的**返回值**也是**调用**`set`**对象的引用**，意味着这些函数**返回的是对象本身**而不是**对象的副本**  
    > 2、如果我们把**一系列操作**连在**一条表达式**：`myScreen.move(4,0).set('#');`，这些操作将会**在同一个对象上执行**  
    > 3、更直观的，我们将这条**语句的含义拆解**，如下：

    ```cpp
    // 如果返回 Screen &，其等价于：
    myScreen.move(4,0);
    myScreen.set('#');

    // 如果返回 Screen，其等价于：
    Screen temp = myScreen.move(4,0);     // 对返回值进行拷贝
    temp.set('#');                        // 不会改变 myScreen 的 contents
    ```

  - **从**`const`**成员函数返回**`*this`

    > 1、下面我们要添加一个`display`**操作**，负责**打印**`Screen`**的内容**。我们希望这个函数能和`move`、`set`**出现在同一序列**，因此该函数也应该**返回它的对象的引用**  
    > 2、从逻辑上说，**显示**并不需要**改变对象内容**，因此我们令`display`是一个`const`成员。此时`this`将是一个**指向**`const`**的指针**，而`*this`就是`const`**对象**  
    > 3、由此推断，`display`的**返回类型**是`const Screen&`。然而，如果真的**返回一个**`const`**的引用**，那我们就**不能**将其**嵌入到一组动作的序列**里(如后示例)  
    > 4、即使**myScreen**是个**非常量对象**，对`set`的调用也**不能通过编译**。问题在于`display`的`const`版本返回了**常量引用**，我们无权`set`一个**常量对象**

    ```cpp
    Screen myScreen;
    // 如果 display 返回常量引用，set 将无权更改常量对象的数据，因而报错
    myScreen.display(cout).set('*');
    ```

  - **基于**`const`**的重载**

    > 1、通过区分**成员函数**是否是`const`的，我们可以对其**进行重载**，其原因主要如下  
    > 2、首先，**非常量版本**的函数对于**常量对象**是不可用的，所以我们只能在**常量对象**上调用`const`**成员函数**。其次，虽然可以在**非常量对象**上使用**常量版本**的函数，但显然此时**非常量版本**是一个**更好的匹配**  
    > 3、如下例，我们将声明一个`do_display`**私有成员**，用于负责打印。**所有的**`display`**操作**都将**调用这个函数**，然后**返回自己的类型的对象**  
    > 4、当`do_display`执行完成后，这**非常量版本**的`display`函数**返回普通引用**，而**常量版本**的`display`函数**返回常量引用**

    ```cpp
    class Screen
    {
        public:
            // 普通版本 display
            Screen &display(std::ostream &os)
            {
                do_display(os);
                return *this;
            }
            // const 版本 display
            const Screen &display(std::ostream &os) const
            {
                do_display(os);
                return *this;
            }

        private:
            void do_display(std::ostream &os) const
            {
                os << contents;
            }
    };
    ```

- **完整的 Screen 类**

  ```cpp
  #include <iostream>
  #include <string>
  #include <vector>

  class Screen
  {
      public:
          typedef std::string::size_type pos;

          Screen() = default; // 默认构造函数
          Screen(pos ht, pos wd, char c)
              : height(ht), width(wd), contents(ht * wd, c) // 构造函数，cursor 会被类内初始值初始化为 0
          {
          }

          char get() const // 读取光标处的字符
          {
              return contents[cursor]; // 隐式内联
          }
          inline char get(pos ht, pos wd) const; // 显式内联
          Screen &move(pos r, pos c);            // 能在之后被设置为内联

          void some_member() const
          {
              ++access_ctr; // 保存一个计数值，用于记录成员函数被调用的次数
          }

          Screen &set(char);
          Screen &set(pos, pos, char);

          // 普通版本 display
          Screen &display(std::ostream &os)
          {
              do_display(os);
              return *this;
          }
          // const 版本 display
          const Screen &display(std::ostream &os) const
          {
              do_display(os);
              return *this;
          }

      private:
          mutable size_t access_ctr; // 即使在一个 const 对象内也能被修改
          pos cursor = 0;
          pos height = 0, width = 0;
          std::string contents;

          void do_display(std::ostream &os) const
          {
              os << contents;
          }
  };

  // 在类内声明为 inline
  char Screen::get(pos r, pos c) const
  {
      pos row = r * width;      // 计算行的位置
      return contents[row + c]; // 返回给定列的字符
  }
  // 在定义处指定 inline
  inline Screen &Screen::move(pos r, pos c)
  {
      pos row = r * width; // 计算行的位置
      cursor = row + c;    // 在行内将光标移动到指定列
      return *this;        // 以左值形式返回对象
  }

  inline Screen &Screen::set(char c)
  {
      contents[cursor] = c; // 设置当前光标所在位置的新值
      return *this;         // 将 this 作为左值返回
  }
  inline Screen &Screen::set(pos r, pos col, char ch)
  {
      contents[r * width + col] = ch; // 设置给定位置的新值
      return *this;                   // 将 this 作为左值返回
  }
  ```

- **友元再探**

  - 先前我们的`Sales_data`类把三个普通的**非成员函数**定义成了**友元**，类还可以把**其他的类**定义成**友元**，还可以把**其他类的成员函数**定义成**友元**

  - **类之间的友元关系**

    > 1、假设我们的`Window_mgr`类的**某些成员**可能需要访问它管理的`Screen`类的**内部数据**。例如我们需要为`Window_mgr`添加一个**clear 成员**，用于把指定的`Screen`**内容设为空白**  
    > 2、此时**clear**需要访问`Screen`的**私有成员**，而要使这种**访问合法**，`Screen`需要把`Window_mgr`指定成它的**友元**  
    > 3、如果一个类指定了**友元类**，则**友元类**的**成员函数**可以访问此类包括**私有成员在内**的**所有成员**  
    > 4、需要注意的是，**友元关系不存在传递性**。即如果`Window_mgr`有它自己的友元，这些友元**不能理所当然地访问**`Screen`

    ```cpp
    class Screen
    {
        friend class Window_mgr;
        // 此处省略先前的类对象
    };

    class Window_mgr
    {
        public:
            // 窗口中每个屏幕的编号
            using ScreenIndex = std::vector<Screen>::size_type;
            // 按照编号将指定的 Screen 重置为空白
            void clear(ScreenIndex i)
            {
                // s 是一个 Screen 的引用，指向我们想清空的屏幕
                Screen &s = screens[i];
                s.contents = std::string(s.height * s.width, ' ');
            }

        private:
            std::vector<Screen> screens{Screen(24, 80, ' ')};
    };
    ```

  - **令函数成员作为友元**

    > 1、除了令**整个类**作为**友元**外，还可以**只为 clear 提供访问权限**。当把一个成员**函数声明**称友元时，必须**明确指出**成员函数**属于哪个类**  
    > 2、但要想令某个**成员函数**作为**友元**，必须要按照如下方式设计程序：  
    > 3、首先定义`Window_mgr`类，其中声明**clear**函数，但**不能定义**它。在**clear**使用`Screen`成员之前必须**先声明**`Screen`；接下来定义`Screen`，包含对于**clear**的友元声明；最后定义**clear**，此时它才可以使用`Screen`成员

    ```cpp
    class Screen
    {
        friend void Window_mgr::clear(ScreenIndex);
    }
    ```

  - **友元函数重载和作用域**

    > 1、尽管**重载函数**的名字相同，但它们仍是**不同的函数**。因此如果一个类想把**一组重载函数声明**成**友元**，则需要对每一个函数**分别声明**  
    > 2、**类**和**非成员函数**的**声明**不是必须在它们的**友元声明之前**，当一个名字**第一个出现**在一个**友元声明**中，我们**隐式假定该名字在当前作用域中可见**，然而友元本身不一定真的声明在当前作用域。甚至就算在**类内定义该函数**，我们也必须在**类外提供相应的声明**，从而使得**函数可见**  
    > 3、重点在于理解**友元声明本身的作用**是**影响访问权限**，而不是**普通意义上的声明**

    ```cpp
    struct X
    {
        // 友元函数可以定义在类内，但不是真正的定义
        friend void f();
        X()
        {
          f();      // 调用 f() 函数，错误：f 还没有被声明
        }
        void g();
        void h();
    };

    void X::g()
    {
        return f(); // 调用 f() 函数，错误：f 还没有被声明
    }
    void f();       // 声明定义在 X 中的函数 f，从此时 f 才被真正声明可用
    void X::h()
    {
        return f(); // 正确：现在 f 的声明在作用域中了
    }
    ```

##### **类的作用域**

- **类的作用域**

  - **引入**

    > 1、每个类都会定义**它自己的作用域**。在**类的作用域外**，**普通数据**和**函数成员**只能由对象、引用、指针使用**成员访问运算符**来访问；对于**类类型成员**则使用**作用域运算符**来访问  
    > 2、不论哪种情况，跟在**运算符后的名字**都必须是**对应类的成员**

    ```cpp
    Screen::pos ht = 24, wd = 80;   // 使用 Screen 定义的 pos 类型
    Screen scr(ht, wd, ' ');
    Screen *p = &scr;
    char c = scr.get();             // 访问 scr 对象的 get 成员
    c = p -> get();                 // 访问 p 所指向的 scr 的 get 成员
    ```

  - **作用域和定义在类外的成员**

    > 1、一个**类**就是一个**作用域**很好的说明了为什么我们在**类外定义成员函数**时需要提供`类名::函数名`。在类外，**成员的名字被隐藏了**  
    > 2、一旦遇到了**类名**，定义的**剩余部分**就在**类的作用域内**了，这里的剩余部分包括**参数列表**和**函数体**，因而我们可以**直接使用类的其他成员**而无须再次授权  
    > 3、`Window_mgr`类的**clear 成员**用到了**该类中定义的**`ScreenIndex`**类型**：`void Window_mgr::clear(ScreenIndex i);`。这里使用`ScreenIndex`时已经在**该类的作用域下**(因为在`Window_mgr::`后)，所以**不需要额外说明**  
    > 4、有时由于**返回类型**出现在**类名前**，此时想要使用`ScreenIndex`作为**返回类型**，必须明确**指定哪个类定义了它**，如下

    ```cpp
    // 作用域::返回类型 类名::函数名(形参列表)
    window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s)
    ```
  
- **名字查找与类作用域**

---

#### **页底评论**

---
