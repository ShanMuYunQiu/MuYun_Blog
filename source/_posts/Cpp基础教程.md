---
title: Cpp基础教程
author: 圣奇宝枣
description: 有关于C++的基础教程，该教程建立在学习过C语言的基础上，进行对比学习，了解不同的特性和更多新内容
sticky: 2
date: 2022-12-03
updated: 2023-01-19
readmore: true
tags:
  - C++
  - 基础语法
categories:
  - 编程语言入门
---

---

_注：该教程建立在学习过 C 语言的基础上，因此很多提过的细节会忽略，主要学习一些 C 语言没有或不同的特性，建议先学习[C 语言基础教程](https://www.shengqibaozao.eu.org/2022/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/?t=1670037021388)_

_此外本文章中没有特殊重申的，大多语句和特性都与 C 语言相同，C++是 C 的超集，兼容了 C 的大多数特性_

---

#### **开始**

---

<div class="success">

> **章节概要**：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介

</div>

<!-- more -->

##### **编写一个简单的 C++程序**

- **简单示例**

  ```cpp
  // 相比C代码，可以省略main(void)的void
  int main()
  {
      return 0;
  }
  ```

##### **初识输入输出**

- **程序示例**

  ```cpp
  #include <iostream>
  int main()0
  {
      std::cout << "Enter two numbers!" << std::endl;
      int v1, v2;
      std::cin >> v1 >> v2;
      std::cout << "The sum of them is " << v1 + v2;
      return 0;
  }
  ```

- **C++的 IO 机制**

  > 1、**C++**包含了一个全面的**标准库**来提供**IO 机制**。其中有**从 C 语言延续而来**的`cstdio`库和**新的**`iostream`库  
  > 2、`iostream`库包含**两个基础类型**：`istream`和`ostream`，分别表示**输入流**和**输出流**  
  > 3、一个**流**(stream)就是一个**字符序列**，是**从 IO 设备读出**或**写入 IO 设备**的

- **标准输入输出对象**

  > 1、标准库定义了 4 个**IO 对象**  
  > 2、为了**处理输入**，我们使用名为`cin`的`istream`类型对象，这个对象也被称为**标准输入**  
  > 3、对于**处理输出**，我们使用名为`cout`的`ostream`类型对象，这个对象也被称为**标准输出**  
  > 4、此外还有其他两个`ostream`类型对象，名为`cerr`和`clog`。其中`cerr`通常用来**输出警告和错误信息**，`clog`用来**输出程序运行时的一般性信息**

- **向流写入写出**

  > 1、如果需要使用`iostream`**库中的对象**进行**输入输出**，则需要用到**流插入符**将内容传输给**流**  
  > 2、`<<`为**输出运算符**。其**接受两个运算对象**，**左侧**必须是一个`ostream`**对象**，**右侧**的运算对象是**要打印的值**。此运算符将**给定的值写入给定的**`ostream`**对象**中  
  > 3、`>>`为**输入运算符**。其与`>>`类型，它**左侧**接受一个`istream`**对象**，**右侧**接受一个**运算对象**。它从给定的`istream`中**读入数据**，并**存入给定的对象**中

- **endl 操纵符**

  > 1、**endl**是一个被称为**操纵符**的**特殊值**  
  > 2、**endl**的效果是**结束当前行**(有换行效果)，并将与设备关联的**缓冲区**的内容**刷到设备中**  
  > 3、**缓冲刷新操作**可以保证到目前为止**程序所产生的所有输出**都**真正写入流中**，而不是仅**停留在内存**中等待写入到流中

- **命名空间**

  > 1、示例程序中使用了`std::cout`和`std::endl`，而不是直接的`cout`和`endl`。其**前缀**`std::`指出**名字**`cout`和`endl`是定义在名为`std`的**命名空间**中的  
  > 2、**命名空间**可以帮助我们避免**不经意的名字定义冲突**以及**使用库中相同名字导致的冲突**。**标准库**定义的**所有名字**都在**命名空间**`std`中  
  > 3、通过**命名空间**使用**标准库**有一个**副作用**：当使用**标准库**中的**一个名字**时，必须通过**作用域运算符**`::`来**显式声明**我们想使用来自`std`中的名字，如示例`std::cout`那样(后续将给出一个更简单的访问标准库名字的方法)

##### **使用 C++版本的 C 标准库头文件**

- **建议使用 C++版本标准库**

  > 1、C++标准库中**兼容了 C 语言的标准库**，其按照如下**命名规则**命名  
  > 2、C 语言的头文件形如`name.h`，C++将其命名为`cname`。即**去掉**`.h`**后缀**，文件名前**添加字母**`c`  
  > 3、因此`stdio.h`和`cstdio`**内容是一样的**，而且`stdio.h`也能在 C++调用，但从**命名规范**上来讲，`cstdio`更符合 C++的要求  
  > 4、特别的，在名为`cname`的**头文件**定义的**名字**从属于**命名空间**`std`，而原本`.h`的则不然  
  > 5、一般来说，C++程序**应使用名为**`cname`**的头文件**，因为这样**标准库的名字**总能在`std`找到。如果使用`.h`形式，那么程序员不得不时刻牢记哪些是从 C 语言继承过来的，哪些又是 C++独有的

##### **类简介**

- 我们将在之后详细学习**类**相关的知识，在此只**简单介绍**

- **什么是类**

  > 1、在 C++中，我们通过**定义一个类**来**定义自己的数据结构**  
  > 2、一个**类**定义了**一个类型**，以及**与之相关的一组操作**  
  > 3、**类机制**是 C++**最重要的特性之一**。实际上，C++最初的**设计焦点**就是能定义使用上像内置类型一样自然的**类类型**

- 如果要使用一个类，我们需要了解**三件事情**：

  > 1、类名是什么？  
  > 2、它在哪里定义的？  
  > 3、它支持什么操作？

---

#### **变量和基本类型**

---

<div class="success">

> **章节概要**：基本内置类型；指定字面量类型；变量；对象；列表初始化；C++关键字；复合类型；引用；指针；void\* 指针；`const`限定符；`const`的引用；`constexpr`和常量表达式；处理类型；类型别名；`auto`类型说明符；`decltype`类型指示符；自定义数据结构；定义类；使用类

</div>

##### **基本内置类型**

- **基本数据类型**

  > 1、C++定义了一套包括**算数类型**和**空类型**在内的**基本数据类型**  
  > 2、其中**算数类型**包含了**整型**、**浮点型**、**字符型**、**布尔型**  
  > 3、**空类型 void**不对应**具体的值**，仅用于一些**特殊的场合**

- C++的**基本数据类型**与 C 语言**规则相同**，但 C++中**直接支持**了**bool 类型**，且`iostream`中**直接支持**了**拓展类型**(如`int32_t`等)

- **指定字面量类型**

  - 通过添加**前缀或后缀**，可以改变不同类型**字面量**的**默认类型**

  - **指定字符和字符串字面量**

    | 前缀 |   类型   | 含义                        |
    | :--: | :------: | --------------------------- |
    |  u   | char16_t | Unicode 16 字符             |
    |  U   | char32_t | Unicode 32 字符             |
    |  L   | wchar_t  | 宽字符                      |
    |  u8  |   char   | UTF-8(仅用于字符串字面常量) |

  - **指定整型字面量**

    |   后缀   | 最小匹配类型 |
    | :------: | :----------: |
    |  u 或 U  |   unsigned   |
    |  l 或 L  |     long     |
    | ll 或 LL |  long long   |

  - **指定浮点型字面量**

    |  后缀  |    类型     |
    | :----: | :---------: |
    | f 或 F |    float    |
    | l 或 L | long double |

##### **变量**

- **变量**

  > 1、**变量**提供一个**具名的**、**可供程序操作的存储空间**  
  > 2、C++中的每个变量都有其**数据类型**，**数据类型**决定着变量所占**内存空间**的**大小及布局方式**、该空间**能存储值的范围**，以及变量**能参与的运算**  
  > 3、对于 C++程序员来说，**变量**和**对象**一般可以**互换使用**

- **对象**

  > 1、C++程序员在很多场合都会使用**对象**这个名词。通常情况下，**对象**指一块**能存储数据**并**具有某种类型**的**内存空间**  
  > 2、一部分人对**对象**的定义并不相同，比如：一些人仅在**与类有关**的场景才使用**对象**这个词；另一些人把**命名了的对象**叫做**变量**；还有一些人把**对象**和**值**区分开来，**对象**指**能被程序修改的数据**，而**值**指**只读的数据**

- **列表初始化**

  - C++定义了**初始化**的**好几种不同形式**，如下：

    ```cpp
    int units_sold = 0;
    int units_sold(0);
    int units_sold = {0}; // 列表初始化
    int units_sold{0};    // 列表初始化
    ```

  - **列表初始化**

    > 1、作为**C++11 新标准**的一部分，用**花括号**来**初始化变量**得到了全面应用。这种初始化形式被称为**列表初始化**  
    > 2、现在，无论是**初始化对象**还是某些时候**为对象赋新值**，都可以使用这样一组**由花括号括起来的初始值**了  
    > 3、当用于**内置类型**变量时，这种初始化形式有一个**重要特点**：如果我们**使用列表初始化**且**初始值存在丢失信息的风险**，**编译器将报错**(如下例)  
    > 4、这样的介绍看似无关紧要，因为我们不会故意**用 long double 值初始化 int 变量**，然而这种初始化**可能在不经意间发生**，因此这种赋值更加**保守安全**

    ```cpp
    long double ld = 3.1415926536;
    int a{ld}, b = {ld};    // 报错：转换未执行，因为存在丢失信息的风险(丢失浮点精度)
    int c(ld), d = ld;      // 正确：转换执行，且确实丢失了部分值(丢失了小数点后的浮点部分)
    ```

- **C++关键字**

  |   关键字   |    关键字    |  关键字   |      关键字      |  关键字  |
  | :--------: | :----------: | :-------: | :--------------: | :------: |
  |  alignas   |   continue   |  friend   |     register     |   true   |
  |  alignof   |   decltype   |   goto    | reinterpret_cast |   try    |
  |    asm     |   default    |    if     |      return      | typedef  |
  |    auto    |    delete    |  inline   |      short       |  typeid  |
  |    bool    |      do      |    int    |      signed      | typename |
  |   break    |    double    |   long    |      sizeof      |  union   |
  |    case    | dynamic_cast |  mutable  |      static      | unsigned |
  |   catch    |     else     | namespace |  static_assert   |  using   |
  |    char    |     enum     |    new    |   static_cast    | virtual  |
  |  char16_t  |   explicit   | noexcept  |      struct      |   void   |
  |  char32_t  |    export    |  nullptr  |      switch      | volatile |
  |   class    |    extern    | operator  |     template     | wchar_t  |
  |   const    |    false     |  private  |       this       |  while   |
  | constexpr  |    float     | protected |   thread_local   |          |
  | const_cast |     for      |  public   |      throw       |          |

##### **复合类型**

- **复合类型**是指**基于其他类型**定义的类型。C++有几种复合类型，在此主要了解其中两种：**引用**和**指针**

- **引用**

  - **示例**

    ```cpp
    int ival = 1024;
    int &refVal = ival;     // 定义引用，refVal 指向 ival
    int &refVal2;           // 报错：引用必须被初始化
    /*------------------------------------------------------------------*/
    refVal = 2;             // 实际赋值给 refVal 指向的 ival
    int &refVal3 = refVal;  // refVal3 指向 refVal 指向的 ival
    /*------------------------------------------------------------------*/
    double dval = 10;
    int &refVal4 = dval;    // 报错：refVal4 为int类型，其指向对象必须为int类型
    int &refVal5 = 10;      // 报错：引用只能绑定在对象上
    ```

  - **引用介绍**

    > 1、**引用**为对象**起了另外一个名字**，通过将声明符写成`&变量名`来**定义引用类型**  
    > 2、**定义引用时**，程序把**引用**和它的**初始值**绑定在一起。一旦初始化完成，**引用**将和它的**初始值对象**一直绑定在一起。因为**无法**令引用**重新绑定另外一个对象**，所以**引用必须初始化**  
    > 3、引用**并非对象**，它只是为一个**已经存在的对象**所起的**另外一个名字**。定义一个引用之后，**对其进行的所有操作**都是在**与之绑定的对象**上进行的  
    > 4、所有**引用的类型**都要和**与之绑定的对象**严格匹配，且**引用只能绑定在对象上**

- **指针**

  - C++的指针整体与 C 语言的指针相同，在此写出一些差异

  - **空指针**

    > 1、**空指针**不指向**任何对象**，下为三种**生成空指针**的方法  
    > 2、第一种方法是使用**字面值**`nullptr`来初始化指针。`nullptr`是一种**特殊类型**的字面值，它可以**被转换成任意其他的指针类型**  
    > 3、第二种方法是使用**字面值 0**来生成空指针(注意不是 int 值)  
    > 4、第三种方法是使用**NULL 预处理器变量**，这个变量在头文件`cstdlib`中定义，**预处理变量**不属于**命名空间**`std`。在新标准下，现在的 C++程序**最好使用**`nullptr`，同时**尽量避免使用**`NULL`

    ```cpp
    int *p1 = nullptr;
    int *pt = 0;
    // 使用 NULL 需要调用 cstdlib 头文件
    int *p3 = NULL;
    ```

- **void\* 指针**

  > 1、void\* 是一种特殊的指针类型，可用于存放**任意对象的地址**。不同的是，我们对该地址**指向对象的类型**并不了解  
  > 2、利用 void\* 指针**能做的事有限**，**不能直接操作**其所指的对象，因为并**不知道对象是什么类型**  
  > 3、概括来说，以 void\* 视角来看，**内存空间**也就仅仅是**内存空间**，**没办法访问**内存空间中的**对象**

##### **const 限定符**

- **简述**

  > 1、有时我们希望定义一种**值不能被改变**的**变量**(或直接称为**常量**)，可以用`const`关键字加以修饰  
  > 2、因为`const`对象**一旦创建**，**值就不能改变**，所以`const`对象**必须初始化**  
  > 3、`const`的用法整体与 C 语言中类似

- `const`**的引用**

  > 1、可以把**引用**绑定到`const`**对象**上，我们称之为**对常量的引用**(或**常量引用**)  
  > 2、**常量引用**仅对**引用**本身作出限定，对于**引用的对象**并未限定。如果对象本身**不是常量**，那么允许通过**其他途径**修改它的值

  ```cpp
  const int i = 1024;
  const int &r1 = i;      // 正确：引用及其对应对象都是常量
  r1 = 42;                // 错误：r1是对常量的引用
  int &r2 = i;            // 错误：r2是对非常量的引用，不能指向常量对象
  /*------------------------------------------------------------*/
  int n = 30;
  const int &r1 = n;
  r1 = 40;                // 错误：r1是对常量的引用
  n = 40;                 // 正确：n本身不是常量
  ```

- `constexpr`**和常量表达式**

  - **常量表达式**

    > 1、**常量表达式**指**值不会改变**且**在编译过程中就能确定值**的表达式  
    > 2、一个对象是不是常量表达式，由它的**数据类型**和**初始值**共同决定

    ```cpp
    const int max_file = 20;          // 是常量表达式
    const int limit = mix_file + 1;   // 是常量表达式
    int staff_size = 27;              // 不是常量表达式：数据类型只是普通 int
    const int sz = get_size();        // 不是常量表达式：不能在编译过程中确定值
    ```

  - `constexpr`**变量**

    > 1、在一个复杂系统中，很难(甚至几乎肯定不能)**分辨一个初始值**是不是**常量表达式**  
    > 2、**C++11**规定，允许将变量声明为`constexpr`类型，由**编译器**来验证**变量的值**是否为**常量表达式**  
    > 3、声明为`constexpr`的变量**一定是一个常量**，而且**必须用常量表达式初始化**  
    > 4、不能使用**普通函数**作为`constexpr`**初始值**，允许定义一种特殊的`constexpr`**函数**，后续介绍

    ```cpp
    constexpr int mf = 20;            // 编译通过
    constexpr int limit = mf + 1;     // 编译通过
    constexpr int sz = size();        // 编译错误：除非 size() 是 constexpr 函数
    ```

  - **字面值类型**

    > 1、**常量表达式**的值需要**在编译时就得到计算**，这些类型一般**比较简单**，值也显而易见，就把它们称为**字面值类型**  
    > 2、目前为止，**算数类型**、**引用**、**指针**都**是**字面值类型。**自定义类**、**IO 库**、**string 类型**都**不是**字面值类型，也就不能被定义为`constexpr`  
    > 3、尽管**指针**和**引用**都能被定义成`constexpr`，但它们的**初始值受到严格限制**。如`constexpr`**指针**的初始值只能是`nullptr`或**0**，或存储于某个**固定地址**中的**对象**

##### **处理类型**

- **类型别名**

  > 1、有两种方法可用于定义**类型别名**，第一种是使用`typedef`**关键字**，与 C 语言用法相同  
  > 2、新标准规定了一种新方法：使用**别名声明**。这种方法使用`using`**关键字**作为**别名声明**的开始，其后紧跟别名和等号，作用是把**等号左侧的名字**规定成**等号右侧的类型**的别名

  ```cpp
  typedef double wages;      // wages 是 double 的别名
  typedef wages base, *p;    // base 是 wages(即double)的别名，p 是 double* 的别名
  using SI = Sales_item;     // SI 是 Sales_item 的别名
  ```

- `auto`**类型说明符**

  > 1、编程时常常需要把**表达式的值**赋给变量，这就要求在**声明变量时**清楚地知道**表达式的类型**，然而做到这一点并不容易，甚至有时根本做不到  
  > 2、**C++11**引入了`auto`**类型说明符**，能让**编译器**替我们去**分析表达式的类型**  
  > 3、和原来**只对应一种特定类型**的说明符(如 double)不同，`auto`能让编译器**通过初始值**推算**变量的类型**。显然，`auto`定义的变量**必须有初始值**  
  > 4、使用`auto`也能在**一条语句**声明**多个变量**，但由于一条声明语句**只能有一个基本数据类型**，所以该语句中**所有变量**的**初始基本数据类型**必须**都一样**

  ```cpp
  auto item = val1 + val2;    // auto 自动判断表达式类型
  auto i = 0, *p = &i;        // 正确：i 是整数，p 是整型指针
  auto sz = 0, pi = 3.14;     // 错误：sz 和 pi 类型不一致
  ```

- `decltype`**类型指示符**

  > 1、有时我们希望从**表达式的类型**推断出要定义的**变量的类型**，但是不想用该表达式的值**初始化变量**。为此，**C++11**引入了`decltype`**说明符**  
  > 2、`delctype`可以**返回操作数的数据类型**，在此过程中，**编译器**分析表达式并**得到它的类型**，但并**不实际计算表达式的值**  
  > 3、注意`delctype`**表达式的结果**如果是**加上括号的变量**，则结果将是**引用**。即`decltype(())`(注意是双层括号)的**结果永远是引用**

  ```cpp
  int ci = 1;
  decltype(ci) x = 0;         // x 的类型就是 ci 的类型，即 int，值为 0
  decltype(def()) sum = x;    // sum的类型就是函数 def() 的返回类型，值为 x 的值
  /*--------------------------------------------------------------------*/
  int i = 1;
  decltype((i)) d;            // 错误：d 是 int& 引用类型，必须初始化
  decltype(i) e;              // 正确：e 是一个未初始化的 int 类型
  ```

##### **自定义数据结构**

- **什么是数据结构**

  > 1、从最基本的层面理解，**数据结构**是把一组**相关的数据元素**组织起来然后使用它们的**策略和方法**  
  > 2、举一个例子，我们想要创建一个`Sales_items`**类**把书本的**ISBN 编号**、**售出量**、**销售收入**等数据组织在一起，并提供诸如`isbn()`**等函数**，`<<`、`>>`、`+`、`+=`**等运算**在内的**一系列操作**，`Sales_item`**类**就是一个**数据结构**  
  > 3、C++允许用户以**类的形式**自定义**数据类型**，而**库类型**`string`、`istream`、`ostream`等也是**以类的形式定义的**

- **定义类**

  - **简单的不含运算功能的类**的定义实际就是**C 的结构体**定义，使用`struct`定义

  - 此外，C++提供**另外一个关键字**`class`定义自己的**数据结构**，后续介绍

- **使用类**：与**C 的结构体**使用**规则相同**

---

#### **字符串、向量和数组**

---

<div class="success">

> **章节概要**：命名空间的`using`声明；标准库类型`string`；定义和初始化`string`对象；`string`对象的操作；处理`string`对象中的字符；范围 for 语句；标准库类型`vector`；模板；定义和初始化`vector`对象；向`vector`对象添加元素；其他`vector`操作；`vector`的索引；迭代器介绍；使用迭代器；泛型编程；迭代器运算；数组；`auto`与数组；指针也是迭代器；与旧代码的接口

</div>

##### **命名空间的 using 声明**

- **引入**

  > 1、目前为止，我们用到的**库函数**基本上都属于**命名空间**`std`，而程序也显式地将这一点标示了出来，如`std::cin`  
  > 2、用这种方法显得**比较繁琐**，然而幸运的是，通过更简单的途径也能使用到**命名空间的成员**  
  > 3、本节将介绍其中一种**最安全的方法**，也就是**使用`using`声明**，后续会介绍另一种方法

- `using`**声明**

  > 1、有了`using`声明就**无须专门的前缀**，也能使用所需的名字了  
  > 2、`using`声明具有**如下形式**`using 命名空间名::名字`，如后示例  
  > 3、按照规定，每个`using`声明只能引入**命名空间**中的**一个成员**，因此每个名字都需要**独立声明**  
  > 4、位于**头文件**的代码**不应该使用**`using`**声明**，因为引用该头文件的源代码也会**引入这个声明**，对于某些程序，可能会**产生名字冲突**

  ```cpp
  #include <iostream>
  using std::cin;
  int main()
  {
      int i;
      cin >> i;
      std::cout << i;
      return 0;
  }
  ```

##### **标准库类型 string**

- **介绍**

  > 1、**标准库类型**`string`表示**可变长的字符序列**(字符串)，使用`string`类型必须先包含`string`**头文件**  
  > 2、作为**标准库的一部分**，`string`定义在**命名空间**`std`中  
  > 3、接下来的示例都假定已包含了下述代码

  ```cpp
  #include <string>
  using std::string
  ```

- **定义和初始化 string 对象**

  > 1、如何**初始化类的对象**是由**类本身**决定的，一个类可以定义**很多种**初始化对象的方式，但这些方式之间**必须有所区别**：或者是**初始值数量不同**，或者是**初始值类型不同**  
  > 2、下为**初始化**`string`**对象**的**方式和示例**

  | 方式                | 说明                                                   |
  | ------------------- | ------------------------------------------------------ |
  | string s1           | 默认初始化，s1 是一个空串                              |
  | string s2(s1)       | 直接初始化，s2 是 s1 的副本                            |
  | string s2 = s1      | 拷贝初始化，s2 是 s1 的副本                            |
  | string s3("value")  | 直接初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s3 = "value" | 拷贝初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s4(n, 'c')   | 直接初始化，把 s4 初始化为连续 n 个字符 c 组成的字符串 |

  ```cpp
  string s1;                    // 默认初始化，s1是空字符串
  string s2 = s1;               // s2是s1的副本
  string s3("value");           // s3是字面值"value"的副本
  string s3 = "value";          // s3是字面值"value"的副本
  string s4(10, 'c');           // 直接初始化，s4内容是 cccccccccc
  string s4 = string(10, 'c');  // 拷贝初始化，s4内容是 cccccccccc
  ```

- **string 对象的操作**

  - **总览**

    > 1、一个**类**除了要规定**初始化其对象的方式**外，还要定义对象上**能执行的操作**。其中，类既能定义**通过函数名调用的操作**，也能定义**各种运算符**在**该类对象**上的**新含义**  
    > 2、下表列举了**大部分**`string`**类的操作**

    | 操作           | 含义                                                                                     |
    | -------------- | ---------------------------------------------------------------------------------------- |
    | os<<s          | 将 s 写入到输出流 os 中，返回 os                                                         |
    | is>>s          | 从 is 中读取字符串赋给 s，字符串以空格分隔，返回 is                                      |
    | getline(is, s) | 从 is 中读取一行赋给 s，返回 is                                                          |
    | s.empty()      | s 为空返回 true，否则返回 false                                                          |
    | s.size()       | 返回 s 中字符个数                                                                        |
    | s[n]           | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起                                             |
    | s1+s2          | 返回 s1 和 s2 连接后的结果                                                               |
    | s1=s2          | 用 s2 的副本代替 s1 中原来的字符                                                         |
    | s1==s2         | 如果 s1 和 s2 中的字符完全一样，则它们相等，对字母的判断依据是 ASCII 码                  |
    | s1!=s2         | 如果 s1 和 s2 中有一个字符不一样，则它们不相等，对字母的判断依据是 ASCII 码              |
    | <,<=,>,>=      | 对字符串从前向后依次比较字符的 ASCII 码，成立与否的依据是首个不相等字符的 ASCII 大小关系 |

  - **读写操作**

    ```cpp
    // 基本读写
    int main()
    {
        string s;
        cin >> s;   // 遇到空格停止
        cout << s;
        return 0;
    }
    ```

    ```cpp
    // getline整行读取
    int main()
    {
        string line;
        getline(cin, line);   // 遇到换行符停止
        cout << line << endl;
        return 0;
    }
    ```

    ```cpp
    // C语言风格EOF读写
    int main()
    {
        string word;
        // while(getline(cin, line))
        while(cin >> word)
            cout << word << endl;
        return 0;
    }
    ```

  - `empty`**和**`size`**操作**

    > 1、`empty`**函数**根据`string`**对象是否为空**返回一个**布尔值**，`size`**函数**返回`string`**对象的长度**  
    > 2、这两个函数都是`string`的**成员函数**。**调用该类函数**的方法是，使用**点操作符**指明是**哪个对象**执行成员函数即可(`对象.成员函数()`)

    ```cpp
    int main()
    {
        string line;
        while(getline(cin, line))
            // 如果字符串不为空 且 字符串长度大于10
            if(!line.empty() && line.size() > 10)
                cout << line << endl;
        return 0;
    }
    ```

  - `string::size_type`**类型**

    > 1、实际上，`size`**函数的返回值**是一个`string::size_type`**类型的值**  
    > 2、尽管我们不太清楚`string::size_type`类型的**具体细节**，但有一点是肯定的，它是一个**无符号类型值**，且**足够存放任何**`string`**对象的大小**  
    > 3、所有**用于存放**`string`**类**的`size`**函数返回值**的**变量**，都应该是**该类型**(`auto len = line.size();`中`line`的类型也**自动设为该类型**)  
    > 4、由于**该类型**是**无符号整型**，因此切记，如果在表达式中**混用**了**无符号数和有符号数**会产生意想不到的错误。如**变量 n**是一个**具有负值的 int**，则表达式`s.size() < n`几乎肯定是**true**，因为**负值 n**会**自动转换**成一个**较大的无符号值**

  - **字面值和**`string`**对象相加**

    > 1、即使一种类型**并非所需**，我们也可以使用它，不过前提是**这种类型能自动转换成所需类型**  
    > 2、因为**标准库**允许把**字符字面值**和**字符串字面值**转换成`string`**对象**，所以在**需要**`string`**对象的地方**就可以用**这两种字面值**代替  
    > 3、注意：当把`string`**对象**和**这两种字面值**混在一条语句中使用时，必须确保**每个加法运算符**的两侧的**运算对象至少有一个**是`string`

    ```cpp
    string s1 = "hello", s2 = "world";
    string s3 = s1 + "," + s2 + '\n';
    /*------------------------------*/
    // 注意按顺序结合后结果的类型
    string s4 = s1 + ",";               // 正确
    string s5 = "hello" + ",";          // 错误
    string s6 = s1 + "," + "world";     // 正确
    string s7 = "hello" + "," + s2;     // 错误
    ```

- **处理 string 对象中的字符**

  - **引入**

    > 1、我们经常需要**单独处理**`string`**对象**中的**字符**，这类处理的关键问题是**如何获取字符本身**，另一个关键问题是要知道**能改变某个字符的特性**  
    > 2、对于后者，我们可以使用**C 语言继承而来**的`cctype`(即`ctype.h`)，对于后者，我们可以通过**范围 for 语句**实现

  - **范围 for 语句**

    > 1、如果想对`string`**对象**中的**每个字符**做点什么，目前最好的操作是使用**C++11 标准**提供的**范围 for 语句**(语法形式如后附)  
    > 2、其中**变量**将被用于**访问序列中的基础元素**。每次**迭代**，**变量**都会被**初始化**为**对象序列**的**下一个元素值**

    ```cpp
    for (变量 : 对象序列)
    {
        循环体;
    }
    ```

  - **示例：统计标点数并输出标点**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        int ct = 0;
        string s;
        getline(cin, s);
        for (auto c : s)
        {
            if (ispunct(c))
            {
                ct++;
                cout << c << ' ';
            }
        }
        cout << endl << "ct: " << ct << endl;
        return 0;
    }
    ```

  - **使用范围 for 改变字符**

    > 1、如果想要**改变**`string`**对象**中**字符的值**，只需要把**循环变量**定义成**引用**类型即可  
    > 2、记住，所谓**引用**只是**给定对象的一个别名**，因此当**引用**作为**循环控制变量**时，这个变量实际**被依次绑定到**序列的**每个元素**上  
    > 3、下示例将**整个字符串**中的**小写字母**转换成**大写字母**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        string s;
        getline(cin, s);
        for (auto &c : s)
        {
            c = toupper(c);
            cout << c << ' ';
        }
        cout << endl << s << endl;
    }
    ```

  - **只处理一部分字符**

    > 1、如果只想处理**一部分**字符，那么**范围 for 语句**则**不能很好的胜任**了。通常访问`string`**对象**中的**单个字符**有两种方式：一种是使用**下标**，另一种是使用**迭代器**(后续介绍)  
    > 2、`string`**对象**的下标使用与**C 语言字符数组**规则类似，使用**for 循环遍历处理**。对象的下标必须**大于等于 0**且**小于**`s.size()`

##### **标准库类型 vector**

- **介绍**

  > 1、标准库类型`vector`表示**对象的集合**，其中**所有对象的类型都相同**  
  > 2、集合中的**每个对象**都有一个**与之对应的索引**，索引用于**访问对象**  
  > 3、因为`vector`**容纳着**其他对象，所以它也常常被称作**容器**  
  > 4、要想使用`vector`，必须包含**适当的头文件**。后续的例子中，都假设包含以下声明

  ```cpp
  #include <vector>
  using std::vector;
  ```

- **模板**

  - **模板简介**

    > 1、C++既有**类模板**，也有**函数模板**，其中`vector`是一个**类模板**。只要对 C++有深入了解后才能**写出模板**，我们将在 16 章介绍。但即使不会创建模板，我们也可以试着使用模板  
    > 2、**模板**本身不是**类或函数**，相反可以将**模板**看做**编译器生成类或函数编写**的一份**说明**。编译器**根据模板创建类或函数**的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数**实例化成何种类型**  
    > 3、对于**类模板**来说，我们通过提供一些**额外信息**来指定模板应**实例化成什么样的类**，需要**提供哪些信息**由模板决定。**提供信息的方式**总是这样：在**模板名字**后面跟**一对尖括号**，在**括号内**放上信息，`模板名<信息>;`

  - **vector 模板**

    > 1、例如`vector`模板，**需要提供的信息**是`vector`内存放的**对象类型**(示例如后附代码)  
    > 2、`vector`是**模板**而非**类型**，由`vector`**生成的类型**必须包含`vector`中**所存放元素的类型**，例如`vector<int>`  
    > 3、`vector`能容纳**绝大多数类型**的**对象**作为其**元素**，但是由于**引用不是对象**，所以**不存在包含引用的**`vector`  
    > 4、早期版本 C++中，如果`vector`**的元素**还是`vector`，必须在**外层**的**右尖括号**和**其元素类型**之间添加一个**空格**。比如应该写成`vector<vector<int> >`

    ```cpp
    vector<int> ivec;               // ivec保存int类型的对象
    vector<Sales_item> Sales_vec;   // 保存Sales_item类型的对象
    vector<vector<string>> file;    // 该向量的元素是vector对象
    ```

- **定义和初始化 vector 对象**

  - 下表列出了**初始化**`vector`**对象**的**方法**

    | 方法                       | 说明                                                    |
    | -------------------------- | ------------------------------------------------------- |
    | vector<T> v1               | v1 是一个空 vector，潜在元素为 T 类型，执行默认初始化   |
    | vector<T> v2(v1)           | v2 中包含有 v1 所有元素的副本                           |
    | vector<T> v2 = v1          | 同上等价                                                |
    | vector<T> v3(n,val)        | v3 包含 n 个重复的元素，每个元素值都是 val              |
    | vector<T> v4(n)            | v4 包含 n 个重复执行了值初始化的对象                    |
    | vector<T> v5{a,b,c,...}    | v5 包含了初始值个数的元素，每个元素被赋予了相应的初始值 |
    | vector<T> v5 = {a,b,c,...} | 同上等价                                                |

  - 区分`()`**值初始化**和`{}`**列表初始化**的含义

    > 1、`vector<int> ivec(3,-1)`含义是**ivec**存放了**3 个值为 -1 的元素**；而`vector<int> ivec{3,-1}`含义是**ivec**存放了**两个元素**，**值**分别为**3 和 -1**  
    > 2、`vector<int> ivec(10)`是指**ivec**创建了**10 个执行了值初始化的元素**(如 int 类型会被初始化为 0)  
    > 3、简单地说，想要**初始化多个相同值**就使用`()`**值初始化**，想要**初始化多个不同值**就使用`{}`**列表初始化**

- **向 vector 对象添加元素**

  > 1、经常我们会遇到，创建一个`vector`时并**不清楚**实际所需**元素个数**，元素的**值**也**无法确定**；还有些时候元素初值已知，但这些值**总量较大**且**各不相同**  
  > 2、例如我们需要`vector`**对象**存储 1-100 的数字，对此更好的办法是先创建一个**空**`vector`，然后在**运行时**利用`vector`的**成员函数**`push_back`来**添加数据**  
  > 3、`push_back`负责把**一个值**当成`vector`**对象**的**尾元素**，添加到**对象的尾端**，示例如下  
  > 4、注意：如果循环体内部含有**向**`vector`**添加元素**的语句，则不能使用**范围 for 语句**

  ```cpp
  vector<int> ivec;
  for (int i = 1; i <= 100; i++)
      ivec.push_back(i);
  ```

- **其他 vector 操作**

  - `vector`提供了一些**其他操作**，下表列出其中比较重要的一些

    | 操作             | 含义                                                          |
    | ---------------- | ------------------------------------------------------------- |
    | v.empty()        | 如果 v 不含有任何元素，返回 true，否则返回 false              |
    | v.size()         | 返回 v 中元素的个数，返回值类型是 `vector<T>::size_type` 类型 |
    | v.push_back(t)   | 将值为 t 的元素添加到 v 的尾端                                |
    | v[n]             | 返回 v 中第 n 个位置上元素的引用                              |
    | v1 = v2          | 用 v2 中的元素拷贝替换 v1 中的元素                            |
    | v1 = {a,b,c,...} | 用列表中的元素拷贝替换 v1 中的元素                            |
    | ==,!=,<,<=,>,>=  | 与 string 相同，比较字典序                                    |

- **vector 的索引**

  > 1、和`string`类似，如果需要**逐个访问全部**`vector`**元素**，也可以使用**范围 for 语句**+**引用**  
  > 2、对于需要**非顺序访问**，可以使用**下标**访问，**下标**同样**从 0 开始计算**  
  > 3、注意：只能对**确知已存在的元素**使用**下标操作**，因此**不能使用下标添加元素**，添加元素只能使用`push.back`

##### **迭代器介绍**

- **介绍**

  > 1、我们已经知道可以使用**下标**访问`string`**对象的字符**和`vector`**对象的元素**，还有另一种**更通用的机制**也能实现，就是**迭代器**  
  > 2、除了`vector`外，**标准库**还定义了**其他几种容器**。**所有标准库容器**都能使用**迭代器**，但只有**少数几种**才同时支持**下标操作**  
  > 3、类似于**指针类型**，迭代器也提供对**对象**的**间接访问**，同时迭代器也有**有效**和**无效**之分。**有效**的迭代器**指向某个元素**或指向**容器尾元素的下一位置**，其余都属于**无效**迭代器

- **使用迭代器**

  - **引入**

    > 1、**和指针不同**的是，**获取迭代器**不是使用**取地址符**，**有迭代器的类型**同时拥有**返回迭代器的成员**  
    > 2、比如**这些类型**都拥有名为**begin**和**end**的**成员**，其中**begin 成员**负责返回**指向第一个元素的迭代器**，**end 成员**负责返回**指向容器尾元素下一位置的迭代器**  
    > 3、**end 成员**返回的**迭代器**常被称作**尾后迭代器**，或简称为**尾迭代器**。这样的迭代器没什么实际含义，只是个**标记**而已，表示我们已经处理完了容器中所有元素。特殊情况下，如果**容器为空**，则**begin**和**end**返回的是**同一个迭代器**  
    > 4、一般来说，我们不清楚(也不需要在意)**迭代器的准确类型**是什么，通常使用`auto`**关键字**定义变量来**自动确定类型**

    ```cpp
    // b 表示 v 的第一个元素，e 表示 v 尾元素的下一位置
    auto b = v.begin(), e = v.end();
    ```

  - **迭代器运算符**

    > 1、下表列举了部分**迭代器支持的运算**  
    > 2、和指针类似，也能通过**解引用迭代器**来获取它**所指示的元素**，执行解引用的迭代器**必须合法**并**确实指示着某个元素**  
    > 3、举个例子，使用**迭代器**访问`string`**对象**，将字符串的**首字母大写**(如下例)

    | 运算             | 含义                                                                                                 |
    | ---------------- | ---------------------------------------------------------------------------------------------------- |
    | \*iter           | 返回迭代器 iter 所指元素的引用                                                                       |
    | iter->mem        | 解引用 iter 并获取该元素的名为 mem 的成员，等价于`(*iter).mem`                                       |
    | ++iter 或 iter++ | 令 iter 指示容器中的下一个元素                                                                       |
    | --iter 或 iter-- | 令 iter 指示容器中的上一个元素                                                                       |
    | iter1 == iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |
    | iter1 != iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |

    ```cpp
    string s("some thing");
    if (s.begin() != s.end())   // 确保 s 为非空字符串
    {
        auto it = s.begin();    // it 表示 s 的第一个字符
        *it = toupper(*it);     // 改为大写
    }
    ```

  - **将迭代器移动到另外一个元素**

    > 1、**迭代器**使用**递增运算符**`++`来移动到**下一个元素**，使用**递减运算符**`--`来移动到**上一个元素**  
    > 2、因为**end 返回的迭代器**并不实际指示**某个元素**，所以**不能**对其进行**递增**或**解引用**  
    > 3、下例为使用**迭代器**依次访问`string`**对象**的**字符**，将**整个字符串的字母大写**

    ```cpp
    string s("hello world");
    for (auto it = s.begin(); it != s.end(); it++)
        *it = toupper(*it);
    ```

  - **迭代器类型**

    > 1、就像**不知道**`string`和`vector`的`size_type`**成员**到底是**什么类型**一样，一般来说我们也**不知道**(也无需知道)**迭代器的精确类型**  
    > 2、实际上，那些**拥有迭代器**的**标准库类型**使用`iterator`和`const_iterator`来表示**迭代器的类型**，其中`const_iterator`和**常量指针**差不多

    ```cpp
    vector<int>::iterator it1;          // it1 能读写 vector<int> 的元素
    string::iterator it2;               // it2 能读写 string 对象中的字符

    vector<int>::const_iterator it3;    // it3 只能读元素，不能写元素
    string::const_iterator it4;         // it4 只能读字符，不能写字符
    ```

  - `cbegin`**和**`cend`**函数**

    > 1、`begin`和`end`返回的**具体类型**由**对象是否是常量**决定。如果对象**是常量**则返回`const_iterator`，如果**不是常量**在返回`iterator`  
    > 2、有时候这种**默认的行为**并非我们所要，如果对象**只需读无须写**最好使用**常量类型**  
    > 3、为了便于我们得到`const_iterator`**类型的返回值**，C++11 引入了两个**新函数**：`cbegin`和`cend`，其返回值一定是`const_iterator`类型

  - **组合解引用和成员访问操作**

    > 1、**解引用迭代器**可获得迭代器**所指的对象**，如果该**对象的类型**恰好是**类**，就有可能希望进一步**访问它的成员**  
    > 2、例如，对于一个由字符串组成的`vector`**对象**，要想检查其**元素是否为空**，令**it**是该`vector`的**迭代器**，只要检查**it 所指字符串是否为空**即可：`(*it).empty()`(注意前面的括号不可省略，因为关系到运算符优先级问题)  
    > 3、为了简化上述表达式，C++定义了**箭头运算符**`->`。箭头运算符把**解引用**和**成员访问**两个操作**结合在一起**，也就是说，`it->mem`等效于`(*it).mem`

  - **某些对**`vector`**对象的操作会使迭代器失效**

    > 1、虽然`vector`对象可以**动态地增长**，但是也会有一些**副作用**  
    > 2、已知的一个限制是不能在**范围 for 语句**内向`vector`**添加元素**。另外一个限制是任何一种**可能改变**`vector`**对象容量**的操作，比如`push_back`，都会使其**迭代器失效**(后续解释)  
    > 3、谨记，但凡是使用了**迭代器**的**循环体**，**都不要**向迭代器所属容器**添加元素**

- **泛型编程**

  > 1、原来使用 C 或 Java 的程序员转而使用 C++ 后，会对**for 循环**中**大量使用**`!=`而不是`<`进行判断感到奇怪  
  > 2、C++程序员**习惯性使用**`!=`，其原因和他们**更愿意用迭代器而非下标**的原因一样：这种编程风格在**标准库提供的所有容器**上都有效  
  > 3、与之类似，**所有标准库容器的迭代器**都定义了`!=`和`==`，但它们中的**大多数没有定义**`<`**运算符**  
  > 4、因此，只要我们养成使用**迭代器**和`!=`的习惯，就**不用太在意**用的到底是**哪种类型**

- **迭代器运算**

  > 1、`string`和`vector`的**迭代器**提供了更多额外的**运算符**，一方面可使得迭代器**每次移动过多个元素**，另外也支持迭代器进行**关系运算**。  
  > 2、所有这些运算都被称为**迭代器运算**，如下表

  | 运算          | 含义                                                                                                                                                                                   |
  | ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | iter + n      | 迭代器加上一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置                                                |
  | iter - n      | 迭代器减去一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置                                                |
  | iter += n     | 迭代器加法的复合赋值语句，将 iter 加 n 的结果赋给 iter                                                                                                                                 |
  | iter -= n     | 迭代器减法的复合赋值语句，将 iter 减 n 的结果赋给 iter                                                                                                                                 |
  | iter1 - iter2 | 两个迭代器相减的结果是它们之间的距离，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置                                                                                        |
  | >,>=,<,<=     | 迭代器关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则前者小于后者，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置，类型是`difference_type`的带符号整型 |

- **使用迭代器运算**

  - 使用迭代器运算的一个**经典算法**是**二分搜索**，其从**有序序列**中寻找某个**给定值**

    ```cpp
    // text 必须是有序的，sought 是要搜索的给定值
    auto beg = text.begin(), end = text.end();    // beg 和 end 表示搜索的范围
    auto mid = text.begin() + (end - bag) / 2;    // 初始中间点
    while (mid != end && *mid != sought)
    {
        if (sought < *mid)                        // 如果在前半部分
            end = mid;                            // 忽略后半部分
        else                                      // 如果在后半部分
            beg = mid + 1;                        // 在mid之后寻找
        mid = beg + (end - beg) / 2;              // 新的中间点
    }
    ```

##### **数组**

- **数组**的大部分使用规则**与 C 语言相同**

- **auto 与数组**

  > 1、由于**数组名**是数组的**首元素地址**，所以使用`auto`**关键字**时，`auto ia2(ia)`等同于`auto ia2(&ia[0])`  
  > 2、但如果使用`decltype`**关键字**，上述转换**不会发生**，`decltype(ia)`**返回类型**是由**10 个整数**构成的**数组**

  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};
  // ia2是一个整型指针，指向ia的首元素
  auto ia2(ia);
  // ia3是一个含有10个整数的数组
  decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}
  ```

- **指针也是迭代器**

  > 1、就像使用**迭代器**遍历`vector`**对象**那样，使用**指针**也能**遍历数组中的元素**。不过前提是先获取到**指向数组首元素的指针**和**指向数组尾元素下一位的指针**  
  > 2、获取**首元素地址**可以使用**数组名**，而**尾后指针**可以获取**尾元素后**那个**并不存在的元素的地址**。如假设定义`int arr[10];`，则可以`int *end = &arr[10]`  
  > 3、尽管**通过计算**可以得到**尾后指针**，但这种方法**极易出错**。为了让指针的使用更简单，C++11 新增了**两个函数**：`begin`**函数**和`end`**函数**  
  > 4、这**两个函数**与**容器中**的**两个同名成员**功能类似，不过**数组不是类类型**，所以这两个函数**不是成员函数**。正确使用的方法是将**数组**作为它们的**参数**，如下

  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};
  int *begin = begin(ia);
  int *end = end(ia);
  ```

- **与旧代码的接口**

  - **引入**

    > 1、很多 C++程序在**标准库出现之前**就已经写成了，它们肯定没用到`string`和`vector`类型；而且有一些 C++程序实际上是**与 C 语言或其他语言**的**接口程序**，当然也无法使用**C++标准库**  
    > 2、但是，现代的 C++ 程序不得不与那些**充满了数组**或**C 风格字符串**的代码衔接。为了使这一工作**简单易行**，C++专门提供了一组功能

  - **混用**`string`**对象和 C 风格字符串**

    > 1、允许使用以`\0`结束的**字符数组**(即 C 风格字符串)来对`string`**对象**进行**初始化**和**赋值**  
    > 2、在`string`**对象**的**加法运算**中允许使用**C 风格字符串**作为其中**一个运算对象**(不能两个都是)；在`string`**对象**的**复合赋值运算**中允许使用**C 风格字符串**作为**右侧运算对象**  
    > 3、上述性质**反过来**就**不成立**了：如果程序某处需要一个**C 风格字符串**，不能用`string`**对象**代替它，例如不能用`string`**对象**初始化一个**指向 char 的指针**  
    > 4、为了完成该功能，`string`专门提供了一个名为`c_str`的**成员函数**：其返回**一个指针**，指向一个**C 风格字符串**，该**字符串内容**与`string`**对象**一样；指针的类型是`const *char`，确保**不会改变字符数组的内容**

    ```cpp
    char *str = s;                // 错误，不能用string对象初始化指向char的指针
    const char *str = s.c_str();  // 正确
    ```

  - **用数组初始化**`vector`**对象**

    - 允许使用**数组**来**初始化**`vector`**对象**。要实现这一目的，只需指明要**拷贝区域**的**首元素地址**和**尾后地址**即可(最简单的方式是用`begin`和`end`函数)

      ```cpp
      int int_arr[] = {0,1,2,3,4,5};
      vector<int> ivec(begin(int_arr), end(int_arr));
      ```

---

#### **表达式**

---

<div class="success">

> **章节概要**：特性补充；**sizeof**运算符；强制类型转换

</div>

##### **特性补充**

- C++的**表达式**和**运算符**与 C 大部分相同，在此**补充**或**强调**一些特性

- **sizeof 运算符**

  > 1、对`string`或`vector`**对象**执行`sizeof`**运算符**只返回**该类型固定部分**的**大小**，**不会计算**对象中的元素占用了多少**空间**  
  > 2、因为`sizeof`的**返回值**是一个**常量表达式**`constexpr size_t`，因此可以用`sizeof`的结果**声明数组的大小**

- **强制类型转换**

  - 一个命名的**强制类型转换**具有**如下形式**：`转换模式<转换类型>(表达式)`

  - 其中，**转换模式**是`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`中的一种

  - `static_cast`**模式**

    > 1、任何具有**明确定义**的**类型转换**，只要不包含**底层**`const`，都可以使用`static_cast`，例如：`double slope = static_cast<double>(i);`  
    > 2、`static_cast`对于**编译器无法自动执行**的**类型转换**也非常有用，例如可以**找回存在于**`void*`**的指针**，转换回**原始的指针类型**，示例如后  
    > 3、但是对于**存在于**`void*`**的指针**，应确保**指针的值保持不变**，且**转换后所得类型**就是**指针所指类型**

    ```cpp
    // 任何非常量对象的地址都能存入void*
    void* p = &d;
    //将void*转换回原始的指针类型(指向double的指针)
    double *dp = static_cast<double*>(p);
    ```

  - `const_cast`**模式**

    > 1、`const_cast`**只能改变**运算对象的**底层**`const`，对于将**常量对象**转换成**非常量对象**的行为，称其为**去掉**`const`**性质**  
    > 2、一旦**去掉了**某个对象的`const`**性质**，编译器将**不再阻止**我们对该对象进行**写入操作**  
    > 3、如果对象**本身不是一个常量**，那么强制类型转换获得**写权限**是**合法的行为**；但如果对象**本身是一个常量**，则再使用`const_cast`执行**写操作**将产生**未定义的后果**

    ```cpp
    const char *pc;
    char *p = const_cast<char*>(pc);    // 正确：但是写操作是未定义的行为
    /*-----------------------------*/
    const char *cp;
    char *q = static_cast<char*>(cp);   // 错误：static_cast不能转换掉const性质
    const_cast<string>(cp);             // 错误，const_cast只能改变常量属性
    static_cast<string>(cp);            // 正确
    ```

  - `reinterpret_cast`**模式**

    > 1、`reinterpret_cast`通常为**运算对象**的**位模式**提供**较低层次**上的重新解释  
    > 2、如下例，我们必须牢记**pc**所指的**真实对象是 int 而非字符**，如果把**pc**当成普通的**字符指针**使用就可以在运行时发生错误  
    > 3、使用`reinterpret_cast`是**非常危险**的，其中关键问题是**类型改变了**，但编译器**没有给出任何警告或错误提示**。下面**使用 pc 时**就会认定它的值是**char\*类型**，**编译器没法知道**它实际存放的是**指向 int 的指针**  
    > 4、`reinterpret_cast`本质上**依赖于机器**。想要安全地使用，必须对**涉及的类型**和**编译器实现转换的过程**都相当了解

    ```cpp
    int *ip;
    char *pc = reinterpret_cast<char*>(ip);
    string str(pc);     // 错误：可能导致异常的运行时行为
    ```

  - `dynamic_cast`**模式**：支持**运行时类型识别**，后续介绍

  - 此外，C 语言的**旧式强制类型转换**仍然支持，但与 C++ 的相比，表现形式上不那么清晰明了，**出错追踪比较困难**，建议使用 C++ 的转换方式

---

#### **语句**

---

<div class="success">

> **章节概要**：`try`语句块和异常处理；C++的异常处理；`throw`表达式；`try`语句块；编写处理代码；标准异常

</div>

##### **try 语句块和异常处理**

- **引入**

  > 1、**异常**是指存在于**运行时**的**反常行为**，这些行为超出了**函数正常功能**的范畴，典型的异常包括**失去数据库连接**以及**遇到意外输入**等。处理反常行为可能是设计所有系统最难的一部分  
  > 2、当**程序的某部分**检测到一个让它**无法处理**的问题时，就需要用到**异常处理**。如果程序中含有**可能引发异常的代码**，那么通常也会有**专门的代码处理问题**  
  > 3、**异常处理机制**为程序中**异常检测**和**异常处理**这两部分的协作提供支持。C++中，异常处理包括以下部分

- **C++的异常处理**

  > 1、`throw`**表达式**：**异常检测**部分使用`throw`**表达式**来表示它**遇到了无法处理的问题**，我们说`throw`**引发了异常**  
  > 2、`try`**语句块**：**异常处理**部分使用`try`**语句块**处理异常。`try`中包含**一个或多个**`catch`**子句**，抛出的**异常**通常会**被某个**`catch`**子句处理**。因为`catch`**子句**处理异常，所以它们也被称为**异常处理代码**  
  > 3、一套**类异常**：用于在`throw`**表达式**和相关的`catch`**子句**之间**传递异常的具体信息**

- **throw 表达式**

  > 1、程序的**异常检测**部分使用`throw`**表达式**引发一个**异常**，形式如`throw 表达式;`，其中的**表达式类型**就是**抛出的异常类型**  
  > 2、如下示例，如果书籍的 ISBN 不一样就**抛出异常**，该**异常类型是**`runtime_error`**对象**。抛出异常将**终止当前的函数**，并把**控制权**转移给**能处理该异常的代码**  
  > 3、类型`runtime_error`是**标准库异常类型**的一种，定义在`stdexcept`**头文件**中，后面将介绍其他的异常类型  
  > 4、我们必须**初始化**`runtime_error`**对象**，方式是给它提供一个`string`**对象**或一个**C 风格字符串**，这个字符串中有一些关于异常的**辅助信息**

  ```cpp
  if(item1.isbn() != item2.isbn())
      throw runtime_error("数据必须具有相同的ISBN");
  cout << item1 + item2 << endl;
  ```

- **try 语句块**

  > 1、`try`**语句块**的通用语法形式如下  
  > 2、跟在`try`**块**之后的是**一个或多个**`catch`**子句**。`catch`**子句**包括三部分：**关键字**`catch`、括号内一个(可能未命名的)**对象的声明**(称作异常声明)、以及**一个块**  
  > 3、当选中了某个`catch`子句**异常处理之后**，执行**与之对应的块**。`catch`**一旦执行完成**，会**跳转到**`try`**块**中**最后一个**`catch`**子句之后**的语句继续执行  
  > 4、`try`**块**中的**程序语句**组成程序的**正常逻辑**，像其他任何块一样，可以有包括声明在内的任意 C++ 语句

  ```cpp
  try
  {
      程序语句
  }
  catch(异常声明)
  {
      处理语句
  }
  catch(异常声明)
  {
      处理语句
  }
  // ...
  ```

- **编写处理代码**

  > 1、编写**异常处理代码**，上面的程序可以按如下示例处理  
  > 2、将程序**本来要执行的任务**放在`try`**语句块**中，因为这段代码**可能抛出异常**  
  > 3、`try`对应一个`catch`**子句**，该子句负责**处理**`runtime_error`**类型的异常**。如果`try`中抛出了**此类异常**，则会执行该`catch`内的语句  
  > 4、`catch`中输出给用户的信息中，输出了`err.what()`的返回值。从`catch`**小括号的定义**能得到**err**是一个`runtime_error`**类的对象**，`what`则是该**类**的一个**成员函数**  
  > 5、`what`成员函数**没有参数**，**返回值**是**C 风格字符串**(即`const char*`)。其中，`runtime_error`的`what`**成员**返回的是**初始化一个具体对象**时所用的`string`**对象的副本**(即`try`中初始化的字符串)

  ```cpp
  while (cin >> item1 >> item2)
  {
      try
      {
          if(item1.isbn() != item2.isbn())
              throw runtime_error("数据必须具有相同的ISBN");
          cout << item1 + item2;
      }
      catch(runtime_error err)
      {
          cout << err.what() << "\n 再次尝试？输入y或n"<< endl;
          char c;
          cin >> c;
          if(!cin || c == 'n')
          {
                cout << "程序退出" << endl;
                break;          // 跳出 while 循环
          }
      }
  }
  ```

- **标准异常**

  - **标准异常类**

    > 1、C++**标准库**中定义了一组**类**，用于报告**标准库函数**遇到的问题。这些**异常类**也可以在**用户编写的程序中**使用，分别定义在**4 个头文件**  
    > 2、`exception`：定义了**最通用的异常类**`exception`，它**只报告异常的发生**，**不提供任何额外信息**  
    > 3、`stdexcept`：定义了几种**常用的异常类**，详细信息见下表  
    > 4、`new`：定义了`bad_alloc`**异常类型**，后续介绍  
    > 5、`type_info`：定义了`bad_cast`**异常类型**，后续介绍

    | stdexcept 定义的异常类 | 含义                                           |
    | ---------------------- | ---------------------------------------------- |
    | exception              | 最常见的错误                                   |
    | runtime_error          | 只有在运行时才能检测出的任务                   |
    | range_error            | 运行时错误：生成的结果超出了有意义的值域范围   |
    | overflow_error         | 运行时错误：计算上溢                           |
    | underflow_error        | 运行时错误：计算下溢                           |
    | logic_error            | 程序逻辑错误                                   |
    | domain_error           | 逻辑错误：参数对应的结果值不存在               |
    | invalid_argument       | 逻辑错误：无效参数                             |
    | length_error           | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
    | out_of_range           | 逻辑错误：使用一个超出有效范围的值             |

  - **运算与成员**

    > 1、**标准库异常类**只定义了几种运算，包括**创建或拷贝异常类型的对象**，以及**为异常类型的对象赋值**  
    > 2、我们只能以**默认初始化**的方式初始化`exception`、`bad_alloc`、`bad_cast`对象，**不允许**为这些对象**提供初始值**  
    > 3、**其他异常类型**的行为恰好相反，应该使用`string`**对象**或者**C 风格字符串**初始化这些类型的对象，**不允许**使用**默认初始化**的方式。创建此类对象时，**必须提供初始值**，该值含有**错误相关信息**  
    > 4、**异常类型**之定义了一个名为`what`的**成员函数**，返回值是**C 风格字符串**，字符串的目的是**提供关于异常的一些文本信息**。对于其他**无初始值的异常类型**，`what`返回的内容由**编译器决定**

---

#### **函数**

---

<div class="success">

> **章节概要**：含有可变形参的函数；`initializer_list`形参；函数的返回值；不要返回局部对象的引用或指针；返回数组指针的函数；函数重载；定义重载函数

</div>

##### **含有可变形参的函数**

- **简介**

  > 1、有时我们**无法提前预知**应该向函数**传递几个实参**。为了编写**能处理不同数量实参**的函数，C++11 提供了以下几种方法  
  > 2、如果所有的**实参类型相同**，可以传递一个名为`initializer_list`的**标准库类型**  
  > 3、如果**实参类型不同**，可以编写一种特殊的函数——**可变参数模板**，将在后续介绍  
  > 4、此外还有一种从**C 标准库**`stdarg.h`继承而来的**省略符形参**`...`，但有了一些限制

- **initializer_list 形参**

  - **简介**

    > 1、`initializer_list`是一种**标准库类型**，用于表示**某种特定类型的值的数组**，其定义在`initializer_list`**头文件**中。后表是它的一些操作  
    > 2、和`vector`一样，**该类型**也是一种**模板类型**，这意味着**定义对象**时，也必须说明列表中**所含元素的类型**：`initializer_list<int> li;`  
    > 3、和`vector`不同的是，该类型对象中的**元素永远是常量值**，我们**无法改变**该类型对象中**元素的值**

  - **使用**

    > 1、我们可以使用**该类型**作为函数的**形参**，使用**迭代器**访问**列表中的元素**  
    > 2、使用函数时，如果想向`initializer_list`**形参**中**传递一个值的序列**，则必须把**序列**放在一对**花括号**内  
    > 3、含有`initializer_list`**形参**的函数也**可以同时拥有其他形参**

    ```cpp
    // 定义函数
    void error_msg(int error_code, initializer_list<string> i1)
    {
        cout << "error code:" << error_code;
        for(auto beg = i1.begin(); beg != i1.end(); beg++)
            cout << *beg << ' ';
        cout << endl;
    }
    // 传参使用
    int error_number = 15;
    string s1("error1"), s2("error2");
    error_msg(error_number, {"function", s1, s2});
    ```

- **省略号形参**`...`

  > 1、**省略号形参**`...`沿用自**C 语言的**`stdarg.h`**库**，为了便于**C++程序**访问某些特殊的**C 代码**  
  > 2、但省略符形参应该**仅仅用于 C 和 C++ 通用的类型**。特别应该注意，C++的大多数**类类型的对象**传递时都**无法正确拷贝**

##### **函数的返回值**

- **不要返回局部对象的引用或指针**

  > 1、函数完成后，所占用的**内存空间**也会**随之释放**。由此，**局部变量的引用**和**指向局部变量的指针**将指向**不再有效的内存区域**  
  > 2、如下示例，对于两条`return`语句，都将返回**未定义的值**

  ```cpp
  // 函数返回值类型是const string &，即一个引用
  const string &manip()
  {
      string ret;
      if (!ret.empty())
          return ret;       // 错误：返回了局部对象的引用，返回的引用将指向无效区域
      return "Empty";       // 错误：Empty也是一个局部临时量，返回的引用将指向无效区域
  }
  ```

- **返回数组指针的函数**

  - **直接声明**

    > 1、如果我们想定义一个**返回数组指针的函数**，则**数组的下标数**必须**跟在函数名后**。而函数的**形参列表**也跟在**函数名后**，且应该**先于数组的下标数**  
    > 2、因此，**返回数组指针的函数**形式如：`类型 (* 函数名(形参列表))[数组下标数]`，具体的例子和解读如下(可以参考[类型声明黄金法则](https://www.shengqibaozao.eu.org/2022/08/22/%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99/?t=1674030612212))

    ```cpp
    int (*func(int i))[10];
    /*---------------------*/
    /*
    解读：
    func(int i)             ：表示函数需要一个int类型形参
    (*func(int i))          ：返回类型是一个指针
    (*func(int i))[10]      ：指针指向一个大小是10的数组
    int (*func(int i))[10]  ：指向的是一个含有10个int值的数组
    */
    ```

  - **使用尾置返回类型**

    > 1、在 C++11 新标准中还有一种可以**简化上述声明**的方法，就是使用**尾置返回类型**  
    > 2、**任何函数的定义**都能使用**尾置返回**，但这种形式对于**返回类型比较复杂**的函数最有效，比如返回类型是**数组的指针**或者**数组的引用**  
    > 3、**尾置返回类型**跟在**形参列表**后面并以一个`->`**符号开头**。为了表示函数**真正的返回类型**跟在**形参列表后**，原先**标识返回值的地方**改为`auto`

    ```cpp
    // 函数返回一个指针，指向含有10个整数的数组
    auto func(int i) -> int(*)[10];
    ```

  - **使用**`decltype`**获取类型**

    > 1、还有一种情况，**如果知道**函数返回的**指针将指向哪个数组**，可以使用`decltype`来**声明返回类型**，如下例  
    > 2、`decltype(odd)`标识了**返回类型**是一个**含有 5 个 int 值的数组**，`*`标识了**返回类型**是一个**指针**  
    > 3、有一个地方要注意，`decltype`并**不负责**把数组类型**转换成**相应的**指针**，所以如果需要返回**指向数组的指针**的函数，需要像下例中**声明时**加一个`*`

    ```cpp
    int odd[] = {1, 3, 5, 7, 9};
    int even[] = {0, 2, 4, 6, 8};
    // 使用 decltype(odd) 获取类型
    decltype(odd) *arrPtr(int i)
    {
        return (i % 2) ? &odd : &even;  // 返回一个指向数组的指针
    }
    ```

##### **函数重载**

- **简介**

  > 1、如果**同一作用域**内的几个函数**名字相同**但**形参列表不同**，我们称之为**重载函数**。如下例  
  > 2、这些函数接受的**形参类型不同**，但是执行的**操作非常相似**，使用**函数重载**可以在一定程度上减轻起名记名的负担  
  > 3、当**调用这些函数**时，编译器会**根据传递的实参**判断具体想要执行的是**哪个函数**

  ```cpp
  // 函数原型
  void print(char *cp);               // 1
  void print(int *beg, int *end);     // 2
  void print(int ia[], size_t size);  // 3
  /*--------------------------------------*/
  // 函数调用
  int j[2] = {0, 1};
  print("Hello World");         // 调用 1
  print(j, end(j) - begin(j));  // 调用 3
  print(begin(j), end(j));      // 调用 2
  ```

- **定义重载函数**

  > 1、对于定义的**重载函数**来说，它们至少应该在**形参数量**或**形参类型**上**有所不同**  
  > 2、假设有两个函数，他们的**返回类型不同**但**形参列表相同**，这种声明不是**重载函数**，是**错误的**  
  > 3、有时候两个**形参列表看起来不一样**，但实际是**相同**的。比如**省略了形参名**，或使用**类型别名**  
  > 4、**不能重载**`main()`**函数**

  ```cpp
  // 不允许两个函数除了返回类型不同其余都相同
  void lookup(Account&);
  bool lookup(Account&);    // 错误
  /*--------------------------------*/
  // 形参列表相同
  void lookup(Account &acct);
  void lookup(Account&);    // 相同，省略了形参名
  typedef Phone Telno;
  void lookup(Phone&);
  void lookup(Telno&);      // 相同，使用了类型别名
  ```

---

#### **页底评论**

---
