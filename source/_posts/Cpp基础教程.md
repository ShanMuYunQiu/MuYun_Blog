---
title: Cpp基础教程
author: 圣奇宝枣
description: 有关于C++的基础教程，该教程建立在学习过C语言的基础上，进行对比学习，了解不同的特性和更多新内容
sticky: 2
date: 2022-12-03
updated: 2023-02-16
readmore: true
tags:
  - C++
  - 基础语法
categories:
  - 编程语言入门
---

---

_注：该教程建立在学习过 C 语言的基础上，因此很多提过的细节会忽略，主要学习一些 C 语言没有或不同的特性，建议先学习[C 语言基础教程](https://www.shengqibaozao.eu.org/2022/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/?t=1670037021388)_

_此外本文章中没有特殊重申的，大多语句和特性都与 C 语言相同，C++是 C 的超集，兼容了 C 的大多数特性_

---

#### **开始**

---

<div class="success">

> **章节概要**：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介

</div>

<!-- more -->

##### **编写一个简单的 C++程序**

- **简单示例**

  ```cpp
  // 相比C代码，可以省略main(void)的void
  int main()
  {
      return 0;
  }
  ```

##### **初识输入输出**

- **程序示例**

  ```cpp
  #include <iostream>
  int main()0
  {
      std::cout << "Enter two numbers!" << std::endl;
      int v1, v2;
      std::cin >> v1 >> v2;
      std::cout << "The sum of them is " << v1 + v2;
      return 0;
  }
  ```

- **C++的 IO 机制**

  > 1、**C++**包含了一个全面的**标准库**来提供**IO 机制**。其中有**从 C 语言延续而来**的`cstdio`库和**新的**`iostream`库  
  > 2、`iostream`库包含**两个基础类型**：`istream`和`ostream`，分别表示**输入流**和**输出流**  
  > 3、一个**流**(stream)就是一个**字符序列**，是**从 IO 设备读出**或**写入 IO 设备**的

- **标准输入输出对象**

  > 1、标准库定义了 4 个**IO 对象**  
  > 2、为了**处理输入**，我们使用名为`cin`的`istream`类型对象，这个对象也被称为**标准输入**  
  > 3、对于**处理输出**，我们使用名为`cout`的`ostream`类型对象，这个对象也被称为**标准输出**  
  > 4、此外还有其他两个`ostream`类型对象，名为`cerr`和`clog`。其中`cerr`通常用来**输出警告和错误信息**，`clog`用来**输出程序运行时的一般性信息**

- **向流写入写出**

  > 1、如果需要使用`iostream`**库中的对象**进行**输入输出**，则需要用到**流插入符**将内容传输给**流**  
  > 2、`<<`为**输出运算符**。其**接受两个运算对象**，**左侧**必须是一个`ostream`**对象**，**右侧**的运算对象是**要打印的值**。此运算符将**给定的值写入给定的**`ostream`**对象**中  
  > 3、`>>`为**输入运算符**。其与`>>`类型，它**左侧**接受一个`istream`**对象**，**右侧**接受一个**运算对象**。它从给定的`istream`中**读入数据**，并**存入给定的对象**中

- **endl 操纵符**

  > 1、**endl**是一个被称为**操纵符**的**特殊值**  
  > 2、**endl**的效果是**结束当前行**(有换行效果)，并将与设备关联的**缓冲区**的内容**刷到设备中**  
  > 3、**缓冲刷新操作**可以保证到目前为止**程序所产生的所有输出**都**真正写入流中**，而不是仅**停留在内存**中等待写入到流中

- **命名空间**

  > 1、示例程序中使用了`std::cout`和`std::endl`，而不是直接的`cout`和`endl`。其**前缀**`std::`指出**名字**`cout`和`endl`是定义在名为`std`的**命名空间**中的  
  > 2、**命名空间**可以帮助我们避免**不经意的名字定义冲突**以及**使用库中相同名字导致的冲突**。**标准库**定义的**所有名字**都在**命名空间**`std`中  
  > 3、通过**命名空间**使用**标准库**有一个**副作用**：当使用**标准库**中的**一个名字**时，必须通过**作用域运算符**`::`来**显式声明**我们想使用来自`std`中的名字，如示例`std::cout`那样(后续将给出一个更简单的访问标准库名字的方法)

##### **使用 C++版本的 C 标准库头文件**

- **建议使用 C++版本标准库**

  > 1、C++标准库中**兼容了 C 语言的标准库**，其按照如下**命名规则**命名  
  > 2、C 语言的头文件形如`name.h`，C++将其命名为`cname`。即**去掉**`.h`**后缀**，文件名前**添加字母**`c`  
  > 3、因此`stdio.h`和`cstdio`**内容是一样的**，而且`stdio.h`也能在 C++调用，但从**命名规范**上来讲，`cstdio`更符合 C++的要求  
  > 4、特别的，在名为`cname`的**头文件**定义的**名字**从属于**命名空间**`std`，而原本`.h`的则不然  
  > 5、一般来说，C++程序**应使用名为**`cname`**的头文件**，因为这样**标准库的名字**总能在`std`找到。如果使用`.h`形式，那么程序员不得不时刻牢记哪些是从 C 语言继承过来的，哪些又是 C++独有的

##### **类简介**

- 我们将在之后详细学习**类**相关的知识，在此只**简单介绍**

- **什么是类**

  > 1、在 C++中，我们通过**定义一个类**来**定义自己的数据结构**  
  > 2、一个**类**定义了**一个类型**，以及**与之相关的一组操作**  
  > 3、**类机制**是 C++**最重要的特性之一**。实际上，C++最初的**设计焦点**就是能定义使用上像内置类型一样自然的**类类型**

- 如果要使用一个类，我们需要了解**三件事情**：

  > 1、类名是什么？  
  > 2、它在哪里定义的？  
  > 3、它支持什么操作？

---

#### **变量和基本类型**

---

<div class="success">

> **章节概要**：基本内置类型；指定字面量类型；变量；对象；列表初始化；C++关键字；复合类型；引用；指针；void\* 指针；`const`限定符；`const`的引用；`constexpr`和常量表达式；处理类型；类型别名；`auto`类型说明符；`decltype`类型指示符；自定义数据结构；定义类；使用类

</div>

##### **基本内置类型**

- **基本数据类型**

  > 1、C++定义了一套包括**算数类型**和**空类型**在内的**基本数据类型**  
  > 2、其中**算数类型**包含了**整型**、**浮点型**、**字符型**、**布尔型**  
  > 3、**空类型 void**不对应**具体的值**，仅用于一些**特殊的场合**

- C++的**基本数据类型**与 C 语言**规则相同**，但 C++中**直接支持**了**bool 类型**，且`iostream`中**直接支持**了**拓展类型**(如`int32_t`等)

- **指定字面量类型**

  - 通过添加**前缀或后缀**，可以改变不同类型**字面量**的**默认类型**

  - **指定字符和字符串字面量**

    | 前缀 |   类型   | 含义                        |
    | :--: | :------: | --------------------------- |
    |  u   | char16_t | Unicode 16 字符             |
    |  U   | char32_t | Unicode 32 字符             |
    |  L   | wchar_t  | 宽字符                      |
    |  u8  |   char   | UTF-8(仅用于字符串字面常量) |

  - **指定整型字面量**

    |   后缀   | 最小匹配类型 |
    | :------: | :----------: |
    |  u 或 U  |   unsigned   |
    |  l 或 L  |     long     |
    | ll 或 LL |  long long   |

  - **指定浮点型字面量**

    |  后缀  |    类型     |
    | :----: | :---------: |
    | f 或 F |    float    |
    | l 或 L | long double |

##### **变量**

- **变量**

  > 1、**变量**提供一个**具名的**、**可供程序操作的存储空间**  
  > 2、C++中的每个变量都有其**数据类型**，**数据类型**决定着变量所占**内存空间**的**大小及布局方式**、该空间**能存储值的范围**，以及变量**能参与的运算**  
  > 3、对于 C++程序员来说，**变量**和**对象**一般可以**互换使用**

- **对象**

  > 1、C++程序员在很多场合都会使用**对象**这个名词。通常情况下，**对象**指一块**能存储数据**并**具有某种类型**的**内存空间**  
  > 2、一部分人对**对象**的定义并不相同，比如：一些人仅在**与类有关**的场景才使用**对象**这个词；另一些人把**命名了的对象**叫做**变量**；还有一些人把**对象**和**值**区分开来，**对象**指**能被程序修改的数据**，而**值**指**只读的数据**

- **列表初始化**

  - C++定义了**初始化**的**好几种不同形式**，如下：

    ```cpp
    int units_sold = 0;
    int units_sold(0);
    int units_sold = {0}; // 列表初始化
    int units_sold{0};    // 列表初始化
    ```

  - **列表初始化**

    > 1、作为**C++11 新标准**的一部分，用**花括号**来**初始化变量**得到了全面应用。这种初始化形式被称为**列表初始化**  
    > 2、现在，无论是**初始化对象**还是某些时候**为对象赋新值**，都可以使用这样一组**由花括号括起来的初始值**了  
    > 3、当用于**内置类型**变量时，这种初始化形式有一个**重要特点**：如果我们**使用列表初始化**且**初始值存在丢失信息的风险**，**编译器将报错**(如下例)  
    > 4、这样的介绍看似无关紧要，因为我们不会故意**用 long double 值初始化 int 变量**，然而这种初始化**可能在不经意间发生**，因此这种赋值更加**保守安全**

    ```cpp
    long double ld = 3.1415926536;
    int a{ld}, b = {ld};    // 报错：转换未执行，因为存在丢失信息的风险(丢失浮点精度)
    int c(ld), d = ld;      // 正确：转换执行，且确实丢失了部分值(丢失了小数点后的浮点部分)
    ```

- **C++关键字**

  |   关键字   |    关键字    |  关键字   |      关键字      |  关键字  |
  | :--------: | :----------: | :-------: | :--------------: | :------: |
  |  alignas   |   continue   |  friend   |     register     |   true   |
  |  alignof   |   decltype   |   goto    | reinterpret_cast |   try    |
  |    asm     |   default    |    if     |      return      | typedef  |
  |    auto    |    delete    |  inline   |      short       |  typeid  |
  |    bool    |      do      |    int    |      signed      | typename |
  |   break    |    double    |   long    |      sizeof      |  union   |
  |    case    | dynamic_cast |  mutable  |      static      | unsigned |
  |   catch    |     else     | namespace |  static_assert   |  using   |
  |    char    |     enum     |    new    |   static_cast    | virtual  |
  |  char16_t  |   explicit   | noexcept  |      struct      |   void   |
  |  char32_t  |    export    |  nullptr  |      switch      | volatile |
  |   class    |    extern    | operator  |     template     | wchar_t  |
  |   const    |    false     |  private  |       this       |  while   |
  | constexpr  |    float     | protected |   thread_local   |          |
  | const_cast |     for      |  public   |      throw       |          |

##### **复合类型**

- **复合类型**是指**基于其他类型**定义的类型。C++有几种复合类型，在此主要了解其中两种：**引用**和**指针**

- **引用**

  - **示例**

    ```cpp
    int ival = 1024;
    int &refVal = ival;     // 定义引用，refVal 指向 ival
    int &refVal2;           // 报错：引用必须被初始化
    /*------------------------------------------------------------------*/
    refVal = 2;             // 实际赋值给 refVal 指向的 ival
    int &refVal3 = refVal;  // refVal3 指向 refVal 指向的 ival
    /*------------------------------------------------------------------*/
    double dval = 10;
    int &refVal4 = dval;    // 报错：refVal4 为int类型，其指向对象必须为int类型
    int &refVal5 = 10;      // 报错：引用只能绑定在对象上
    ```

  - **引用介绍**

    > 1、**引用**为对象**起了另外一个名字**，通过将声明符写成`&变量名`来**定义引用类型**  
    > 2、**定义引用时**，程序把**引用**和它的**初始值**绑定在一起。一旦初始化完成，**引用**将和它的**初始值对象**一直绑定在一起。因为**无法**令引用**重新绑定另外一个对象**，所以**引用必须初始化**  
    > 3、引用**并非对象**，它只是为一个**已经存在的对象**所起的**另外一个名字**。定义一个引用之后，**对其进行的所有操作**都是在**与之绑定的对象**上进行的  
    > 4、所有**引用的类型**都要和**与之绑定的对象**严格匹配，且**引用只能绑定在对象上**

- **指针**

  - C++的指针整体与 C 语言的指针相同，在此写出一些差异

  - **空指针**

    > 1、**空指针**不指向**任何对象**，下为三种**生成空指针**的方法  
    > 2、第一种方法是使用**字面值**`nullptr`来初始化指针。`nullptr`是一种**特殊类型**的字面值，它可以**被转换成任意其他的指针类型**  
    > 3、第二种方法是使用**字面值 0**来生成空指针(注意不是 int 值)  
    > 4、第三种方法是使用**NULL 预处理器变量**，这个变量在头文件`cstdlib`中定义，**预处理变量**不属于**命名空间**`std`。在新标准下，现在的 C++程序**最好使用**`nullptr`，同时**尽量避免使用**`NULL`

    ```cpp
    int *p1 = nullptr;
    int *pt = 0;
    // 使用 NULL 需要调用 cstdlib 头文件
    int *p3 = NULL;
    ```

- **void\* 指针**

  > 1、void\* 是一种特殊的指针类型，可用于存放**任意对象的地址**。不同的是，我们对该地址**指向对象的类型**并不了解  
  > 2、利用 void\* 指针**能做的事有限**，**不能直接操作**其所指的对象，因为并**不知道对象是什么类型**  
  > 3、概括来说，以 void\* 视角来看，**内存空间**也就仅仅是**内存空间**，**没办法访问**内存空间中的**对象**

##### **const 限定符**

- **简述**

  > 1、有时我们希望定义一种**值不能被改变**的**变量**(或直接称为**常量**)，可以用`const`关键字加以修饰  
  > 2、因为`const`对象**一旦创建**，**值就不能改变**，所以`const`对象**必须初始化**  
  > 3、`const`的用法整体与 C 语言中类似

- `const`**的引用**

  > 1、可以把**引用**绑定到`const`**对象**上，我们称之为**对常量的引用**(或**常量引用**)  
  > 2、**常量引用**仅对**引用**本身作出限定，对于**引用的对象**并未限定。如果对象本身**不是常量**，那么允许通过**其他途径**修改它的值

  ```cpp
  const int i = 1024;
  const int &r1 = i;      // 正确：引用及其对应对象都是常量
  r1 = 42;                // 错误：r1是对常量的引用
  int &r2 = i;            // 错误：r2是对非常量的引用，不能指向常量对象
  /*------------------------------------------------------------*/
  int n = 30;
  const int &r1 = n;
  r1 = 40;                // 错误：r1是对常量的引用
  n = 40;                 // 正确：n本身不是常量
  ```

- `constexpr`**和常量表达式**

  - **常量表达式**

    > 1、**常量表达式**指**值不会改变**且**在编译过程中就能确定值**的表达式  
    > 2、一个对象是不是常量表达式，由它的**数据类型**和**初始值**共同决定

    ```cpp
    const int max_file = 20;          // 是常量表达式
    const int limit = mix_file + 1;   // 是常量表达式
    int staff_size = 27;              // 不是常量表达式：数据类型只是普通 int
    const int sz = get_size();        // 不是常量表达式：不能在编译过程中确定值
    ```

  - `constexpr`**变量**

    > 1、在一个复杂系统中，很难(甚至几乎肯定不能)**分辨一个初始值**是不是**常量表达式**  
    > 2、**C++11**规定，允许将变量声明为`constexpr`类型，由**编译器**来验证**变量的值**是否为**常量表达式**  
    > 3、声明为`constexpr`的变量**一定是一个常量**，而且**必须用常量表达式初始化**  
    > 4、不能使用**普通函数**作为`constexpr`**初始值**，允许定义一种特殊的`constexpr`**函数**，后续介绍

    ```cpp
    constexpr int mf = 20;            // 编译通过
    constexpr int limit = mf + 1;     // 编译通过
    constexpr int sz = size();        // 编译错误：除非 size() 是 constexpr 函数
    ```

  - **字面值类型**

    > 1、**常量表达式**的值需要**在编译时就得到计算**，这些类型一般**比较简单**，值也显而易见，就把它们称为**字面值类型**  
    > 2、目前为止，**算数类型**、**引用**、**指针**都**是**字面值类型。**自定义类**、**IO 库**、**string 类型**都**不是**字面值类型，也就不能被定义为`constexpr`  
    > 3、尽管**指针**和**引用**都能被定义成`constexpr`，但它们的**初始值受到严格限制**。如`constexpr`**指针**的初始值只能是`nullptr`或**0**，或存储于某个**固定地址**中的**对象**

##### **处理类型**

- **类型别名**

  > 1、有两种方法可用于定义**类型别名**，第一种是使用`typedef`**关键字**，与 C 语言用法相同  
  > 2、新标准规定了一种新方法：使用**别名声明**。这种方法使用`using`**关键字**作为**别名声明**的开始，其后紧跟别名和等号，作用是把**等号左侧的名字**规定成**等号右侧的类型**的别名

  ```cpp
  typedef double wages;      // wages 是 double 的别名
  typedef wages base, *p;    // base 是 wages(即double)的别名，p 是 double* 的别名
  using SI = Sales_item;     // SI 是 Sales_item 的别名
  ```

- `auto`**类型说明符**

  > 1、编程时常常需要把**表达式的值**赋给变量，这就要求在**声明变量时**清楚地知道**表达式的类型**，然而做到这一点并不容易，甚至有时根本做不到  
  > 2、**C++11**引入了`auto`**类型说明符**，能让**编译器**替我们去**分析表达式的类型**  
  > 3、和原来**只对应一种特定类型**的说明符(如 double)不同，`auto`能让编译器**通过初始值**推算**变量的类型**。显然，`auto`定义的变量**必须有初始值**  
  > 4、使用`auto`也能在**一条语句**声明**多个变量**，但由于一条声明语句**只能有一个基本数据类型**，所以该语句中**所有变量**的**初始基本数据类型**必须**都一样**

  ```cpp
  auto item = val1 + val2;    // auto 自动判断表达式类型
  auto i = 0, *p = &i;        // 正确：i 是整数，p 是整型指针
  auto sz = 0, pi = 3.14;     // 错误：sz 和 pi 类型不一致
  ```

- `decltype`**类型指示符**

  > 1、有时我们希望从**表达式的类型**推断出要定义的**变量的类型**，但是不想用该表达式的值**初始化变量**。为此，**C++11**引入了`decltype`**说明符**  
  > 2、`delctype`可以**返回操作数的数据类型**，在此过程中，**编译器**分析表达式并**得到它的类型**，但并**不实际计算表达式的值**  
  > 3、注意`delctype`**表达式的结果**如果是**加上括号的变量**，则结果将是**引用**。即`decltype(())`(注意是双层括号)的**结果永远是引用**

  ```cpp
  int ci = 1;
  decltype(ci) x = 0;         // x 的类型就是 ci 的类型，即 int，值为 0
  decltype(def()) sum = x;    // sum的类型就是函数 def() 的返回类型，值为 x 的值
  /*--------------------------------------------------------------------*/
  int i = 1;
  decltype((i)) d;            // 错误：d 是 int& 引用类型，必须初始化
  decltype(i) e;              // 正确：e 是一个未初始化的 int 类型
  ```

##### **自定义数据结构**

- **什么是数据结构**

  > 1、从最基本的层面理解，**数据结构**是把一组**相关的数据元素**组织起来然后使用它们的**策略和方法**  
  > 2、举一个例子，我们想要创建一个`Sales_items`**类**把书本的**ISBN 编号**、**售出量**、**销售收入**等数据组织在一起，并提供诸如`isbn()`**等函数**，`<<`、`>>`、`+`、`+=`**等运算**在内的**一系列操作**，`Sales_item`**类**就是一个**数据结构**  
  > 3、C++允许用户以**类的形式**自定义**数据类型**，而**库类型**`string`、`istream`、`ostream`等也是**以类的形式定义的**

- **定义类**

  - **简单的不含运算功能的类**的定义实际就是**C 的结构体**定义，使用`struct`定义

  - 此外，C++提供**另外一个关键字**`class`定义自己的**数据结构**，后续介绍

- **使用类**：简单的**类**的使用与**C 的结构体**使用规则相似，但定义**类对象**(结构变量)时不需要再使用`struct`再次声明

---

#### **字符串、向量和数组**

---

<div class="success">

> **章节概要**：命名空间的`using`声明；标准库类型`string`；定义和初始化`string`对象；`string`对象的操作；处理`string`对象中的字符；范围 for 语句；标准库类型`vector`；模板；定义和初始化`vector`对象；向`vector`对象添加元素；其他`vector`操作；`vector`的索引；迭代器介绍；使用迭代器；泛型编程；迭代器运算；数组；`auto`与数组；指针也是迭代器；与旧代码的接口

</div>

##### **命名空间的 using 声明**

- **引入**

  > 1、目前为止，我们用到的**库函数**基本上都属于**命名空间**`std`，而程序也显式地将这一点标示了出来，如`std::cin`  
  > 2、用这种方法显得**比较繁琐**，然而幸运的是，通过更简单的途径也能使用到**命名空间的成员**  
  > 3、本节将介绍其中一种**最安全的方法**，也就是**使用`using`声明**，后续会介绍另一种方法

- `using`**声明**

  > 1、有了`using`声明就**无须专门的前缀**，也能使用所需的名字了  
  > 2、`using`声明具有**如下形式**`using 命名空间名::名字`，如后示例  
  > 3、按照规定，每个`using`声明只能引入**命名空间**中的**一个成员**，因此每个名字都需要**独立声明**  
  > 4、位于**头文件**的代码**不应该使用**`using`**声明**，因为引用该头文件的源代码也会**引入这个声明**，对于某些程序，可能会**产生名字冲突**

  ```cpp
  #include <iostream>
  using std::cin;
  int main()
  {
      int i;
      cin >> i;
      std::cout << i;
      return 0;
  }
  ```

##### **标准库类型 string**

- **介绍**

  > 1、**标准库类型**`string`表示**可变长的字符序列**(字符串)，使用`string`类型必须先包含`string`**头文件**  
  > 2、作为**标准库的一部分**，`string`定义在**命名空间**`std`中  
  > 3、接下来的示例都假定已包含了下述代码

  ```cpp
  #include <string>
  using std::string
  ```

- **定义和初始化 string 对象**

  > 1、如何**初始化类的对象**是由**类本身**决定的，一个类可以定义**很多种**初始化对象的方式，但这些方式之间**必须有所区别**：或者是**初始值数量不同**，或者是**初始值类型不同**  
  > 2、下为**初始化**`string`**对象**的**方式和示例**

  | 方式                | 说明                                                   |
  | ------------------- | ------------------------------------------------------ |
  | string s1           | 默认初始化，s1 是一个空串                              |
  | string s2(s1)       | 直接初始化，s2 是 s1 的副本                            |
  | string s2 = s1      | 拷贝初始化，s2 是 s1 的副本                            |
  | string s3("value")  | 直接初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s3 = "value" | 拷贝初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s4(n, 'c')   | 直接初始化，把 s4 初始化为连续 n 个字符 c 组成的字符串 |

  ```cpp
  string s1;                    // 默认初始化，s1是空字符串
  string s2 = s1;               // s2是s1的副本
  string s3("value");           // s3是字面值"value"的副本
  string s3 = "value";          // s3是字面值"value"的副本
  string s4(10, 'c');           // 直接初始化，s4内容是 cccccccccc
  string s4 = string(10, 'c');  // 拷贝初始化，s4内容是 cccccccccc
  ```

- **string 对象的操作**

  - **总览**

    > 1、一个**类**除了要规定**初始化其对象的方式**外，还要定义对象上**能执行的操作**。其中，类既能定义**通过函数名调用的操作**，也能定义**各种运算符**在**该类对象**上的**新含义**  
    > 2、下表列举了**大部分**`string`**类的操作**

    | 操作           | 含义                                                                                     |
    | -------------- | ---------------------------------------------------------------------------------------- |
    | os<<s          | 将 s 写入到输出流 os 中，返回 os                                                         |
    | is>>s          | 从 is 中读取字符串赋给 s，字符串以空格分隔，返回 is                                      |
    | getline(is, s) | 从 is 中读取一行赋给 s，返回 is                                                          |
    | s.empty()      | s 为空返回 true，否则返回 false                                                          |
    | s.size()       | 返回 s 中字符个数                                                                        |
    | s[n]           | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起                                             |
    | s1+s2          | 返回 s1 和 s2 连接后的结果                                                               |
    | s1=s2          | 用 s2 的副本代替 s1 中原来的字符                                                         |
    | s1==s2         | 如果 s1 和 s2 中的字符完全一样，则它们相等，对字母的判断依据是 ASCII 码                  |
    | s1!=s2         | 如果 s1 和 s2 中有一个字符不一样，则它们不相等，对字母的判断依据是 ASCII 码              |
    | <,<=,>,>=      | 对字符串从前向后依次比较字符的 ASCII 码，成立与否的依据是首个不相等字符的 ASCII 大小关系 |

  - **读写操作**

    ```cpp
    // 基本读写
    int main()
    {
        string s;
        cin >> s;   // 遇到空格停止
        cout << s;
        return 0;
    }
    ```

    ```cpp
    // getline整行读取
    int main()
    {
        string line;
        getline(cin, line);   // 遇到换行符停止
        cout << line << endl;
        return 0;
    }
    ```

    ```cpp
    // C语言风格EOF读写
    int main()
    {
        string word;
        // while(getline(cin, line))
        while(cin >> word)
            cout << word << endl;
        return 0;
    }
    ```

  - `empty`**和**`size`**操作**

    > 1、`empty`**函数**根据`string`**对象是否为空**返回一个**布尔值**，`size`**函数**返回`string`**对象的长度**  
    > 2、这两个函数都是`string`的**成员函数**。**调用该类函数**的方法是，使用**点操作符**指明是**哪个对象**执行成员函数即可(`对象.成员函数()`)

    ```cpp
    int main()
    {
        string line;
        while(getline(cin, line))
            // 如果字符串不为空 且 字符串长度大于10
            if(!line.empty() && line.size() > 10)
                cout << line << endl;
        return 0;
    }
    ```

  - `string::size_type`**类型**

    > 1、实际上，`size`**函数的返回值**是一个`string::size_type`**类型的值**  
    > 2、尽管我们不太清楚`string::size_type`类型的**具体细节**，但有一点是肯定的，它是一个**无符号类型值**，且**足够存放任何**`string`**对象的大小**  
    > 3、所有**用于存放**`string`**类**的`size`**函数返回值**的**变量**，都应该是**该类型**(`auto len = line.size();`中`line`的类型也**自动设为该类型**)  
    > 4、由于**该类型**是**无符号整型**，因此切记，如果在表达式中**混用**了**无符号数和有符号数**会产生意想不到的错误。如**变量 n**是一个**具有负值的 int**，则表达式`s.size() < n`几乎肯定是**true**，因为**负值 n**会**自动转换**成一个**较大的无符号值**

  - **字面值和**`string`**对象相加**

    > 1、即使一种类型**并非所需**，我们也可以使用它，不过前提是**这种类型能自动转换成所需类型**  
    > 2、因为**标准库**允许把**字符字面值**和**字符串字面值**转换成`string`**对象**，所以在**需要**`string`**对象的地方**就可以用**这两种字面值**代替  
    > 3、注意：当把`string`**对象**和**这两种字面值**混在一条语句中使用时，必须确保**每个加法运算符**的两侧的**运算对象至少有一个**是`string`

    ```cpp
    string s1 = "hello", s2 = "world";
    string s3 = s1 + "," + s2 + '\n';
    /*------------------------------*/
    // 注意按顺序结合后结果的类型
    string s4 = s1 + ",";               // 正确
    string s5 = "hello" + ",";          // 错误
    string s6 = s1 + "," + "world";     // 正确
    string s7 = "hello" + "," + s2;     // 错误
    ```

- **处理 string 对象中的字符**

  - **引入**

    > 1、我们经常需要**单独处理**`string`**对象**中的**字符**，这类处理的关键问题是**如何获取字符本身**，另一个关键问题是要知道**能改变某个字符的特性**  
    > 2、对于后者，我们可以使用**C 语言继承而来**的`cctype`(即`ctype.h`)，对于后者，我们可以通过**范围 for 语句**实现

  - **范围 for 语句**

    > 1、如果想对`string`**对象**中的**每个字符**做点什么，目前最好的操作是使用**C++11 标准**提供的**范围 for 语句**(语法形式如后附)  
    > 2、其中**变量**将被用于**访问序列中的基础元素**。每次**迭代**，**变量**都会被**初始化**为**对象序列**的**下一个元素值**

    ```cpp
    for (变量 : 对象序列)
    {
        循环体;
    }
    ```

  - **示例：统计标点数并输出标点**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        int ct = 0;
        string s;
        getline(cin, s);
        for (auto c : s)
        {
            if (ispunct(c))
            {
                ct++;
                cout << c << ' ';
            }
        }
        cout << endl << "ct: " << ct << endl;
        return 0;
    }
    ```

  - **使用范围 for 改变字符**

    > 1、如果想要**改变**`string`**对象**中**字符的值**，只需要把**循环变量**定义成**引用**类型即可  
    > 2、记住，所谓**引用**只是**给定对象的一个别名**，因此当**引用**作为**循环控制变量**时，这个变量实际**被依次绑定到**序列的**每个元素**上  
    > 3、下示例将**整个字符串**中的**小写字母**转换成**大写字母**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        string s;
        getline(cin, s);
        for (auto &c : s)
        {
            c = toupper(c);
            cout << c << ' ';
        }
        cout << endl << s << endl;
    }
    ```

  - **只处理一部分字符**

    > 1、如果只想处理**一部分**字符，那么**范围 for 语句**则**不能很好的胜任**了。通常访问`string`**对象**中的**单个字符**有两种方式：一种是使用**下标**，另一种是使用**迭代器**(后续介绍)  
    > 2、`string`**对象**的下标使用与**C 语言字符数组**规则类似，使用**for 循环遍历处理**。对象的下标必须**大于等于 0**且**小于**`s.size()`

##### **标准库类型 vector**

- **介绍**

  > 1、标准库类型`vector`表示**对象的集合**，其中**所有对象的类型都相同**  
  > 2、集合中的**每个对象**都有一个**与之对应的索引**，索引用于**访问对象**  
  > 3、因为`vector`**容纳着**其他对象，所以它也常常被称作**容器**  
  > 4、要想使用`vector`，必须包含**适当的头文件**。后续的例子中，都假设包含以下声明

  ```cpp
  #include <vector>
  using std::vector;
  ```

- **模板**

  - **模板简介**

    > 1、C++既有**类模板**，也有**函数模板**，其中`vector`是一个**类模板**。只要对 C++有深入了解后才能**写出模板**，我们将在 16 章介绍。但即使不会创建模板，我们也可以试着使用模板  
    > 2、**模板**本身不是**类或函数**，相反可以将**模板**看做**编译器生成类或函数编写**的一份**说明**。编译器**根据模板创建类或函数**的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数**实例化成何种类型**  
    > 3、对于**类模板**来说，我们通过提供一些**额外信息**来指定模板应**实例化成什么样的类**，需要**提供哪些信息**由模板决定。**提供信息的方式**总是这样：在**模板名字**后面跟**一对尖括号**，在**括号内**放上信息，`模板名<信息>;`

  - **vector 模板**

    > 1、例如`vector`模板，**需要提供的信息**是`vector`内存放的**对象类型**(示例如后附代码)  
    > 2、`vector`是**模板**而非**类型**，由`vector`**生成的类型**必须包含`vector`中**所存放元素的类型**，例如`vector<int>`  
    > 3、`vector`能容纳**绝大多数类型**的**对象**作为其**元素**，但是由于**引用不是对象**，所以**不存在包含引用的**`vector`  
    > 4、早期版本 C++中，如果`vector`**的元素**还是`vector`，必须在**外层**的**右尖括号**和**其元素类型**之间添加一个**空格**。比如应该写成`vector<vector<int> >`

    ```cpp
    vector<int> ivec;               // ivec保存int类型的对象
    vector<Sales_item> Sales_vec;   // 保存Sales_item类型的对象
    vector<vector<string>> file;    // 该向量的元素是vector对象
    ```

- **定义和初始化 vector 对象**

  - 下表列出了**初始化**`vector`**对象**的**方法**

    | 方法                       | 说明                                                    |
    | -------------------------- | ------------------------------------------------------- |
    | vector<T> v1               | v1 是一个空 vector，潜在元素为 T 类型，执行默认初始化   |
    | vector<T> v2(v1)           | v2 中包含有 v1 所有元素的副本                           |
    | vector<T> v2 = v1          | 同上等价                                                |
    | vector<T> v3(n,val)        | v3 包含 n 个重复的元素，每个元素值都是 val              |
    | vector<T> v4(n)            | v4 包含 n 个重复执行了值初始化的对象                    |
    | vector<T> v5{a,b,c,...}    | v5 包含了初始值个数的元素，每个元素被赋予了相应的初始值 |
    | vector<T> v5 = {a,b,c,...} | 同上等价                                                |

  - 区分`()`**值初始化**和`{}`**列表初始化**的含义

    > 1、`vector<int> ivec(3,-1)`含义是**ivec**存放了**3 个值为 -1 的元素**；而`vector<int> ivec{3,-1}`含义是**ivec**存放了**两个元素**，**值**分别为**3 和 -1**  
    > 2、`vector<int> ivec(10)`是指**ivec**创建了**10 个执行了值初始化的元素**(如 int 类型会被初始化为 0)  
    > 3、简单地说，想要**初始化多个相同值**就使用`()`**值初始化**，想要**初始化多个不同值**就使用`{}`**列表初始化**

- **向 vector 对象添加元素**

  > 1、经常我们会遇到，创建一个`vector`时并**不清楚**实际所需**元素个数**，元素的**值**也**无法确定**；还有些时候元素初值已知，但这些值**总量较大**且**各不相同**  
  > 2、例如我们需要`vector`**对象**存储 1-100 的数字，对此更好的办法是先创建一个**空**`vector`，然后在**运行时**利用`vector`的**成员函数**`push_back`来**添加数据**  
  > 3、`push_back`负责把**一个值**当成`vector`**对象**的**尾元素**，添加到**对象的尾端**，示例如下  
  > 4、注意：如果循环体内部含有**向**`vector`**添加元素**的语句，则不能使用**范围 for 语句**

  ```cpp
  vector<int> ivec;
  for (int i = 1; i <= 100; i++)
      ivec.push_back(i);
  ```

- **其他 vector 操作**

  - `vector`提供了一些**其他操作**，下表列出其中比较重要的一些

    | 操作             | 含义                                                          |
    | ---------------- | ------------------------------------------------------------- |
    | v.empty()        | 如果 v 不含有任何元素，返回 true，否则返回 false              |
    | v.size()         | 返回 v 中元素的个数，返回值类型是 `vector<T>::size_type` 类型 |
    | v.push_back(t)   | 将值为 t 的元素添加到 v 的尾端                                |
    | v[n]             | 返回 v 中第 n 个位置上元素的引用                              |
    | v1 = v2          | 用 v2 中的元素拷贝替换 v1 中的元素                            |
    | v1 = {a,b,c,...} | 用列表中的元素拷贝替换 v1 中的元素                            |
    | ==,!=,<,<=,>,>=  | 与 string 相同，比较字典序                                    |

- **vector 的索引**

  > 1、和`string`类似，如果需要**逐个访问全部**`vector`**元素**，也可以使用**范围 for 语句**+**引用**  
  > 2、对于需要**非顺序访问**，可以使用**下标**访问，**下标**同样**从 0 开始计算**  
  > 3、注意：只能对**确知已存在的元素**使用**下标操作**，因此**不能使用下标添加元素**，添加元素只能使用`push.back`

##### **迭代器介绍**

- **介绍**

  > 1、我们已经知道可以使用**下标**访问`string`**对象的字符**和`vector`**对象的元素**，还有另一种**更通用的机制**也能实现，就是**迭代器**  
  > 2、除了`vector`外，**标准库**还定义了**其他几种容器**。**所有标准库容器**都能使用**迭代器**，但只有**少数几种**才同时支持**下标操作**  
  > 3、类似于**指针类型**，迭代器也提供对**对象**的**间接访问**，同时迭代器也有**有效**和**无效**之分。**有效**的迭代器**指向某个元素**或指向**容器尾元素的下一位置**，其余都属于**无效**迭代器

- **使用迭代器**

  - **引入**

    > 1、**和指针不同**的是，**获取迭代器**不是使用**取地址符**，**有迭代器的类型**同时拥有**返回迭代器的成员**  
    > 2、比如**这些类型**都拥有名为**begin**和**end**的**成员**，其中**begin 成员**负责返回**指向第一个元素的迭代器**，**end 成员**负责返回**指向容器尾元素下一位置的迭代器**  
    > 3、**end 成员**返回的**迭代器**常被称作**尾后迭代器**，或简称为**尾迭代器**。这样的迭代器没什么实际含义，只是个**标记**而已，表示我们已经处理完了容器中所有元素。特殊情况下，如果**容器为空**，则**begin**和**end**返回的是**同一个迭代器**  
    > 4、一般来说，我们不清楚(也不需要在意)**迭代器的准确类型**是什么，通常使用`auto`**关键字**定义变量来**自动确定类型**

    ```cpp
    // b 表示 v 的第一个元素，e 表示 v 尾元素的下一位置
    auto b = v.begin(), e = v.end();
    ```

  - **迭代器运算符**

    > 1、下表列举了部分**迭代器支持的运算**  
    > 2、和指针类似，也能通过**解引用迭代器**来获取它**所指示的元素**，执行解引用的迭代器**必须合法**并**确实指示着某个元素**  
    > 3、举个例子，使用**迭代器**访问`string`**对象**，将字符串的**首字母大写**(如下例)

    | 运算             | 含义                                                                                                 |
    | ---------------- | ---------------------------------------------------------------------------------------------------- |
    | \*iter           | 返回迭代器 iter 所指元素的引用                                                                       |
    | iter->mem        | 解引用 iter 并获取该元素的名为 mem 的成员，等价于`(*iter).mem`                                       |
    | ++iter 或 iter++ | 令 iter 指示容器中的下一个元素                                                                       |
    | --iter 或 iter-- | 令 iter 指示容器中的上一个元素                                                                       |
    | iter1 == iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |
    | iter1 != iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |

    ```cpp
    string s("some thing");
    if (s.begin() != s.end())   // 确保 s 为非空字符串
    {
        auto it = s.begin();    // it 表示 s 的第一个字符
        *it = toupper(*it);     // 改为大写
    }
    ```

  - **将迭代器移动到另外一个元素**

    > 1、**迭代器**使用**递增运算符**`++`来移动到**下一个元素**，使用**递减运算符**`--`来移动到**上一个元素**  
    > 2、因为**end 返回的迭代器**并不实际指示**某个元素**，所以**不能**对其进行**递增**或**解引用**  
    > 3、下例为使用**迭代器**依次访问`string`**对象**的**字符**，将**整个字符串的字母大写**

    ```cpp
    string s("hello world");
    for (auto it = s.begin(); it != s.end(); it++)
        *it = toupper(*it);
    ```

  - **迭代器类型**

    > 1、就像**不知道**`string`和`vector`的`size_type`**成员**到底是**什么类型**一样，一般来说我们也**不知道**(也无需知道)**迭代器的精确类型**  
    > 2、实际上，那些**拥有迭代器**的**标准库类型**使用`iterator`和`const_iterator`来表示**迭代器的类型**，其中`const_iterator`和**常量指针**差不多

    ```cpp
    vector<int>::iterator it1;          // it1 能读写 vector<int> 的元素
    string::iterator it2;               // it2 能读写 string 对象中的字符

    vector<int>::const_iterator it3;    // it3 只能读元素，不能写元素
    string::const_iterator it4;         // it4 只能读字符，不能写字符
    ```

  - `cbegin`**和**`cend`**函数**

    > 1、`begin`和`end`返回的**具体类型**由**对象是否是常量**决定。如果对象**是常量**则返回`const_iterator`，如果**不是常量**在返回`iterator`  
    > 2、有时候这种**默认的行为**并非我们所要，如果对象**只需读无须写**最好使用**常量类型**  
    > 3、为了便于我们得到`const_iterator`**类型的返回值**，C++11 引入了两个**新函数**：`cbegin`和`cend`，其返回值一定是`const_iterator`类型

  - **组合解引用和成员访问操作**

    > 1、**解引用迭代器**可获得迭代器**所指的对象**，如果该**对象的类型**恰好是**类**，就有可能希望进一步**访问它的成员**  
    > 2、例如，对于一个由字符串组成的`vector`**对象**，要想检查其**元素是否为空**，令**it**是该`vector`的**迭代器**，只要检查**it 所指字符串是否为空**即可：`(*it).empty()`(注意前面的括号不可省略，因为关系到运算符优先级问题)  
    > 3、为了简化上述表达式，C++定义了**箭头运算符**`->`。箭头运算符把**解引用**和**成员访问**两个操作**结合在一起**，也就是说，`it->mem`等效于`(*it).mem`

  - **某些对**`vector`**对象的操作会使迭代器失效**

    > 1、虽然`vector`对象可以**动态地增长**，但是也会有一些**副作用**  
    > 2、已知的一个限制是不能在**范围 for 语句**内向`vector`**添加元素**。另外一个限制是任何一种**可能改变**`vector`**对象容量**的操作，比如`push_back`，都会使其**迭代器失效**(后续解释)  
    > 3、谨记，但凡是使用了**迭代器**的**循环体**，**都不要**向迭代器所属容器**添加元素**

- **泛型编程**

  > 1、原来使用 C 或 Java 的程序员转而使用 C++ 后，会对**for 循环**中**大量使用**`!=`而不是`<`进行判断感到奇怪  
  > 2、C++程序员**习惯性使用**`!=`，其原因和他们**更愿意用迭代器而非下标**的原因一样：这种编程风格在**标准库提供的所有容器**上都有效  
  > 3、与之类似，**所有标准库容器的迭代器**都定义了`!=`和`==`，但它们中的**大多数没有定义**`<`**运算符**  
  > 4、因此，只要我们养成使用**迭代器**和`!=`的习惯，就**不用太在意**用的到底是**哪种类型**

- **迭代器运算**

  > 1、`string`和`vector`的**迭代器**提供了更多额外的**运算符**，一方面可使得迭代器**每次移动过多个元素**，另外也支持迭代器进行**关系运算**。  
  > 2、所有这些运算都被称为**迭代器运算**，如下表

  | 运算          | 含义                                                                                                                                                                                   |
  | ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | iter + n      | 迭代器加上一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置                                                |
  | iter - n      | 迭代器减去一个整数值结果仍为迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或指示 end 位置                                                |
  | iter += n     | 迭代器加法的复合赋值语句，将 iter 加 n 的结果赋给 iter                                                                                                                                 |
  | iter -= n     | 迭代器减法的复合赋值语句，将 iter 减 n 的结果赋给 iter                                                                                                                                 |
  | iter1 - iter2 | 两个迭代器相减的结果是它们之间的距离，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置                                                                                        |
  | >,>=,<,<=     | 迭代器关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则前者小于后者，参与运算的两个迭代器必须指向同一个容器中的元素或 end 位置，类型是`difference_type`的带符号整型 |

- **使用迭代器运算**

  - 使用迭代器运算的一个**经典算法**是**二分搜索**，其从**有序序列**中寻找某个**给定值**

    ```cpp
    // text 必须是有序的，sought 是要搜索的给定值
    auto beg = text.begin(), end = text.end();    // beg 和 end 表示搜索的范围
    auto mid = text.begin() + (end - bag) / 2;    // 初始中间点
    while (mid != end && *mid != sought)
    {
        if (sought < *mid)                        // 如果在前半部分
            end = mid;                            // 忽略后半部分
        else                                      // 如果在后半部分
            beg = mid + 1;                        // 在mid之后寻找
        mid = beg + (end - beg) / 2;              // 新的中间点
    }
    ```

##### **数组**

- **数组**的大部分使用规则**与 C 语言相同**

- **auto 与数组**

  > 1、由于**数组名**是数组的**首元素地址**，所以使用`auto`**关键字**时，`auto ia2(ia)`等同于`auto ia2(&ia[0])`  
  > 2、但如果使用`decltype`**关键字**，上述转换**不会发生**，`decltype(ia)`**返回类型**是由**10 个整数**构成的**数组**

  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};
  // ia2是一个整型指针，指向ia的首元素
  auto ia2(ia);
  // ia3是一个含有10个整数的数组
  decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}
  ```

- **指针也是迭代器**

  > 1、就像使用**迭代器**遍历`vector`**对象**那样，使用**指针**也能**遍历数组中的元素**。不过前提是先获取到**指向数组首元素的指针**和**指向数组尾元素下一位的指针**  
  > 2、获取**首元素地址**可以使用**数组名**，而**尾后指针**可以获取**尾元素后**那个**并不存在的元素的地址**。如假设定义`int arr[10];`，则可以`int *end = &arr[10]`  
  > 3、尽管**通过计算**可以得到**尾后指针**，但这种方法**极易出错**。为了让指针的使用更简单，C++11 新增了**两个函数**：`begin`**函数**和`end`**函数**  
  > 4、这**两个函数**与**容器中**的**两个同名成员**功能类似，不过**数组不是类类型**，所以这两个函数**不是成员函数**。正确使用的方法是将**数组**作为它们的**参数**，如下

  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};
  int *begin = begin(ia);
  int *end = end(ia);
  ```

- **与旧代码的接口**

  - **引入**

    > 1、很多 C++程序在**标准库出现之前**就已经写成了，它们肯定没用到`string`和`vector`类型；而且有一些 C++程序实际上是**与 C 语言或其他语言**的**接口程序**，当然也无法使用**C++标准库**  
    > 2、但是，现代的 C++ 程序不得不与那些**充满了数组**或**C 风格字符串**的代码衔接。为了使这一工作**简单易行**，C++专门提供了一组功能

  - **混用**`string`**对象和 C 风格字符串**

    > 1、允许使用以`\0`结束的**字符数组**(即 C 风格字符串)来对`string`**对象**进行**初始化**和**赋值**  
    > 2、在`string`**对象**的**加法运算**中允许使用**C 风格字符串**作为其中**一个运算对象**(不能两个都是)；在`string`**对象**的**复合赋值运算**中允许使用**C 风格字符串**作为**右侧运算对象**  
    > 3、上述性质**反过来**就**不成立**了：如果程序某处需要一个**C 风格字符串**，不能用`string`**对象**代替它，例如不能用`string`**对象**初始化一个**指向 char 的指针**  
    > 4、为了完成该功能，`string`专门提供了一个名为`c_str`的**成员函数**：其返回**一个指针**，指向一个**C 风格字符串**，该**字符串内容**与`string`**对象**一样；指针的类型是`const *char`，确保**不会改变字符数组的内容**

    ```cpp
    char *str = s;                // 错误，不能用string对象初始化指向char的指针
    const char *str = s.c_str();  // 正确
    ```

  - **用数组初始化**`vector`**对象**

    - 允许使用**数组**来**初始化**`vector`**对象**。要实现这一目的，只需指明要**拷贝区域**的**首元素地址**和**尾后地址**即可(最简单的方式是用`begin`和`end`函数)

      ```cpp
      int int_arr[] = {0,1,2,3,4,5};
      vector<int> ivec(begin(int_arr), end(int_arr));
      ```

---

#### **表达式**

---

<div class="success">

> **章节概要**：特性补充；**sizeof**运算符；强制类型转换

</div>

##### **特性补充**

- C++的**表达式**和**运算符**与 C 大部分相同，在此**补充**或**强调**一些特性

- **sizeof 运算符**

  > 1、对`string`或`vector`**对象**执行`sizeof`**运算符**只返回**该类型固定部分**的**大小**，**不会计算**对象中的元素占用了多少**空间**  
  > 2、因为`sizeof`的**返回值**是一个**常量表达式**`constexpr size_t`，因此可以用`sizeof`的结果**声明数组的大小**

- **强制类型转换**

  - 一个命名的**强制类型转换**具有**如下形式**：`转换模式<转换类型>(表达式)`

  - 其中，**转换模式**是`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`中的一种

  - `static_cast`**模式**

    > 1、任何具有**明确定义**的**类型转换**，只要不包含**底层**`const`，都可以使用`static_cast`，例如：`double slope = static_cast<double>(i);`  
    > 2、`static_cast`对于**编译器无法自动执行**的**类型转换**也非常有用，例如可以**找回存在于**`void*`**的指针**，转换回**原始的指针类型**，示例如后  
    > 3、但是对于**存在于**`void*`**的指针**，应确保**指针的值保持不变**，且**转换后所得类型**就是**指针所指类型**

    ```cpp
    // 任何非常量对象的地址都能存入void*
    void* p = &d;
    //将void*转换回原始的指针类型(指向double的指针)
    double *dp = static_cast<double*>(p);
    ```

  - `const_cast`**模式**

    > 1、`const_cast`**只能改变**运算对象的**底层**`const`，对于将**常量对象**转换成**非常量对象**的行为，称其为**去掉**`const`**性质**  
    > 2、一旦**去掉了**某个对象的`const`**性质**，编译器将**不再阻止**我们对该对象进行**写入操作**  
    > 3、如果对象**本身不是一个常量**，那么强制类型转换获得**写权限**是**合法的行为**；但如果对象**本身是一个常量**，则再使用`const_cast`执行**写操作**将产生**未定义的后果**

    ```cpp
    const char *pc;
    char *p = const_cast<char*>(pc);    // 正确：但是写操作是未定义的行为
    /*-----------------------------*/
    const char *cp;
    char *q = static_cast<char*>(cp);   // 错误：static_cast不能转换掉const性质
    const_cast<string>(cp);             // 错误，const_cast只能改变常量属性
    static_cast<string>(cp);            // 正确
    ```

  - `reinterpret_cast`**模式**

    > 1、`reinterpret_cast`通常为**运算对象**的**位模式**提供**较低层次**上的重新解释  
    > 2、如下例，我们必须牢记**pc**所指的**真实对象是 int 而非字符**，如果把**pc**当成普通的**字符指针**使用就可以在运行时发生错误  
    > 3、使用`reinterpret_cast`是**非常危险**的，其中关键问题是**类型改变了**，但编译器**没有给出任何警告或错误提示**。下面**使用 pc 时**就会认定它的值是**char\*类型**，**编译器没法知道**它实际存放的是**指向 int 的指针**  
    > 4、`reinterpret_cast`本质上**依赖于机器**。想要安全地使用，必须对**涉及的类型**和**编译器实现转换的过程**都相当了解

    ```cpp
    int *ip;
    char *pc = reinterpret_cast<char*>(ip);
    string str(pc);     // 错误：可能导致异常的运行时行为
    ```

  - `dynamic_cast`**模式**：支持**运行时类型识别**，后续介绍

  - 此外，C 语言的**旧式强制类型转换**仍然支持，但与 C++ 的相比，表现形式上不那么清晰明了，**出错追踪比较困难**，建议使用 C++ 的转换方式

---

#### **语句**

---

<div class="success">

> **章节概要**：`try`语句块和异常处理；C++的异常处理；`throw`表达式；`try`语句块；编写处理代码；标准异常

</div>

##### **try 语句块和异常处理**

- **引入**

  > 1、**异常**是指存在于**运行时**的**反常行为**，这些行为超出了**函数正常功能**的范畴，典型的异常包括**失去数据库连接**以及**遇到意外输入**等。处理反常行为可能是设计所有系统最难的一部分  
  > 2、当**程序的某部分**检测到一个让它**无法处理**的问题时，就需要用到**异常处理**。如果程序中含有**可能引发异常的代码**，那么通常也会有**专门的代码处理问题**  
  > 3、**异常处理机制**为程序中**异常检测**和**异常处理**这两部分的协作提供支持。C++中，异常处理包括以下部分

- **C++的异常处理**

  > 1、`throw`**表达式**：**异常检测**部分使用`throw`**表达式**来表示它**遇到了无法处理的问题**，我们说`throw`**引发了异常**  
  > 2、`try`**语句块**：**异常处理**部分使用`try`**语句块**处理异常。`try`中包含**一个或多个**`catch`**子句**，抛出的**异常**通常会**被某个**`catch`**子句处理**。因为`catch`**子句**处理异常，所以它们也被称为**异常处理代码**  
  > 3、一套**类异常**：用于在`throw`**表达式**和相关的`catch`**子句**之间**传递异常的具体信息**

- **throw 表达式**

  > 1、程序的**异常检测**部分使用`throw`**表达式**引发一个**异常**，形式如`throw 表达式;`，其中的**表达式类型**就是**抛出的异常类型**  
  > 2、如下示例，如果书籍的 ISBN 不一样就**抛出异常**，该**异常类型是**`runtime_error`**对象**。抛出异常将**终止当前的函数**，并把**控制权**转移给**能处理该异常的代码**  
  > 3、类型`runtime_error`是**标准库异常类型**的一种，定义在`stdexcept`**头文件**中，后面将介绍其他的异常类型  
  > 4、我们必须**初始化**`runtime_error`**对象**，方式是给它提供一个`string`**对象**或一个**C 风格字符串**，这个字符串中有一些关于异常的**辅助信息**

  ```cpp
  if(item1.isbn() != item2.isbn())
      throw runtime_error("数据必须具有相同的ISBN");
  cout << item1 + item2 << endl;
  ```

- **try 语句块**

  > 1、`try`**语句块**的通用语法形式如下  
  > 2、跟在`try`**块**之后的是**一个或多个**`catch`**子句**。`catch`**子句**包括三部分：**关键字**`catch`、括号内一个(可能未命名的)**对象的声明**(称作异常声明)、以及**一个块**  
  > 3、当选中了某个`catch`子句**异常处理之后**，执行**与之对应的块**。`catch`**一旦执行完成**，会**跳转到**`try`**块**中**最后一个**`catch`**子句之后**的语句继续执行  
  > 4、`try`**块**中的**程序语句**组成程序的**正常逻辑**，像其他任何块一样，可以有包括声明在内的任意 C++ 语句

  ```cpp
  try
  {
      程序语句
  }
  catch(异常声明)
  {
      处理语句
  }
  catch(异常声明)
  {
      处理语句
  }
  // ...
  ```

- **编写处理代码**

  > 1、编写**异常处理代码**，上面的程序可以按如下示例处理  
  > 2、将程序**本来要执行的任务**放在`try`**语句块**中，因为这段代码**可能抛出异常**  
  > 3、`try`对应一个`catch`**子句**，该子句负责**处理**`runtime_error`**类型的异常**。如果`try`中抛出了**此类异常**，则会执行该`catch`内的语句  
  > 4、`catch`中输出给用户的信息中，输出了`err.what()`的返回值。从`catch`**小括号的定义**能得到**err**是一个`runtime_error`**类的对象**，`what`则是该**类**的一个**成员函数**  
  > 5、`what`成员函数**没有参数**，**返回值**是**C 风格字符串**(即`const char*`)。其中，`runtime_error`的`what`**成员**返回的是**初始化一个具体对象**时所用的`string`**对象的副本**(即`try`中初始化的字符串)

  ```cpp
  while (cin >> item1 >> item2)
  {
      try
      {
          if(item1.isbn() != item2.isbn())
              throw runtime_error("数据必须具有相同的ISBN");
          cout << item1 + item2;
      }
      catch(runtime_error err)
      {
          cout << err.what() << "\n 再次尝试？输入y或n"<< endl;
          char c;
          cin >> c;
          if(!cin || c == 'n')
          {
                cout << "程序退出" << endl;
                break;          // 跳出 while 循环
          }
      }
  }
  ```

- **标准异常**

  - **标准异常类**

    > 1、C++**标准库**中定义了一组**类**，用于报告**标准库函数**遇到的问题。这些**异常类**也可以在**用户编写的程序中**使用，分别定义在**4 个头文件**  
    > 2、`exception`：定义了**最通用的异常类**`exception`，它**只报告异常的发生**，**不提供任何额外信息**  
    > 3、`stdexcept`：定义了几种**常用的异常类**，详细信息见下表  
    > 4、`new`：定义了`bad_alloc`**异常类型**，后续介绍  
    > 5、`type_info`：定义了`bad_cast`**异常类型**，后续介绍

    | stdexcept 定义的异常类 | 含义                                           |
    | ---------------------- | ---------------------------------------------- |
    | exception              | 最常见的错误                                   |
    | runtime_error          | 只有在运行时才能检测出的任务                   |
    | range_error            | 运行时错误：生成的结果超出了有意义的值域范围   |
    | overflow_error         | 运行时错误：计算上溢                           |
    | underflow_error        | 运行时错误：计算下溢                           |
    | logic_error            | 程序逻辑错误                                   |
    | domain_error           | 逻辑错误：参数对应的结果值不存在               |
    | invalid_argument       | 逻辑错误：无效参数                             |
    | length_error           | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
    | out_of_range           | 逻辑错误：使用一个超出有效范围的值             |

  - **运算与成员**

    > 1、**标准库异常类**只定义了几种运算，包括**创建或拷贝异常类型的对象**，以及**为异常类型的对象赋值**  
    > 2、我们只能以**默认初始化**的方式初始化`exception`、`bad_alloc`、`bad_cast`对象，**不允许**为这些对象**提供初始值**  
    > 3、**其他异常类型**的行为恰好相反，应该使用`string`**对象**或者**C 风格字符串**初始化这些类型的对象，**不允许**使用**默认初始化**的方式。创建此类对象时，**必须提供初始值**，该值含有**错误相关信息**  
    > 4、**异常类型**之定义了一个名为`what`的**成员函数**，返回值是**C 风格字符串**，字符串的目的是**提供关于异常的一些文本信息**。对于其他**无初始值的异常类型**，`what`返回的内容由**编译器决定**

---

#### **函数**

---

<div class="success">

> **章节概要**：含有可变形参的函数；`initializer_list`形参；函数的返回值；不要返回局部对象的引用或指针；返回数组指针的函数；函数重载；定义重载函数；重载和`const`形参；`const_cast`和重载；特殊用途语言特性；默认实参；内联函数；`constexpr`函数

</div>

##### **含有可变形参的函数**

- **简介**

  > 1、有时我们**无法提前预知**应该向函数**传递几个实参**。为了编写**能处理不同数量实参**的函数，C++11 提供了以下几种方法  
  > 2、如果所有的**实参类型相同**，可以传递一个名为`initializer_list`的**标准库类型**  
  > 3、如果**实参类型不同**，可以编写一种特殊的函数——**可变参数模板**，将在后续介绍  
  > 4、此外还有一种从**C 标准库**`stdarg.h`继承而来的**省略符形参**`...`，但有了一些限制

- **initializer_list 形参**

  - **简介**

    > 1、`initializer_list`是一种**标准库类型**，用于表示**某种特定类型的值的数组**，其定义在`initializer_list`**头文件**中。后表是它的一些操作  
    > 2、和`vector`一样，**该类型**也是一种**模板类型**，这意味着**定义对象**时，也必须说明列表中**所含元素的类型**：`initializer_list<int> li;`  
    > 3、和`vector`不同的是，该类型对象中的**元素永远是常量值**，我们**无法改变**该类型对象中**元素的值**

  - **使用**

    > 1、我们可以使用**该类型**作为函数的**形参**，使用**迭代器**访问**列表中的元素**  
    > 2、使用函数时，如果想向`initializer_list`**形参**中**传递一个值的序列**，则必须把**序列**放在一对**花括号**内  
    > 3、含有`initializer_list`**形参**的函数也**可以同时拥有其他形参**

    ```cpp
    // 定义函数
    void error_msg(int error_code, initializer_list<string> i1)
    {
        cout << "error code:" << error_code;
        for(auto beg = i1.begin(); beg != i1.end(); beg++)
            cout << *beg << ' ';
        cout << endl;
    }
    // 传参使用
    int error_number = 15;
    string s1("error1"), s2("error2");
    error_msg(error_number, {"function", s1, s2});
    ```

- **省略号形参**`...`

  > 1、**省略号形参**`...`沿用自**C 语言的**`stdarg.h`**库**，为了便于**C++程序**访问某些特殊的**C 代码**  
  > 2、但省略符形参应该**仅仅用于 C 和 C++ 通用的类型**。特别应该注意，C++的大多数**类类型的对象**传递时都**无法正确拷贝**

##### **函数的返回值**

- **不要返回局部对象的引用或指针**

  > 1、函数完成后，所占用的**内存空间**也会**随之释放**。由此，**局部变量的引用**和**指向局部变量的指针**将指向**不再有效的内存区域**  
  > 2、如下示例，对于两条`return`语句，都将返回**未定义的值**

  ```cpp
  // 函数返回值类型是const string &，即一个引用
  const string &manip()
  {
      string ret;
      if (!ret.empty())
          return ret;       // 错误：返回了局部对象的引用，返回的引用将指向无效区域
      return "Empty";       // 错误：Empty也是一个局部临时量，返回的引用将指向无效区域
  }
  ```

- **返回数组指针的函数**

  - **直接声明**

    > 1、如果我们想定义一个**返回数组指针的函数**，则**数组的下标数**必须**跟在函数名后**。而函数的**形参列表**也跟在**函数名后**，且应该**先于数组的下标数**  
    > 2、因此，**返回数组指针的函数**形式如：`类型 (* 函数名(形参列表))[数组下标数]`，具体的例子和解读如下(可以参考[类型声明黄金法则](https://www.shengqibaozao.eu.org/2022/08/22/%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99/?t=1674030612212))

    ```cpp
    int (*func(int i))[10];
    /*---------------------*/
    /*
    解读：
    func(int i)             ：表示函数需要一个int类型形参
    (*func(int i))          ：返回类型是一个指针
    (*func(int i))[10]      ：指针指向一个大小是10的数组
    int (*func(int i))[10]  ：指向的是一个含有10个int值的数组
    */
    ```

  - **使用尾置返回类型**

    > 1、在 C++11 新标准中还有一种可以**简化上述声明**的方法，就是使用**尾置返回类型**  
    > 2、**任何函数的定义**都能使用**尾置返回**，但这种形式对于**返回类型比较复杂**的函数最有效，比如返回类型是**数组的指针**或者**数组的引用**  
    > 3、**尾置返回类型**跟在**形参列表**后面并以一个`->`**符号开头**。为了表示函数**真正的返回类型**跟在**形参列表后**，原先**标识返回值的地方**改为`auto`

    ```cpp
    // 函数返回一个指针，指向含有10个整数的数组
    auto func(int i) -> int(*)[10];
    ```

  - **使用**`decltype`**获取类型**

    > 1、还有一种情况，**如果知道**函数返回的**指针将指向哪个数组**，可以使用`decltype`来**声明返回类型**，如下例  
    > 2、`decltype(odd)`标识了**返回类型**是一个**含有 5 个 int 值的数组**，`*`标识了**返回类型**是一个**指针**  
    > 3、有一个地方要注意，`decltype`并**不负责**把数组类型**转换成**相应的**指针**，所以如果需要返回**指向数组的指针**的函数，需要像下例中**声明时**加一个`*`

    ```cpp
    int odd[] = {1, 3, 5, 7, 9};
    int even[] = {0, 2, 4, 6, 8};
    // 使用 decltype(odd) 获取类型
    decltype(odd) *arrPtr(int i)
    {
        return (i % 2) ? &odd : &even;  // 返回一个指向数组的指针
    }
    ```

##### **函数重载**

- **简介**

  > 1、如果**同一作用域**内的几个函数**名字相同**但**形参列表不同**，我们称之为**重载函数**。如下例  
  > 2、这些函数接受的**形参类型不同**，但是执行的**操作非常相似**，使用**函数重载**可以在一定程度上减轻起名记名的负担  
  > 3、当**调用这些函数**时，编译器会**根据传递的实参**判断具体想要执行的是**哪个函数**

  ```cpp
  // 函数原型
  void print(char *cp);               // 1
  void print(int *beg, int *end);     // 2
  void print(int ia[], size_t size);  // 3
  /*--------------------------------------*/
  // 函数调用
  int j[2] = {0, 1};
  print("Hello World");         // 调用 1
  print(j, end(j) - begin(j));  // 调用 3
  print(begin(j), end(j));      // 调用 2
  ```

- **定义重载函数**

  > 1、对于定义的**重载函数**来说，它们至少应该在**形参数量**或**形参类型**上**有所不同**  
  > 2、假设有两个函数，他们的**返回类型不同**但**形参列表相同**，这种声明不是**重载函数**，是**错误的**  
  > 3、有时候两个**形参列表看起来不一样**，但实际是**相同**的。比如**省略了形参名**，或使用**类型别名**  
  > 4、**不能重载**`main()`**函数**

  ```cpp
  // 不允许两个函数除了返回类型不同其余都相同
  void lookup(Account&);
  bool lookup(Account&);    // 错误
  /*--------------------------------*/
  // 形参列表相同
  void lookup(Account &acct);
  void lookup(Account&);    // 相同，省略了形参名
  typedef Phone Telno;
  void lookup(Phone&);
  void lookup(Telno&);      // 相同，使用了类型别名
  ```

- **重载和 const 形参**

  > 1、**顶层**`const`不影响传入函数的**对象**，一个拥有**顶层**`const`**的形参**无法和另一个**没有顶层**`const`**的形参**区分开来  
  > 2、如果**形参**是某种类型的**指针或引用**，则通过**区分**其**指向**的是**常量对象**还是**非常量对象**可以实现**函数重载**，注意此时的`const`**是底层的**

  ```cpp
  void lookup(Phone);
  void lookup(const Phone);       // 重复声明了void lookup(Phone)
  void lookup(Phone*);
  void lookup(Phone* const);      // 重复声明了void lookup(Phone*)，顶层const
  /*------------------------------------------------------*/
  void lookup(Account&);          // 作用于Account的引用
  void lookup(const Account&);    // 新函数，作用于常量引用
  void lookup(Account*);          // 作用于指向Account的指针
  void lookup(const Account*);    // 新函数，作用于指向常量的指针，底层const
  ```

- **const_cast 和重载**

  > 1、`const_cast`在**重载函数**的情境中最有用，如下例  
  > 2、**原函数**的**参数**和**返回类型**都是`const string`**的引用**。虽然我们可以对两个**非常量的**`string`调用这个函数，但**返回结果**仍是`const string`，我们并**不希望返回的是常量**  
  > 3、此时我们需要一种**新的函数**，当它的**实参不是常量**时，得到的结果是一个**非常量引用**，使用`const_cast`可以很方便做到这一点  
  > 4、**新函数**内通过`const_cast`把参数先转为**常量**，调用**原函数**，再将**原函数结果**转为**非常量**

  ```cpp
  // 原函数，返回 const string 的引用
  const string &shorterString(const string &s1, const string &s2)
  {
      return s1.size() <= s2.size() ? s1 : s2;
  }
  // 重载函数，返回非 const 的引用
  string &shorterString(string &s1, string &s2)
  {
      auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
      return const_cast<string&>(r);
  }
  ```

##### **特殊用途语言特性**

- **默认实参**

  > 1、可以将**函数**的**形参列表**中的值赋予初始值，这便是**默认实参**。当**函数调用**时，如果**没有给定这个值的实参**，便会使用**默认实参**  
  > 2、我们可以为**一个或多个形参**赋予默认值。但要注意，一旦某个形参被赋予了默认值，它**后面的所有形参**都**必须有默认值**  
  > 3、**函数调用**时，实参按照**位置顺序**解析，**默认实参**负责填补函数调用**缺少的尾部实参**(即靠右侧位置的形参)。即**不能省略前面的参数值**，**只能省略尾部的参数值**

  ```cpp
  // 默认实参函数定义
  typedef string::size_type sz;
  string screen(sz ht = 24, sz wid = 24, char background = ' ');
  // 函数调用
  string window;
  window = screen();            // screen(24, 80, ' ')
  window = screen(66);          // screen(66, 80, ' ')
  window = screen(66,256,'#')   // screen(66, 256, '#')
  // 错误调用
  window = screen(, , '?');     // 错误
  window = screen('?');         // 错误，screen('?', 80, ' ')
  ```

- **内联函数**

  > 1、使用`inline`将函数指定为**内联函数**，通常就是将它在**每个调用点**上**内联地展开**，可以**避免函数调用的开销**。说明如下示例  
  > 2、**内联**只是向**编译器**发出的**一个请求**，**编译器**可以选择**忽略这个请求**  
  > 3、一般来说，**内联机制**用于**优化规模较小**、**流程直接**、**调用频繁**的函数。很多编译器不支持**内联递归函数**，而且一个**大于 75 行**的函数也不大可能在**调用点内联展开**

  ```cpp
  // 原函数即程序调用
  inline string shorterString(string &s1, string &s2)
  {
      return s1.size() <= s2.size() ? s1 : s2;
  }
  string s1 = "abcde", s2 = "abcdef";
  cout << shorterString(s1, s2);

  // 在编译过程中，函数调用将直接展开成下面形式，从而不经过shorterString，减少了函数调用的开销
  cout << (s1.size() <= s2.size() ? s1 : s2);
  ```

- **constexpr 函数**

  > 1、`constexpr`**函数**是指能用于**常量表达式**的函数。定义的方法与其他函数类似，但**有如下规定**：函数的**返回类型**及**所有形参**都必须是**字面值类型**，而且函数体中必须**有且仅有一条**`return`**语句**  
  > 2、执行**初始化任务**时，**编译器**把**对**`constexpr`**函数的调用**都替换成其**结果值**。为了能在编译过程中**随时展开**，`constexpr`**函数**被**隐式指定为内联函数**  
  > 3、`constexpr`**函数**不一定返回常量表达式

  ```cpp
  constexpr size_t scale(size_t ct)
  {
      return 3 * ct;
  }

  int arr[scale(2)];      // 正确，编译时 scale(2) 将被内联展开为 6
  int i = 2;
  int a2[scale(i)];       // 错误，i不是常量表达式
  ```

---

#### **类**

---

<div class="success">

> **章节概要**：定义抽象数据类型；设计`Sales_data`类；定义`Sales_data`类；分析与设计；`this`参数；`const`成员函数；返回`this`对象的函数；该类相关的非成员函数；构造函数；合成的默认构造函数；合成的默认构造函数的局限性；定义构造函数；`= default`的含义；构造函数初始值列表；类外定义构造函数；拷贝、赋值和析构；访问控制与封装；`public`和`private`；`class`和`struct`；友元；类的其他特性；类成员再探；`mutable`可变数据成员；返回`*this`的成员函数；从`const`成员函数返回`*this`；基于`const`的重载；友元再探；类之间的友元关系；令函数成员作为友元；友元函数重载和作用域；类的作用域；名字查找与类作用域；构造函数再探；委托构造函数；隐式类类型转换；`explicit`抑制构造函数隐式转换；聚合类；字面值常量类；`constexpr`构造函数；类的静态成员；声明、使用、定义静态成员；静态成员的类内初始化；静态成员与普通成员的区别

</div>

##### **定义抽象数据类型**

- **抽象数据类型**

  > 1、如果一个类，我们可以通过它的**接口**(例如描述的操作)来**使用该类的对象**，但**不能访问该类的数据成员**(甚至不知道该类有哪些数据成员)，我们称**这样的类**为**抽象数据类型**  
  > 2、反之，如果一个类**允许用户**直接**访问它的数据成员**，并要求**用户**来**编写操作**，**这样的类**不是一个抽象数据类型  
  > 3、对于一个**普通的数据类型**(非抽象数据类型)，如果想把它变成**抽象数据类型**，我们需要**定义一些操作**供类的用户使用。一旦**定义了自己的操作**，我们就可以**封装它的数据成员**了

- **设计 Sales_data 类**

  - **引入**

    > 1、为了方便图书管理，我们需要**设计一个类**便于**信息存储**与**操作**，需要先**分析满足下列操作**：  
    > 2、类中需要有**能读写的数据对象**，需要对这些对象**支持一些操作**  
    > 3、**操作包括**一个名为`isbn`的**成员函数**，并且支持`+`、`=`、`+=`、`<<`、`>>`**运算符**  
    > 4、我们将在后续学习**重载运算符**，现在对于**运算符运算**，我们先定义为**普通函数**的形式  
    > 5、由于特殊的原因(后续重载运算符介绍)，执行**加法**和**IO 的函数**不作为**类的成员**，我们将其定义成**普通函数**

  - **该类应包含的操作**

    > 1、一个`isbn`**成员函数**，返回**对象的 ISBN 编号**  
    > 2、一个`combine`**成员函数**，用于将一个`Sales_data`**对象加到另一个对象上**  
    > 3、一个`add`**函数**，执行两个`Sales_data`对象的**加法**  
    > 4、一个`read`**函数**，将数据从`istream`**读入到**`Sales_data`**对象中**  
    > 5、一个`print`**函数**，将`Sales_data`**对象的值输出到**`ostream`中

  - **使用类的接口**(先不考虑如何实现该类，首先看看应该如何使用这些接口函数)

    ```cpp
    Sales_data total;             // 保存当前求和结果的变量
    if(read(cin, total))          // 读入第一笔交易
    {
        Sales_data trans;         // 保存下一条交易数据的变量
        while(read(cin, trans))   // 读入剩余的交易
        {
            if(total.isbn() == trans.isbn())    // 检查 isbn
              total.combine(trans);             // 更新变量 total 当前的值
            else
            {
                print(cout, total) << endl;     // 输出结果
                total = trans;                  // 处理下一本书
            }
        }
        print(cout, total) << endl; // 输出最后一条交易
    }
    else                            // 如果没有输入
    {
        cerr << "No data?" << endl; // 通知用户
    }
    ```

- **定义 Sales_data 类**

  - **分析与设计**

    > 1、该类的**数据成员**有：`string`类型的**bookNo**，表示 ISBN 编号；`unsigned`类型的**units_sold**，表示某书的销量；`double`类型的**revenue**，表示这本书的总销售收入  
    > 2、类中将包含`combine`和`isbn`两个**成员函数**，此外，我们还需要另一个**成员函数**`avg_price`返回售出书籍的平均价格。由于`avg_price`的**目的并非通用**，所以它应该属于**类的实现的一部分**，而不是**接口的一部分**  
    > 3、**定义**和**声明**一个**成员函数**的方法与普通函数差不多。**成员函数的声明**必须在**类的内部**，而它的**定义可以在外部**。作为**接口组成部分**的**非成员函数**`add`、`read`、`print`等，它们的**定义和声明**都在**类的外部**  
    > 4、定义在**类内部的函数**是**隐式的内联函数**

    ```cpp
    struct Sales_data
    {
        // 数据成员
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
        // 成员函数
        std::string isbn() const
        {
            return bookNo;
        }
        Sales_data &combine(const Sales_data &);    // 将在类外定义
        double avg_price() const;                   // 将在类外定义
    };
    // 非成员接口函数
    Sales_data add(const Sales_data &, const Sales_data &);
    std::ostream &print(std::ostream &, const Sales_data &);
    std::istream &read(std::istream &, Sales_data &);
    ```

  - `this`**参数**

    > 1、`isbn`**成员函数**是如何获得**bookNo 成员**所依赖的**对象**的呢？  
    > 2、观察对`isbn`的**调用**：`total.isbn()`。我们使用了**点运算符**来访问**total 对象**中的`isbn`**成员函数**并调用它  
    > 3、还有一种**例外的形式**，当我们**调用成员函数**时，实际上是在**替某个对象调用它**。如果`isbn`指向`Sales_data`的**成员**(如 bookNo)，则它**隐式地**指向**调用该函数的对象的成员**。在上例中，当`isbn`返回**bookNo**时，实际上它**隐式地**返回**total.bookNo**  
    > 4、**成员函数**通过名为`this`的**额外的隐式参数**来访问和调用它的那个对象，当我们**调用成员函数**时，会用**请求该函数的对象地址**初始化`this`。例如调用`total.isbn()`时，**编译器**负责把**total 的地址**传递给`isbn`的**隐式形参**`this`  
    > 5、在**成员函数体**内部，也可以直接使用**调用该函数的对象的成员**，而无须通过**成员访问运算符**，因为`this`所指的**正是这个对象**。任何对**类成员**的**直接访问**都被看作`this`的**隐式引用**  
    > 6、对于我们来说，`this`**形参**是**隐式定义**的，我们可以在**成员函数体**内部使用`this`。尽管没有必要，但我们还是可以把`isbn`的**函数体写为**`return this->bookNo;`  
    > 7、因为`this`**总是指向这个对象**，所以`this`是一个**常量指针**，**不允许修改**`this`中保存的地址

  - `const`**成员函数**

    > 1、`isbn`函数的另一个**关键之处**是**参数列表后的**`const`，这里，`const`的作用是**修改隐式**`this`**指针的类型**  
    > 2、默认情况下，`this`的类型是**指向类类型**的**非常量版本**的**常量指针**，例如`Sales_data`**成员函数**中，`this`的类型是`Sales_data *const`。这意味着，我们不能把`this`绑定到一个**常量对象**上，这使得不能在一个**常量对象**上调用**普通的成员函数**  
    > 3、如果`isbn`是一个**普通函数**且`this`是一个**普通指针形参**，则我们**应该把**`this`**声明成**`const Sales_data *const`**类型**，毕竟`isbn`函数体内**不会改变**`this`**所指的对象**  
    > 4、然而，`this`**是隐式的**而且不会出现在**形参列表**中，在哪将`this`声明成**指向常量的指针**？C++的做法是把`const`放在成员函数的**参数列表后**  
    > 5、紧跟在**参数列表后**的`const`表示`this`是一个**指向常量的指针**，而像这样使用`const`的**成员函数**称作**常量成员函数**

  - **在类的外部定义成员函数**

    > 1、前面提过**成员函数的定义可以在类外**，我们的`avg_price`和`combine`**成员函数**就打算通过这种方式定义  
    > 2、要注意，**类外部定义的成员的名字**必须包含**所属的类名**，通过**作用域运算符**来告知**编译器**定义的这个函数是**类内的成员函数**

    ```cpp
    double Sales_data::avg_price() const
    {
        if (units_sold)
            return revenue / units_sold;
        else
            return 0;
    }
    ```

  - **返回**`this`**对象的函数**

    > 1、函数`combine`的设计初衷类似于**复合赋值运算符**`+=`，其定义如下  
    > 2、当程序调用`total.combine(trans);`时，`this`指针绑定了**total 的地址**，**rhs 引用**绑定了**实参 trans**  
    > 3、该函数值得关注的是它的**返回类型**和**返回语句**。模仿标准的**赋值运算符**把它的**左侧运算对象**当做**左值**返回，因此`combine`**必须返回引用**，而**左侧运算对象**又是`Sales_data`**对象**，因此返回类型是`Sales_data&`  
    > 4、如前所述，我们需要**把该对象当做左值返回**。我们无须使用隐式的`this`指针访问**函数调用者**的**某个具体成员**，而是要把**调用函数的对象**当做一个整体来访问，即`return *this;`，该调用**返回 total 的引用**

    ```cpp
    Sales_data &Sales_data::combine(const Sales_data &rhs)
    {
        // 把 rhs 的成员加到 this 的成员上
        units_sold += rhs.units_sold;
        revenue += rhs.revenue;
        // 返回调用该函数的对象
        return *this;
    }
    ```

  - **该类相关的非成员函数**

    - `read`和`print`函数

      > 1、`read`和`print`函数分别接受一个**各自 IO 类型的引用**作为其参数，是因为**IO 类**属于**不能被拷贝的类型**，因此只能**通过引用传递**。而且，读取和写入的操作**会改变流的内容**，所以使用**普通引用**而不是`const`**引用**  
      > 2、`print`**函数不负责换行**。一般来说，**执行输出任务的函数**应该尽量**减少对格式的控制**，这样可以确保**由用户代码决定**是否换行

      ```cpp
      // 输入的交易信息包括 ISBN、售出总数、售出单价
      std::istream &read(std::istream &is, Sales_data &item)
      {
          double price = 0;
          is >> item.bookNo >> item.units_sold >> price;
          item.revenue = price * item.units_sold;
          return is;
      }

      std::ostream &print(std::ostream &os, const Sales_data &item)
      {
          os << item.isbn() << ' ' << item.units_sold << ' ' << item.revenue << ' ' << item.avg_price();
          return os;
      }
      ```

    - `add`函数

      ```cpp
      Sales_data add(const Sales_data &lhs, const Sales_data &rsh)
      {
          Sales_data sum = lhs; // 把 lhs 的数据成员拷贝给 sum
          sum.combine(rsh);     // 把 rsh 的数据成员添加到 sum
          return sum;           // 返回新的 Sales_data 对象
      }
      ```

- **构造函数**

  - **介绍**

    > 1、每个**类**都分别定义了它的**对象被初始化的方式**，**类**通过一个或几个**特殊的成员函数**控制其对象的初始化过程，**这些函数**被称为**构造函数**  
    > 2、**构造函数**的任务是**初始化类对象**的**数据成员**，无论何时只要**有类的对象被创建**，**就会执行构造函数**  
    > 3、构造函数的**名字和类名相同**。和其他函数不同的是，构造函数**没有返回类型**，且不能被声明成`const`。类可以包含**多个构造函数**，和其他**重载函数**类似  
    > 4、当我们创建类的一个`const`**对象**时，直到**构造函数完成初始化**过程，对象才真正取得了**常量属性**。因此**构造函数**在`const`**对象**的构造过程中**可以向其写值**

  - **合成的默认构造函数**

    > 1、我们的`Sales_data`类并没有定义任何**构造函数**，可是之前**使用了**`Sales_data`**对象**的程序却没有异常，它们是如何初始化的？  
    > 2、我们没有为这些对象**提供初始值**，它们执行了**默认初始化**。**类**通过一个**特殊的构造函数**来控制**默认初始化过程**，这个函数叫做**默认构造函数**，其**无须任何实参**  
    > 3、如我们所见，**默认构造函数**在很多方面都有其**特殊性**。其中之一是，如果我们的类**没有显式定义构造函数**，编译器会为我们**隐式定义一个默认构造函数**，这样的函数有称为**合成的默认构造函数**  
    > 4、对于大多数类来说，这个**合成的默认构造函数**将按照**如下规则**初始化数据：使用**类内的初始值**(如果有的话)**初始化**成员，否则**默认初始化该成员**

  - **合成的默认构造函数的局限性**

    > 1、**合成的默认构造函数**只适合**非常简单**的类，对于一个**普通的类**来说，**必须**定义它自己的**默认构造函数**，原因有三：  
    > 2、首先，编译器只有在发现**类不包含任何构造函数时**才会替我们生成默认构造函数，一旦我们**定义了一些其他构造函数**，除非我们**再定义**一个**默认生成函数**，否则类将**没有默认构造函数**。如果一个类需要**在某种情况下控制初始化**，那么该类很可能**在所有情况下都需要控制**  
    > 3、其次，对于某些类来说，**合成的默认构造函数**可能执行**错误的操作**。如果定义在**块中的内置类型**或数组指针这类的**复合类型的对象**被**默认初始化**，它们的值是**未定义**的。因此这样的类应该在**类内初始化**这些成员，或定义一个自己的**默认构造函数**  
    > 4、最后，有时候**编译器**不能为**某些类**合成默认构造函数。对这样的类来说，**必须**自定义**默认构造函数**，否则该类将没有可用的**默认构造函数**

  - **定义构造函数**

    - **示例**

      > 1、对于我们的`Sales_data`类，我们将使用**下面的参数**定义 4 个不同的**构造函数**  
      > 2、一个`istream&`，从中读取一条交易信息  
      > 3、一个`const string&`，表示 ISBN 编号；一个`unsigned`，表示图书数量；一个`double`，表示售出单价  
      > 4、一个`const string&`，表示 ISBN 编号，编译器将赋予其他成员默认值  
      > 5、一个**空参数列表**(即默认构造函数)，如刚刚介绍，既然**已定义其他构造函数**，那么也**必须**定义一个**默认构造函数**

      ```cpp
      struct Sales_data
      {
          // 新增的构造函数
          Sales_data() = default;
          Sales_data(const std::string &s) : bookNo(s)
          {
          }
          Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
          {
          }
          Sales_data(std::istream &);   // 将在类外定义

          // 数据成员
          std::string bookNo;
          unsigned units_sold = 0;
          double revenue = 0.0;
          // 成员函数
          std::string isbn() const
          {
              return bookNo;
          }
          Sales_data &combine(const Sales_data &);
          double avg_price() const;
      };
      ```

    - `= default`的含义

      > 1、我们首先解释**默认构造函数**：`Sales_data() = default;`  
      > 2、首先请明确：因为该构造函数**不接受任何实参**，所以它是**默认构造函数**。我们定义它只是因为我们既需要**其他形式的构造函数**，又需要**默认的构造函数**，我们希望它的作用完全等同于**合成的默认构造函数**  
      > 3、在 C++11 中，如果我们需要**默认的行为**，可以通过在**参数列表后**写上`= default`来**要求编译器生成构造函数**。其中`= default`既可以和声明一起**出现在类内**，也可以作为定义**出现在类外**  
      > 4、和其他函数一样，如果`= default`在**类内**，则默认构造函数**是内联的**；反之则**不是内联的**

    - **构造函数初始值列表**

      > 1、之后的两个构造函数中，出现了**新的部分**，即**冒号**及**冒号和花括号之间**的代码。其中**花括号**定义了**空的函数体**，我们把**新出现的部分**称为**构造函数初始值列表**  
      > 2、这部分负责为**新创建的对象**的一个或几个**数据成员**赋初值。**构造函数初始值**是**成员名字**的一个列表，每个名字后紧跟**括号括起来的**或者**在花括号内的**成员初始值。不同成员初始化通过**逗号分隔**  
      > 3、例如，上例含有三个参数的**构造函数**分别用**前两个参数**初始化了成员**bookNo**和**units_sold**，而**revenue**的初始值则通过`revenue(p * n)`使用计算后的值作为初始值  
      > 4、需要注意，这两个**构造函数**的**函数体是空的**是因为这些构造函数的**唯一目的**就是**为成员赋值**，没有其他任务需要执行

    - **类外定义构造函数**

      > 1、我们将在**类外定义**以`istream`为参数的构造函数。该函数需要**执行一些实际操作**，所以在函数体内，调用了之前定义的`read`**函数**给**数据成员赋值**  
      > 2、`Sales_data::Sales_data`的含义是，我们定义的是`Sales_data`**类的成员**，其**成员名**是`Sales_data`  
      > 3、这个**构造函数**的**初始值列表为空**，但是由于执行了**构造函数体**，所以**对象的成员**依然能被初始化

      ```cpp
      Sales_data::Sales_data(std::istream &is)
      {
          read(is, *this);
      }
      ```

- **拷贝、赋值和析构**

  > 1、除了定义类的对象**如何初始化**外，类还需要控制**拷贝**、**赋值**和**销毁对象时发生的行为**  
  > 2、如果我们不**主动定义**这些操作，编译器将替我们**合成它们**。一般来说，编译器生成的版本将对对象的**每个成员**执行**拷贝**、**赋值**和**销毁操作**  
  > 3、我们将在 13 章介绍如何**自定义上述操作**

- **完整的类与使用**

  ```cpp
  #include <iostream>
  #include <string>

  struct Sales_data
  {
      // 新增的构造函数
      Sales_data() = default;
      Sales_data(const std::string &s) : bookNo(s)
      {
      }
      Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
      {
      }
      Sales_data(std::istream &);

      // 数据成员
      std::string bookNo;
      unsigned units_sold = 0;
      double revenue = 0.0;
      // 成员函数
      std::string isbn() const
      {
          return bookNo;
      }
      Sales_data &combine(const Sales_data &);
      double avg_price() const;
  };


  // 非成员接口函数
  Sales_data add(const Sales_data &, const Sales_data &);
  std::ostream &print(std::ostream &, const Sales_data &);
  std::istream &read(std::istream &, Sales_data &);

  double Sales_data::avg_price() const
  {
      if (units_sold)
          return revenue / units_sold;
      else
          return 0;
  }

  Sales_data &Sales_data::combine(const Sales_data &rhs)
  {
      // 把 rhs 的成员加到 this 的成员上
      units_sold += rhs.units_sold;
      revenue += rhs.revenue;
      // 返回调用该函数的对象
      return *this;
  }

  // 输入的交易信息包括 ISBN、售出总数、售出单价
  std::istream &read(std::istream &is, Sales_data &item)
  {
      double price = 0;
      is >> item.bookNo >> item.units_sold >> price;
      item.revenue = price * item.units_sold;
      return is;
  }

  std::ostream &print(std::ostream &os, const Sales_data &item)
  {
      os << item.isbn() << ' ' << item.units_sold << ' ' << item.revenue << ' ' << item.avg_price();
      return os;
  }

  Sales_data add(const Sales_data &lhs, const Sales_data &rsh)
  {
      Sales_data sum = lhs; // 把 lhs 的数据成员拷贝给 sum
      sum.combine(rsh);     // 把 rsh 的数据成员添加到 sum
      return sum;           // 返回新的 Sales_data 对象
  }

  // 构造函数
  Sales_data::Sales_data(std::istream &is)
  {
      read(is, *this);
  }

  int main()
  {
      Sales_data total;          // 保存当前求和结果的变量
      if (read(std::cin, total)) // 读入第一笔交易
      {
          Sales_data trans;             // 保存下一条交易数据的变量
          while (read(std::cin, trans)) // 读入剩余的交易
          {
              if (total.isbn() == trans.isbn()) // 检查 isbn
                  total.combine(trans);         // 更新变量 total 当前的值
              else
              {
                  print(std::cout, total) << std::endl; // 输出结果
                  total = trans;                        // 处理下一本书
              }
          }
          print(std::cout, total) << std::endl; // 输出最后一条交易
      }
      else // 如果没有输入
      {
          std::cerr << "No data?" << std::endl; // 通知用户
      }
      return 0;
  }
  ```

##### **访问控制与封装**

- **public 和 private**

  > 1、对目前为止，我们已经为类**定义了接口**，但没有任何机制**强制用户使用这些接口**。我们的类**还没有封装**，也就是说，用户可以**直达**`Sales_data`**对象内部**并**控制它的具体细节**  
  > 2、C++中，我们使用**访问说明符**来加强类的**封装性**，如下说明。我们可以使用这些说明符再次定义`Sales_data`类，如后示例程序  
  > 3、`public`**说明符**：定义在`publib`后的成员**可以在整个程序内被访问**，`public`成员**定义类的接口**  
  > 4、`private`**说明符**：定义在`private`后的成员**只可以被类的成员函数访问**，不能被使用该类的代码访问，`private`部分封装了**类的实现细节**  
  > 5、通常**构造函数**和**部分成员函数**跟在`public`后，而**数据成员**和**作为实现部分的函数**跟在`private`后  
  > 6、一个类可以包含**任意数量**的**访问说明符**，每个**访问说明符**指定了接下来的**成员访问级别**，其**有效范围**直到出现**下一个访问说明符**或**类的结尾**

  ```cpp
  class Sales_data
  {
      public:
          Sales_data() = default;
          Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n)
          {
          }
          Sales_data(const std::string &s) : bookNo(s)
          {
          }
          Sales_data(std::istream &);

          std::string isbn() const
          {
              return bookNo;
          }
          Sales_data &combine(const Sales_data &);

      private:
          double avg_price() const
          {
              return units_sold ? revenue / units_sold : 0;
          }
          unsigned units_sold = 0;
          std::string bookNo;
          double revenue = 0.0;
  };
  ```

- **class 和 struct**

  > 1、上例我们使用了`class`而非`struct`**定义类**，这种变化只是**形式上有所不同**，可以**任意选择**。**唯一区别**是它们的**默认访问权限不一样**  
  > 2、类可以在它**第一个访问说明符前**定义成员，这种成员的**访问权限**依赖于**类定义的方式**  
  > 3、使用`struct`则这种成员**默认是**`public`的，而`class`这种成员**默认是**`private`的

- **友元**

  > 1、既然`Sales_data`的**数据成员**是`private`的，那么我们的`add`、`print`、`add`函数就**无法正常编译**了。这是因为这几个函数虽然**是类接口的一部分**，但**不是类的成员**  
  > 2、类可以允许**其他类或函数**访问它的**非公有成员**，方法是令它们成为该类的**友元**。对于函数，只需要增加一条`friend`**关键字**开头的**函数声明**即可  
  > 3、**友元声明**只能出现在**类定义内部**，但友元**不是类的成员**也**不受访问控制的约束**  
  > 4、**友元声明**仅仅指定了**访问权限**，而非一个通常意义上的**函数声明**。如果我们希望**类的用户**能够调用某个**友元函数**，就必须在**友元声明外**再次专门进行一次**函数声明**

  ```cpp
  friend Sales_data add(const Sales_data &, const Sales_data &);
  friend std::istream &read(std::istream &, Sales_data &);
  friend std::ostream &print(std::ostream &, const Sales_data &);
  ```

##### **类的其他特性**

- **类成员再探**

  - 为了展示这些新特性，我们需要定义**一对相互关联的类**：`Screen`和`Window_mgr`

  - **定义类型成员**

    > 1、假设`Screen`表示显示器中的**一个窗口**，该类中包含一个用于**保存内容**的`string`成员和分别用于表示**光标位置**、**屏幕的高和宽**的`string::size_type`成员  
    > 2、除了定义**数据和函数成员**外，类还可以**自定义某种类型**在类中的**别名**。这种**类型别名**与其他成员一样存在**访问限制**，可以是`public`或`private`的一种  
    > 3、如下我们在`public`部分定义了`pos`**别名**，这样用户就可以使用这个名字。`Screen`的用户不应该知道该类使用`string`**对象**来**存放数据**，因此通过把`pos`定义成`public`可以**隐藏**`Screen`的**实现细节**

    ```cpp
    class Screen
    {
        public:
            typedef std::string::size_type pos;

        private:
            pos cursor = 0;
            pos height = 0, width = 0;
            std::string contents;
    };
    ```

  - `Screen`**类的成员函数**

    ```cpp
    class Screen
    {
        public:
            typedef std::string::size_type pos;
            Screen() = default; // 默认构造函数
            Screen(pos ht, pos wd, char c)
                : height(ht), width(wd), contents(ht * wd, c) // 构造函数，cursor 会被类内初始值初始化为 0
            {
            }
            char get() const // 读取光标处的字符
            {
                return contents[cursor]; // 隐式内联
            }
            // 重载成员函数 get
            inline char get(pos ht, pos wd) const; // 显式内联
            Screen &move(pos r, pos c);            // 能在之后被设置为内联

        private:
            pos cursor = 0;
            pos height = 0, width = 0;
            std::string contents;
    };

    // 在类内声明为 inline
    char Screen::get(pos r, pos c) const
    {
        pos row = r * width;      // 计算行的位置
        return contents[row + c]; // 返回给定列的字符
    }
    // 在定义处指定 inline
    inline Screen &Screen::move(pos r, pos c)
    {
        pos row = r * width; // 计算行的位置
        cursor = row + c;    // 在行内将光标移动到指定列
        return *this;        // 以左值形式返回对象
    }
    ```

  - `mutable`**可变数据成员**

    > 1、有时我们希望能**修改类的某个数据成员**，即使是在一个`const`**成员函数**里，对此可以通过在**变量的声明**中加入`mutable`**关键字**声明一个**可变数据成员**  
    > 2、一个**可变数据成员**永远不会是`const`，即使它是`const`**对象的成员**。因此，一个`const`**成员函数**可以改变一个可变成员的值  
    > 3、例如，我们将给`Screen`添加一个**access_ctr 可变成员**，以跟纵成员函数被调用了多少次，如下例。尽管`some_member`是一个`const`**成员函数**，但依然可以改变**access_ctr**的值

    ```cpp
    public:
        void some_member() const
        {
            ++access_ctr; // 保存一个计数值，用于记录成员函数被调用的次数
        }

    private:
        mutable size_t access_ctr; // 即使在一个 const 对象内也能被修改
    ```

  - **类数据成员的初始值**

    > 1、定义好`Screen`后，我们将继续定义一个**窗口管理类**并用它来表示显示器上的**一组**`Screen`。这个类将包含一个`Screen`**类型的**`vector`，**每个元素**表示一个特定的`Screen`  
    > 2、默认情况下，我们希望`Window_mgr`类开始时总是**拥有一个默认初始化的**`Screen`。C++11 中，最好的办法是把这个**默认值**声明成一个**类内初始值**，由`Screen`的**构造函数初始化**

    ```cpp
    class Window_mgr
    {
        private:
            // 默认情况下，一个 Window_mgr 包含一个标准尺寸的空白 Screen，通过类内初始值和 Screen 的构造函数实现
            std::vector<Screen> screens{Screen(24, 80, ' ')};
    };
    ```

- **返回 \*this 的成员函数**

  - **继续改进**

    ```cpp
    class Screen
    {
        public:
            // 添加两个新的成员函数
            Screen &set(char);
            Screen &set(pos, pos, char);
    };

    inline Screen &Screen::set(char c)
    {
        contents[cursor] = c; // 设置当前光标所在位置的新值
        return *this;         // 将 this 作为左值返回
    }
    inline Screen &Screen::set(pos r, pos col, char ch)
    {
        contents[r * width + col] = ch; // 设置给定位置的新值
        return *this;                   // 将 this 作为左值返回
    }
    ```

  - **返回**`*this`**的意义**

    > 1、和`move`操作一样，`set`的**返回值**也是**调用**`set`**对象的引用**，意味着这些函数**返回的是对象本身**而不是**对象的副本**  
    > 2、如果我们把**一系列操作**连在**一条表达式**：`myScreen.move(4,0).set('#');`，这些操作将会**在同一个对象上执行**  
    > 3、更直观的，我们将这条**语句的含义拆解**，如下：

    ```cpp
    // 如果返回 Screen &，其等价于：
    myScreen.move(4,0);
    myScreen.set('#');

    // 如果返回 Screen，其等价于：
    Screen temp = myScreen.move(4,0);     // 对返回值进行拷贝
    temp.set('#');                        // 不会改变 myScreen 的 contents
    ```

  - **从**`const`**成员函数返回**`*this`

    > 1、下面我们要添加一个`display`**操作**，负责**打印**`Screen`**的内容**。我们希望这个函数能和`move`、`set`**出现在同一序列**，因此该函数也应该**返回它的对象的引用**  
    > 2、从逻辑上说，**显示**并不需要**改变对象内容**，因此我们令`display`是一个`const`成员。此时`this`将是一个**指向**`const`**的指针**，而`*this`就是`const`**对象**  
    > 3、由此推断，`display`的**返回类型**是`const Screen&`。然而，如果真的**返回一个**`const`**的引用**，那我们就**不能**将其**嵌入到一组动作的序列**里(如后示例)  
    > 4、即使**myScreen**是个**非常量对象**，对`set`的调用也**不能通过编译**。问题在于`display`的`const`版本返回了**常量引用**，我们无权`set`一个**常量对象**

    ```cpp
    Screen myScreen;
    // 如果 display 返回常量引用，set 将无权更改常量对象的数据，因而报错
    myScreen.display(cout).set('*');
    ```

  - **基于**`const`**的重载**

    > 1、通过区分**成员函数**是否是`const`的，我们可以对其**进行重载**，其原因主要如下  
    > 2、首先，**非常量版本**的函数对于**常量对象**是不可用的，所以我们只能在**常量对象**上调用`const`**成员函数**。其次，虽然可以在**非常量对象**上使用**常量版本**的函数，但显然此时**非常量版本**是一个**更好的匹配**  
    > 3、如下例，我们将声明一个`do_display`**私有成员**，用于负责打印。**所有的**`display`**操作**都将**调用这个函数**，然后**返回自己的类型的对象**  
    > 4、当`do_display`执行完成后，这**非常量版本**的`display`函数**返回普通引用**，而**常量版本**的`display`函数**返回常量引用**

    ```cpp
    class Screen
    {
        public:
            // 普通版本 display
            Screen &display(std::ostream &os)
            {
                do_display(os);
                return *this;
            }
            // const 版本 display
            const Screen &display(std::ostream &os) const
            {
                do_display(os);
                return *this;
            }

        private:
            void do_display(std::ostream &os) const
            {
                os << contents;
            }
    };
    ```

- **完整的 Screen 类**

  ```cpp
  #include <iostream>
  #include <string>
  #include <vector>

  class Screen
  {
      public:
          typedef std::string::size_type pos;

          Screen() = default; // 默认构造函数
          Screen(pos ht, pos wd, char c)
              : height(ht), width(wd), contents(ht * wd, c) // 构造函数，cursor 会被类内初始值初始化为 0
          {
          }

          char get() const // 读取光标处的字符
          {
              return contents[cursor]; // 隐式内联
          }
          inline char get(pos ht, pos wd) const; // 显式内联
          Screen &move(pos r, pos c);            // 能在之后被设置为内联

          void some_member() const
          {
              ++access_ctr; // 保存一个计数值，用于记录成员函数被调用的次数
          }

          Screen &set(char);
          Screen &set(pos, pos, char);

          // 普通版本 display
          Screen &display(std::ostream &os)
          {
              do_display(os);
              return *this;
          }
          // const 版本 display
          const Screen &display(std::ostream &os) const
          {
              do_display(os);
              return *this;
          }

      private:
          mutable size_t access_ctr; // 即使在一个 const 对象内也能被修改
          pos cursor = 0;
          pos height = 0, width = 0;
          std::string contents;

          void do_display(std::ostream &os) const
          {
              os << contents;
          }
  };

  // 在类内声明为 inline
  char Screen::get(pos r, pos c) const
  {
      pos row = r * width;      // 计算行的位置
      return contents[row + c]; // 返回给定列的字符
  }
  // 在定义处指定 inline
  inline Screen &Screen::move(pos r, pos c)
  {
      pos row = r * width; // 计算行的位置
      cursor = row + c;    // 在行内将光标移动到指定列
      return *this;        // 以左值形式返回对象
  }

  inline Screen &Screen::set(char c)
  {
      contents[cursor] = c; // 设置当前光标所在位置的新值
      return *this;         // 将 this 作为左值返回
  }
  inline Screen &Screen::set(pos r, pos col, char ch)
  {
      contents[r * width + col] = ch; // 设置给定位置的新值
      return *this;                   // 将 this 作为左值返回
  }
  ```

- **友元再探**

  - 先前我们的`Sales_data`类把三个普通的**非成员函数**定义成了**友元**，类还可以把**其他的类**定义成**友元**，还可以把**其他类的成员函数**定义成**友元**

  - **类之间的友元关系**

    > 1、假设我们的`Window_mgr`类的**某些成员**可能需要访问它管理的`Screen`类的**内部数据**。例如我们需要为`Window_mgr`添加一个**clear 成员**，用于把指定的`Screen`**内容设为空白**  
    > 2、此时**clear**需要访问`Screen`的**私有成员**，而要使这种**访问合法**，`Screen`需要把`Window_mgr`指定成它的**友元**  
    > 3、如果一个类指定了**友元类**，则**友元类**的**成员函数**可以访问此类包括**私有成员在内**的**所有成员**  
    > 4、需要注意的是，**友元关系不存在传递性**。即如果`Window_mgr`有它自己的友元，这些友元**不能理所当然地访问**`Screen`

    ```cpp
    class Screen
    {
        friend class Window_mgr;
        // 此处省略先前的类对象
    };

    class Window_mgr
    {
        public:
            // 窗口中每个屏幕的编号
            using ScreenIndex = std::vector<Screen>::size_type;
            // 按照编号将指定的 Screen 重置为空白
            void clear(ScreenIndex i)
            {
                // s 是一个 Screen 的引用，指向我们想清空的屏幕
                Screen &s = screens[i];
                s.contents = std::string(s.height * s.width, ' ');
            }

        private:
            std::vector<Screen> screens{Screen(24, 80, ' ')};
    };
    ```

  - **令函数成员作为友元**

    > 1、除了令**整个类**作为**友元**外，还可以**只为 clear 提供访问权限**。当把一个成员**函数声明**称友元时，必须**明确指出**成员函数**属于哪个类**  
    > 2、但要想令某个**成员函数**作为**友元**，必须要按照如下方式设计程序：  
    > 3、首先定义`Window_mgr`类，其中声明**clear**函数，但**不能定义**它。在**clear**使用`Screen`成员之前必须**先声明**`Screen`；接下来定义`Screen`，包含对于**clear**的友元声明；最后定义**clear**，此时它才可以使用`Screen`成员

    ```cpp
    class Screen
    {
        friend void Window_mgr::clear(ScreenIndex);
    }
    ```

  - **友元函数重载和作用域**

    > 1、尽管**重载函数**的名字相同，但它们仍是**不同的函数**。因此如果一个类想把**一组重载函数声明**成**友元**，则需要对每一个函数**分别声明**  
    > 2、**类**和**非成员函数**的**声明**不是必须在它们的**友元声明之前**，当一个名字**第一个出现**在一个**友元声明**中，我们**隐式假定该名字在当前作用域中可见**，然而友元本身不一定真的声明在当前作用域。甚至就算在**类内定义该函数**，我们也必须在**类外提供相应的声明**，从而使得**函数可见**  
    > 3、重点在于理解**友元声明本身的作用**是**影响访问权限**，而不是**普通意义上的声明**

    ```cpp
    struct X
    {
        // 友元函数可以定义在类内，但不是真正的定义
        friend void f();
        X()
        {
          f();      // 调用 f() 函数，错误：f 还没有被声明
        }
        void g();
        void h();
    };

    void X::g()
    {
        return f(); // 调用 f() 函数，错误：f 还没有被声明
    }
    void f();       // 声明定义在 X 中的函数 f，从此时 f 才被真正声明可用
    void X::h()
    {
        return f(); // 正确：现在 f 的声明在作用域中了
    }
    ```

##### **类的作用域**

- **类的作用域**

  - **引入**

    > 1、每个类都会定义**它自己的作用域**。在**类的作用域外**，**普通数据**和**函数成员**只能由对象、引用、指针使用**成员访问运算符**来访问；对于**类类型成员**则使用**作用域运算符**来访问  
    > 2、不论哪种情况，跟在**运算符后的名字**都必须是**对应类的成员**

    ```cpp
    Screen::pos ht = 24, wd = 80;   // 使用 Screen 定义的 pos 类型
    Screen scr(ht, wd, ' ');
    Screen *p = &scr;
    char c = scr.get();             // 访问 scr 对象的 get 成员
    c = p -> get();                 // 访问 p 所指向的 scr 的 get 成员
    ```

  - **作用域和定义在类外的成员**

    > 1、一个**类**就是一个**作用域**很好的说明了为什么我们在**类外定义成员函数**时需要提供`类名::函数名`。在类外，**成员的名字被隐藏了**  
    > 2、一旦遇到了**类名**，定义的**剩余部分**就在**类的作用域内**了，这里的剩余部分包括**参数列表**和**函数体**，因而我们可以**直接使用类的其他成员**而无须再次授权  
    > 3、`Window_mgr`类的**clear 成员**用到了**该类中定义的**`ScreenIndex`**类型**：`void Window_mgr::clear(ScreenIndex i);`。这里使用`ScreenIndex`时已经在**该类的作用域下**(因为在`Window_mgr::`后)，所以**不需要额外说明**  
    > 4、有时由于**返回类型**出现在**类名前**，此时想要使用`ScreenIndex`作为**返回类型**，必须明确**指定哪个类定义了它**，如下

    ```cpp
    // 作用域::返回类型 类名::函数名(形参列表)
    window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s)
    ```

- **名字查找与类作用域**

  - **用于类成员声明的名字查找**

    ```cpp
    typedef double Money;
    std::string bal;

    class Account
    {
        public:
            Money balance()
            {
                return bal;
            }

        private:
            Money bal;
    };
    ```

    > 1、**编译器**看到`balance`函数的声明语句时，将先在`Account`**类内查找 Money 的声明**，没找到就到**类外的作用域**去查找，找到**Money**的`typedef`语句  
    > 2、`balance`函数体由于在**整个类可见后**才被处理，因此其`return`语句返回**名为 bal 的成员**而不是外层的`string`对象

  - **类型名要特殊处理**

    ```cpp
    typedef double Money;

    class Account
    {
        public:
            Money balance()
            {
                return bal;             // 已经使用了外层作用域的 Money
            }

        private:
            typedef double Money;       // 错误：不能重新定义 Money
            Money bal;
    };
    ```

    > 1、一般来说，**内层作用域**可以重新定义**外层作用域**的名字，即使该名字已经在**内层作用域**中使用过  
    > 2、然而**在类中**，如果**成员使用了外层作用域中的名字**，而该名字**代表一种类型**，则类**不能在之后重新定义**该名字  
    > 3、尽管**重新定义类型名字**是一种错误的行为，但是**编译器并不为此负责**，一些编译器将顺利通过这样的代码

  - **成员定义中的普通块作用域的名字查找**

    ```cpp
    int height; // 定义了一个名字，稍后将在 Screen 中使用

    class Screen
    {
        public:
            typedef std::string::size_type pos;
            void dummy_fcn(pos height)
            {
                cursor = width * height; // 使用的是函数的形参 height
            }

        private:
            pos cursor = 0;
            pos height = 0, width = 0;
    };
    ```

    > 1、该例中，**编译器**处理函数中的**乘法表达式**时，它首先在**函数作用域**内查找名字，即先查找**形参列表**的**同名形参**。因此该例使用的是**形参 height**而非**成员 height**或**全局 height**  
    > 2、如果要在这种情况下单独使用**其他作用域的名字**，可以使用`::height`调用**全局 height**，使用`this -> height`或`Screen::height`调用**成员 height**

##### **构造函数再探**

- **委托构造函数**

  > 1、C++11 新标准拓展了**构造函数初始值**的功能，使得我们可以定义所谓的**委托构造函数**。一个**委托构造函数**，使用它**所属类的其他构造函数**执行它自己的初始化过程  
  > 2、和其他构造函数一样，一个**委托构造函数**也有一个**成员初始值列表**和一个**函数体**。与其他成员初始值一样，**类名后面**紧跟圆括号括起来的**参数列表**，**列表必须与类中另一个构造函数匹配**

  ```cpp
  class Sales_data
  {
      public:
          // 非委托构造函数使用对应的实参初始化成员
          Sales_data(std::string s, unsigned ct, double price) : bookNo(s), units_sold(ct), revenue(ct * price)
          {
          }
          // 其余构造函数全部委托给另一个构造函数
          Sales_data() : Sales_data("", 0, 0)
          {
          }
          Sales_data(std::string s) : Sales_data(s, 0, 0)
          {
          }
          Sales_data(std::istream &is) : Sales_data()
          {
              read(is, *this); // 之前上文类中定义过的函数
          }

      private:
          std::string bookNo;
          unsigned units_sold = 0;
          double revenue = 0.0;
  };
  ```

- **隐式类类型转换**

  - **介绍**

    > 1、在类中，如果**构造函数**只接受**一个实参**，则它实际上定义了**转换为此类类型**的**隐式转换机制**，有时我们把这种构造函数称为**转换构造函数**  
    > 2、在先前的`Sales_data`类中，接受`string`的和接受`istream`的**构造函数**分别定义了**这两种类型向**`Sales_data`**隐式转换**的规则。也就是说，在需要使用`Sales_data`的地方，可以使用`string`或`istream`**代替**  
    > 3、如下例，我们用一个`string`**实参**调用了`combine`**成员函数**。该调用合法，**编译器**用给定的`string`自动创建了一个**临时**`Sales_data`**对象**，这个新生成的**临时对象**被传递给了`combine`

    ```cpp
    std::string null_book = "9-999-99999-9";
    // 构造一个临时的 Sales_data 对象，该对象的 units_sold 和 revenue 都为 0，bookNo 等于 null_book
    item.combine(null_book);
    ```

  - **只允许一步类类型转换**

    > 1、**编译器**只会自动地**执行一步类型转换**，因此下面代码隐式使用了**两种转换规则**是错误的  
    > 2、如果我们想完成上述调用，可以主动进行一步**显式转换**，如后例

    ```cpp
    // 错误：需要用户定义的两种转换，但编译器只转换一次
    // 1 把 字符串字面量 转换成 string
    // 2 把 string 转换成 Sales_data
    item.combine("9-999-99999-9");
    ```

    ```cpp
    // 正确：显式转换成 string，隐式转换成 Sales_data
    item.combine(string("9-999-99999-9"));
    // 正确：隐式转换成 string，显式转换成 Sales_data
    item.combine(Sales_data("9-999-99999-9"));
    ```

  - `explicit`**抑制构造函数隐式转换**

    > 1、我们可以通过将只有一个实参的**构造函数**声明为`explicit`来**阻止隐式转换**(多个实参的构造函数不能用于执行隐式转换，所以无须指定)，此时将**不能通过**指定了`explicit`的**构造函数**来**隐式创建类对象**  
    > 2、**只能在类内声明构造函数时**使用`explicit`，在类外定义时不应重复  
    > 3、`explicit`**构造函数**只能用于**直接初始化**，当我们执行**拷贝初始化**(`=`)不能使用`explicit`构造函数

    ```cpp
    class Sales_data
    {
        public:
            explicit Sales_data(std::istream&): bookNo(s)
            {
            }
    };
    // 错误：类外定义时不要重复使用 explicit
    explicit Sales_data::Sales_data(std::istream &is)
    {
        read(is, *this);
    }
    // 错误：不能使用拷贝初始化
    Sales_data item = null_book;
    ```

- **聚合类**

  > 1、**聚合类**使得用户可以**直接访问其成员**，当一个类满足**如下条件**时，我们说它是**聚合**的：  
  > 2、**所有成员**都是`public`的；没有定义任何**构造函数**；没有**类内初始值**；没有**基类**，也没有`virtual`**函数**(这部分后续介绍)  
  > 3、我们可以提供一个**花括号括起来**的**成员初始值列表**来初始化聚合类的**数据成员**，顺序必须与声明的顺序一致

- **字面值常量类**

  - **介绍**

    > 1、之前我们提到过`constexpr`**函数**的**参数**和**返回值**都必须是**字面值类型**。除了算数类型、引用、指针外，**某些类也是字面值类型**  
    > 2、和其他类不同，这样的类可能含有`constexpr`**构造函数**，这样的成员必须**符合**`constexpr`**函数的所有要求**，它们是**隐式**`const`的  
    > 3、**数据成员都是字面值类型**的**聚合类**都是**字面值常量类**，此外，如果一个类满足**以下要求**，也是一个**字面值常量类**：  
    > 4、**数据成员**都必须是**字面值类型**；类必须包含**至少一个**`constexpr`**函数**；数据成员的**类内初始值**必须是**常量表达式**，如果成员属于某种类类型，**初始值**必须使用成员自己的`constexpr`**构造函数**；类必须使用**析构函数**的**默认定义**，该成员负责销毁类的对象

  - `constexpr`**构造函数**

    > 1、`constexpr`**构造函数**可以声明成`=default`。否则，该函数就必须既满足**构造函数的要求**(不包含返回语句)，又满足`constexpr`**函数的要求**(唯一可执行的语句就是返回语句)  
    > 2、综合这两点，`constexpr`**构造函数体**一般来说是**空的**  
    > 3、`constexpr`**构造函数**必须**初始化所有数据成员**，**初始值**要么使用`constexpr`**构造函数**，要么是**一条常量表达式**

    ```cpp
    class Debug
    {
        public:
            constexpr Debug(bool b = true) : hw(b), io(b), other(b)
            {
            }
            constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(o)
            {
            }
            constexpr bool any()
            {
                return hw || io || other;
            }

        private:
            bool hw;
            bool io;
            bool other;
    };
    ```

##### **类的静态成员**

- **引入**

  > 1、有的时候类需要它的**一些成员**与**类本身**直接相关，而不是与类的**各个对象**保持关联  
  > 2、例如，一个**银行账户类**可能需要一个**数据成员**来表示当前的**基准利率**，我们希望**利率与类关联**，没必要**每个对象**都**存储利率信息**  
  > 3、一旦利率浮动，我们希望**所有的对象**都能**使用新值**

- **声明静态成员**

  > 1、我们通过在**成员的声明前**加上关键字`static`使其**与类关联在一起**。下例为我们模拟实现的银行账户类  
  > 2、**静态成员**存在于任何对象之外，对象中**不包含**任何**与数据成员有关**的数据  
  > 3、**静态成员函数**也**不与任何对象绑定**在一起，它们**不包含**`this`**指针**，且静态成员函数**不能声明成**`const`

  ```cpp
  class Account
  {
      public:
          void calculate()
          {
              amount += amount * interesRate;
          }
          static double rate()
          {
              return interesRate;
          }
          static void rate(double);

      private:
          std::string owner;
          double amount;
          static double interesRate;
          static double initRate();
  };
  ```

- **使用静态成员**

  ```cpp
  // 使用作用域运算符直接访问静态成员
  double r;
  r = Account::rate();

  // 使用类的对象、引用或指针来访问静态成员
  Account ac1;
  Account *ac2 = &ac1;
  r = ac1.rate();
  r = ac2 -> rate();

  // 成员函数不通过作用域运算符就能直接使用静态成员
  class Account
  {
      public:
          void calculate()
          {
              ammout += amount * interestRate;    // 直接使用
          }
      private:
          static double interestRate;
  };
  ```

- **定义静态成员**

  > 1、和其他**成员函数**一样，我们在**类内和类外**都可以定义**静态成员函数**。当在**类外定义时**，不要重复`static`关键字  
  > 2、因为**静态数据成员**不属于类的任何一个对象，所以它们并不是在**创建类的时候**被定义的，这意味着它们**不是由构造函数初始化的**  
  > 3、我们**不能在类内初始化静态成员**，相反，我们必须**在类外定义和初始化**每个静态成员

  ```cpp
  // 类外定义静态成员函数
  void Account::rate(double newRate)
  {
      interestRate = newRate;
  }

  // 定义并初始化一个静态成员
  double Account::interestRate = initRate();
  ```

- **静态成员的类内初始化**

  > 1、通常情况下，类的**静态成员**不应该在类内初始化  
  > 2、然而，我们可以为**静态成员**提供`const`**整型**的**类内初始值**，不过要求**静态成员**必须是**字面值常量类型**的`constexpr`  
  > 3、如果在**类内提供了一个初始值**，则静态成员的定义**不能再指定一个初始值**

  ```cpp
  class Account
  {
      public:
          static double rate()
          {
              return interestRate;
          }
          static void rate(double);

      private:
          static constexpr int period = 30; // period 是常量表达式
          double daily_tbl[period];
  };
  ```

- **静态成员与普通成员的区别**

  > 1、**静态成员**能用于**某些场景**，而**普通成员不能**。静态成员**独立于任何对象**，因此，在某些**普通成员可能非法**的场合，**静态成员**可以**正常使用**。比如**静态数据成员**可以是**不完全类型**(后续介绍)  
  > 2、特别的，**静态数据成员的类型**可以是它**所属的类类型**，而**普通成员**只能声明成它**所属类的指针或引用**  
  > 3、此外，我们可以使用**静态成员**作为**默认实参**，而**普通成员不能**，这是因为**普通成员的值**本身**属于对象的一部分**

---

#### **IO 库**

---

<div class="success">

> **章节概要**：`IO`类；`IO`库类型；`IO`类型间的关系；`IO`对象；无拷贝或赋值；条件状态；查询流的状态；管理条件状态；管理输出缓冲；缓冲刷新的原因；刷新输出缓冲区；`unitbuf`操作符；`tie`关联输入和输出流；文件输入输出；`fstream`操作；`fstream`对象；`open`和`close`；文件模式；指定文件模式的限制；阻止丢弃已有数据；`string`流；`stringstream`操作；使用`istringstream`；使用`ostringstream`

</div>

##### **IO 类**

- **IO 库类型**

  > 1、目前为止，我们已使用过的`IO`**类型和对象**都是操纵**char**数据的。但现实场景下，我们不能限制**实际应用程序**仅从**控制台窗口**进行**IO 操作**  
  > 2、**应用程序**常常需要**读写命名文件**，而且使用`IO`**操作**处理`string`中的字符很方便。此外，还可能读写**需要宽字符支持的语言**  
  > 3、为了支持这些不同种类的**IO 操作**，在`istream`和`ostream`之外，**标准库**还定义了其他一些`IO`**库类型**，下表列出其中部分  
  > 4、`iostream`定义了用于**读写流的基本类型**；`fstream`定义了**读写命名文件的类型**；`sstream`定义了**读写内存**`string`**对象的类型**  
  > 5、为了支持**使用宽字符的语言**，标准库定义了一组类型和对象来**操纵**`wchat_t`**类型数据**。宽字符版本的**类型和函数名**以`w`开头，如`wcin`、`wcout`、`wcerr`等

  | 头文件   | 类型                          | 描述               |
  | -------- | ----------------------------- | ------------------ |
  | iostream | istream，wistream             | 从流中读取数据     |
  | iostream | ostream，wostream             | 向流中写入数据     |
  | iostream | iostream，wiostream           | 读写流             |
  | fstream  | ifstream，wifstream           | 从文件读取数据     |
  | fstream  | ofstream，wofstream           | 向文件写入数据     |
  | fstream  | fstream，wfstream             | 读写文件           |
  | sstream  | istringstream，wistringstream | 从`string`读取数据 |
  | sstream  | ostringstream，wostringstream | 向`string`写入数据 |
  | sstream  | stringstream，wstringstream   | 读写`string`       |

- **IO 类型间的关系**

  > 1、概念上，**设备类型**和**字符大小**都不会影响我们要执行的**IO 操作**。比如我们可以使用`>>`**读取数据**，却**不必管**是从控制台，磁盘文件，或是`string`中读取；也**不必管**读取的字符能存入一个**char 对象**内，还是需要一个`wchar_t`**对象**  
  > 2、**标准库**使我们能**忽略**这些**不同类型流之间的差异**，是通过**继承机制**实现的。我们可以使用**具有继承关系的类**，而不必了解**继承机制如何工作**的细节  
  > 3、简单地说，**继承机制**使我们可以声明一个**特定的类**继承自**另一个类**。我们通常可以将一个**派生类对象**(继承类对象)当做其**基类对象**(被继承的类对象)来使用  
  > 4、比如，`ifstream`和`istringstream`都**继承自**`istream`。因此，我们可以像**使用**`istream`**对象**那样，**使用**`ifstream`和`istringstream`**对象**。这意味着，我们如何使用`cin`的，就可以**同样使用这些类型的对象**

- **IO 对象**

  - **无拷贝或赋值**

    > 1、我们**不能拷贝**或**对**`IO`**对象赋值**  
    > 2、由于**不能拷贝**，因此我们不能将**形参**或**返回类型**设置为**流类型**。进行**IO 操作**的**函数**通常**以引用的方式传递和返回流**  
    > 3、由于**读写一个 IO 对象**会**改变其状态**，所以**传递和返回的引用**也不能是`const`的

    ```cpp
    #include <fstream>

    std::ofstream out1, out2;
    out1 = out2;                          // 错误：不能对流对象赋值
    std::ofstream print(std::ofstream);   // 错误：不能初始化 ofstream 参数
    out2 = print(out2);                   // 错误：不能拷贝流对象
    ```

  - **条件状态**

    > 1、**IO 操作**一个与生俱来的问题是**可能发生错误**。一些错误是**可恢复的**，而其他错误**可能发生在系统深处**，已经超出了应用程序**可修正的范围**  
    > 2、下表列出了`IO`**类**所定义的一些**函数和标志**，可以帮助我们**访问和操纵**流的**条件状态**

    | 函数和标志       | 描述                                                                                              |
    | ---------------- | ------------------------------------------------------------------------------------------------- |
    | strm::iostate    | 是一种机器相关的类型，提供了表达条件状态的完整功能                                                |
    | strm::badbit     | 用来指出流已崩溃                                                                                  |
    | strm::failbit    | 用来指出一个 IO 操作失败了                                                                        |
    | strm::eofbit     | 用来指出流到达了文件结束                                                                          |
    | strm::goodbit    | 用来指出流未处于错误状态，此值保证为 0                                                            |
    | s.eof()          | 若流 s 的 eofbit 置位，则返回 true                                                                |
    | s.fail()         | 若流 s 的 failbit 或 badbit 置位，则返回 true                                                     |
    | s.bad()          | 如流 s 的 badbit 置位，则返回 true                                                                |
    | s.good()         | 若流 s 处于有效状态，则返回 true                                                                  |
    | s.clear()        | 将流 s 中所有条件状态位复位，将流的状态设置为有效，返回 void                                      |
    | s.clear(flag)    | 根据给定的 flag 标志位，将流 s 中对应条件状态位复位，其中 flag 的类型为`strm::iostate`，返回 void |
    | s.setstate(flag) | 根据给定的 flag 标志位，将流 s 中对应条件状态位置位，其中 flag 的类型为`strm::iostate`，返回 void |
    | s.rdstate()      | 返回流 s 的当前条件状态，返回值类型为`strm::iostate`                                              |

  - **查询流的状态**

    > 1、`IO`**库**定义了**与机器无关的**`iostate`**类型**，它提供了**表达流状态的完整功能**，该类型应作为一个**位集合**来使用  
    > 2、该类型包含如上表中的**四个**`constexpr`**值**，这些值用来表示**特定类型的 IO 条件**，可以与**位运算符**一起使用来**一次性检测或设置多个标志位**  
    > 3、`badbit`表示**系统级错误**，如不可恢复的读写操作，通常如果`badbit`**被置位**，流就**无法再使用**了；`failbit`在发生**可恢复错误**后**被置位**，如读取类型不对应等错误，通常这种问题是可修正的，流**还可以继续使用**；如果到达**文件结束位置**，`eofbit`和`failbit`**都会被置位**；`goodbit`**值为 0**表示**流未发生错误**  
    > 4、同样，如上表所列，**标准库**还定义了一组函数来**查询标志位的状态**

  - **管理条件状态**

    > 1、如上表，**标准库**中还有一些用来**管理条件状态**的函数  
    > 2、**流对象的成员**`rdstate`返回一个`iostate`**值**，对应**当前流的状态**；`setstate`操作将给定的**条件位置位**，表示发生了对应错误；`clear`是一个**重载成员函数**，它分别有一个**不接受参数**的版本和**接受一个**`iostate`**参数**的版本，用于将**条件位复位**

    ```cpp
    auto old_state = cin.rdstate(); // 记住 cin 的当前状态
    cin.clear();                    // 复位，使 cin 有效
    process_input(cin);             // 使用 cin
    cin.setstate(old_state);        // 将 cin 置为原有状态
    ```

- **管理输出缓冲**

  - 每个**输出流**都管理一个**缓冲区**，用来保存**程序读写的数据**。如果需要**打印一串文本**，**文本串**可能会**立即打印**出来，也可能被操作系统**保存在缓冲区中**，之后**再打印**

  - **缓冲刷新的原因**

    > 1、程序**正常结束**，作为`main`函数的`return`**操作的一部分**，**缓冲刷新**被执行  
    > 2、**缓冲区满时**，需要**刷新缓冲**，而后新的数据才能继续写入缓冲区  
    > 3、我们可以使用**操纵符**(如`endl`)来**显式刷新缓冲区**  
    > 4、在每个**输出操作之后**，我们可以用**操纵符**`unitbuf`**设置流的内部状态**，来**清空缓冲区**。默认情况下，对`cerr`是设置`unitbuf`的，因此**写到**`cerr`**的内容**都是**立即刷新**的  
    > 5、一个**输出流**可能**被关联到另一个流**，这种情况下，当读写**被关联的流**时，**关联到的流**的**缓冲区会被刷新**。例如默认情况下，`cin`和`cerr`都关联到`cout`，因此，读`cin`或写`cerr`都会导致`cout`**的缓冲区被刷新**

  - **刷新输出缓冲区**

    > 1、我们已经使用过**操纵符**`endl`，它完成**换行并刷新缓冲区**的工作  
    > 2、`IO`**库**中还有两个**类似的操纵符**：`flush`和`ends`。其中`flush`**只刷新缓冲区**，不输出任何额外字符；`ends`向缓冲区**插入一个空字符**，然后**刷新缓冲区**

    ```cpp
    cout << "hi!" << endl;
    cout << "hi!" << flush;
    cout << "hi!" << ends;
    ```

  - `unitbuf`**操作符**

    > 1、如果想在接下来**每次输出操作后**都**刷新缓冲区**，我们可以使用`unitbuf`**操纵符**  
    > 2、它告诉**流**在接下来的**每次写操作之后**都**执行一次**`flush`**操作**  
    > 3、而使用`nounitbuf`可以**重置流**，使其恢复使用正常的**系统管理**的**缓冲区刷新机制**

    ```cpp
    cout << unitbuf;        // 此后所有输出操作后都会立即刷新缓冲区
    cout << nounitbuf;      // 此后回到正常的缓冲机制
    ```

  - `tie`**关联输入和输出流**

    > 1、当一个**输入流**被**关联到**一个**输出流**时，任何试图**从输入流读取数据**的操作将会导致**关联的输出流被刷新**  
    > 2、`tie`有**两个重载的版本**。**不带参数**的`tie`返回**指向输出流的指针**。如果本对象当前关联到一个**输出流**，则返回的就是**这个流的指针**；如果对象**未关联**到其他流，则返回**空指针**  
    > 3、接受一个**指向**`ostream`**的指针**作为**参数**的`tie`，**将自己关联到此**`ostream`。即`x.tie(&o)`返回**指向原输出流的指针**，并将**流**`x`关联到**新输出流**`o`  
    > 4、我们既可以将`istream`**关联到**`ostream`，也可以将`ostream`**关联到**`ostream`。**每个流**同时最多**关联到一个流**，但**多个流**可以同时关联到**同一个**`ostream`

    ```cpp
    cin.tie(&cout);                       // 将 cin 和 cout 关联在一起
    // old_tie 指向当前关联到 cin 的流(如果有的话)
    ostream *old_tie = cin.tie(nullptr);  // cin 不再与其他流关联
    // 将 cin 和 cerr 关联，这不是一个好主意，因为 cin 应该关联到 cout
    cin.tie(&cerr);                       // 读取 cin 会刷新 cerr 而不是 cout
    cin.tie(old_tie);                     // 重建 cin 和 cout 间的正常关联
    ```

##### **文件输入输出**

- `fstream`**操作**

  > 1、**头文件**`fstream`定义了**三个类型**来支持**文件 IO**：`ifstream`、`ofstream`、`fstream`，这些类型**提供的操作**与我们之前是用过的对象`cin`和`cout`**操作一样**  
  > 2、特别是，我们可以用`IO`**运算符**(流插入符`<<`和`>>`)来**读写文件**，可以用`getline`从一个`ifstream`**读取数据**  
  > 3、除了**继承自**`iostream`**类型**的行为外，`fstream`还增加了一些新成员来**管理与流关联的文件**，如下表

  | fstream 操作           | 描述                                                                                                                                                             |
  | ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | fstream fstrm          | 创建一个未绑定的文件流，此处的 fstream 是头文件 fstream 中定义的一个类型                                                                                         |
  | fstream fstrm(s)       | 创建一个 fstream，并打开名为 s 的文件。s 可以是 string 类型或指向字符数组形式字符串的指针。这些构造函数都是 explicit 的，默认文件模式 mode 依赖于 fstream 的类型 |
  | fstream fstrm(s, mode) | 与前一个构造函数类似，但按照指定模式 mode 打开文件                                                                                                               |
  | fstrm.open(s)          | 打开名为 s 的文件，并将文件与 fstrm 绑定，返回 void。默认文件模式 mode 依赖于 fstream 的类型                                                                     |
  | fstrm.close()          | 关闭与 fstrm 绑定的文件，返回 void                                                                                                                               |
  | fstrm.is_open()        | 返回一个 bool 值，指出与 fstrm 关联的文件是否成功打开且尚未关闭                                                                                                  |

- `fstream`**对象**

  - **创建对象**

    > 1、当我们想要**读写一个文件**时，可以定义一个**文件流对象**，并**将对象与文件关联起来**  
    > 2、每个文件流都定义了一个名为`open`的**成员函数**，它完成一些系统相关的操作，来**定位给定的文件**，并视情况打开为**读或写模式**  
    > 3、创建**文件流对象**时，可以**直接提供文件名**(可选)，如果直接提供了文件名，则`open`**会被自动调用**

    ```cpp
    ifstream in(ifile);         // 构造一个 ifstream 并打开 ifile 文件
    ofstream out;               // 输出文件流未关联到任何文件
    ```

  - **可以用**`fstream`**替代**`iostream&`

    > 1、之前提到过，在要求使用**基类类型对象**的地方，我们可以使用**继承类型对象**来**替代**  
    > 2、这意味着，接受一个`iostream`**类型引用或指针**的参数的函数，也可以用一个对应的`fstream`或`sstream`**类型**来**调用**

  - `open`**和**`close`

    > 1、如果我们定义了一个**空文件流对象**，可以随后**调用**`open`来**将它与文件关联**起来，如下示例  
    > 2、如果**调用**`open`**失败**，`failbit`将被置位。由于**调用可能失败**，所以使用类似`if(out)`的方式**进行检测**是好习惯  
    > 3、一旦一个**文件流已经打开**，它就会一直**保持关联**。如果对一个**已打开的文件流**调用`open`**会失败**，并会导致`failbit`被置位，随后试图**使用该文件流**的操作**都会失败**  
    > 4、为了**将文件流关联到另一个文件**，必须先`close`**关闭已关联的文件**，成功关闭后才可以**打开新的文件**。如果`open`成功，则`open`会**设置流的状态**，使得`good()`为**true**

    ```cpp
    ifstream in(ifile);         // 构造一个 ifstream 并打开 ifile 文件
    ofstream out;               // 输出文件流未关联到任何文件
    out.open(ifile + ".copy");  // 打开指定文件

    in.close();                 // 关闭文件
    in.open(ifile + "2");       // 打开另一个文件
    ```

- **文件模式**

  - **文件模式**

    > 1、每个流都有一个**关联的文件模式**，用来指出**如何使用文件**，如下表  
    > 2、无论用哪种方法打开文件(调用`open`或文件名初始化流等)，都可以**指定文件模式**  
    > 3、默认情况下，`ifstream`以`in`打开，`ofstream`以`out`打开，`fstream`以`in`和`out`打开

    | 文件模式 | 含义                               |
    | :------: | ---------------------------------- |
    |    in    | 只读(输入)模式                     |
    |   out    | 只写(输出)模式                     |
    |   app    | 只写，每次写操作前均定位到文件末尾 |
    |   ate    | 打开文件后立刻定位到文件末尾       |
    |  trunc   | 阶段文件                           |
    |  binary  | 二进制模式                         |

  - **指定文件模式的限制**

    > 1、只可以对`ofstream`或`fstream`设定`out`模式  
    > 2、只可以对`ifstream`或`fstream`设定`in`模式  
    > 3、只有当`out`**被设定时**才能设定`trunc`模式  
    > 4、只要`trunc`**没被设定**，就可以设定`app`模式  
    > 5、默认情况下，即使我们**没有设定**`trunc`，以`out`打开的文件**也会被阶段**。为了**保留以**`out`**打开的文件的内容**，我们必须**同时指定**`app`模式，这样只会将数据**追加到文件末尾**；或者**同时指定**`in`模式，即**打开文件同时进行读写操作**  
    > 6、`ate`和`binary`可用于**任何类型**的文件流对象，且可以与其他任何类型模式**组合使用**

  - **阻止丢弃已有数据**

    > 1、默认情况下，当我们**打开一个**`ofstream`时，**文件的内容会被丢弃**  
    > 2、**阻止清空**`ostream`**给定文件**的方式是**同时指定**`app`**模式**

    ```cpp
    // 下列语句中，file 都会被截断
    ofstream out1("file");
    ofstream out2("file", ofstream::out);
    ofstream out3("file", ofstream::out | ofstream::trunc);
    // 下列语句，通过 app 保留了文件内容
    ofstream app1("file", ofstream::app);
    ofstream app2("file", ofstream::out | ofstream::app);
    ```

##### **string 流**

- `stringstream`**操作**

  > 1、**头文件**`sstream`定义了**三个类型**来支持**内存 IO**：`istringstream`、`ostringstream`、`stringstream`  
  > 2、与`fstream`类似，`sstream`**定义的类型**也都**继承自**`iostream`  
  > 3、除了**继承**得来的操作，`sstream`还定义了一些成员来**管理与流相关联的**`string`，如下表

  | stringstream 操作 | 描述                                                                             |
  | ----------------- | -------------------------------------------------------------------------------- |
  | sstream strm      | 创建一个未绑定的 stringstream 对象，此处的 sstream 是头文件 sstream 中的一个类型 |
  | sstream strm(s)   | 创建一个 sstream，保存字符串 s 的一个拷贝。此构造函数是 explicit 的              |
  | strm.str()        | 返回 strm 保存的 string 的拷贝                                                   |
  | strm.str(s)       | 将字符串 s 拷贝到 strm 中，返回 void                                             |

- **使用**`istringstream`

  - 当我们的某些工作是**对整行文本进行处理**，而其他一些工作是**处理行内的单个单词**，通常可以使用`istringstream`(在理解上，可以认为该类型对象类似于一个单独的`string`输入缓冲区)

  - **示例**

    > 1、假定有一个文件，列出了一些人和他们的电话号码，某些人只有**一个号码**，另一些人有**多个号码**，文件中每条记录都**以人名开始**，后面跟随**一个或多个电话号码**，不同记录之间换行。通过程序实现这些内容的存储  
    > 2、我们在程序中使用一个`istringstream`**与读入的文本行绑定**，这样就可以在**该类型对象**上使用**输入运算符**`>>`来**读取每个元素**

    ```cpp
    #include <iostream>
    #include <sstream>
    #include <string>
    #include <vector>

    struct PersonInfo
    {
        public:
            std::string name;
            std::vector<std::string> phones;
    };

    int main()
    {
        std::string line, word;         // 分别保存来自输入的一行和单词
        std::vector<PersonInfo> people; // 保存来自输入的所有记录
        // 逐行从输入读取数据
        while (std::getline(std::cin, line))
        {
            PersonInfo info;                 // 创建一个保存此记录数据的对象
            std::istringstream record(line); // 将记录绑定到刚读入的行
            record >> info.name;             // 读取名字(到空格停止)
            while (record >> word)           // 读取电话号码(到空格停止并再次循环)
                info.phones.push_back(word); // 保持它们
            people.push_back(info);          // 将此记录追加到 people 末尾
        }
        return 0;
    }
    ```

- **使用**`ostringstream`

  - 当我们**逐步构造输出**，希望**最后一起打印**时，`ostringstream`是很有用的(在理解上，可以认为该类型对象类似于一个单独的`string`输出缓冲区)

  - **示例**

    > 1、假定对于`istringstream`的上例，我们想**逐个验证电话**再**改变其格式**输出，对于有无效号码的人，我们不会将其输出，而是打印一条包含**人名和无效号码**的**错误信息**。通过程序实现这些内容的格式化与转存  
    > 2、由于我们**不希望输出有无效号码的人**，因此对每个人，直到**验证完所有号码**才能进行输出。这种情况下，我们可以将输出内容先写入到一个`ostringstream`中更加方便

    ```cpp
    #include <iostream>
    #include <sstream>
    #include <string>
    #include <vector>

    struct PersonInfo
    {
        public:
            std::string name;
            std::vector<std::string> phones;
    };

    int main()
    {
        std::string line, word;         // 分别保存来自输入的一行和单词
        std::vector<PersonInfo> people; // 保存来自输入的所有记录
        // 逐行从输入读取数据
        while (std::getline(std::cin, line))
        {
            PersonInfo info;                 // 创建一个保存此记录数据的对象
            std::istringstream record(line); // 将记录绑定到刚读入的行
            record >> info.name;             // 读取名字
            while (record >> word)           // 读取电话号码
                info.phones.push_back(word); // 保持它们
            people.push_back(info);          // 将此记录追加到 people 末尾
        }

        // 假定已有两个函数：
        // valid() 完成电话号码验证；format() 完成格式化
        for (const auto &entry : people) // 对于 people 的每一项
        {
            std::ostringstream formatted, badNums; // 每个循环创建的对象
            for (const auto &nums : entry.phones)  // 对每个数
            {
                if (!valid(nums))                     // 如果无效
                    badNums << " " << nums;           // 将数的字符存入 badNums
                else                                  // 如果有效
                    formatted << " " << format(nums); // 进行格式化
            }
            if (badNums.str().empty()) // 如果没有错误的数，打印名字和格式化的数
                std::cout << entry.name << " " << formatted.str() << std::endl;
            else // 如果有错误，打印错误信息
                std::cerr << "input error: " << entry.name << " invalid number(s): " << badNums.str() << std::endl;
        }
        return 0;
    }
    ```

---

#### **顺序容器**

---

<div class="success">

> **章节概要**：顺序容器概述；顺序容器类型；选择容器；容器库概览；容器操作；迭代器范围；容器类型成员；`begin`和`end`成员；容器定义与初始化；`assign`和`swap`；顺序容器操作；添加元素；添加元素的操作；使用`insert`添加元素；使用`insert`的返回值；使用`emplace`；访问元素；删除元素；特殊的`forward_list`操作；改变容器大小；有关迭代器失效；`vector`对象如何增长；操作原理描述；管理容量的成员函数；额外的`string`操作

</div>

##### **顺序容器概述**

- **顺序容器类型**

  > 1、下表中列出了**标准库**中的**顺序容器**，其中大部分类型都提供**高效灵活的内存管理**，我们可以**添加删除元素**、**扩张收缩容器大小**  
  > 2、容器**保存元素的策略**对**容器操作**有着**固有且重大的影响**。某些情况下，**存储策略**还会影响特定容器**是否支持特定操作**  
  > 3、`forward_list`和`array`是**C++新标准**增加的类型。与**内置数组**相比，`array`是一种**更安全易用**的数组类型  
  > 4、**新标准库的容器**比旧版本**快得多**，其性能几乎与**最精心优化过**的**同类数据结构**一样好，甚至过之  
  > 5、现代**C++程序**应该尽可能多使用**标准库容器**，而不是像**内置数组**这样的**原始数据结构**

  | 顺序容器类型 | 描述                                                                   |
  | ------------ | ---------------------------------------------------------------------- |
  | vector       | 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 |
  | deque        | 双端队列，支持快速随机访问，在头尾插入删除速度很快                     |
  | list         | 双向链表，只支持双向顺序访问，在任何位置插入删除速度都很快             |
  | forward_list | 单向链表，只支持单向顺序访问，在任何位置插入删除速度都很快             |
  | array        | 固定大小数组，支持快速随机访问，不能添加删除元素                       |
  | string       | 与 vector 类似，专门用来保存字符，随机访问快，尾部插入删除速度快       |

- **选择容器**

  > 1、通常，使用`vector`是**最好的选择**，除非你有**很好的理由**选择其他容器  
  > 2、如果你的程序有**很多小的元素**，且**空间的额外开销**很重要，则不要使用`list`或`forward_list`  
  > 3、如果程序要求**随机访问元素**，应使用`vector`或`deque`  
  > 4、如果程序要求**在容器的中间插入或删除**元素，应使用`list`或`forward_list`  
  > 5、如果程序需要**在头尾插入或删除**元素，但不会在中间插入或删除，则使用`deque`  
  > 6、如果程序只在**输入时**才**在容器中间位置插入**元素，随后需要**随机访问元素**，则最好在**输入阶段**使用`list`，完成后**拷贝到**`vector`(但最好确定是否真的一定要在中间位置插入元素，大多情况可以输入到`vector`再通过`sort`函数排序)

##### **容器库概览**

- 一般来说，每个**容器**都定义在一个**头文件**中，**头文件名与类型名相同**

- **容器操作**

  - **类型别名**

    | 类型别名        | 描述                                                   |
    | --------------- | ------------------------------------------------------ |
    | iterator        | 此容器类型的迭代器类型                                 |
    | const_iterator  | 可以读取元素但不能修改元素的迭代器类型                 |
    | size_type       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |
    | difference_type | 带符号整数类型，足够保存两个迭代器之间的距离           |
    | value_type      | 元素类型                                               |
    | reference       | 元素的左值类型，与 value_type&含义相同                 |
    | const_reference | 元素的 const 左值类型，即 cosnt value_type&            |

  - **构造函数**

    | 构造函数       | 描述                                                                 |
    | -------------- | -------------------------------------------------------------------- |
    | C c            | 默认构造函数，构造空容器                                             |
    | C c1(c2)       | 构造 c2 的拷贝 c1                                                    |
    | C c(b,e)       | 构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c，但不适用于 array |
    | C c{a,b,c,...} | 列表初始化 c                                                         |

  - **赋值和 swap**(assign 不适用于关联容器和 array)

    | 赋值和 swap      | 描述                                                                                |
    | ---------------- | ----------------------------------------------------------------------------------- |
    | c1 = c2          | 将 c1 的元素替换为 c2 的元素                                                        |
    | c1 = {a,b,c,...} | 将 c1 的元素替换为列表中的元素，但不适用于 array                                    |
    | a.swap(b)        | 交换 a 和 b 的元素                                                                  |
    | swap(a,b)        | 交换 a 和 b 的元素                                                                  |
    | seq.assign(b,e)  | 将 seq 中的元素替换为迭代器 b 和 e 所表示范围中的元素，b 和 e 不能指向 seq 中的元素 |
    | seq.assign(il)   | 将 seq 中的元素替换为初始化列表 il 中的元素                                         |
    | seq.assign(n,t)  | 将 seq 中的元素替换为 n 个值为 t 的元素                                             |

  - **大小**

    | 大小         | 描述                                  |
    | ------------ | ------------------------------------- |
    | c.size()     | c 中元素的数目，但不支持 forward_list |
    | c.max_size() | c 可保存的最大元素数目                |
    | c.empty()    | 若 c 为空，返回 true，否则返回 false  |

  - **增删元素**(不适用于 array，且在不同容器中这些操作的接口都不同)

    | 增删元素         | 描述                           |
    | ---------------- | ------------------------------ |
    | c.insert(args)   | 将 args 中的元素拷贝进 c       |
    | c.emplace(inits) | 使用 inits 构造 c 中的一个元素 |
    | c.erase(args)    | 删除 args 指定的元素           |
    | c.clear()        | 删除 c 中所有元素，返回 void   |

  - **关系运算符**

    | 关系运算符   | 描述                           |
    | ------------ | ------------------------------ |
    | ==，!=       | 所有容器都支持相等和不等运算符 |
    | <，<=，>，>= | 关系运算符，无序关联容器不支持 |

  - **获取迭代器**

    | 获取迭代器           | 描述                                        |
    | -------------------- | ------------------------------------------- |
    | c.begin()，c.end()   | 返回指向 c 的首元素与尾元素之后位置的迭代器 |
    | c.cbegin()，c.cend() | 返回 const_interator                        |

  - **反向容器的额外成员**(不支持 forward_list)

    | 反向容器的额外成员      | 描述                                        |
    | ----------------------- | ------------------------------------------- |
    | reverse_iterator        | 按逆序寻址元素的迭代器                      |
    | const_reverse_interator | 不能修改元素的逆序迭代器                    |
    | c.rbegin()，c.rend()    | 返回指向 c 的尾元素与首元素之前位置的迭代器 |
    | c.crbegin()，c.crend()  | 返回 const_reverse_interator                |

- **迭代器范围**

  > 1、一个**迭代器范围**由一对迭代器表示，**两个迭代器**分别指向**同一个容器**中的**元素位置**或**尾元素之后位置**，这**两个迭代器**通常被称为**begin**和**end**  
  > 2、这种元素范围被称为**左闭合区间**，数学描述为`[begin, end)`，表示**自 begin 开始**，**于 end 前结束**  
  > 3、标准库使用**左闭合范围**是因为这种范围有**三种方便的特性**，假定**begin**和**end**构成合法的迭代器范围，则有：  
  > 4、如果**begin**和**end**相等，则范围为空；如果**begin**和**end**不等，则范围至少包含一个元素，且**begin**指向首元素；我们可以对**begin**递增若干次，使`begin==end`，过程中进行迭代

- **容器类型成员**

  > 1、每个容器都定义了**多个类型**，我们已经使用过**其中三种**：`size_type`、`iterator`、`const_iterator`  
  > 2、除了已经使用过的**迭代器类型**，大多容器还提供**反向迭代器**，简单说，**反向迭代器**就是一种**反向遍历容器**的迭代器  
  > 3、剩下还有一些**类型别名**，通过别名我们可以在**不了解容器中元素类型**的情况下**使用它**。比如**元素类型**`value_type`；**元素类型引用**`reference`或`const_reference`

- **begin 和 end 成员**

  > 1、`begin`和`end`**操作**生成指向容器**首元素位置**和**尾后位置**的迭代器，这两个迭代器**最常见的用途**是形成一个**包含容器所有元素**的**迭代器范围**  
  > 2、`begin`和`end`有**多个版本**，带`r`的版本(`rbegin`)返回**反向迭代器**，带`c`的版本(`cbegin`)返回`const`**迭代器**，二者可叠加(`crbegin`)

- **容器定义与初始化**

  - **将一个容器初始化为另一个容器的拷贝**

    > 1、将一个**新容器**创建为**另一个容器的拷贝**有两种方法：可以**直接拷贝整个容器**，或者可以拷贝由一个**迭代器对指定的元素范围**  
    > 2、为了创建一个**容器**为**另一个容器的拷贝**(即第一种方法)，两个**容器的类型**及其**元素的类型**必须匹配  
    > 3、而使用**迭代器对**(即第二种方法)本质上是**拷贝迭代器指向的数据**，就不要求**容器类型相同**了，但**元素类型**需要**能转换成相应的类型**

  - `array`**具有固定大小**

    > 1、与**内置数组**一样，`array`**的大小**也是**类型的一部分**，即定义一个`array`时，除了指定**元素类型**，还要指定**容器大小**：`array<int, 42>`、`array<int, 42>::size_type`  
    > 2、由于**大小**是`array`**类型的一部分**，所以`array`不支持**普通的容器构造函数**，`array`**大小固定**的特性也影响了它所定义的**构造函数的行为**  
    > 3、一个**默认构造**的`array`是**非空**的，它包含**与其大小一样多的元素**，这些**元素**都被**默认初始化**  
    > 4、虽然我们不能对**内置数组**进行**拷贝**或**对象赋值操作**，但对于`array`来说**并无此限制**

- **assign 和 swap**

  - **使用**`assgin`(仅顺序容器)

    > 1、使用**赋值运算符**赋值要求左边和右边的**运算对象类型相同**，而**除**`array`**外的顺序容器**还定义了一个`assign`**成员函数**，允许我们从**不同但相容的类型**赋值，或从**容器的一个子序列**赋值  
    > 2、`assign`操作用**迭代器参数**所**指定的元素**替换**左边容器的所有元素**，比如我们可以用`assign`实现将`vector`**中的一段**`char*`赋值给一个`list`**中的**`string`，如下例

    ```cpp
    list<string> names;
    vector<const char*> oldstyle;
    names = oldstyle;                                   // 错误：容器类型不匹配
    names.assign(oldstyle.cbegin(), oldstyle.cend());   // 正确：可以将 const char* 转换成 string
    ```

  - **使用**`swap`

    > 1、`swap`操作**交换两个相同类型容器**的**内存**，调用`swap`后，两个容器中的**元素将会交换**  
    > 2、除`array`外，`swap`**不对任何元素**进行**拷贝**、**删除**、**插入**操作，**不会真正移动元素**，因此可以保证在`O(1)`**常数时间**内完成；而`array`会**真正交换它们的元素**，因此所需时间是`O(n)`**级别**的  
    > 3、**元素不会被移动**意味着除`string`外，指向容器的**迭代器**、**引用**、**指针**在`swap`**之后不会失效**，它们仍**指向**`swap`**之前所指向的那些元素**，只是`swap`之后这些元素已经**属于不同的容器**了(即`swap`前指向`vec1[3]`，`swap`后指向`vec2[3]`，而`vec2`实际就是交换前的`vec1`)。不同的是，对一个`string`调用`swap`会导致**迭代器**、**引用**、**指针失效**

##### **顺序容器操作**

- **添加元素**

  - **添加元素的操作**

    > 1、除`array`外，所有**标准库容器**都提供**灵活的内存管理**，在运行时可以**动态添加或删除元素**来**改变容器大小**，如下表  
    > 2、这些操作**会改变容器大小**，因此`array`**不支持这些操作**  
    > 3、`forward_list`有自己**专有版本的**`insert`和`emplace`，且**不支持**`push_back`和`emplace_back`  
    > 4、`vector`和`string`**不支持**`push_front`和`emplace_front`

    | 添加元素的操作                         | 描述                                                                                                                                                  |
    | -------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
    | c.push_back(t)，c.emplace_back(args)   | 在 c 的尾部创建一个值为 t 或由 args 创建的元素，返回 void                                                                                             |
    | c.push_front(t)，c.emplace_front(args) | 在 c 的头部创建一个值为 t 或由 args 创建的元素，返回 void                                                                                             |
    | c.insert(p,t)，c.emplace(p,args)       | 在迭代器 p 指向的元素之前创建一个值为 t 或由 args 创建的元素，返回指向新添加元素的迭代器                                                              |
    | c.insert(p,n,t)                        | 在迭代器 p 指向的元素之前插入 n 个值为 t 的元素，返回指向新添加的第一个元素的迭代器                                                                   |
    | c.insert(p,b,e)                        | 将迭代器 b 和 e 指定的范围内的元素插入到迭代器 p 指向的元素之前，b 和 e 不能指向 c 中的元素，返回指向新添加的第一个元素的迭代器，若范围为空，则返回 p |
    | c.insert(p,il)                         | il 是一个花括号包裹的元素值列表列表，将这些给定值插入到迭代器 p 指向的元素之前，返回指向新添加的第一个元素的迭代器，若列表为空，则返回 p              |

  - **使用**`insert`**添加元素**

    > 1、`push_back`和`push_front`操作能够快捷**添加元素**到**容器头尾**，而`insert`允许我们在容器**任意位置插入元素**  
    > 2、每个`insert`**函数**都接受一个**迭代器**作为**第一个参数**，指出在容器**什么位置放置新元素**，它可以指向容器**任何位置**，包括**尾后位置**，`insert`会将元素**插入到这个位置之前**  
    > 3、虽然某些容器**不支持**`push_front`，但对`insert`操作**插入开始位置并无限制**，因此我们可以将元素**插入到容器开始位置**，而不必关心容器是否支持`push_front`，但这样操作需要**注意运行效率**  
    > 4、此外`insert`还可以**接受更多参数**来**添加多个相同值**或**添加一个迭代器范围内的值**，使用方法见上表格

    ```cpp
    vector<string> svec;
    list<string> slist;

    // 等价于调用 slist.push_front("Hello!");
    slist.insert(slist.begin(), "Hello!");

    // vector 不支持 push_front，但可以 insert 到 begin() 之前
    // 警告：插入到 vector 末尾之外的任何位置都可能很慢
    svec.insert(svec.begin(), "Hello!");
    ```

  - **使用**`insert`**的返回值**

    > 1、`insert`返回**指向新添加的第一个元素**的**迭代器**  
    > 2、通过使用`insert`的返回值，可以在容器中一个**特定位置反复插入元素**，如下例

    ```cpp
    string word;
    list<string> lst;
    auto iter = lst.begin();
    while(cin >> word)
        iter = list.insert(iter, word);   // 每次执行后 iter 都赋值为返回值，即每次 iter 都指向开头位置
    ```

  - **使用**`emplace`

    > 1、**新标准**引入了**三个新成员**：`emplace_front`、`emplace`、`emplace_back`，这些操作将会**构造元素**(而不是拷贝元素)，分别对应`push_front`、`insert`、`push_back`  
    > 2、当调用`push`或`insert`**成员函数**时，我们将**元素类型的对象**传递给它们，这些**对象**被**拷贝到容器中**。而当我们调用`emplace`时，则是将**参数**传递给**元素类型的构造函数**，`emplace`使用这些参数在**容器管理的内存空间中**直接**构造元素**  
    > 3、`emplace`函数在容器中**直接构造元素**，所以传递给`emplace`函数的**参数**必须与**元素类型的构造函数**相匹配

- **访问元素**

  > 1、下表列出了**顺序容器**中**访问元素**的**操作**，如果容器**没有元素**，则访问操作是**未定义的**  
  > 2、`at`和**下标操作**只适用于`string`、`vector`、`deque`、`array`，此外`back`不适用于`forward_list`  
  > 3、此外，使用时有一些注意事项，如下示例

  | 访问元素的操作 | 描述                                                                                 |
  | -------------- | ------------------------------------------------------------------------------------ |
  | c.back()       | 返回 c 中尾元素的引用                                                                |
  | c.front()      | 返回 c 中首元素的引用                                                                |
  | c[n]           | 返回 c 中下标为 n 的元素的引用，n 是一个无符号整数。如 n>=c.size()，则函数行为未定义 |
  | c.at(n)        | 返回 c 中下标为 n 的元素的引用。如果下标越界，则抛出一个`out_of_range`异常           |

  ```cpp
  // 在解引用一个迭代器或调用 front 或 back 之前检查是否有元素
  if(!c.empty())
  {
      // val1 和 val2 是 c 中第一个元素值的拷贝
      auto val1 = *c.begin();   // 解引用迭代器
      auto val2 = c.front();    // front 获取首元素的引用
      // val3 和 val4 是 c 中最后一个元素值的拷贝(但此处操作对 forward_list 不适用)
      auto last = c.end();      // 注意迭代器指向尾后位置
      auto val3 = *(--last);    // 注意不能递减 forward_list
      auto val4 = c.back();     // forward_list 不支持
  }
  ```

- **删除元素**

  > 1、与**添加元素**的操作类似，非`array`的容器也有多种**删除元素**的方式，如下表。需要注意，删除元素的函数**不检查其参数**，程序员必须**确保待删除的元素存在**  
  > 2、这些操作**会改变容器大小**，所以**不适用于**`array`  
  > 3、`forward_list`有**特殊版本的**`erase`，且**不支持**`pop_back`  
  > 4、`vector`和`string`**不支持**`pop_front`

  | 删除元素的操作 | 描述                                                                                                                    |
  | -------------- | ----------------------------------------------------------------------------------------------------------------------- |
  | c.pop_back()   | 删除 c 中尾元素，函数返回 void                                                                                          |
  | c.pop_front()  | 删除 c 中首元素，函数返回 void                                                                                          |
  | c.erase(p)     | 删除迭代器 p 所指定的元素，返回一个指向被删除元素之后元素的迭代器。若 p 是尾后迭代器，则函数行为未定义                  |
  | c.erase(b,e)   | 删除迭代器 b 和 e 所指范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器。若 e 本身是尾后迭代器，返回尾后迭代器 |
  | c.clear()      | 删除 c 中所有元素，返回 void                                                                                            |

- **特殊的 forward_list 操作**

  - **单向链表的操作**

    > 1、为了理解`forward_list`为什么有**特殊版本**的**添加和删除操作**，考虑当我们从一个**单向链表**删除一个元素会发生什么。当**删除一个元素**时，会**改变序列中的链接**，如**删除**`elem3`会**改变**`elem2`**指向**`elem4`  
    > 2、当**添加或删除一个元素**时，**该元素之前的元素**的**后继**会**发生改变**。为了执行这一操作，我们需要**访问其前驱**，以**改变前驱的链接**。但是`forward_list`是**单向链表**，没有简单的办法**获取一个元素的前驱**  
    > 3、由于这个原因，在一个`forward_list`中的**增删操作**是通过**改变给定元素后的元素**来完成的，这样，我们总是可以访问到**被增删操作所影响的元素**

  - `forward_list`**增删操作**

    > 1、由于`forward_list`**操作**与**其他容器上的操作**的**实现方式不同**，所以定义了**一套特殊的函数**，如下表  
    > 2、为了**支持这些操作**，`forward_list`也定义了`before_begin`，它是一个**首前迭代器**，它将允许我们在**链表首元素之前**的不存在的元素**之后**执行**增删操作**

    | forward_list 增删操作                                                                           | 描述                                                                                                                                                                                                                                      |
    | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | lst.before_begin()，lst.cbefore_begin()                                                         | 返回指向链表首前元素的迭代器，此迭代器不能解引用。cbefore_begin 返回一个 const_iterator                                                                                                                                                   |
    | lst.insert_after(p,t)，lst.insert_after(p,n,t)，lst.insert_after(p,b,e)，lst.insert_after(p,il) | 在迭代器 p 之后的位置插入元素。t 是一个对象，n 是数量，b 和 e 是表示范围的一对迭代器(但不能指向 lst 内)，il 是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果 b 和 e 的范围为空，则返回 p。若 p 为尾后迭代器，则函数行为未定义 |
    | emplace_after(p,args)                                                                           | 使用 args 在 p 指定的位置之后创建一个元素，返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数行为未定义                                                                                                                            |
    | lst.erase_after(p)，lst.erase_after(b,e)                                                        | 删除 p 指向的位置之后的元素，或删除[b,e)之间的元素。返回一个指向被删元素之后元素的迭代器或尾后迭代器。如果 p 指向 lst 的尾元素或是一个尾后迭代器，则函数行为未定义                                                                        |

  - **示例程序**

    ```cpp
    forward_list<int> flst = {0,1,2,3,4,5,6,7,8,9};
    auto prev = flst.before_begin();        // 表示 flst 的首前元素
    auto curr = flst.begin();               // 表示 flst 的第一个元素
    while(curr != flst.end())               // 表示仍有元素要处理
    {
        if(*curr % 2)                       // 若元素为奇数
            curr = flst.erase_after(prev);  // 删除它并移动 curr
        else
        {
            prev = curr;                    // prev 指向 curr，即移动 prev 指向了下一个元素
            ++curr;                         // 移动迭代器 curr，指向 curr 下一个元素
        }
    }
    ```

- **改变容器大小**

  > 1、下标列出了**改变容器大小的操作**，但**不适用于**`array`  
  > 2、注意：如果`resize`**缩小容器**，则**指向被删除元素**的**迭代器**、**引用**、**指针**都会**失效**；对`vector`、`string`、`deque`进行`resize`可能导致**迭代器**、**指针**、**引用失效**

  | 改变容器大小的操作 | 描述                                                                                                    |
  | ------------------ | ------------------------------------------------------------------------------------------------------- |
  | c.resize(n)        | 调整 c 的大小为 n 个元素，如 n < c.size()，则多出的元素被丢弃；若必须添加新元素，则对新元素进行值初始化 |
  | c.resize(n,t)      | 调整 c 的大小为 n 个元素，任何新添加的元素都初始化值为 t                                                |

  ```cpp
  list<int> ilist(10, 42);      // 10 个 int，每个的值都是 42
  ilist.resize(15);             // 再将 5 个值为 0 的元素添加到 ilist 的末尾
  ilist.resize(25, -1);         // 再将 10 个值为 -1 的元素添加到 ilist 的末尾
  ilist.resize(5);              // 再从 ilist 末尾删除 20 个元素
  ```

- **有关迭代器失效**

  - **迭代器失效**

    > 1、向**容器**中**添加元素**和**删除元素**的操作可能使**指向容器元素**的**指针**、**引用**、**迭代器失效**  
    > 2、一个**失效的指针**、**引用**、**迭代器**将**不再表示任何元素**，使用它们是一种**严重的程序设计错误**，可能引起与**使用未初始化指针一样的问题**  
    > 3、有关**迭代器失效**的具体说明如下

  - **向容器添加元素时**

    > 1、如果**容器**是`vector`或`string`，且**存储空间被重新分配**，则**上述三者都会失效**；如果**存储空间未重新分配**，则**指向插入位置之前**的**三者仍然有效**，但**指向插入位置之后**的**三者将失效**  
    > 2、对于`deque`，插入到**除首尾位置之外**的任何位置都会**导致三者失效**；如果**在首尾插入元素**，**迭代器会失效**，但**指针引用不会失效**  
    > 3、对于`list`和`forward_list`，指向容器的**三者仍然有效**

  - **从容器删除元素时**

    > 1、对于`vector`和`string`，指向**被删元素之前**元素的**三者仍然有效**，**之后部分**的**三者将失效**  
    > 2、对于`deque`，如果在**首尾之外**的任何位置**删除元素**，那么**指向被删除元素外**的其他元素的**三者也会失效**；如果**删除尾元素**，则**尾后迭代器也会失效**，**其他位置三者不受影响**；如果**删除首元素**，**三者也不会受影响**  
    > 3、对于`list`和`forward_list`，**指向容器其他位置**的**三者仍然有效**  
    > 4、注意，当我们**删除元素时**，**被删除元素**的**三者一定失效**，**尾后迭代器**也**一定失效**

  - **编写改变容器的循环程序**

    > 1、**添加删除**`vector`、`string`、`deque`元素的**循环程序**必须考虑**上述三者可能失效**的问题。程序必须保证**每个循环步中**都**更新三者**  
    > 2、如果循环中**调用的是**`insert`或`erase`，那么**更新迭代器很容易**，我们可以利用**这些操作**的**返回值**来更新，如下示例

    ```cpp
    vector<int> vi = {0,1,2,3,4,5,6,7,8,9};
    auto iter = vi.begin();
    while(iter != vi.end())
    {
        if(*iter % 2)
        {
            iter = vi.insert(iter, *iter);    // 复制当前元素
            iter += 2;                        // 向前移动迭代器，跳过当前元素以及插入到它之前的元素
        }
        else
            iter = vi.erase(iter);            // 删除偶数元素
            // 不应向前移动迭代器，iter 指向我们删除的元素之后的元素
    }
    ```

  - **不要保存**`end`**返回的迭代器**

    > 1、当我们在`vector`、`string`或在`deque`**首元素之外**的任何位置**增删元素**时，原来`end`返回的**迭代器总是会失效的**  
    > 2、因此，**增删元素**的循环程序必须**反复调用**`end`，而**不能在循环之前保存**`end`**返回的迭代器**来**一直当做容器末尾使用**  
    > 3、通常**C++标准库**的实现中`end()`**都很快**，部分原因就是因为**需要经常反复调用**

##### **vector 对象如何增长**

- **操作原理描述**

  > 1、为了支持**快速随机访问**，`vector`将元素**连续存储**(每个元素紧挨着前一个元素存储)。通常情况下，我们**不关心**一个**标准库类型如何实现**，**只需要关心**它**如何使用**。然而对于`vector`和`string`，其**部分实现渗透到了接口上**  
  > 2、假定容器中**元素是连续存储的**，且**容器大小可变**，考虑向`vector`或`string`**添加元素**会发生什么：如果**没有空间容纳新元素**，容器**不可能**简单将它**添加到内存中其他位置**，因为**元素必须连续存储**  
  > 3、假如如此，容器必须**分配新的内存空间**来**保存已有元素和新元素**，将**已有元素移动到新空间**，然后**添加新元素**，再**释放旧空间**。如果我们**每添加一个新元素**就执行一次这样的操作，性能会**慢到不可接受**  
  > 4、为了**避免这种代价**，**标准库实现者**采用了可以**减少容器空间重新分配次数**的策略。当不得不重新**获取新的空间**时，`vector`和`string`通常会分配**比新的空间需求更大的空间**。容器预留这些空间**作为备用**，可用来**保存更多新元素**，并**减少重新分配次数**

- **管理容量的成员函数**

  > 1、`vector`和`string`类型提供了一些**成员函数**，它们允许我们**与实现中内存分配的部分互动**，如下表  
  > 2、`shrink_to_fit`只适用于`vector`、`string`、`deque`。新标准中可以使用`shrink_to_fit`要求容器**退回不需要的内存空间**，但具体的实现**可以选择忽略此请求**  
  > 3、`capacity`和`reserve`只适用于`vector`和`string`。注意`reserve`并**不改变元素的数量**，它**仅影响预先分配多大的内存**

  | 容器大小管理操作  | 描述                                               |
  | ----------------- | -------------------------------------------------- |
  | c.shrink_to_fit() | 将 capacity() 减少为与 size() 相同大小             |
  | c.capacity()      | 返回不重新分配内存空间的情况下，c 还能保存多少元素 |
  | c.reserve(n)      | 分配至少能容纳 n 个元素的内存空间                  |

##### **额外的 string 操作**

---

#### **页底评论**

---
