---
title: Cpp基础教程
author: 圣奇宝枣
description: 有关于C++的基础教程，该教程建立在学习过C语言的基础上，进行对比学习，了解不同的特性和更多新内容
sticky: 2
date: 2022-12-03 10:11:16
updated: 2023-01-03 19:54:22
readmore: true
tags:
  - C++
  - 基础语法
categories:
  - 编程语言入门
---

---

_注：该教程建立在学习过 C 语言的基础上，因此很多提过的细节会忽略，主要学习一些 C 语言没有或不同的特性，建议先学习[C 语言基础教程](https://www.shengqibaozao.eu.org/2022/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/?t=1670037021388)_

_此外本文章中没有特殊重申的，大多语句和特性都与 C 语言相同，C++是 C 的超集，兼容了 C 的大多数特性_

---

#### **开始**

---

<div class="success">

> **章节概要**：编写一个简单的 C++程序；初识输入输出；类简介

</div>

<!-- more -->

##### **编写一个简单的 C++程序**

- **简单示例**

  ```cpp
  // 相比C代码，可以省略main(void)的void
  int main()
  {
      return 0;
  }
  ```

##### **初识输入输出**

- **程序示例**

  ```cpp
  #include <iostream>
  int main()0
  {
      std::cout << "Enter two numbers!" << std::endl;
      int v1, v2;
      std::cin >> v1 >> v2;
      std::cout << "The sum of them is " << v1 + v2;
      return 0;
  }
  ```

- **C++的 IO 机制**

  > 1、**C++**包含了一个全面的**标准库**来提供**IO 机制**。其中有**从 C 语言延续而来**的`cstdio`库和**新的**`iostream`库  
  > 2、`iostream`库包含**两个基础类型**：`istream`和`ostream`，分别表示**输入流**和**输出流**  
  > 3、一个**流**(stream)就是一个**字符序列**，是**从 IO 设备读出**或**写入 IO 设备**的

- **标准输入输出对象**

  > 1、标准库定义了 4 个**IO 对象**  
  > 2、为了**处理输入**，我们使用名为`cin`的`istream`类型对象，这个对象也被称为**标准输入**  
  > 3、对于**处理输出**，我们使用名为`cout`的`ostream`类型对象，这个对象也被称为**标准输出**  
  > 4、此外还有其他两个`ostream`类型对象，名为`cerr`和`clog`。其中`cerr`通常用来**输出警告和错误信息**，`clog`用来**输出程序运行时的一般性信息**

- **向流写入写出**

  > 1、如果需要使用`iostream`**库中的对象**进行**输入输出**，则需要用到**流插入符**将内容传输给**流**  
  > 2、`<<`为**输出运算符**。其**接受两个运算对象**，**左侧**必须是一个`ostream`**对象**，**右侧**的运算对象是**要打印的值**。此运算符将**给定的值写入给定的**`ostream`**对象**中  
  > 3、`>>`为**输入运算符**。其与`>>`类型，它**左侧**接受一个`istream`**对象**，**右侧**接受一个**运算对象**。它从给定的`istream`中**读入数据**，并**存入给定的对象**中

- **endl 操纵符**

  > 1、**endl**是一个被称为**操纵符**的**特殊值**  
  > 2、**endl**的效果是**结束当前行**(有换行效果)，并将与设备关联的**缓冲区**的内容**刷到设备中**  
  > 3、**缓冲刷新操作**可以保证到目前为止**程序所产生的所有输出**都**真正写入流中**，而不是仅**停留在内存**中等待写入到流中

- **命名空间**

  > 1、示例程序中使用了`std::cout`和`std::endl`，而不是直接的`cout`和`endl`。其**前缀**`std::`指出**名字**`cout`和`endl`是定义在名为`std`的**命名空间**中的  
  > 2、**命名空间**可以帮助我们避免**不经意的名字定义冲突**以及**使用库中相同名字导致的冲突**。**标准库**定义的**所有名字**都在**命名空间**`std`中  
  > 3、通过**命名空间**使用**标准库**有一个**副作用**：当使用**标准库**中的**一个名字**时，必须通过**作用域运算符**`::`来**显式声明**我们想使用来自`std`中的名字，如示例`std::cout`那样(后续将给出一个更简单的访问标准库名字的方法)

##### **类简介**

- 我们将在之后详细学习**类**相关的知识，在此只**简单介绍**

- **什么是类**

  > 1、在 C++中，我们通过**定义一个类**来**定义自己的数据结构**  
  > 2、一个**类**定义了**一个类型**，以及**与之相关的一组操作**  
  > 3、**类机制**是 C++**最重要的特性之一**。实际上，C++最初的**设计焦点**就是能定义使用上像内置类型一样自然的**类类型**

- 如果要使用一个类，我们需要了解**三件事情**：

  > 1、类名是什么？  
  > 2、它在哪里定义的？  
  > 3、它支持什么操作？

---

#### **变量和基本类型**

---

<div class="success">

> **章节概要**：基本内置类型；指定字面量类型；变量；对象；列表初始化；C++关键字；复合类型；引用；指针；const 限定符

</div>

##### **基本内置类型**

- **基本数据类型**

  > 1、C++定义了一套包括**算数类型**和**空类型**在内的**基本数据类型**  
  > 2、其中**算数类型**包含了**整型**、**浮点型**、**字符型**、**布尔型**  
  > 3、**空类型 void**不对应**具体的值**，仅用于一些**特殊的场合**

- C++的**基本数据类型**与 C 语言**规则相同**，但 C++中**直接支持**了**bool 类型**，且`iostream`中**直接支持**了**拓展类型**(如`int32_t`等)

- **指定字面量类型**

  - 通过添加**前缀或后缀**，可以改变不同类型**字面量**的**默认类型**

  - **指定字符和字符串字面量**

    | 前缀 |   类型   | 含义                        |
    | :--: | :------: | --------------------------- |
    |  u   | char16_t | Unicode 16 字符             |
    |  U   | char32_t | Unicode 32 字符             |
    |  L   | wchar_t  | 宽字符                      |
    |  u8  |   char   | UTF-8(仅用于字符串字面常量) |

  - **指定整型字面量**

    |   后缀   | 最小匹配类型 |
    | :------: | :----------: |
    |  u 或 U  |   unsigned   |
    |  l 或 L  |     long     |
    | ll 或 LL |  long long   |

  - **指定浮点型字面量**

    |  后缀  |    类型     |
    | :----: | :---------: |
    | f 或 F |    float    |
    | l 或 L | long double |

##### **变量**

- **变量**

  > 1、**变量**提供一个**具名的**、**可供程序操作的存储空间**  
  > 2、C++中的每个变量都有其**数据类型**，**数据类型**决定着变量所占**内存空间**的**大小及布局方式**、该空间**能存储值的范围**，以及变量**能参与的运算**  
  > 3、对于 C++程序员来说，**变量**和**对象**一般可以**互换使用**

- **对象**

  > 1、C++程序员在很多场合都会使用**对象**这个名词。通常情况下，**对象**指一块**能存储数据**并**具有某种类型**的**内存空间**  
  > 2、一部分人对**对象**的定义并不相同，比如：一些人仅在**与类有关**的场景才使用**对象**这个词；另一些人把**命名了的对象**叫做**变量**；还有一些人把**对象**和**值**区分开来，**对象**指**能被程序修改的数据**，而**值**指**只读的数据**

- **列表初始化**

  - C++定义了**初始化**的**好几种不同形式**，如下：

    ```cpp
    int units_sold = 0;
    int units_sold(0);
    int units_sold = {0}; // 列表初始化
    int units_sold{0};    // 列表初始化
    ```

  - **列表初始化**

    > 1、作为**C++11 新标准**的一部分，用**花括号**来**初始化变量**得到了全面应用。这种初始化形式被称为**列表初始化**  
    > 2、现在，无论是**初始化对象**还是某些时候**为对象赋新值**，都可以使用这样一组**由花括号括起来的初始值**了  
    > 3、当用于**内置类型**变量时，这种初始化形式有一个**重要特点**：如果我们**使用列表初始化**且**初始值存在丢失信息的风险**，**编译器将报错**(如下例)  
    > 4、这样的介绍看似无关紧要，因为我们不会故意**用 long double 值初始化 int 变量**，然而这种初始化**可能在不经意间发生**，因此这种赋值更加**保守安全**

    ```cpp
    long double ld = 3.1415926536;
    int a{ld}, b = {ld};    // 报错：转换未执行，因为存在丢失信息的风险(丢失浮点精度)
    int c(ld), d = ld;      // 正确：转换执行，且确实丢失了部分值(丢失了小数点后的浮点部分)
    ```

- **C++关键字**

  |   关键字   |    关键字    |  关键字   |      关键字      |  关键字  |
  | :--------: | :----------: | :-------: | :--------------: | :------: |
  |  alignas   |   continue   |  friend   |     register     |   true   |
  |  alignof   |   decltype   |   goto    | reinterpret_cast |   try    |
  |    asm     |   default    |    if     |      return      | typedef  |
  |    auto    |    delete    |  inline   |      short       |  typeid  |
  |    bool    |      do      |    int    |      signed      | typename |
  |   break    |    double    |   long    |      sizeof      |  union   |
  |    case    | dynamic_cast |  mutable  |      static      | unsigned |
  |   catch    |     else     | namespace |  static_assert   |  using   |
  |    char    |     enum     |    new    |   static_cast    | virtual  |
  |  char16_t  |   explicit   | noexcept  |      struct      |   void   |
  |  char32_t  |    export    |  nullptr  |      switch      | volatile |
  |   class    |    extern    | operator  |     template     | wchar_t  |
  |   const    |    false     |  private  |       this       |  while   |
  | constexpr  |    float     | protected |   thread_local   |          |
  | const_cast |     for      |  public   |      throw       |          |

##### **复合类型**

- **复合类型**是指**基于其他类型**定义的类型。C++有几种复合类型，在此主要了解其中两种：**引用**和**指针**

- **引用**

  - **示例**

    ```cpp
    int ival = 1024;
    int &refVal = ival;     // 定义引用，refVal 指向 ival
    int &refVal2;           // 报错：引用必须被初始化

    refVal = 2;             // 实际赋值给 refVal 指向的 ival
    int &refVal3 = refVal;  // refVal3 指向 refVal 指向的 ival

    double dval = 10;
    int &refVal4 = dval;    // 报错：refVal4 为int类型，其指向对象必须为int类型
    int &refVal5 = 10;      // 报错：引用只能绑定在对象上
    ```

  - **引用介绍**

    > 1、**引用**为对象**起了另外一个名字**，通过将声明符写成`&变量名`来**定义引用类型**  
    > 2、**定义引用时**，程序把**引用**和它的**初始值**绑定在一起。一旦初始化完成，**引用**将和它的**初始值对象**一直绑定在一起。因为**无法**令引用**重新绑定另外一个对象**，所以**引用必须初始化**  
    > 3、引用**并非对象**，它只是为一个**已经存在的对象**所起的**另外一个名字**。定义一个引用之后，**对其进行的所有操作**都是在**与之绑定的对象**上进行的  
    > 4、所有**引用的类型**都要和**与之绑定的对象**严格匹配，且**引用只能绑定在对象上**

- **指针**

  - C++的指针整体与 C 语言的指针相同，在此写出一些差异

  - **空指针**

    > 1、**空指针**不指向**任何对象**，下为三种**生成空指针**的方法  
    > 2、第一种方法是使用**字面值**`nullptr`来初始化指针。`nullptr`是一种**特殊类型**的字面值，它可以**被转换成任意其他的指针类型**  
    > 3、第二种方法是使用**字面值 0**来生成空指针(注意不是 int 值)  
    > 4、第三种方法是使用**NULL 预处理器变量**，这个变量在头文件`cstdlib`中定义，**预处理变量**不属于**命名空间**`std`。在新标准下，现在的 C++程序**最好使用**`nullptr`，同时**尽量避免使用**`NULL`

    ```cpp
    int *p1 = nullptr;
    int *pt = 0;
    // 使用 NULL 需要调用 cstdlib 头文件
    int *p3 = NULL;
    ```

##### **const 限定符**

- 

---

#### **页底评论**

---
