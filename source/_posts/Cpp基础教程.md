---
title: Cpp基础教程
author: 圣奇宝枣
description: 有关于C++的基础教程，该教程建立在学习过C语言的基础上，进行对比学习，了解不同的特性和更多新内容
sticky: 2
date: 2022-12-03
updated: 2023-01-09
readmore: true
tags:
  - C++
  - 基础语法
categories:
  - 编程语言入门
---

---

_注：该教程建立在学习过 C 语言的基础上，因此很多提过的细节会忽略，主要学习一些 C 语言没有或不同的特性，建议先学习[C 语言基础教程](https://www.shengqibaozao.eu.org/2022/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/?t=1670037021388)_

_此外本文章中没有特殊重申的，大多语句和特性都与 C 语言相同，C++是 C 的超集，兼容了 C 的大多数特性_

---

#### **开始**

---

<div class="success">

> **章节概要**：编写一个简单的 C++程序；初识输入输出；使用 C++ 版本的 C 标准库头文件；类简介

</div>

<!-- more -->

##### **编写一个简单的 C++程序**

- **简单示例**

  ```cpp
  // 相比C代码，可以省略main(void)的void
  int main()
  {
      return 0;
  }
  ```

##### **初识输入输出**

- **程序示例**

  ```cpp
  #include <iostream>
  int main()0
  {
      std::cout << "Enter two numbers!" << std::endl;
      int v1, v2;
      std::cin >> v1 >> v2;
      std::cout << "The sum of them is " << v1 + v2;
      return 0;
  }
  ```

- **C++的 IO 机制**

  > 1、**C++**包含了一个全面的**标准库**来提供**IO 机制**。其中有**从 C 语言延续而来**的`cstdio`库和**新的**`iostream`库  
  > 2、`iostream`库包含**两个基础类型**：`istream`和`ostream`，分别表示**输入流**和**输出流**  
  > 3、一个**流**(stream)就是一个**字符序列**，是**从 IO 设备读出**或**写入 IO 设备**的

- **标准输入输出对象**

  > 1、标准库定义了 4 个**IO 对象**  
  > 2、为了**处理输入**，我们使用名为`cin`的`istream`类型对象，这个对象也被称为**标准输入**  
  > 3、对于**处理输出**，我们使用名为`cout`的`ostream`类型对象，这个对象也被称为**标准输出**  
  > 4、此外还有其他两个`ostream`类型对象，名为`cerr`和`clog`。其中`cerr`通常用来**输出警告和错误信息**，`clog`用来**输出程序运行时的一般性信息**

- **向流写入写出**

  > 1、如果需要使用`iostream`**库中的对象**进行**输入输出**，则需要用到**流插入符**将内容传输给**流**  
  > 2、`<<`为**输出运算符**。其**接受两个运算对象**，**左侧**必须是一个`ostream`**对象**，**右侧**的运算对象是**要打印的值**。此运算符将**给定的值写入给定的**`ostream`**对象**中  
  > 3、`>>`为**输入运算符**。其与`>>`类型，它**左侧**接受一个`istream`**对象**，**右侧**接受一个**运算对象**。它从给定的`istream`中**读入数据**，并**存入给定的对象**中

- **endl 操纵符**

  > 1、**endl**是一个被称为**操纵符**的**特殊值**  
  > 2、**endl**的效果是**结束当前行**(有换行效果)，并将与设备关联的**缓冲区**的内容**刷到设备中**  
  > 3、**缓冲刷新操作**可以保证到目前为止**程序所产生的所有输出**都**真正写入流中**，而不是仅**停留在内存**中等待写入到流中

- **命名空间**

  > 1、示例程序中使用了`std::cout`和`std::endl`，而不是直接的`cout`和`endl`。其**前缀**`std::`指出**名字**`cout`和`endl`是定义在名为`std`的**命名空间**中的  
  > 2、**命名空间**可以帮助我们避免**不经意的名字定义冲突**以及**使用库中相同名字导致的冲突**。**标准库**定义的**所有名字**都在**命名空间**`std`中  
  > 3、通过**命名空间**使用**标准库**有一个**副作用**：当使用**标准库**中的**一个名字**时，必须通过**作用域运算符**`::`来**显式声明**我们想使用来自`std`中的名字，如示例`std::cout`那样(后续将给出一个更简单的访问标准库名字的方法)

##### **使用 C++版本的 C 标准库头文件**

- **建议使用 C++版本标准库**

  > 1、C++标准库中**兼容了 C 语言的标准库**，其按照如下**命名规则**命名  
  > 2、C 语言的头文件形如`name.h`，C++将其命名为`cname`。即**去掉**`.h`**后缀**，文件名前**添加字母**`c`  
  > 3、因此`stdio.h`和`cstdio`**内容是一样的**，而且`stdio.h`也能在 C++调用，但从**命名规范**上来讲，`cstdio`更符合 C++的要求  
  > 4、特别的，在名为`cname`的**头文件**定义的**名字**从属于**命名空间**`std`，而原本`.h`的则不然  
  > 5、一般来说，C++程序**应使用名为**`cname`**的头文件**，因为这样**标准库的名字**总能在`std`找到。如果使用`.h`形式，那么程序员不得不时刻牢记哪些是从 C 语言继承过来的，哪些又是 C++独有的

##### **类简介**

- 我们将在之后详细学习**类**相关的知识，在此只**简单介绍**

- **什么是类**

  > 1、在 C++中，我们通过**定义一个类**来**定义自己的数据结构**  
  > 2、一个**类**定义了**一个类型**，以及**与之相关的一组操作**  
  > 3、**类机制**是 C++**最重要的特性之一**。实际上，C++最初的**设计焦点**就是能定义使用上像内置类型一样自然的**类类型**

- 如果要使用一个类，我们需要了解**三件事情**：

  > 1、类名是什么？  
  > 2、它在哪里定义的？  
  > 3、它支持什么操作？

---

#### **变量和基本类型**

---

<div class="success">

> **章节概要**：基本内置类型；指定字面量类型；变量；对象；列表初始化；C++关键字；复合类型；引用；指针；void\* 指针；`const`限定符；`const`的引用；`constexpr`和常量表达式；处理类型；类型别名；`auto`类型说明符；`decltype`类型指示符；自定义数据结构；定义类；使用类

</div>

##### **基本内置类型**

- **基本数据类型**

  > 1、C++定义了一套包括**算数类型**和**空类型**在内的**基本数据类型**  
  > 2、其中**算数类型**包含了**整型**、**浮点型**、**字符型**、**布尔型**  
  > 3、**空类型 void**不对应**具体的值**，仅用于一些**特殊的场合**

- C++的**基本数据类型**与 C 语言**规则相同**，但 C++中**直接支持**了**bool 类型**，且`iostream`中**直接支持**了**拓展类型**(如`int32_t`等)

- **指定字面量类型**

  - 通过添加**前缀或后缀**，可以改变不同类型**字面量**的**默认类型**

  - **指定字符和字符串字面量**

    | 前缀 |   类型   | 含义                        |
    | :--: | :------: | --------------------------- |
    |  u   | char16_t | Unicode 16 字符             |
    |  U   | char32_t | Unicode 32 字符             |
    |  L   | wchar_t  | 宽字符                      |
    |  u8  |   char   | UTF-8(仅用于字符串字面常量) |

  - **指定整型字面量**

    |   后缀   | 最小匹配类型 |
    | :------: | :----------: |
    |  u 或 U  |   unsigned   |
    |  l 或 L  |     long     |
    | ll 或 LL |  long long   |

  - **指定浮点型字面量**

    |  后缀  |    类型     |
    | :----: | :---------: |
    | f 或 F |    float    |
    | l 或 L | long double |

##### **变量**

- **变量**

  > 1、**变量**提供一个**具名的**、**可供程序操作的存储空间**  
  > 2、C++中的每个变量都有其**数据类型**，**数据类型**决定着变量所占**内存空间**的**大小及布局方式**、该空间**能存储值的范围**，以及变量**能参与的运算**  
  > 3、对于 C++程序员来说，**变量**和**对象**一般可以**互换使用**

- **对象**

  > 1、C++程序员在很多场合都会使用**对象**这个名词。通常情况下，**对象**指一块**能存储数据**并**具有某种类型**的**内存空间**  
  > 2、一部分人对**对象**的定义并不相同，比如：一些人仅在**与类有关**的场景才使用**对象**这个词；另一些人把**命名了的对象**叫做**变量**；还有一些人把**对象**和**值**区分开来，**对象**指**能被程序修改的数据**，而**值**指**只读的数据**

- **列表初始化**

  - C++定义了**初始化**的**好几种不同形式**，如下：

    ```cpp
    int units_sold = 0;
    int units_sold(0);
    int units_sold = {0}; // 列表初始化
    int units_sold{0};    // 列表初始化
    ```

  - **列表初始化**

    > 1、作为**C++11 新标准**的一部分，用**花括号**来**初始化变量**得到了全面应用。这种初始化形式被称为**列表初始化**  
    > 2、现在，无论是**初始化对象**还是某些时候**为对象赋新值**，都可以使用这样一组**由花括号括起来的初始值**了  
    > 3、当用于**内置类型**变量时，这种初始化形式有一个**重要特点**：如果我们**使用列表初始化**且**初始值存在丢失信息的风险**，**编译器将报错**(如下例)  
    > 4、这样的介绍看似无关紧要，因为我们不会故意**用 long double 值初始化 int 变量**，然而这种初始化**可能在不经意间发生**，因此这种赋值更加**保守安全**

    ```cpp
    long double ld = 3.1415926536;
    int a{ld}, b = {ld};    // 报错：转换未执行，因为存在丢失信息的风险(丢失浮点精度)
    int c(ld), d = ld;      // 正确：转换执行，且确实丢失了部分值(丢失了小数点后的浮点部分)
    ```

- **C++关键字**

  |   关键字   |    关键字    |  关键字   |      关键字      |  关键字  |
  | :--------: | :----------: | :-------: | :--------------: | :------: |
  |  alignas   |   continue   |  friend   |     register     |   true   |
  |  alignof   |   decltype   |   goto    | reinterpret_cast |   try    |
  |    asm     |   default    |    if     |      return      | typedef  |
  |    auto    |    delete    |  inline   |      short       |  typeid  |
  |    bool    |      do      |    int    |      signed      | typename |
  |   break    |    double    |   long    |      sizeof      |  union   |
  |    case    | dynamic_cast |  mutable  |      static      | unsigned |
  |   catch    |     else     | namespace |  static_assert   |  using   |
  |    char    |     enum     |    new    |   static_cast    | virtual  |
  |  char16_t  |   explicit   | noexcept  |      struct      |   void   |
  |  char32_t  |    export    |  nullptr  |      switch      | volatile |
  |   class    |    extern    | operator  |     template     | wchar_t  |
  |   const    |    false     |  private  |       this       |  while   |
  | constexpr  |    float     | protected |   thread_local   |          |
  | const_cast |     for      |  public   |      throw       |          |

##### **复合类型**

- **复合类型**是指**基于其他类型**定义的类型。C++有几种复合类型，在此主要了解其中两种：**引用**和**指针**

- **引用**

  - **示例**

    ```cpp
    int ival = 1024;
    int &refVal = ival;     // 定义引用，refVal 指向 ival
    int &refVal2;           // 报错：引用必须被初始化
    /*------------------------------------------------------------------*/
    refVal = 2;             // 实际赋值给 refVal 指向的 ival
    int &refVal3 = refVal;  // refVal3 指向 refVal 指向的 ival
    /*------------------------------------------------------------------*/
    double dval = 10;
    int &refVal4 = dval;    // 报错：refVal4 为int类型，其指向对象必须为int类型
    int &refVal5 = 10;      // 报错：引用只能绑定在对象上
    ```

  - **引用介绍**

    > 1、**引用**为对象**起了另外一个名字**，通过将声明符写成`&变量名`来**定义引用类型**  
    > 2、**定义引用时**，程序把**引用**和它的**初始值**绑定在一起。一旦初始化完成，**引用**将和它的**初始值对象**一直绑定在一起。因为**无法**令引用**重新绑定另外一个对象**，所以**引用必须初始化**  
    > 3、引用**并非对象**，它只是为一个**已经存在的对象**所起的**另外一个名字**。定义一个引用之后，**对其进行的所有操作**都是在**与之绑定的对象**上进行的  
    > 4、所有**引用的类型**都要和**与之绑定的对象**严格匹配，且**引用只能绑定在对象上**

- **指针**

  - C++的指针整体与 C 语言的指针相同，在此写出一些差异

  - **空指针**

    > 1、**空指针**不指向**任何对象**，下为三种**生成空指针**的方法  
    > 2、第一种方法是使用**字面值**`nullptr`来初始化指针。`nullptr`是一种**特殊类型**的字面值，它可以**被转换成任意其他的指针类型**  
    > 3、第二种方法是使用**字面值 0**来生成空指针(注意不是 int 值)  
    > 4、第三种方法是使用**NULL 预处理器变量**，这个变量在头文件`cstdlib`中定义，**预处理变量**不属于**命名空间**`std`。在新标准下，现在的 C++程序**最好使用**`nullptr`，同时**尽量避免使用**`NULL`

    ```cpp
    int *p1 = nullptr;
    int *pt = 0;
    // 使用 NULL 需要调用 cstdlib 头文件
    int *p3 = NULL;
    ```

- **void\* 指针**

  > 1、void\* 是一种特殊的指针类型，可用于存放**任意对象的地址**。不同的是，我们对该地址**指向对象的类型**并不了解  
  > 2、利用 void\* 指针**能做的事有限**，**不能直接操作**其所指的对象，因为并**不知道对象是什么类型**  
  > 3、概括来说，以 void\* 视角来看，**内存空间**也就仅仅是**内存空间**，**没办法访问**内存空间中的**对象**

##### **const 限定符**

- **简述**

  > 1、有时我们希望定义一种**值不能被改变**的**变量**(或直接称为**常量**)，可以用`const`关键字加以修饰  
  > 2、因为`const`对象**一旦创建**，**值就不能改变**，所以`const`对象**必须初始化**  
  > 3、`const`的用法整体与 C 语言中类似

- `const`**的引用**

  > 1、可以把**引用**绑定到`const`**对象**上，我们称之为**对常量的引用**(或**常量引用**)  
  > 2、**常量引用**仅对**引用**本身作出限定，对于**引用的对象**并未限定。如果对象本身**不是常量**，那么允许通过**其他途径**修改它的值

  ```cpp
  const int i = 1024;
  const int &r1 = i;      // 正确：引用及其对应对象都是常量
  r1 = 42;                // 错误：r1是对常量的引用
  int &r2 = i;            // 错误：r2是对非常量的引用，不能指向常量对象
  /*------------------------------------------------------------*/
  int n = 30;
  const int &r1 = n;
  r1 = 40;                // 错误：r1是对常量的引用
  n = 40;                 // 正确：n本身不是常量
  ```

- `constexpr`**和常量表达式**

  - **常量表达式**

    > 1、**常量表达式**指**值不会改变**且**在编译过程中就能确定值**的表达式  
    > 2、一个对象是不是常量表达式，由它的**数据类型**和**初始值**共同决定

    ```cpp
    const int max_file = 20;          // 是常量表达式
    const int limit = mix_file + 1;   // 是常量表达式
    int staff_size = 27;              // 不是常量表达式：数据类型只是普通 int
    const int sz = get_size();        // 不是常量表达式：不能在编译过程中确定值
    ```

  - `constexpr`**变量**

    > 1、在一个复杂系统中，很难(甚至几乎肯定不能)**分辨一个初始值**是不是**常量表达式**  
    > 2、**C++11**规定，允许将变量声明为`constexpr`类型，由**编译器**来验证**变量的值**是否为**常量表达式**  
    > 3、声明为`constexpr`的变量**一定是一个常量**，而且**必须用常量表达式初始化**  
    > 4、不能使用**普通函数**作为`constexpr`**初始值**，允许定义一种特殊的`constexpr`**函数**，后续介绍

    ```cpp
    constexpr int mf = 20;            // 编译通过
    constexpr int limit = mf + 1;     // 编译通过
    constexpr int sz = size();        // 编译错误：除非 size() 是 constexpr 函数
    ```

  - **字面值类型**

    > 1、**常量表达式**的值需要**在编译时就得到计算**，这些类型一般**比较简单**，值也显而易见，就把它们称为**字面值类型**  
    > 2、目前为止，**算数类型**、**引用**、**指针**都**是**字面值类型。**自定义类**、**IO 库**、**string 类型**都**不是**字面值类型，也就不能被定义为`constexpr`  
    > 3、尽管**指针**和**引用**都能被定义成`constexpr`，但它们的**初始值受到严格限制**。如`constexpr`**指针**的初始值只能是`nullptr`或**0**，或存储于某个**固定地址**中的**对象**

##### **处理类型**

- **类型别名**

  > 1、有两种方法可用于定义**类型别名**，第一种是使用`typedef`**关键字**，与 C 语言用法相同  
  > 2、新标准规定了一种新方法：使用**别名声明**。这种方法使用`using`**关键字**作为**别名声明**的开始，其后紧跟别名和等号，作用是把**等号左侧的名字**规定成**等号右侧的类型**的别名

  ```cpp
  typedef double wages;      // wages 是 double 的别名
  typedef wages base, *p;    // base 是 wages(即double)的别名，p 是 double* 的别名
  using SI = Sales_item;     // SI 是 Sales_item 的别名
  ```

- `auto`**类型说明符**

  > 1、编程时常常需要把**表达式的值**赋给变量，这就要求在**声明变量时**清楚地知道**表达式的类型**，然而做到这一点并不容易，甚至有时根本做不到  
  > 2、**C++11**引入了`auto`**类型说明符**，能让**编译器**替我们去**分析表达式的类型**  
  > 3、和原来**只对应一种特定类型**的说明符(如 double)不同，`auto`能让编译器**通过初始值**推算**变量的类型**。显然，`auto`定义的变量**必须有初始值**  
  > 4、使用`auto`也能在**一条语句**声明**多个变量**，但由于一条声明语句**只能有一个基本数据类型**，所以该语句中**所有变量**的**初始基本数据类型**必须**都一样**

  ```cpp
  auto item = val1 + val2;    // auto 自动判断表达式类型
  auto i = 0, *p = &i;        // 正确：i 是整数，p 是整型指针
  auto sz = 0, pi = 3.14;     // 错误：sz 和 pi 类型不一致
  ```

- `decltype`**类型指示符**

  > 1、有时我们希望从**表达式的类型**推断出要定义的**变量的类型**，但是不想用该表达式的值**初始化变量**。为此，**C++11**引入了`decltype`**说明符**  
  > 2、`delctype`可以**返回操作数的数据类型**，在此过程中，**编译器**分析表达式并**得到它的类型**，但并**不实际计算表达式的值**  
  > 3、注意`delctype`**表达式的结果**如果是**加上括号的变量**，则结果将是**引用**。即`decltype(())`(注意是双层括号)的**结果永远是引用**

  ```cpp
  int ci = 1;
  decltype(ci) x = 0;         // x 的类型就是 ci 的类型，即 int，值为 0
  decltype(def()) sum = x;    // sum的类型就是函数 def() 的返回类型，值为 x 的值
  /*--------------------------------------------------------------------*/
  int i = 1;
  decltype((i)) d;            // 错误：d 是 int& 引用类型，必须初始化
  decltype(i) e;              // 正确：e 是一个未初始化的 int 类型
  ```

##### **自定义数据结构**

- **什么是数据结构**

  > 1、从最基本的层面理解，**数据结构**是把一组**相关的数据元素**组织起来然后使用它们的**策略和方法**  
  > 2、举一个例子，我们想要创建一个`Sales_items`**类**把书本的**ISBN 编号**、**售出量**、**销售收入**等数据组织在一起，并提供诸如`isbn()`**等函数**，`<<`、`>>`、`+`、`+=`**等运算**在内的**一系列操作**，`Sales_item`**类**就是一个**数据结构**  
  > 3、C++允许用户以**类的形式**自定义**数据类型**，而**库类型**`string`、`istream`、`ostream`等也是**以类的形式定义的**

- **定义类**

  - **简单的不含运算功能的类**的定义实际就是**C 的结构体**定义，使用`struct`定义

  - 此外，C++提供**另外一个关键字**`class`定义自己的**数据结构**，后续介绍

- **使用类**：与**C 的结构体**使用**规则相同**

---

#### **字符串、向量和数组**

---

<div class="success">

> **章节概要**：命名空间的`using`声明；标准库类型`string`；定义和初始化`string`对象；`string`对象的操作；处理`string`对象中的字符；范围 for 语句；标准库类型`vector`；模板；定义和初始化`vector`对象；向`vector`对象添加元素；其他`vector`操作；`vector`的索引；迭代器介绍；使用迭代器；泛型编程；迭代器运算

</div>

##### **命名空间的 using 声明**

- **引入**

  > 1、目前为止，我们用到的**库函数**基本上都属于**命名空间**`std`，而程序也显式地将这一点标示了出来，如`std::cin`  
  > 2、用这种方法显得**比较繁琐**，然而幸运的是，通过更简单的途径也能使用到**命名空间的成员**  
  > 3、本节将介绍其中一种**最安全的方法**，也就是**使用`using`声明**，后续会介绍另一种方法

- `using`**声明**

  > 1、有了`using`声明就**无须专门的前缀**，也能使用所需的名字了  
  > 2、`using`声明具有**如下形式**`using 命名空间名::名字`，如后示例  
  > 3、按照规定，每个`using`声明只能引入**命名空间**中的**一个成员**，因此每个名字都需要**独立声明**  
  > 4、位于**头文件**的代码**不应该使用**`using`**声明**，因为引用该头文件的源代码也会**引入这个声明**，对于某些程序，可能会**产生名字冲突**

  ```cpp
  #include <iostream>
  using std::cin;
  int main()
  {
      int i;
      cin >> i;
      std::cout << i;
      return 0;
  }
  ```

##### **标准库类型 string**

- **介绍**

  > 1、**标准库类型**`string`表示**可变长的字符序列**(字符串)，使用`string`类型必须先包含`string`**头文件**  
  > 2、作为**标准库的一部分**，`string`定义在**命名空间**`std`中  
  > 3、接下来的示例都假定已包含了下述代码

  ```cpp
  #include <string>
  using std::string
  ```

- **定义和初始化 string 对象**

  > 1、如何**初始化类的对象**是由**类本身**决定的，一个类可以定义**很多种**初始化对象的方式，但这些方式之间**必须有所区别**：或者是**初始值数量不同**，或者是**初始值类型不同**  
  > 2、下为**初始化**`string`**对象**的**方式和示例**

  | 方式                | 说明                                                   |
  | ------------------- | ------------------------------------------------------ |
  | string s1           | 默认初始化，s1 是一个空串                              |
  | string s2(s1)       | 直接初始化，s2 是 s1 的副本                            |
  | string s2 = s1      | 拷贝初始化，s2 是 s1 的副本                            |
  | string s3("value")  | 直接初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s3 = "value" | 拷贝初始化，s3 是字符串字面值"value"的副本，空字符除外 |
  | string s4(n, 'c')   | 直接初始化，把 s4 初始化为连续 n 个字符 c 组成的字符串 |

  ```cpp
  string s1;                    // 默认初始化，s1是空字符串
  string s2 = s1;               // s2是s1的副本
  string s3("value");           // s3是字面值"value"的副本
  string s3 = "value";          // s3是字面值"value"的副本
  string s4(10, 'c');           // 直接初始化，s4内容是 cccccccccc
  string s4 = string(10, 'c');  // 拷贝初始化，s4内容是 cccccccccc
  ```

- **string 对象的操作**

  - **总览**

    > 1、一个**类**除了要规定**初始化其对象的方式**外，还要定义对象上**能执行的操作**。其中，类既能定义**通过函数名调用的操作**，也能定义**各种运算符**在**该类对象**上的**新含义**  
    > 2、下表列举了**大部分**`string`**类的操作**

    | 操作           | 含义                                                                                     |
    | -------------- | ---------------------------------------------------------------------------------------- |
    | os<<s          | 将 s 写入到输出流 os 中，返回 os                                                         |
    | is>>s          | 从 is 中读取字符串赋给 s，字符串以空格分隔，返回 is                                      |
    | getline(is, s) | 从 is 中读取一行赋给 s，返回 is                                                          |
    | s.empty()      | s 为空返回 true，否则返回 false                                                          |
    | s.size()       | 返回 s 中字符个数                                                                        |
    | s[n]           | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起                                             |
    | s1+s2          | 返回 s1 和 s2 连接后的结果                                                               |
    | s1=s2          | 用 s2 的副本代替 s1 中原来的字符                                                         |
    | s1==s2         | 如果 s1 和 s2 中的字符完全一样，则它们相等，对字母的判断依据是 ASCII 码                  |
    | s1!=s2         | 如果 s1 和 s2 中有一个字符不一样，则它们不相等，对字母的判断依据是 ASCII 码              |
    | <,<=,>,>=      | 对字符串从前向后依次比较字符的 ASCII 码，成立与否的依据是首个不相等字符的 ASCII 大小关系 |

  - **读写操作**

    ```cpp
    // 基本读写
    int main()
    {
        string s;
        cin >> s;   // 遇到空格停止
        cout << s;
        return 0;
    }
    ```

    ```cpp
    // getline整行读取
    int main()
    {
        string line;
        getline(cin, line);   // 遇到换行符停止
        cout << line << endl;
        return 0;
    }
    ```

    ```cpp
    // C语言风格EOF读写
    int main()
    {
        string word;
        // while(getline(cin, line))
        while(cin >> word)
            cout << word << endl;
        return 0;
    }
    ```

  - `empty`**和**`size`**操作**

    > 1、`empty`**函数**根据`string`**对象是否为空**返回一个**布尔值**，`size`**函数**返回`string`**对象的长度**  
    > 2、这两个函数都是`string`的**成员函数**。**调用该类函数**的方法是，使用**点操作符**指明是**哪个对象**执行成员函数即可(`对象.成员函数()`)

    ```cpp
    int main()
    {
        string line;
        while(getline(cin, line))
            // 如果字符串不为空 且 字符串长度大于10
            if(!line.empty() && line.size() > 10)
                cout << line << endl;
        return 0;
    }
    ```

  - `string::size_type`**类型**

    > 1、实际上，`size`**函数的返回值**是一个`string::size_type`**类型的值**  
    > 2、尽管我们不太清楚`string::size_type`类型的**具体细节**，但有一点是肯定的，它是一个**无符号类型值**，且**足够存放任何**`string`**对象的大小**  
    > 3、所有**用于存放**`string`**类**的`size`**函数返回值**的**变量**，都应该是**该类型**(`auto len = line.size();`中`line`的类型也**自动设为该类型**)  
    > 4、由于**该类型**是**无符号整型**，因此切记，如果在表达式中**混用**了**无符号数和有符号数**会产生意想不到的错误。如**变量 n**是一个**具有负值的 int**，则表达式`s.size() < n`几乎肯定是**true**，因为**负值 n**会**自动转换**成一个**较大的无符号值**

  - **字面值和**`string`**对象相加**

    > 1、即使一种类型**并非所需**，我们也可以使用它，不过前提是**这种类型能自动转换成所需类型**  
    > 2、因为**标准库**允许把**字符字面值**和**字符串字面值**转换成`string`**对象**，所以在**需要**`string`**对象的地方**就可以用**这两种字面值**代替  
    > 3、注意：当把`string`**对象**和**这两种字面值**混在一条语句中使用时，必须确保**每个加法运算符**的两侧的**运算对象至少有一个**是`string`

    ```cpp
    string s1 = "hello", s2 = "world";
    string s3 = s1 + "," + s2 + '\n';
    /*------------------------------*/
    // 注意按顺序结合后结果的类型
    string s4 = s1 + ",";               // 正确
    string s5 = "hello" + ",";          // 错误
    string s6 = s1 + "," + "world";     // 正确
    string s7 = "hello" + "," + s2;     // 错误
    ```

- **处理 string 对象中的字符**

  - **引入**

    > 1、我们经常需要**单独处理**`string`**对象**中的**字符**，这类处理的关键问题是**如何获取字符本身**，另一个关键问题是要知道**能改变某个字符的特性**  
    > 2、对于后者，我们可以使用**C 语言继承而来**的`cctype`(即`ctype.h`)，对于后者，我们可以通过**范围 for 语句**实现

  - **范围 for 语句**

    > 1、如果想对`string`**对象**中的**每个字符**做点什么，目前最好的操作是使用**C++11 标准**提供的**范围 for 语句**(语法形式如后附)  
    > 2、其中**变量**将被用于**访问序列中的基础元素**。每次**迭代**，**变量**都会被**初始化**为**对象序列**的**下一个元素值**

    ```cpp
    for (变量 : 对象序列)
    {
        循环体;
    }
    ```

  - **示例：统计标点数并输出标点**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        int ct = 0;
        string s;
        getline(cin, s);
        for (auto c : s)
        {
            if (ispunct(c))
            {
                ct++;
                cout << c << ' ';
            }
        }
        cout << endl << "ct: " << ct << endl;
        return 0;
    }
    ```

  - **使用范围 for 改变字符**

    > 1、如果想要**改变**`string`**对象**中**字符的值**，只需要把**循环变量**定义成**引用**类型即可  
    > 2、记住，所谓**引用**只是**给定对象的一个别名**，因此当**引用**作为**循环控制变量**时，这个变量实际**被依次绑定到**序列的**每个元素**上  
    > 3、下示例将**整个字符串**中的**小写字母**转换成**大写字母**

    ```cpp
    #include <cctype>
    #include <iostream>
    #include <string>

    using std::cin;
    using std::cout;
    using std::endl;
    using std::getline;
    using std::string;

    int main()
    {
        string s;
        getline(cin, s);
        for (auto &c : s)
        {
            c = toupper(c);
            cout << c << ' ';
        }
        cout << endl << s << endl;
    }
    ```

  - **只处理一部分字符**

    > 1、如果只想处理**一部分**字符，那么**范围 for 语句**则**不能很好的胜任**了。通常访问`string`**对象**中的**单个字符**有两种方式：一种是使用**下标**，另一种是使用**迭代器**(后续介绍)  
    > 2、`string`**对象**的下标使用与**C 语言字符数组**规则类似，使用**for 循环遍历处理**。对象的下标必须**大于等于 0**且**小于**`s.size()`

##### **标准库类型 vector**

- **介绍**

  > 1、标准库类型`vector`表示**对象的集合**，其中**所有对象的类型都相同**  
  > 2、集合中的**每个对象**都有一个**与之对应的索引**，索引用于**访问对象**  
  > 3、因为`vector`**容纳着**其他对象，所以它也常常被称作**容器**  
  > 4、要想使用`vector`，必须包含**适当的头文件**。后续的例子中，都假设包含以下声明

  ```cpp
  #include <vector>
  using std::vector;
  ```

- **模板**

  - **模板简介**

    > 1、C++既有**类模板**，也有**函数模板**，其中`vector`是一个**类模板**。只要对 C++有深入了解后才能**写出模板**，我们将在 16 章介绍。但即使不会创建模板，我们也可以试着使用模板  
    > 2、**模板**本身不是**类或函数**，相反可以将**模板**看做**编译器生成类或函数编写**的一份**说明**。编译器**根据模板创建类或函数**的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数**实例化成何种类型**  
    > 3、对于**类模板**来说，我们通过提供一些**额外信息**来指定模板应**实例化成什么样的类**，需要**提供哪些信息**由模板决定。**提供信息的方式**总是这样：在**模板名字**后面跟**一对尖括号**，在**括号内**放上信息，`模板名<信息>;`

  - **vector 模板**

    > 1、例如`vector`模板，**需要提供的信息**是`vector`内存放的**对象类型**(示例如后附代码)  
    > 2、`vector`是**模板**而非**类型**，由`vector`**生成的类型**必须包含`vector`中**所存放元素的类型**，例如`vector<int>`  
    > 3、`vector`能容纳**绝大多数类型**的**对象**作为其**元素**，但是由于**引用不是对象**，所以**不存在包含引用的**`vector`  
    > 4、早期版本 C++中，如果`vector`**的元素**还是`vector`，必须在**外层**的**右尖括号**和**其元素类型**之间添加一个**空格**。比如应该写成`vector<vector<int> >`

    ```cpp
    vector<int> ivec;               // ivec保存int类型的对象
    vector<Sales_item> Sales_vec;   // 保存Sales_item类型的对象
    vector<vector<string>> file;    // 该向量的元素是vector对象
    ```

- **定义和初始化 vector 对象**

  - 下表列出了**初始化**`vector`**对象**的**方法**

    | 方法                       | 说明                                                    |
    | -------------------------- | ------------------------------------------------------- |
    | vector<T> v1               | v1 是一个空 vector，潜在元素为 T 类型，执行默认初始化   |
    | vector<T> v2(v1)           | v2 中包含有 v1 所有元素的副本                           |
    | vector<T> v2 = v1          | 同上等价                                                |
    | vector<T> v3(n,val)        | v3 包含 n 个重复的元素，每个元素值都是 val              |
    | vector<T> v4(n)            | v4 包含 n 个重复执行了值初始化的对象                    |
    | vector<T> v5{a,b,c,...}    | v5 包含了初始值个数的元素，每个元素被赋予了相应的初始值 |
    | vector<T> v5 = {a,b,c,...} | 同上等价                                                |

  - 区分`()`**值初始化**和`{}`**列表初始化**的含义

    > 1、`vector<int> ivec(3,-1)`含义是**ivec**存放了**3 个值为 -1 的元素**；而`vector<int> ivec{3,-1}`含义是**ivec**存放了**两个元素**，**值**分别为**3 和 -1**  
    > 2、`vector<int> ivec(10)`是指**ivec**创建了**10 个执行了值初始化的元素**(如 int 类型会被初始化为 0)  
    > 3、简单地说，想要**初始化多个相同值**就使用`()`**值初始化**，想要**初始化多个不同值**就使用`{}`**列表初始化**

- **向 vector 对象添加元素**

  > 1、经常我们会遇到，创建一个`vector`时并**不清楚**实际所需**元素个数**，元素的**值**也**无法确定**；还有些时候元素初值已知，但这些值**总量较大**且**各不相同**  
  > 2、例如我们需要`vector`**对象**存储 1-100 的数字，对此更好的办法是先创建一个**空**`vector`，然后在**运行时**利用`vector`的**成员函数**`push_back`来**添加数据**  
  > 3、`push_back`负责把**一个值**当成`vector`**对象**的**尾元素**，添加到**对象的尾端**，示例如下  
  > 4、注意：如果循环体内部含有**向**`vector`**添加元素**的语句，则不能使用**范围 for 语句**

  ```cpp
  vector<int> ivec;
  for (int i = 1; i <= 100; i++)
      ivec.push_back(i);
  ```

- **其他 vector 操作**

  - `vector`提供了一些**其他操作**，下表列出其中比较重要的一些

    | 操作             | 含义                                                          |
    | ---------------- | ------------------------------------------------------------- |
    | v.empty()        | 如果 v 不含有任何元素，返回 true，否则返回 false              |
    | v.size()         | 返回 v 中元素的个数，返回值类型是 `vector<T>::size_type` 类型 |
    | v.push_back(t)   | 将值为 t 的元素添加到 v 的尾端                                |
    | v[n]             | 返回 v 中第 n 个位置上元素的引用                              |
    | v1 = v2          | 用 v2 中的元素拷贝替换 v1 中的元素                            |
    | v1 = {a,b,c,...} | 用列表中的元素拷贝替换 v1 中的元素                            |
    | ==,!=,<,<=,>,>=  | 与 string 相同，比较字典序                                    |

- **vector 的索引**

  > 1、和`string`类似，如果需要**逐个访问全部**`vector`**元素**，也可以使用**范围 for 语句**+**引用**  
  > 2、对于需要**非顺序访问**，可以使用**下标**访问，**下标**同样**从 0 开始计算**  
  > 3、注意：只能对**确知已存在的元素**使用**下标操作**，因此**不能使用下标添加元素**，添加元素只能使用`push.back`

##### **迭代器介绍**

- **介绍**

  > 1、我们已经知道可以使用**下标**访问`string`**对象的字符**和`vector`**对象的元素**，还有另一种**更通用的机制**也能实现，就是**迭代器**  
  > 2、除了`vector`外，**标准库**还定义了**其他几种容器**。**所有标准库容器**都能使用**迭代器**，但只有**少数几种**才同时支持**下标操作**  
  > 3、类似于**指针类型**，迭代器也提供对**对象**的**间接访问**，同时迭代器也有**有效**和**无效**之分。**有效**的迭代器**指向某个元素**或指向**容器尾元素的下一位置**，其余都属于**无效**迭代器

- **使用迭代器**

  - **引入**

    > 1、**和指针不同**的是，**获取迭代器**不是使用**取地址符**，**有迭代器的类型**同时拥有**返回迭代器的成员**  
    > 2、比如**这些类型**都拥有名为**begin**和**end**的**成员**，其中**begin 成员**负责返回**指向第一个元素的迭代器**，**end 成员**负责返回**指向容器尾元素下一位置的迭代器**  
    > 3、**end 成员**返回的**迭代器**常被称作**尾后迭代器**，或简称为**尾迭代器**。这样的迭代器没什么实际含义，只是个**标记**而已，表示我们已经处理完了容器中所有元素。特殊情况下，如果**容器为空**，则**begin**和**end**返回的是**同一个迭代器**  
    > 4、一般来说，我们不清楚(也不需要在意)**迭代器的准确类型**是什么，通常使用`auto`**关键字**定义变量来**自动确定类型**

    ```cpp
    // b 表示 v 的第一个元素，e 表示 v 尾元素的下一位置
    auto b = v.begin(), e = v.end();
    ```

  - **迭代器运算符**

    > 1、下表列举了部分**迭代器支持的运算**  
    > 2、和指针类似，也能通过**解引用迭代器**来获取它**所指示的元素**，执行解引用的迭代器**必须合法**并**确实指示着某个元素**  
    > 3、举个例子，使用**迭代器**访问`string`**对象**，将字符串的**首字母大写**(如下例)

    | 运算             | 含义                                                                                                 |
    | ---------------- | ---------------------------------------------------------------------------------------------------- |
    | \*iter           | 返回迭代器 iter 所指元素的引用                                                                       |
    | iter->mem        | 解引用 iter 并获取该元素的名为 mem 的成员，等价于`(*iter).mem`                                       |
    | ++iter 或 iter++ | 令 iter 指示容器中的下一个元素                                                                       |
    | --iter 或 iter-- | 令 iter 指示容器中的上一个元素                                                                       |
    | iter1 == iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |
    | iter1 != iter2   | 判断两个迭代器是否相等，如果两个迭代器指示同一个元素或它们是同一个容器的尾迭代器，则相等，否则不相等 |

    ```cpp
    string s("some thing");
    if (s.begin() != s.end())   // 确保 s 为非空字符串
    {
        auto it = s.begin();    // it 表示 s 的第一个字符
        *it = toupper(*it);     // 改为大写
    }
    ```

  - **将迭代器移动到另外一个元素**

    > 1、**迭代器**使用**递增运算符**`++`来移动到**下一个元素**，使用**递减运算符**`--`来移动到**上一个元素**  
    > 2、因为**end 返回的迭代器**并不实际指示**某个元素**，所以**不能**对其进行**递增**或**解引用**  
    > 3、下例为使用**迭代器**依次访问`string`**对象**的**字符**，将**整个字符串的字母大写**

    ```cpp
    string s("hello world");
    for (auto it = s.begin(); it != s.end(); it++)
        *it = toupper(*it);
    ```

  - **迭代器类型**

    > 1、就像**不知道**`string`和`vector`的`size_type`**成员**到底是**什么类型**一样，一般来说我们也**不知道**(也无需知道)**迭代器的精确类型**  
    > 2、实际上，那些**拥有迭代器**的**标准库类型**使用`iterator`和`const_iterator`来表示**迭代器的类型**，其中`const_iterator`和**常量指针**差不多

    ```cpp
    vector<int>::iterator it1;          // it1 能读写 vector<int> 的元素
    string::iterator it2;               // it2 能读写 string 对象中的字符

    vector<int>::const_iterator it3;    // it3 只能读元素，不能写元素
    string::const_iterator it4;         // it4 只能读字符，不能写字符
    ```

  - `cbegin`**和**`cend`**函数**

    > 1、`begin`和`end`返回的**具体类型**由**对象是否是常量**决定。如果对象**是常量**则返回`const_iterator`，如果**不是常量**在返回`iterator`  
    > 2、有时候这种**默认的行为**并非我们所要，如果对象**只需读无须写**最好使用**常量类型**  
    > 3、为了便于我们得到`const_iterator`**类型的返回值**，C++11 引入了两个**新函数**：`cbegin`和`cend`，其返回值一定是`const_iterator`类型

  - **组合解引用和成员访问操作**

    > 1、**解引用迭代器**可获得迭代器**所指的对象**，如果该**对象的类型**恰好是**类**，就有可能希望进一步**访问它的成员**  
    > 2、例如，对于一个由字符串组成的`vector`**对象**，要想检查其**元素是否为空**，令**it**是该`vector`的**迭代器**，只要检查**it 所指字符串是否为空**即可：`(*it).empty()`(注意前面的括号不可省略，因为关系到运算符优先级问题)  
    > 3、为了简化上述表达式，C++定义了**箭头运算符**`->`。箭头运算符把**解引用**和**成员访问**两个操作**结合在一起**，也就是说，`it->mem`等效于`(*it).mem`

  - **某些对**`vector`**对象的操作会使迭代器失效**

    > 1、虽然`vector`对象可以**动态地增长**，但是也会有一些**副作用**  
    > 2、已知的一个限制是不能在**范围 for 语句**内向`vector`**添加元素**。另外一个限制是任何一种**可能改变**`vector`**对象容量**的操作，比如`push_back`，都会使其**迭代器失效**(后续解释)  
    > 3、谨记，但凡是使用了**迭代器**的**循环体**，**都不要**向迭代器所属容器**添加元素**

- **泛型编程**

  > 1、原来使用 C 或 Java 的程序员转而使用 C++ 后，会对**for 循环**中**大量使用**`!=`而不是`<`进行判断感到奇怪  
  > 2、C++程序员**习惯性使用**`!=`，其原因和他们**更愿意用迭代器而非下标**的原因一样：这种编程风格在**标准库提供的所有容器**上都有效  
  > 3、与之类似，**所有标准库容器的迭代器**都定义了`!=`和`==`，但它们中的**大多数没有定义**`<`**运算符**  
  > 4、因此，只要我们养成使用**迭代器**和`!=`的习惯，就**不用太在意**用的到底是**哪种类型**

- **迭代器运算**

  - 码字中。。。

---

#### **页底评论**

---
