---
title: 高精度算法
author: 圣奇宝枣
description: C/C++的数据类型表示范围有上限，使用高精度算法进行大数运算
sticky: 0
date: 2022-12-23 08:38:58
updated: 2022-12-23 08:38:58
readmore: true
tags:
  - 高精度
  - C语言
  - C++
categories:
  - 编程技巧与算法
---

---

#### **引入**

---

> 1、C 与 C++的数据类型**表示范围有上限**，有时会遇到一些**特别大的数据量级**，使用`unsigned long long`都无法表示  
> 2、此时需要使用**高精度算法**，当然通常只用来**表示数据**和做一些**简单运算**  
> 3、所谓高精度，就是用**字符数组**来**模拟数据运算**(运算过程大多模拟竖式运算)  
> 4、下面将介绍一些**常用的高精度算法**

<!-- more -->

---

#### **高精度加法**

---

```c
#include <stdio.h>
#include <string.h>

// 定义两个字符数组，存储高精度数
char s1[1001], s2[1001];
// 定义int类型数组，用来存储转换后的int类型数字
int a[1001], b[1001], c[1001];

int main(void)
{
    scanf("%s", s1);
    scanf("%s", s2);
    // 存储两个高精度数的位数
    int la = strlen(s1), lb = strlen(s2);

    // 将字符转换为数字，并按照竖式的样式低位对齐存储(倒序转置)
    for (int i = 0; i < la; i++)
        a[la - i - 1] = s1[i] - '0';
    for (int i = 0; i < lb; i++)
        b[lb - i - 1] = s2[i] - '0';

    /*
    此处注意，若
    s1 = 12345， s2 = 827
    转置后低位对齐：
    a = 54321， b = 728
    */

    // 相加的结果的位数最大比这两个数中更大的数的位数多1，因为是下标，所以循环时用<=就会直接多1
    int lc = la > lb ? la : lb;

    // 开始运算，i从lc开始从个位计算，到1为止，因为下标0留给最高位可能的进位
    for (int i = 0; i <= lc; i++)
    {
        // 当前位相加(累加)
        c[i] += a[i] + b[i];
        // 进位
        c[i + 1] = c[i] / 10;
        // 处理当前位
        c[i] %= 10;
    }

    // 删除前导0
    if (c[lc] == 0 && lc > 0)
        lc--;

    // 输出，再次翻转倒序
    for (int i = lc; i >= 0; i--)
    {
        printf("%d", c[i]);
    }
    return 0;
}
```

---

#### **高精度减法**

---

```c
// 如果 a<b，结果等于 -(b-a)，因此应该交换这两个值运算 b-a 再加负号
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

bool flag = false;                 // 是否需要输出负号
char s1[1001], s2[1001], s3[1001]; // 如果需要交换，则用s3作交换中间值
int a[1001], b[1001], c[1001];

// 比较两个数的大小函数，如果s1 > s2，就返回 true，否则 false
bool compare(char *s1, char *s2)
{
    // 先比较位数，位数长的自然大
    int u = strlen(s1), v = strlen(s2);
    if (u != v)
        return u > v;
    // 如果位数相同，从前向后(即高位到低位)比较
    for (int i = 0; i < u; i++)
        if (s1[i] != s2[i])
            return s1[i] > s2[i];
    // 否则就是完全相同
    return true;
}

int main(void)
{
    scanf("%s", s1);
    scanf("%s", s2);

    // 如果 s1 比 s2 大
    if (!compare(s1, s2))
    {
        flag = true;
        strcpy(s3, s1);
        strcpy(s1, s2);
        strcpy(s2, s3);
    }

    // 这段思路与加法相同，记录位数，转置为int类型
    int la = strlen(s1), lb = strlen(s2);
    for (int i = 0; i < la; i++)
        a[la - i - 1] = s1[i] - '0';
    for (int i = 0; i < lb; i++)
        b[lb - i - 1] = s2[i] - '0';

    // lc 最大即为 la，lb 中的更大者
    int lc = la > lb ? la : lb;

    // 开始计算
    for (int i = 0; i < lc; i++)
    {
        // 如果需要借位
        if (a[i] < b[i])
        {
            a[i + 1]--;
            a[i] += 10;
        }
        c[i] = a[i] - b[i];
    }

    // 删除前导0
    while (c[lc] == 0 && lc > 0)
        lc--;

    // 输出
    if (flag)
        printf("-");
    for (int i = lc; i >= 0; i--)
        printf("%d", c[i]);
    return 0;
}
```

---

#### **高精度乘法**

---

- 码字中。。。

---

#### **页底评论**

---
