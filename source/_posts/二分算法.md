---
title: 二分算法
author: 圣奇宝枣
description: 运用二分查找来提高搜索效率
sticky: 0
date: 2023-08-06
updated: 2023-08-06
readmore: true
tags:
  - 二分查找
  - 二分答案
  - C++
categories:
  - 算法
---

---

#### **二分查找**

---

- **引入**

  > 1、假设对于一个**有序数列**，例如`{1, 2, 3, 5, 5, 5, 8, 9}`(实际可能会很长)，我们要在里面查找**某个元素的位置**或其**是否存在**  
  > 2、如果普通地**使用循环遍历**，那么**时间复杂度**为`O(n)`**常数级**；但如果使用**二分查找**，**时间复杂度**仅为`O(log n)`**对数级**，效率大大提升  
  > 3、**二分查找**每次操作得到**当前未比较序列**的**中间下标**`mid`，如果`mid`**对应的值满足**(或不满足)**条件**，则对于**有序数列**而言，`mid`**前面的一系列值都满足**(或都不满足)**条件**，这样便一次查找了**未比较序列**的**一半的元素**，便可根据情况**调整未比较序列的边界**。重复以上操作，直到**未比较序列**都已经比较，整个序列便**按照给定的条件分为了**(满足条件/不满足条件)**两个组别**，**根据实际情况返回下标**即可

<!-- more -->

- **左闭右开的写法**

  > 1、**左闭右开**指的是每次查找的**未比较序列**为`[L, R)`，对于这样的序列，**必须满足**`L != R`**才是合法序列**。这种写法是目前**较为主流的写法**  
  > 2、注意**二分查找**本质上是**将序列按照条件分为两组**，我们用`L`和`R`**标记两组的边界**，而**具体的条件**需要**根据需求更改**，**返回的值**也要**根据需求调整**，因此需要**具体分析**  
  > 3、**大致的代码模板**如下，**需要酌情修改的地方**已**注释标注说明**。下图给出了**面对不同要求**的**调整方法**

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二分查找1.png)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二分查找2.png)

  ```cpp
  #include <iostream>
  using namespace std;

  // [L, R) 左闭右开的写法
  int binary_search(int arr[], int n, int key)
  {
      // L 表示从最左端到下标 L 处都属于 A 组，R 表示从最右端到下标 R 处都属于 B 组
      // L 和 R 都越出边界一个元素，为了应对所有元素都是 A 组或都是 B 组的情况
      int L = -1, R = n;
      int mid;

      // 左闭右开的写法，L 和 R 不能相等，否则是非法区间 [L, R)
      // 直到二者相邻，则表示 A 组 B 组界限已清晰，循环条件也可写为 while(L < R)
      while (L + 1 != R)
      {
          mid = (L + R) / 2;  // 计算中间值下标，向下取整
          if (arr[mid] < key) // 属于 A 组的条件，按照实际需要更改!!!
              L = mid;        // 说明从最左端到 mid 都属于 A 组，L 记录 A 组边界到 mid
          else                // 否则说明属于B组
              R = mid;        // 说明从最右端到 mid 都属于 B 组，R 记录 B 组边界到 mid
      }
      // 至此，数列按照 if 的条件分为了 A B 两组，L 和 R分别表示两组的边界下标，根据实际情况返回 L 或 R 或其他下标
      return R;
  }

  int main()
  {
      int arr[8] = {1, 2, 3, 5, 5, 5, 8, 9};
      // 查找第一个 >=5 的下标：函数 if 的条件为 arr[mid] < 5，这些下标将划归 A 组，其余将划归 B 组
      // 函数返回 R，便是返回 B 组第一个元素下标，即第一个 >=5 的元素下标
      cout << binary_search(arr, 8, 5);
      return 0;
  }
  ```

---

#### **页底评论**

---
