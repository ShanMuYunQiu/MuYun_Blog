---
title: 二分算法
author: 圣奇宝枣
description: 运用二分查找来提高搜索效率，运用二分答案将最值问题转换成判定问题
sticky: 0
date: 2023-08-06
updated: 2023-08-06
readmore: true
tags:
  - 二分查找
  - 二分答案
  - C++
categories:
  - 算法
---

---

#### **二分查找**

---

- **引入**

  > 1、假设对于一个**有序数列**，例如`{1, 2, 3, 5, 5, 5, 8, 9}`(实际可能会很长)，我们要在里面查找**某个元素的位置**或其**是否存在**  
  > 2、如果普通地**使用循环遍历**，那么**时间复杂度**为`O(n)`**常数级**；但如果使用**二分查找**，**时间复杂度**仅为`O(log n)`**对数级**，效率大大提升  
  > 3、**二分查找**每次操作得到**当前未比较序列**的**中间下标**`mid`，如果`mid`**对应的值满足**(或不满足)**条件**，则对于**有序数列**而言，`mid`**前面的一系列值都满足**(或都不满足)**条件**，这样便一次查找了**未比较序列**的**一半的元素**，便可根据情况**调整未比较序列的边界**。重复以上操作，直到**未比较序列**都已经比较，整个序列便**按照给定的条件分为了**(满足条件/不满足条件)**两个组别**，**根据实际情况返回下标**即可

<!-- more -->

- **左闭右开的写法**

  > 1、**左闭右开**指的是每次查找的**未比较序列**为`[L, R)`，对于这样的序列，**必须满足**`L != R`**才是合法序列**。这种写法是目前**较为主流的写法**  
  > 2、注意**二分查找**本质上是**将序列按照条件分为两组**，我们用`L`和`R`**标记两组的边界**，而**具体的条件**需要**根据需求更改**，**返回的值**也要**根据需求调整**，因此需要**具体分析**  
  > 3、**大致的代码模板**如下，**需要酌情修改的地方**已**注释标注说明**。下图给出了**面对不同要求**的**调整方法**

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二分查找1.png)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二分查找2.png)

  ```cpp
  #include <iostream>
  using namespace std;

  // [L, R) 左闭右开的写法
  int binary_search(int arr[], int n, int key)
  {
      // L 表示从最左端到下标 L 处都属于 A 组，R 表示从最右端到下标 R 处都属于 B 组
      // L 和 R 都越出边界一个元素，为了应对所有元素都是 A 组或都是 B 组的情况
      int L = -1, R = n;
      int mid;

      // 左闭右开的写法，L 和 R 不能相等，否则是非法区间 [L, R)
      // 直到二者相邻，则表示 A 组 B 组界限已清晰，循环条件也可写为 while(L < R)
      while (L + 1 != R)
      {
          mid = (L + R) / 2;  // 计算中间值下标，向下取整
          if (arr[mid] < key) // 属于 A 组的条件，按照实际需要更改!!!
              L = mid;        // 说明从最左端到 mid 都属于 A 组，L 记录 A 组边界到 mid
          else                // 否则说明属于B组
              R = mid;        // 说明从最右端到 mid 都属于 B 组，R 记录 B 组边界到 mid
      }
      // 至此，数列按照 if 的条件分为了 A B 两组，L 和 R分别表示两组的边界下标，根据实际情况返回 L 或 R 或其他下标
      return R;
  }

  int main()
  {
      int arr[8] = {1, 2, 3, 5, 5, 5, 8, 9};
      // 查找第一个 >=5 的下标：函数 if 的条件为 arr[mid] < 5，这些下标将划归 A 组，其余将划归 B 组
      // 函数返回 R，便是返回 B 组第一个元素下标，即第一个 >=5 的元素下标
      cout << binary_search(arr, 8, 5);
      return 0;
  }
  ```

- **左闭右闭的写法**

  ```cpp
  #include <iostream>
  using namespace std;

  // [L, R] 左闭右闭的写法：只返回答案，如果没有找到则返回 -1
  int binary_search(int arr[], int n, int key)
  {
      int L = -1, R = n;
      int mid;

      while (L <= R)
      {
          mid = (L + R) / 2;

          if (arr[mid] < key)
              L = mid + 1;
          else if (arr[mid] > key)
              R = mid - 1;
          else
              return mid;
      }
      return -1;
  }

  int main()
  {
      int arr[8] = {1, 2, 3, 5, 5, 5, 8, 9};
      cout << binary_search(arr, 8, 5);
      return 0;
  }
  ```

---

#### **二分答案**

---

- **例题引入**

  > 1、在**二分查找**的基础上，对于**数据量**在**10<sup>5</sup>以上**时，**二分答案**是一种很常用的算法。如果直接**线性处理**且**时间复杂度**达到**O(n<sup>2</sup>)**时，程序大概率会**超时**，而**二分答案**通常至少能将其**优化为**`O(nlog n)`**级别**  
  > 2、在此以[洛谷 P2440](https://www.luogu.com.cn/problem/P2440)为例。该题本身是一个**最值问题**，但直接**求最值很不好求**，但是如果告诉我们切**5cm**一段，变成一个**判定问题**就**比较简单**了，**二分答案**便可以将一个**最值问题**转换成**判定问题**  
  > 3、但我们并**不知道答案是多少**，因此我们可以先**假设答案的范围**为**1 ~ 10<sup>9</sup>**(实际不需要这么大，根据情况分析)。在这个范围内，如果**某个数不是答案**，那**这个数到右边**的范围**都不是答案**；同理**如果一个答案可以**，那**这个数到左边**的范围**都可以是答案**。因此，这种问题便可以**对答案进行二分讨论**  
  > 4、通常当一个问题**可以二分答案**时，我们需要定义一个`check`**函数**用来进行判定，在`main`中通过**二分查找**的形式来**二分答案**

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  // 原木的数量 和 需要切成小段的数量
  int n, k;
  int len[100001];

  // 判断答案是否成立
  bool check(int mid)
  {
      long long ct = 0;

      if (mid == 0) // 防止除数为 0
          return false;

      for (int i = 0; i < n; i++)
      {
          ct += len[i] / mid;
      }
      return ct >= k;
  }

  int main()
  {
      cin >> n >> k;
      int max_len = -1; // 所有原木的最长的长度，作为右端点

      for (int i = 0; i < n; i++)
      {
          cin >> len[i];
          max_len = len[i] > max_len ? len[i] : max_len;
      }

      int L = 0, R = max_len, mid;
      while (L + 1 != R)
      {
          mid = (L + R) / 2;
          if (check(mid)) // 如果是答案
              L = mid;
          else
              R = mid;
      }

      // L 指向满足要求的答案中最大的答案位置(分界的标记处)
      cout << L << endl;
      return 0;
  }
  ```

---

#### **页底评论**

---
