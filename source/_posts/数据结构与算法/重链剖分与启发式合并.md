---
title: 重链剖分与启发式合并
author: 山暮云秋
description: 学习重链剖分及其应用，了解启发式合并的思路
sticky: 0
readmore: true
tags:
  - 重链剖分
  - LCA
  - 启发式合并
  - 树
  - 图
  - C++
categories:
  - 数据结构与算法
abbrlink: 5499b3ee
date: 2025-03-09 00:00:00
updated: 2025-03-10 00:00:00
---

---

### **重链剖分**

---

- **重链**

  > 1、**重儿子**：一个节点的**最重**的儿子，即 **size 最大**(子树大小最大)的儿子。一个节点**至多有一个重儿子**，其余都是轻儿子  
  > 2、**重链**：从某个节点开始，一直走**重儿子**得到的一条链，称为**重链**。一张图中可能有多条重链，树上的一条简单路径，至多经过 $\log n$ 条重链  
  > 3、**链顶**(顶)：一条重链中**深度最小的节点**，称为**链顶**，通常直接称为**顶**  
  > 4、如下图，图中节点旁的**数字**表示**节点的 size**，标记**红色点**为**顶**，**红色边**连接的路径为**一条重链**，**单独的顶**也是**一条重链**

  <!-- more -->

  ![](https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/%E7%AE%97%E6%B3%95/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86.png)

- **重链剖分**

  > 1、将一张图**划分为多条重链**，称为**重链剖分**。观察上图，用 $son[]$ 标记**每个节点的重儿子**，如 $son[1] = 6$；用 $top[]$ 标记每个节点**所属重链的顶**，如 $top[1,6,8,10,12] = 1$，这样做的目的是可以**迅速找到链顶**并**跳跃到其他链**  
  > 2、要进行**重链剖分**，实际就是求 $son[]$ 和 $top[]$。实际实现时，首先跑**第一遍 DFS**，递归地处理出**每个节点的 size**，可以顺便求出 $son[]$，再跑**第二遍 DFS**，递归地处理 $top[]$  
  > 3、对于**第二次 DFS**，多使用一个参数 $t$ **传递链顶**。先走**重儿子** $son[x]$(需要先判断是否存在)，此时传递 $t = t$，即 $son[x]$ 与 $x$ **链顶相同**；之后遍历走**轻儿子** $y$，传递 $t = y$，即 $y$ 为**一条新的重链的链顶**。具体模板实现如下，具体应用见例题

- **模板实现**

  ```cpp
  vector<int> g[N];
  int sz[N], son[N], top[N];

  // 处理 size[] 和 son[]
  void DFS1(int x)
  {
      // 先将每个新点自己的大小标记为 1
      sz[x] = 1;

      // 遍历子节点
      for (auto &y : g[x])
      {
          DFS1(y);

          // 递回时，加上子节点子树的大小
          sz[x] += sz[y];

          // 如果当前子节点 size 最大，标记为 x 的重儿子
          if (sz[y] > sz[son[x]])
              son[x] = y;
      }
  }

  // 处理 top[]，参数 t 传递链顶
  void DFS2(int x, int t)
  {
      // 标记 top[]
      top[x] = t;

      // 对于重儿子，son[x] 链顶与 x 相同
      if (son[x])
          DFS2(son[x], t);

      // 遍历所有轻儿子，轻儿子为新的重链链顶
      for (auto &y : g[x])
          if (y != son[x])
              DFS2(y, y);
  }
  ```

---

### **例-重链剖分 LCA**

---

- **重链剖分 LCA**

  > 1、[LCA](https://www.starrycoding.com/problem/92)：输入树的**节点个数** $n$，这棵树**以节点** $1$ **为根**，接下来 $n-1$ 行，分别输入节点 $2 \to n$ 的**父节点**，再输入**询问次数** $q$，每个询问给出**两个整数** $u, v$，输出 $u, v$ 的**最近公共祖先** $lca(u,v)$  
  > 2、以求下图 $lca(5, 11)$ 为例，假设图已按照上述方式进行**重链剖分**。两个点如果**在同一条链上**，那么**深度较小的点**即为 $lca$；只要**不在一条链上**，就将 $top$ **较深的向上跳**，因为此时我们将**点的问题**转换成了**链的问题**，则应该关注**链顶**的位置，直到两点位于**同一条链**上  
  > 3、对于每次跳跃，**链顶的父亲**一定位于一条**新的链上**，便跳跃到**链顶的父亲**到达**新的链**。由于任意一条**简单路径**经过的**重链数**最多为 $\log n$，所以跳跃次数**不会超过** $\log n$ **次**。对于该问题，需要额外的 $fa[]$ 和 $dep[]$ 数组存储**父节点**和**深度**  
  > 4、该例为**重链剖分优化复杂度**的一个简单示例，后续例子将学习重链剖分的**更高级更常用的应用**

  ![](https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/%E7%AE%97%E6%B3%95/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86.png)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;

  vector<int> g[N];
  int fa[N], dep[N];         // 父节点和深度
  int sz[N], son[N], top[N]; // 重链剖分

  // 处理 size[] 和 son[]，额外处理 dep[]
  void DFS1(int x, int pre)
  {
      // 先将每个新点自己的大小标记为 1
      sz[x] = 1;

      // 处理深度 pre
      dep[x] = dep[pre] + 1;

      // 遍历子节点
      for (auto &y : g[x])
      {
          DFS1(y, x);

          // 递回时，加上子节点子树的大小
          sz[x] += sz[y];

          // 如果当前子节点 size 最大，标记为 x 的重儿子
          if (sz[y] > sz[son[x]])
              son[x] = y;
      }
  }

  // 处理 top[]，参数 t 传递链顶
  void DFS2(int x, int t)
  {
      // 标记 top[]
      top[x] = t;

      // 对于重儿子，son[x] 链顶与 x 相同
      if (son[x])
          DFS2(son[x], t);

      // 遍历所有轻儿子，轻儿子为新的重链链顶
      for (auto &y : g[x])
          if (y != son[x])
              DFS2(y, y);
  }

  // 求 LCA
  int LCA(int x, int y)
  {
      // 只要不在同一条链上
      while (top[x] != top[y])
      {
          // 将链顶 top 低的向上跳，跳至链顶父节点
          if (dep[top[x]] < dep[top[top[y]]])
              swap(x, y);
          x = fa[top[x]];
      }

      // 在同一条链，返回深度浅的
      return dep[x] < dep[y] ? x : y;
  }

  void solve()
  {
      int n;
      cin >> n;
      for (int i = 2; i <= n; i++)
      {
          cin >> fa[i];
          g[fa[i]].push_back(i);
      }

      DFS1(1, 0); // 第一轮 DFS
      DFS2(1, 1); // 第二轮 DFS

      int q;
      cin >> q;
      while (q--)
      {
          int x, y;
          cin >> x >> y;
          cout << LCA(x, y) << '\n';
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **例-树链剖分**

---

- **树链剖分**

  > 1、[树链剖分](https://www.starrycoding.com/problem/92)：输入 $n, m, r, p$ 分别表示**树的节点个数**、**操作个数**、**根节点序号**、**模数**($n, m \leq 10^5$)。接下来 $n$ 行，输入**非负值**表示各个节点的**初始数值**；下面 $n-1$ 行，每行输入 $x, y$ 表示两点间**连有一条边**。对于 $m$ 个操作，输入 $1\ x\ y\ z$ 表示树上从 $x$ 到 $y$ 的最短路径上所有节点值 $+ z$；输入 $2\ x\ y$ 输出树上从 $x$ 到 $y$ 的最短路径上所有节点值之和；输入 $3\ x\ z$ 表示将以 $x$ 为根的子树内所有节点值 $+ z$；输入 $4\ x$ 输出以 $x$ 为根的子树内所有节点值之和。输出的**结果对** $p$ **取模**  
  > 2、对于**区间和维护**可以使用**线段树**，但这是一个**树上问题**而非**连续区间问题**，因此可以引入**时间戳** $dfn$ 表示 **DFS 序**，注意重链剖分的 **DFS 先走重儿子**，这样使得**同一重链上**的节点 $dfn$ **是连续的**，此时便转换成了**连续区间**，可以根据 $dfn$ **建线段树**(如下图，点右侧数字为 $dfn$ 时间戳，线段树处理的区间上红色线段对应图中一条重链)  
  > 3、对于题目前两种操作，与求 $lca$ 的思路类似，因为树上两点**最短路径**为 $x \to lca(x, y) \to y$。实际实现时，是让 $x,y$ 到达 $lca(x,y)$，同样每次将**链顶深度较深的点向上跳**，但跳跃前要对**线段树的区间** $[dfn[top[x]], dfn[x]]$ 进行**累加**或者**求和**(处理当前所处链上的需要处理的点，且这段区间一定是连续的)；重复操作直至两点**在同一重链**，则最后一条需要处理的链对应到**线段树的区间**的下标，为两点中**深度较浅的点** $dfn$ 到**深度较深的点** $dfn$。例如下图中，处理点 $8$ 到 $7$ 路径上点 $+2$ 的过程为：线段树的区间 $[6,6] + 2$，点 $8$ 跳到 $5$；线段树的区间 $[9, 10] + 2$，点 $7$ 跳到 $1$；线段树的区间 $[1, 3] + 2$，完成操作  
  > 4、对于题目后两种操作，对于处理 $x$ **这棵子树**，令 $x$ 点的 $dfn[x] = k$，那么**这棵子树**的所有点的 $dfn$ **范围**一定在 $[k, k + sz[x] - 1]$，且**该区间一定连续**。因此，这两种操作同样是对线段树上这段**连续的** $dfn$ **区间**进行操作

  ![](https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/%E7%AE%97%E6%B3%95/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%862.png)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  using ll = long long;
  const int N = 1e5 + 10;

  ll n, m, r, p;
  vector<int> g[N];
  ll a[N], t[N << 2], lz[N << 2]; // 线段树
  ll sz[N], son[N], top[N];       // 重链剖分
  ll fa[N], dep[N];               // 父节点和深度
  ll dfn[N], idx;                 // 时间戳

  // 求 sz 和 son，建立 fa 和 dep
  void DFS1(int x, int pre)
  {
      sz[x] = 1;

      fa[x] = pre;
      dep[x] = dep[pre] + 1;

      for (auto &y : g[x])
      {
          // 不走父亲
          if (y == pre)
              continue;

          DFS1(y, x);

          sz[x] += sz[y];
          if (sz[y] > sz[son[x]])
              son[x] = y;
      }
  }

  // 求 top，建立 dfn(先走重儿子)
  void DFS2(int x, int t)
  {
      top[x] = t;
      dfn[x] = ++idx;

      // 先走重儿子
      if (son[x])
          DFS2(son[x], t);

      // 再走轻儿子
      for (auto &y : g[x])
      {
          // 额外特判 fa[x]，不走父亲
          if (y == fa[x] || y == son[x])
              continue;

          DFS2(y, y);
      }
  }

  // 线段树
  void pushup(int o)
  {
      t[o] = (t[o << 1] + t[o << 1 | 1]) % p;
  }

  // buildTree 在 solve() 中直接通过 add() 实现

  void update(int s, int e, int o, ll x)
  {
      t[o] = t[o] + x * (e - s + 1) % p;
      lz[o] = lz[o] + x % p;
  }

  void pushdown(int s, int e, int o)
  {
      if (!lz[o])
          return;

      int mid = (s + e) >> 1;
      update(s, mid, o << 1, lz[o]);
      update(mid + 1, e, o << 1 | 1, lz[o]);
      lz[o] = 0;
  }

  void add(int l, int r, ll x, int s = 1, int e = n, int o = 1)
  {
      if (l <= s && e <= r)
      {
          update(s, e, o, x);
          return;
      }

      pushdown(s, e, o);

      int mid = (s + e) >> 1;
      if (mid >= l)
          add(l, r, x, s, mid, o << 1);
      if (mid + 1 <= r)
          add(l, r, x, mid + 1, e, o << 1 | 1);

      pushup(o);
  }

  ll query(int l, int r, int s = 1, int e = n, int o = 1)
  {
      if (l <= s && e <= r)
          return t[o];

      pushdown(s, e, o);

      int mid = (s + e) >> 1;
      ll res = 0;
      if (mid >= l)
          res = (res + query(l, r, s, mid, o << 1)) % p;
      if (mid + 1 <= r)
          res = (res + query(l, r, mid + 1, e, o << 1 | 1)) % p;

      return res;
  }

  // 操作 1，将 x y 路径上点 + z
  void LCA_add(ll x, ll y, ll z)
  {
      // 只要不在同一条链上
      while (top[x] != top[y])
      {
          // 深度较深的往上跳
          if (dep[top[x]] < dep[top[y]])
              swap(x, y);

          // 将要处理的链上的点 + z 再向上跳
          add(dfn[top[x]], dfn[x], z);
          x = fa[top[x]];
      }

      // 在同一条链上，处理剩下的链
      if (dep[x] > dep[y])
          swap(x, y);
      add(dfn[x], dfn[y], z);
  }

  // 操作 2，求 x y 路径上点之和，由操作 1 修改
  ll LCA_sum(ll x, ll y)
  {
      ll ans = 0;

      // 只要不在同一条链上
      while (top[x] != top[y])
      {
          // 深度较深的往上跳
          if (dep[top[x]] < dep[top[y]])
              swap(x, y);

          // 将要处理的链上的点相加
          ans = (ans + query(dfn[top[x]], dfn[x])) % p;
          x = fa[top[x]];
      }

      // 在同一条链上，处理剩下的链
      if (dep[x] > dep[y])
          swap(x, y);
      ans = (ans + query(dfn[x], dfn[y])) % p;

      return ans;
  }

  void solve()
  {
      cin >> n >> m >> r >> p;
      for (int i = 1; i <= n; i++)
          cin >> a[i];

      for (int i = 1; i < n; i++)
      {
          int x, y;
          cin >> x >> y;
          g[x].push_back(y);
          g[y].push_back(x);
      }

      // 重链剖分
      DFS1(r, 0);
      DFS2(r, r);

      // buildTree，将 a[i] 按 dfn 对应到线段树上
      for (int i = 1; i <= n; i++)
          add(dfn[i], dfn[i], a[i]);

      while (m--)
      {
          int op;
          cin >> op;

          ll x, y, z;
          if (op == 1)
          {
              cin >> x >> y >> z;
              LCA_add(x, y, z);
          }
          else if (op == 2)
          {
              cin >> x >> y;
              cout << LCA_sum(x, y) << '\n';
          }
          else if (op == 3)
          {
              cin >> x >> z;
              // 令 k = dfn[x]，将 [k, k + sz[x] - 1] + z
              add(dfn[x], dfn[x] + sz[x] - 1, z % p);
          }
          else
          {
              cin >> x;
              cout << query(dfn[x], dfn[x] + sz[x] - 1) << '\n';
          }
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **页底评论**

---
