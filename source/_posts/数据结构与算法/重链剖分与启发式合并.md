---
title: 重链剖分与启发式合并
author: 山暮云秋
description: 学习重链剖分及其应用，了解启发式合并的思路
sticky: 0
readmore: true
tags:
  - 重链剖分
  - LCA
  - 启发式合并
  - 树
  - 图
  - C++
categories:
  - 数据结构与算法
abbrlink: 5499b3ee
date: 2025-03-09 00:00:00
updated: 2025-03-09 00:00:00
---

---

### **重链剖分**

---

- **重链**

  > 1、**重儿子**：一个节点的**最重**的儿子，即 **size 最大**(子树大小最大)的儿子。一个节点**至多有一个重儿子**，其余都是轻儿子  
  > 2、**重链**：从某个节点开始，一直走**重儿子**得到的一条链，称为**重链**。一张图中可能有多条重链，树上的一条简单路径，至多经过 $\log n$ 条重链  
  > 3、**链顶**(顶)：一条重链中**深度最小的节点**，称为**链顶**，通常直接称为**顶**  
  > 4、如下图，图中节点旁的**数字**表示**节点的 size**，标记**红色点**为**顶**，**红色边**连接的路径为**一条重链**，**单独的顶**也是**一条重链**

  <!-- more -->

  ![](https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/%E7%AE%97%E6%B3%95/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86.png)

- **重链剖分**

  > 1、将一张图**划分为多条重链**，称为**重链剖分**。观察上图，用 $son[]$ 标记**每个节点的重儿子**，如 $son[1] = 6$；用 $top[]$ 标记每个节点**所属重链的顶**，如 $top[1,6,8,10,12] = 1$，这样做的目的是可以**迅速找到链顶**并**跳跃到其他链**  
  > 2、要进行**重链剖分**，实际就是求 $son[]$ 和 $top[]$。实际实现时，首先跑**第一遍 DFS**，递归地处理出**每个节点的 size**，可以顺便求出 $son[]$，再跑**第二遍 DFS**，递归地处理 $top[]$  
  > 3、对于**第二次 DFS**，多使用一个参数 $t$ **传递链顶**。先走**重儿子** $son[x]$(需要先判断是否存在)，此时传递 $t = t$，即 $son[x]$ 与 $x$ **链顶相同**；之后遍历走**轻儿子** $y$，传递 $t = y$，即 $y$ 为**一条新的重链的链顶**。具体模板实现如下，具体应用见例题

- **模板实现**

  ```cpp
  vector<int> g[N];
  int son[N], sz[N], top[N];

  // 处理 size[] 和 son[]
  void DFS1(int x)
  {
      // 先将每个新点自己的大小标记为 1
      sz[x] = 1;

      // 遍历子节点
      for (auto &y : g[x])
      {
          DFS1(y);

          // 递回时，加上子节点子树的大小
          sz[x] += sz[y];

          // 如果当前子节点 size 最大，标记为 x 的重儿子
          if (sz[y] > sz[son[x]])
              son[x] = y;
      }
  }

  // 处理 top[]，参数 t 传递链顶
  void DFS2(int x, int t)
  {
      // 标记 top[]
      top[x] = t;

      // 对于重儿子，son[x] 链顶与 x 相同
      if (son[x])
          DFS2(son[x], t);

      // 遍历所有轻儿子，轻儿子为新的重链链顶
      for (auto &y : g[x])
          if (y != son[x])
              DFS2(y, y);
  }
  ```

---

### **例-重链剖分 LCA**

---

- **重链剖分 LCA**

  > 1、[LCA](https://www.starrycoding.com/problem/92)：输入树的**节点个数** $n$，这棵树**以节点** $1$ **为根**，接下来 $n-1$ 行，分别输入节点 $2 \to n$ 的**父节点**，再输入**询问次数** $q$，每个询问给出**两个整数** $u, v$，输出 $u, v$ 的**最近公共祖先** $lca(u,v)$  
  > 2、以求下图 $lca(5, 11)$ 为例，假设图已按照上述方式进行**重链剖分**。两个点如果**在同一条链上**，那么**深度较小的点**即为 $lca$；只要**不在一条链上**，就将 $top$ **较深的向上跳**，因为此时我们将**点的问题**转换成了**链的问题**，则应该关注**链顶**的位置，直到两点位于**同一条链**上  
  > 3、对于每次跳跃，**链顶的父亲**一定位于一条**新的链上**，便跳跃到**链顶的父亲**到达**新的链**。由于任意一条**简单路径**经过的**重链数**最多为 $\log n$，所以跳跃次数**不会超过** $\log n$ **次**。对于该问题，需要额外的 $fa[]$ 和 $dep[]$ 数组存储**父节点**和**深度**  
  > 4、该例为**重链剖分优化复杂度**的一个简单示例，后续例子将学习重链剖分的**更高级更常用的应用**

  ![](https://jsd.vxo.im/gh/ShanMuYunQiu/Image/blog/%E7%AE%97%E6%B3%95/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86.png)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;

  vector<int> g[N];
  int fa[N], dep[N];         // 父节点和深度
  int son[N], sz[N], top[N]; // 重链剖分

  // 处理 size[] 和 son[]，额外处理 dep[]
  void DFS1(int x, int pre)
  {
      // 先将每个新点自己的大小标记为 1
      sz[x] = 1;

      // 处理深度 pre
      dep[x] = dep[pre] + 1;

      // 遍历子节点
      for (auto &y : g[x])
      {
          DFS1(y, x);

          // 递回时，加上子节点子树的大小
          sz[x] += sz[y];

          // 如果当前子节点 size 最大，标记为 x 的重儿子
          if (sz[y] > sz[son[x]])
              son[x] = y;
      }
  }

  // 处理 top[]，参数 t 传递链顶
  void DFS2(int x, int t)
  {
      // 标记 top[]
      top[x] = t;

      // 对于重儿子，son[x] 链顶与 x 相同
      if (son[x])
          DFS2(son[x], t);

      // 遍历所有轻儿子，轻儿子为新的重链链顶
      for (auto &y : g[x])
          if (y != son[x])
              DFS2(y, y);
  }

  // 求 LCA
  int LCA(int x, int y)
  {
      // 只要不在同一条链上
      while (top[x] != top[y])
      {
          // 将链顶 top 低的向上跳，跳至链顶父节点
          if (dep[top[x]] < dep[top[top[y]]])
              swap(x, y);
          x = fa[top[x]];
      }

      // 在同一条链，返回深度浅的
      return dep[x] < dep[y] ? x : y;
  }

  void solve()
  {
      int n;
      cin >> n;
      for (int i = 2; i <= n; i++)
      {
          cin >> fa[i];
          g[fa[i]].push_back(i);
      }

      DFS1(1, 0); // 第一轮 DFS
      DFS2(1, 1); // 第二轮 DFS

      int q;
      cin >> q;
      while (q--)
      {
          int x, y;
          cin >> x >> y;
          cout << LCA(x, y) << '\n';
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **页底评论**

---
