---
title: 乘法逆元
author: 山暮云秋
description: 运用乘法逆元解决模意义下的除法问题，将其转换为模意义下的乘法，了解多种求乘法逆元的思路
sticky: 0
readmore: true
tags:
  - 乘法逆元
  - 数学
  - C++
categories:
  - 数据结构与算法
abbrlink: bfaab9bd
date: 2023-08-12 00:00:00
updated: 2023-08-13 00:00:00
---

---

#### **乘法逆元介绍**

---

- **引入**

  > 1、对于**模意义下的运算**，例如我们知道**有**`(a + b) % p = (a % p) + (b % p)`或者`(a * b) % p = (a % p) * (b % p)`**成立**，但是对于**模意义下的除法**却**不成立**：`(a / b) % p != (a % p) / (b % p)`。不过，我们可以把**模意义的除法**转换成**模意义的乘法**  
  > 2、举例探讨：(7 / 2) % 5 中，把**除法转成乘法**写作 (7 \* (1/2)) % 5，再将**分数**写成**幂的形式**写作 (7 \* 2<sup>-1</sup>) % 5  
  > 3、由于**取模运算**的**结果一定是整数**，所以 (7 \* 2<sup>-1</sup>) % 5 **结果一定是整数**，即说明必定能把 2<sup>-1</sup> 这个分数**转换成某个整数**。所以，问题的关键就在于**能转换成哪个整数**  
  > 4、这时便需要引入**乘法逆元**的概念了，它可以辅助我们完成**模意义的除法**到**模意义的乘法**的**转换**

<!-- more -->

- **乘法逆元**

  > 1、类比初中的**倒数**的概念：如果 **a \* b = 1**，则 **a 和 b 互为倒数**。对于 (7 \* 2<sup>-1</sup>) % 5 来说，其**可以等价地写成** (7 \* 3) % 5，这是因为**在模 5 下**，有 (3 \* 2) % 5 = 1 成立。可以**近似地理解成**，**3 和 2** 在**模 5** 下**互为倒数**，但这里实际**不称作倒数**，而称作**乘法逆元**  
  > 2、因此，对于上面的例子，**7 乘 (1/2) 模 5**，就可以理解成**7 乘 (2 的乘法逆元) 模 5**，这样便可以**转换成模意义的乘法**得到结果。即**被除数**除以**除数**再**模 n**，等同于**被除数**乘**除数的乘法逆元**再**模 n**  
  > 3、如何得到**乘法逆元**？例如**求 (1/2) 在模 7 下的乘法逆元**，就要看**谁乘 2 模 7 等于 1**，显然存在 (2 \* 4) % 7 = 1，因此**4 是 (1/2) 的乘法逆元**，算式写作 2<sup>-1</sup> mod 7 = 4。注意此时式子中 2<sup>-1</sup> **代表逆元**，**而不是分数**  
  > 4、**乘法逆元**的**详细定义**如下图。**模运算**下也会继承一些**普通幂运算的性质**，如下图的**运算示例**。**乘法逆元**还有一些**性质**，如下图

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/乘法逆元.png)
  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/乘法逆元运算.png)
  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/乘法逆元性质.png)

---

#### **求逆元-拓展欧几里得算法**

---

- **引入**

  > 1、由于前面**乘法逆元性质**中提到，只有当`gcd(a, n) = 1`(即 a, n 互素，n 为模数)才有**乘法逆元**存在。先前介绍过[拓展欧几里得算法](../394de44a/)，因为`gcd(a, n) = 1`，根据**裴蜀定理**一定有`as + nt = gcd(a, n) = 1`，**等式两边同时模 n**，便得到 **a\*s 和 1 在模 n 下同余**。易知，**模 n 下 a 的乘法逆元是 s**  
  > 2、因此，要求**乘法逆元**时，就可以调用**拓展欧几里得算法**，把 **a, n** 当做参数传入，其**返回的 s 即为所求**。要得到**最小的正整数**的**乘法逆元**`inv[b]`，只需要处理一下 s：`inv_b = (s % n + n) % n`

- **代码实现**

  ```cpp
  #include <iostream>
  using namespace std;

  int ex_gcd(int a, int b, int &s, int &t)
  {
      // s, t 表示 s_i 和 t_i，其默认值为 s_1 = 0 和 t_1 = 1
      // s_ 和 t_ 表示 s_i-1 和 t_i-1，其默认值表示 s_0 = 1 和 t_0 = 0
      int s_ = 1, t_ = 0, q, temp;
      while (a % b)
      {
          q = a / b;

          // 迭代公式：s_i+1 = s_i-1 - s_i * q_i
          temp = s;       // 记录当前 s_i
          s = s_ - s * q; // 计算 s_i+1
          s_ = temp;      // 下一轮 s_i
          // 迭代公式计算 t_i+1
          temp = t;
          t = t_ - t * q;
          t_ = temp;

          temp = a % b;
          a = b;
          b = temp;
      }
      return b;
  }

  int main()
  {
      // 求 (a / b) % n 的值，易证 s 为 b 的乘法逆元
      // s, t 表示 s_i 和 t_i，其默认值为 s_1 = 0 和 t_1 = 1
      int a, b, n, s = 0, t = 1;
      cin >> a >> b >> n;

      // 如果 b, n 互素，才有乘法逆元；算出 b 的乘法逆元，存入 s
      if (ex_gcd(b, n, s, t) == 1)
      {
          // 得到最小的正整数的乘法逆元
          int inv_b = (s % n + n) % n;
          // 被除数 除以 除数 再模 n，等同于 被除数 乘 除数的乘法逆元 再模 n
          // 对于模乘法，(a * b) % n = ((a % n) * (b % n)) % n
          cout << ((a % n) * (inv_b % n)) % n;
      }
      else
          cout << "Impossible";
      return 0;
  }
  ```

---

#### **求逆元-快速幂 & 费马小定理**

---

- **引入**

  > 1、**费马小定理**：若有**整数 a, p** 且 **p 为质数**，则有 **a<sup>p</sup> - a 是 p 的倍数**，也可以表示为 **a<sup>p</sup> 与 a 在模 p 下同余**。如果 **a 不是 p 的倍数**的话，这个定理可描述为 **a<sup>p-1</sup> 和 1 在模 p 下同余**  
  > 2、因为**乘法逆元性质**有`gcd(a, n) = 1`(a, n 互素，n 为模数)，满足 **a 不是 n 的倍数**。因此，当 **n 为质数**时(必须条件)，一定有 **a<sup>n-1</sup> 和 1** 在模 n 下同余，又因为**乘法逆元定义**中有 **a\*z 和 1** 在模 n 下同余(z 为 a 的乘法逆元)，因此得到 **a\*z 和 a<sup>n-1</sup>** 在模 n 下同余。两边**同时除以 a**，得到 **z 和 a<sup>n-2</sup>** 在模 n 下同余  
  > 3、因此，在 **n 为质数**的情况下(1e9 + 7 是常见的满足条件的模数)，要求**乘法逆元 z**，只需要求 **a<sup>n-2</sup> % n** 的值，使用**快速幂**(幂取模)来计算即可

- **代码实现**

  ```cpp
  #include <iostream>
  using namespace std;

  int gcd(int a, int b)
  {
      int temp;
      while (a % b)
      {
          temp = a;
          a = b;
          b = temp % b;
      }
      return b;
  }

  // 幂取模
  unsigned long long ModExp(int a, int n, int m)
  {
      unsigned long long result = 1;
      a %= m; // 对第一次的乘数 a 取模

      while (n)
      {
          if (n & 1)
              result = (result * a) % m; // 对结果取模，结果又是下一次运算的乘数之一

          a = (a * a) % m; // 对乘数 a 取模
          n >>= 1;
      }

      return result;
  }

  int main()
  {
      // 求 (a / b) % n 的值
      int a, b, n;
      cin >> a >> b >> n;

      // 如果 b, n 互素，才有乘法逆元；只有 n 为质数才可以用快速幂(is_prime细节省略)
      if (gcd(b, n) == 1 && is_prime(n))
      {
          // b 的乘法逆元
          int inv_b = ModExp(b, n - 2, n) % n;
          cout << ((a % n) * (inv_b % n)) % n;
      }
      else
          cout << "Impossible";
      return 0;
  }
  ```

---

#### **求逆元-线性递推**

---

- **引入**

  > 1、设有`n = a * q + r`(a, n 互素，n 为模数)，必然有 **aq + r 与 0** 在模 n 下同余，且有`q = n / a`，`r = n % a`  
  > 2、令**同余方程**两边同乘 a<sup>-1</sup> \* r<sup>-1</sup>(即`inv[a] * inv[r]`)，因为**乘法逆元定义**中有`(a * inv[a]) % n = 1`，所以方程可变为 **q \* inv[r] + inv[a] 与 0** 在模 n 下同余，移项得到 **inv[a] 与 -q \* inv[r]** 在模 n 下同余。把第一步得到的 **q, n 的值带入**，最终得到 **inv[a] 与 -(n / a) \* inv[n % a]** 在模 n 下同余  
  > 3、分析可得，**同余方程右侧**的`[n % a]`**一定小于方程左侧**的`[a]`，这说明如果通过**递推的方式求左侧值**时，**右侧的值都是已知的**，只需要给出`inv[0] = 0, inv[1] = 1`(0 没有乘法逆元，1 的乘法逆元是 1)作为**递推初始值**即可。另外，**右侧的有**`-(n / a)`使得**求得的左侧值**可能是**负值**，因此需要转换成**最小的正整数**的**乘法逆元**：`inv = (inv % n + n) % n`  
  > 4、因此，要求**乘法逆元 z**(`z = inv[a]`)，可以通过**递推式**`inv[a] = -n / a * inv[n % a]`**计算**(其中`inv[0] = 0, inv[1] = 1`，每次计算后须转换为最小正整数乘法逆元)

- **代码实现**

  ```cpp
  #include <iostream>
  using namespace std;

  // inv[0] = 0, inv[1] = 1
  int inv[1000001] = {0, 1};

  int gcd(int a, int b)
  {
      int temp;
      while (a % b)
      {
          temp = a;
          a = b;
          b = temp % b;
      }
      return b;
  }

  // 转换成最小正整数逆元
  int pos_mod(int a, int n)
  {
      return (a % n + n) % n;
  }

  // 递归计算乘法逆元
  int get_inv(int a, int n)
  {
      // 直到计算到 inv[a]，可能是inv[0] 或 inv[1]
      if (inv[a])
          return inv[a];
      // 递推表达式，未知值继续递归
      inv[a] = pos_mod(-n / a * get_inv(n % a, n), n);

      return inv[a]; // 返回最后的结果
  }

  int main()
  {
      // 求 (a / b) % n 的值
      int a, b, n;
      cin >> a >> b >> n;

      // 如果 b, n 互素，才有乘法逆元
      if (gcd(b, n) == 1)
      {
          int inv_b = get_inv(b, n);
          cout << ((a % n) * (inv_b % n)) % n;
      }
      else
          cout << "Impossible";
      return 0;
  }
  ```

---

#### **页底评论**

---
