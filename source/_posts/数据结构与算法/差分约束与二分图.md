---
title: 差分约束与二分图
author: 山暮云秋
description: 学习差分约束系统，学习二分图染色与匈牙利算法
sticky: 0
readmore: true
tags:
  - 差分约束
  - 二分图染色
  - 匈牙利算法
  - 图
  - C++
categories:
  - 数据结构与算法
abbrlink: e8bacb09
date: 2025-03-03 00:00:00
updated: 2025-03-04 00:00:00
---

---

### **差分约束**

---

- **差分约束**

  > 1、[差分约束](https://www.starrycoding.com/problem/104)：有 $T$ 组样例($T \leq 10^3$)，对于每组样例，给定 $n$ 和 $m$ ($n,m \leq 5 \times 10^3$)，表示有 $n$ 个**未知量**和一个大小为 $m$ 的**不等式组**。对于 $m$ 个**不等式**，输入 $1\ i\ j\ z$ 表示 $x_i \leq x_j + z$，输入 $2\ i\ j\ z$ 表示 $x_i \geq x_j + z$，输入 $3\ i\ j$ 表示 $x_i = x_j$。需要判断**不等式组**是否**存在一组未知量可以作为解**，存在输出 $YES$ 否则输出 $NO$  
  > 2、**差分约束系统**是一种特殊的，形如 $x_i - x_j \leq c_k$ 的 $n$ **元一次不等式组**，其每一个**约束条件**都可以变形为 $x_i \leq x_j + c_k$。观察变形后的**约束条件**，很接近先前**单源最短路**的**松弛操作后**保证的状态 $d[y] \leq d[x] + w$ (三角形不等式)，不妨把每个解 $x_i$ 看作图中**一个点**，对应地从节点 $j$ 向 $i$ 连一条长度为 $z$ 的边(将约束条件转换成图)，如果在这样的图上**跑完了最短路**，则一定保证**约束条件满足**。即，求 $x_i$ 的**一组解**等价于在图上求**一组最短距离** $d[i]$ (即 $x_i = d[i]$)，如果**这样的图存在**，即 $d[]$ **存在且合法**(没有负环)，说明**存在一组解**  
  > 3、实现时，**最短路**需要一个**起点**，但因为**无法保证整个图连通**，则以任意点作为起点都**不能保证**得到**到所有点的最短路**，所以可以构建一个**虚拟源点** $0$ **作为起点**且**到所有点距离为** $0$，将整个图连通。对于题面给出的**第一种不等式**，是与**约束条件**相同的形式；对于**第二种不等式**应将 $\geq$ 式转换成 $\leq$ 式，即 $x_j \leq x_i - z$，**边权为** $-z$；对于**第三种等式**，可以相似地转换成 $x_i \leq x_j + 0$ 且 $x_j \leq x_i + 0$，即 $x_i, x_j$ 点**双向连通**且**边权为** $0$。对于**最短路的实现**，由于存在**负权边**且需要**判断负环**，所以用 **Bellman-Ford** 或 **SPFA**，注意由于多加了一个**虚拟源点**，因此 **SPFA** 判断**是否负环的条件**要修改为 `++cnt[y] > n` 或 `++cnt[y] >= n + 1`(Bellman-Ford 也同理需要多松弛一次)  
  > 4、运行后，$d[i]$ 的值就是 $x_i$ **的一组解**。此外容易发现，这组解**同时增减相同的值** $a$ 后也仍是**一组解**，因为有 $(x_i + a) - (x_j + a) = x_i - x_j \leq c_k$

  <!-- more -->

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  using ll = long long;
  const int N = 1e4 + 10;
  const ll INF = 2e18;

  struct Edge
  {
          ll x, w;
  };
  vector<Edge> g[N];

  int n, m;
  ll d[N];

  // SPFA，返回是否有负环
  bool SPFA(int st)
  {
      for(int i = 1; i <= n; i++)
          d[i] = INF;
      d[st] = 0;

      queue<int> q;
      bitset<N> inq;
      int cnt[N] = {};

      q.push(st), inq[st] = true;
      while (q.size())
      {
          int x = q.front();
          q.pop(), inq[x] = false;

          for (auto &[y, w] : g[x])
          {
              if (d[x] + w < d[y])
              {
                  if (++cnt[y] > n)
                      return true;

                  d[y] = d[x] + w;
                  if (!inq[y])
                      q.push(y), inq[y] = true;
              }
          }
      }
      return false;
  }

  void solve()
  {
      cin >> n >> m;

      // 清空图
      for (int i = 1; i <= n; i++)
          g[i].clear();

      // 建图
      while (m--)
      {
          int op;
          cin >> op;

          int i, j, z;
          if (op == 1)
          {
              // x_i <= x_j + z，连 j ->  i 边权为 z
              cin >> i >> j >> z;
              g[j].push_back({i, z});
          }
          else if (op == 2)
          {
              // x_j <= x_i - z，连 i -> j 边权为 -z
              cin >> i >> j >> z;
              g[i].push_back({j, -z});
          }
          else
          {
              // x_i = x_j，双向连通 i--j 边权为 0
              cin >> i >> j;
              g[i].push_back({j, 0});
              g[j].push_back({i, 0});
          }
      }

      // 建立虚拟源点
      for (int i = 1; i <= n; i++)
          g[0].push_back({i, 0});

      // 判断负环(是否有一组解)
      if (SPFA(0))
          cout << "NO" << '\n';
      else
          cout << "YES" << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **页底评论**

---
