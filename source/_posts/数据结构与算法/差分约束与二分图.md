---
title: 差分约束与二分图
author: 山暮云秋
description: 学习差分约束系统，学习二分图染色与匈牙利算法
sticky: 0
readmore: true
tags:
  - 差分约束
  - 二分图染色
  - 匈牙利算法
  - 图
  - C++
categories:
  - 数据结构与算法
abbrlink: e8bacb09
date: 2025-03-03 00:00:00
updated: 2025-03-07 00:00:00
---

---

### **差分约束**

---

- **差分约束**

  > 1、[差分约束](https://www.starrycoding.com/problem/104)：有 $T$ 组样例($T \leq 10^3$)，对于每组样例，给定 $n$ 和 $m$ ($n,m \leq 5 \times 10^3$)，表示有 $n$ 个**未知量**和一个大小为 $m$ 的**不等式组**。对于 $m$ 个**不等式**，输入 $1\ i\ j\ z$ 表示 $x_i \leq x_j + z$，输入 $2\ i\ j\ z$ 表示 $x_i \geq x_j + z$，输入 $3\ i\ j$ 表示 $x_i = x_j$。需要判断**不等式组**是否**存在一组未知量可以作为解**，存在输出 $YES$ 否则输出 $NO$  
  > 2、**差分约束系统**是一种特殊的，形如 $x_i - x_j \leq c_k$ 的 $n$ **元一次不等式组**，其每一个**约束条件**都可以变形为 $x_i \leq x_j + c_k$。观察变形后的**约束条件**，很接近先前**单源最短路**的**松弛操作后**保证的状态 $d[y] \leq d[x] + w$ (三角形不等式)，不妨把每个解 $x_i$ 看作图中**一个点**，对应地从节点 $j$ 向 $i$ 连一条长度为 $z$ 的边(将约束条件转换成图)，如果在这样的图上**跑完了最短路**，则一定保证**约束条件满足**。即，求 $x_i$ 的**一组解**等价于在图上求**一组最短距离** $d[]$ (即 $x_i = d[i]$)，如果**这样的图存在**，即 $d[]$ **存在且合法**(没有负环)，说明**存在至少一组解**  
  > 3、实现时，**最短路**需要一个**起点**，但因为**无法保证整个图连通**，则以任意点作为起点都**不能保证**得到**到所有点的最短路**，所以需要构建一个**虚拟源点** $0$ **作为起点**且**到所有点距离为** $0$，将整个图连通。对于题面给出的**第一种不等式**，是与**约束条件**相同的形式；对于**第二种不等式**应将 $\geq$ 式转换成 $\leq$ 式，即 $x_j \leq x_i - z$，**边权为** $-z$；对于**第三种等式**，可以相似地转换成 $x_i \leq x_j + 0$ 且 $x_j \leq x_i + 0$，即 $x_i, x_j$ 点**双向连通**且**边权为** $0$。此处的**连边规则**在下面的**补充**处**另有详细说明**，并非一定移项成这种形式  
  > 4、对于**最短路的实现**，由于存在**负权边**且需要**判断负环**，所以用 **Bellman-Ford** 或 **SPFA**，注意由于多加了一个**虚拟源点**，因此 **SPFA** 判断**是否负环的条件**要修改为 `++cnt[y] > n` 或 `++cnt[y] >= n + 1`(Bellman-Ford 也同理需要多松弛一次)  
  > 5、运行后，$d[]$ 的值就是 $x$ **的一组解**。容易发现，这组解**同时增减相同的值** $a$ 后也仍是**一组解**，因为有 $(x_i + a) - (x_j + a) = x_i - x_j \leq c_k$，**增减的值**在约束条件中**会被抵消**

  <!-- more -->

- **补充：求差分约束的确定最值**

  > 1、接上文，最终**求到的解**可以**同时增减**且**仍然成立**，所以实际得到的答案中**确定的部分**是 $x_1, x_2, x_3, ...$ 的**取值范围**之间的**相对大小关系**，某些题目会补充一个条件，通过给定一个**解的基准点的最值**(最大值或最小值)，便可以确定**基准点的绝对的取值范围**，从而确定出其他点的绝对的取值范围，并问其他点的**取值最值**(此时便可以确定下来了)。但注意前提，**图自身一定要连通**(不算额外添加的虚拟源点)  
  > 2、如上例(注意，上例并不满足图自身连通的前提条件！在此假设条件成立，仅作示例说明思路)：若补充条件假设 $x_1$ **的最大值为** $0$，则 $x_1$ **便是解的基准点**，且 $x_1$ 的**取值范围也已确定**(最大为 $0$，最小值也会因最大值确定而确定)，其他点的**取值范围**借由与 $x_1$ 的相对大小关系也**可以确定**，题目改问有解时**输出** $x_1 \sim x_n$ **的最大值**  
  > 3、此时，需要额外思考：如果题目要求 $x_i$ **的最大值**(即该例的情况)，需要的是**最短路**，因为执行最短路后会**满足** $x_j \leq x_i + w$ **的恒成立条件**，那么此时对于每个 $x_j$ 都是**最大值**(因为如果 $x_j$ 不是最大值，一定还有 $x_i + w \lt x_j$ 可以松弛它)。类似地，如果题目要求 $x_i$ **的最小值**(下一道例题的情况)，需要的是**最长路**，因为执行最长路后会**满足** $x_j \geq x_i + w$ **的恒成立条件**，那么此时对于每个 $x_j$ 都是**最小值**。注意，**最大最小值**与**最短最长路**的算法本身没有关系，只是**运用其思路**，利用**运行后满足的恒成立条件**来确定最值(实现时只需在最短路上稍作更改)  
  > 4、具体实现时，需要先**确定求哪种最值**，**确定恒成立关系**(可以记住上述推理的结论，最大值最短路、最小值最长路)，再将**给定的约束条件**移项成**对应路的恒成立条件**的形式(求不同的最值连边构造的图是不一样的)，以确定**连边方向**是 $i \to j$ 还是 $j \to i$。因此，对于上例的**最短路**，应转换成 $a \leq b + w$ 的形式连 $b \to a = w$ 的边；而对于**最长路**，是转换成 $a \geq b + w$ 的形式连 $b \to a = w$ 的边  
  > 5、回到该例，由上面分析可知，**连边规则**与**最短路**的部分与下面代码示例相同，最后得到 $d[]$ 数组为**一组可行解**(且因为是最短路求得，每个解都是各自范围的最大值)。不过注意，此时还不能直接输出，因为基准的 $d[1]$ **应该为** $0$，而**实际所求**并不一定，那么**实际与基准偏差的值**即为 $d[1] - 0 = d[1]$，输出时每个点**应减去偏差**，即应该输出 $d[i] - d[1]$，即为答案(再次说明，该例实际不满足图连通的条件，因此更改代码后答案会错，仅作示例说明思路)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  using ll = long long;
  const int N = 1e4 + 10;
  const ll INF = 2e18;

  struct Edge
  {
          ll x, w;
  };
  vector<Edge> g[N];

  int n, m;
  ll d[N];

  // SPFA，返回是否有负环
  bool SPFA(int st)
  {
      for(int i = 1; i <= n; i++)
          d[i] = INF;
      d[st] = 0;

      queue<int> q;
      bitset<N> inq;
      int cnt[N] = {};

      q.push(st), inq[st] = true;
      while (q.size())
      {
          int x = q.front();
          q.pop(), inq[x] = false;

          for (auto &[y, w] : g[x])
          {
              if (d[x] + w < d[y])
              {
                  if (++cnt[y] > n)
                      return true;

                  d[y] = d[x] + w;
                  if (!inq[y])
                      q.push(y), inq[y] = true;
              }
          }
      }
      return false;
  }

  void solve()
  {
      cin >> n >> m;

      // 清空图
      for (int i = 1; i <= n; i++)
          g[i].clear();

      // 建图
      while (m--)
      {
          int op;
          cin >> op;

          int i, j, z;
          if (op == 1)
          {
              // x_i <= x_j + z，连 j ->  i 边权为 z
              cin >> i >> j >> z;
              g[j].push_back({i, z});
          }
          else if (op == 2)
          {
              // x_j <= x_i - z，连 i -> j 边权为 -z
              cin >> i >> j >> z;
              g[i].push_back({j, -z});
          }
          else
          {
              // x_i = x_j，双向连通 i--j 边权为 0
              cin >> i >> j;
              g[i].push_back({j, 0});
              g[j].push_back({i, 0});
          }
      }

      // 建立虚拟源点
      for (int i = 1; i <= n; i++)
          g[0].push_back({i, 0});

      // 判断负环(是否有一组解)
      if (SPFA(0))
          cout << "NO" << '\n';
      else
          cout << "YES" << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **例-Intervals**

---

- **Intervals**

  > 1、[Intervals(改编自 POJ 1201)](https://www.starrycoding.com/problem/105)：请**构造一个集合**，给定 $n$ 个条件($n \leq 5 \times 10^4$)，对于每个条件，输入 $a_i, b_i, c_i$，表示要求**集合中元素值**在 $[a_i, b_i]$ **之间的数字至少出现** $c_i$ 次，即从 $[1, 5 \times 10^4]$ **尽可能少**地选择数字满足条件，求这个集合的**最小大小**  
  > 2、**差分约束**实际的题目中常会有很多**隐含的条件**，可能需要全部找到才能满足题目所给的模型，甚至**差分约束条件**也会被包装隐藏，较常用的一种获得**差分约束条件**的思想是**前缀和**。如该例，设 $d[i]$ 存储 $1 \to i$ **选择了多少个元素**(实际也是一个前缀和)，那么对于**给出的一个条件** $a, b, c$，可以翻译为 $d[b] - d[a-1] \geq c$ (即$[a, b]$ 间选择的元素至少为 $c$ 个)，这便将条件翻译为了**差分约束条件**，题目实际便是求这些**不等式组的一组解**中 $d[5\times 10^4]$ 的**最小值**
  > 3、由于要求**最小值**，所以应该要跑**最长路**，则上式应该变为最长路的**恒成立条件**的形式 $d[b] \geq d[a-1] + c$，**应建立** $a-1$ **到** $b$ **的边权为** $c$ **的边**。但只靠这样建图，不能满足**求差分约束确定最值**所需的**图自身联通**的前提条件，所以需要找其他**隐含条件**：因为是前缀和，所以有 $d[i] \geq d[i-1] + 0$，可以建立 $i-1$ 到 $i$ 的边权为 $0$ 的边，前缀和还有 $d[i-1] \geq d[i] - 1$，可以建立 $i$ 到 $i-1$ 的边权为 $-1$ 的边，这样便满足了**图自身连通**的条件(此外，常见的条件还有 $d[i] \leq d[0] = 0$ 连通 $0 \to i = 0$ 的边，此处的 $0$ 点并非添加的虚拟源点，而是前缀和本身自带的)。此外，**隐含的基准值**是 $d[0]$ **最小值为** $0$，因此**偏差为** $d[0] - 0 = 0$ (实际的 $d[0] = 0$ 减去基准值 $0$)，所以最终**输出的答案为** $d[m] - d[0] = d[m]$  
  > 4、实现时要注意，**求最长路**在最短路基础上修改：$d[]$ **初始化为** $-\infty$，**松弛条件**变为 $d[x] + w > d[y]$，由于是**求最长路**，所以原先判断负环应改为**判断正环**防止**无限累加**(判断的方式相同)，可以证明，该题目**不存在正环**(建图左连向右边权总是非负，唯一的 $i$ 连向 $i-1$ 的情况边权为 $-1$，而前缀和元素与前一个元素差值最大为 $1$，因此成环也绝不为正环)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  using ll = long long;
  const int N = 5e4 + 10;
  const ll INF = 2e18;

  struct Edge
  {
          ll x, w;
  };
  vector<Edge> g[N];

  // m 为可能所选最大的元素的范围，+1 预留出一个下标 0
  int n, m = 5e4 + 1;
  ll d[N];

  // 最长路，图连通，且可以证明该题没有正环，不需要判断正环
  void SPFA(int st)
  {
      // 最长路，初始化为 -INF
      for (int i = 1; i <= m; i++)
          d[i] = -INF;
      d[st] = 0;

      queue<int> q;
      bitset<N> inq;

      q.push(st), inq[st] = true;
      while (q.size())
      {
          int x = q.front();
          q.pop(), inq[x] = false;

          for (auto &[y, w] : g[x])
          {
              // 最长路，d[x] + w > d[y] 才松弛
              if (d[x] + w > d[y])
              {
                  d[y] = d[x] + w;
                  if (!inq[y])
                      q.push(y), inq[y] = true;
              }
          }
      }
  }

  void solve()
  {
      cin >> n;
      // 差分约束条件建图，d[b] >= d[a-1] + c
      for (int i = 1; i <= n; i++)
      {
          ll a, b, c;
          cin >> a >> b >> c;
          g[a - 1].push_back({b, c});
      }

      // 隐含条件建图
      for (int i = 1; i <= m; i++)
      {
          // 隐含条件 d[i] >= d[i-1] + 0
          g[i - 1].push_back({i, 0});
          // 隐含条件 d[i-1] >= d[i] - 1
          g[i].push_back({i - 1, -1});
      }

      SPFA(0);

      // 输出即 d[m] - 偏差 0 = d[m]
      cout << d[m] << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **例-奇怪的奶牛**

---

- **奇怪的奶牛**

  > 1、[奇怪的奶牛(改编自 POJ 3169)](https://www.starrycoding.com/problem/106)：有 $n$ 头奶牛按**编号从小到大**排列($n \leq 10^3$)，它们中有 $t$ 对好朋友和 $r$ 对坏朋友($t,r \leq 10^4$)。对于**好朋友**，输入 $x, y, w$ 表示 $x, y$ 的距离**不超过** $w$(即中间间隔至多 $w-1$ 个位置)；对于**坏朋友**，输入 $x, y, w$ 表示 $x, y$ 的距离**不少于** $w$。一个位置可以放**多头奶牛**，如果希望**农场越长越好**，输出**最长的长度**，如果**无限长**输出 $-2$，如果**不存在方案**输出 **-1**  
  > 2、令 $d[i]$ 表示第 $i$ 头奶牛的位置，则**好朋友**的约束条件可以翻译为 $d[y] - d[x] \leq w$，**坏朋友**的约束条件可以翻译为 $d[y] - d[x] \geq w$，最终要求 $d[n]$ 的**最大值**  
  > 3、由于是**最大值**，所以用**最短路**。对于**好朋友**，变换约束条件为 $d[y] \leq d[x] + w$，连 $x \to y = w$ 的边；对于**坏朋友**，变换约束条件为 $d[x] \leq d[y] - w$，连 $y \to x = -w$ 的边。跑 **SPFA**，如果**有负环**说明**没有方案**；如果 $d[n]$ **没有约束没被联通**(没有被更新)说明可以**无限长**；此外**基准点**为 $d[1]$ 的最大值为 $1$，偏差为 $0$，因此答案为 $d[n] - 0 = d[n]$

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  using ll = long long;
  const int N = 1e3 + 10;
  const ll INF = 2e18;

  struct Edge
  {
          ll x, w;
  };
  vector<Edge> g[N];

  int n, t, r;
  ll d[N];

  // 返回 d[n] 最大位置，返回 -1 表示负环，返回 -2 表示 d[n] 没有约束无穷大
  ll SPFA(int st)
  {
      for (int i = 1; i <= n; i++)
          d[i] = INF;
      d[st] = 1; // 1 号牛放在 1 号位置

      queue<int> q;
      bitset<N> inq;
      int cnt[N] = {};

      q.push(st), inq[st] = true;
      while (q.size())
      {
          int x = q.front();
          q.pop(), inq[x] = false;

          for (auto &[y, w] : g[x])
          {
              // 最短路
              if (d[x] + w < d[y])
              {
                  if (++cnt[y] >= n)
                      return -1;

                  d[y] = d[x] + w;
                  if (!inq[y])
                      q.push(y), inq[y] = true;
              }
          }
      }

      // d[n] 没有约束不会被更新，INF
      return d[n] == INF ? -2 : d[n];
  }

  void solve()
  {
      cin >> n >> t >> r;

      // 好朋友，d[y] <= d[x] + w
      for (int i = 1; i <= t; i++)
      {
          ll x, y, w;
          cin >> x >> y >> w;
          g[x].push_back({y, w});
      }

      // 坏朋友，d[x] <= d[y] - w
      for (int i = 1; i <= r; i++)
      {
          ll x, y, w;
          cin >> x >> y >> w;
          g[y].push_back({x, -w});
      }

      cout << SPFA(1);
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **页底评论**

---
