---
title: 欧拉路径与哈密顿路径
author: 山暮云秋
description: 学习欧拉路径、欧拉回路与哈密顿路径的特点，学习 Fleury 算法和 Hierholzer 算法
sticky: 0
readmore: true
tags:
  - 欧拉路径
  - 哈密顿路径
  - Fleury
  - Hierholzer
  - 数学
  - C++
categories:
  - 数据结构与算法
abbrlink: 89c44d72
date: 2024-02-26 00:00:00
updated: 2024-02-27 00:00:00
---

---

### **欧拉路径与哈密顿路径**

---

- **欧拉路**

  > 1、**欧拉路径**：从**某一点出发**经过一条**不间断的路径**，**这条路径**刚好访问整个图的所有边**一次且仅一次**(一笔画问题)。一个图可能有**多条欧拉路径**  
  > 2、**欧拉回路**：一条**首尾相接**的**欧拉路径**(首尾相接的一笔画问题)。一个图可能有**多条欧拉回路**  
  > 3、**欧拉图**：具有**欧拉回路**的图。特点为：**无向图**中所有顶点的**度都是偶数**；**有向图**中所有顶点的**入度和出度都相等**  
  > 4、**半欧拉图**：具有**欧拉路径**但不具有**欧拉回路**的图。特点为：**无向图**中**有且仅有两个顶点**的**度为奇数**，这两个顶点分别为**起点和终点**；**有向图**中**有且仅有一个顶点**的**出度 - 入度** $= 1$，另**有且仅有一个顶点**的**入度 - 出度** $= 1$，这两个顶点分别为**起点和终点**  
  > 5、推论：**欧拉图**的所有**欧拉路径**都是**欧拉回路**，所以计算**欧拉回路**与**欧拉路径**的算法完全一样

<!-- more -->

- **哈密顿路径**

  > 1、

---

### **Fleury 算法**

---

- **Fleury 算法**

  > 1、

---

### **Hierholzer 算法**

---

- **Hierholzer 算法**

  > 1、**预先判断**给定的图是不是**欧拉图**或**半欧拉图**  
  > 2、对于**欧拉图**：**起点任意**。对于**半欧拉图**：如果是**无向图**，选择任意**奇数度点**；如果是**有向图**，选择**出度 - 入度 $= 1$ 的点**  
  > 3、**初始化**设置**答案栈** $ans$，存储走过路径**途径的节点**。对图进行 **DFS**，允许点**重复经过**，每访问一条边就**将其删掉**，然后对**这条边另一端的节点**进行遍历。当一个节点**完成遍历**且**没有相连边**时，将该节点**入栈**，并**回溯到上一层**  
  > 4、遍历结束后，将 $ans$ 中的节点**依次出栈**，得到的就是**欧拉路径**/**欧拉回路**的**节点访问顺序**  
  > 5、为了方便实现，在此先使用**邻接矩阵**建图，实现最简单的功能。复杂度很高，需要优化

- **无向图代码实现**

  ```cpp
  const int N = 1e4 + 10;
  int n; // 点的个数

  bitset<N> g[N]; // 邻接矩阵建图
  int deg[N];     // 存储每个点的度
  stack<int> stk; // 存储答案路径

  // 获取每个点的度
  void get_degree()
  {
      for (int i = 1; i < n; i++)
          for (int j = i + 1; j <= n; j++)
              if (g[i][j])
                  deg[i]++, deg[j]++; // 无向图中 i、j 各有 1 度
  }

  // 获取起点
  int get_start()
  {
      int ct = 0, st = 1;
      for (int i = 1; i <= n; i++)
      {
          // 如果度为奇数
          if (deg[i] % 2)
          {
              ct++;
              st = i;
          }
          // 有 2 个以上奇数度点，不存在欧拉路径
          if (ct > 2)
              return -1;
      }
      return st;
  }

  // DFS 与 Hierholzer
  void Hierholzer(int x)
  {
      for (int y = 1; y <= n; y++)
      {
          if (g[x][y])
          {
              g[x][y] = g[y][x] = 0; // 删除边
              Hierholzer(y);         // DFS
          }
      }
      stk.push(x);
  }
  ```

- **有向图代码实现**

  ```cpp
  const int N = 1e4 + 10;
  int n; // 点的个数

  bitset<N> g[N]; // 邻接矩阵建图
  int deg[N];     // 存储每个点 入度-出度 的差
  stack<int> stk; // 存储答案路径

  // 获取每个点的度
  void get_degree()
  {
      for (int i = 1; i < n; i++)
          for (int j = i + 1; j <= n; j++)
              if (g[i][j])
                  deg[i]--, deg[j]++; // 有向图，i 出度 -1，j 入度 +1
  }

  // 获取起点
  int get_start()
  {
      int plus_one = 0, minus_one = 0, st = 1;
      for (int i = 1; i <= n; i++)
      {
          // 统计入度 - 出度 = 1 的次数
          if (deg[i] == 1)
              plus_one++;
          // 统计出度 - 入度 = 1 的次数
          else if (deg[i] == -1)
          {
              minus_one++;
              st = i; // 作为起点
          }
          // 非以上情况且非 0，不存在欧拉路径
          else if (deg[i] != 0)
              return -1;
      }

      // 所有点入度 = 出度 或 有且仅有一个 plus 和 minus 时有欧拉路径
      if ((plus_one == 0 && minus_one == 0) || (plus_one == 1 && minus_one == 1))
          return st;
      else
          return -1;
  }

  // DFS 与 Hierholzer
  void Hierholzer(int x)
  {
      for (int y = 1; y <= n; y++)
      {
          if (g[x][y])
          {
              g[x][y] = 0;   // 删除边，注意有向图只删除 x->y
              Hierholzer(y); // DFS
          }
      }
      stk.push(x);
  }
  ```

---

### **页底评论**

---
