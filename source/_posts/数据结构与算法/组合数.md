---
title: 组合数
author: 山暮云秋
description: "学习通过递推法或公式法求组合数 C(n, m)"
sticky: 0
readmore: true
tags:
  - 组合数
  - 数学
  - C++
categories:
  - 数据结构与算法
abbrlink: 9ac1aea8
date: 2023-11-25 00:00:00
updated: 2023-12-12 00:00:00
---

---

### **递推求组合数**

---

- **递推求组合数**

  > 1、**组合数**中有`C(n, m) = C(n-1, m-1) + C(n-1, m)`。其中`C(n, m)`意为从 **n 个元素中选出 m 个元素**有多少种**不同组合**，其**总的可能**可划分为**组合中选了第一个**和**组合中没选第一个**两种。如果**组合中选了第一个**，那么**剩下的方案数**还有`C(n-1, m-1)`种(从剩余元素中选 m-1 个)；如果**组合中没选第一个**，那么**剩下的组合**中还有`C(n-1, m)`种；这**两种结果互斥**，因此相加便可得到**总的方案**  
  > 2、这种方法运用了**递推**与**DP**的思想，**上面的等式**为**状态转移方程**。其中，`C(n, m)`为**新状态**，通过方程将其转移为**两个老状态的和**。此外，需要确定**起始点**和**边界**：**起始点**为`C(i, 0) = 1`(从任意多的元素中选 0 个，有 1 种方案——不选)；**边界**为`C(i, j)`(其中 0 <= j <= i，i <= n)

<!-- more -->

- **求组合数 1**

  > 1、[求组合数 1](https://www.starrycoding.com/problem/45)：给定 **n 和 m**(不超过 1000)，输出一个 **n\*m 的矩阵**，矩阵**下标从 0 开始**，矩阵的元素`a[i][j] = C(i, j)`，结果对 10<sup>9</sup> + 7 取模  
  > 2、注意在对`c[][]`**初始化**时，对于 **i=0** 和 **j=0** 都**已被初始化**，此外在**进行状态转移时**，需要**注意边界**(i < n，j < m，0 <= j <= i)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 1e3 + 10;
  const int P = 1e9 + 7;

  long long c[N][N];

  void solve()
  {
      int n, m;
      cin >> n >> m;
      // 初始化，C(i, 0) = 1
      for (int i = 0; i < n; i++)
          c[i][0] = 1LL;

      // 通过状态转移方程进行转移，C(i, j) = C(i - 1, j - 1) + C(i - 1, j)
      // 注意 i 边界，i < n
      for (int i = 1; i < n; i++)
          // 注意 j 边界，j <= i && j < m
          for (int j = 1; j <= i && j < m; j++)
              // 状态转移
              c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;

      for (int i = 0; i < n; i++)
      {
          for (int j = 0; j < m; j++)
              cout << c[i][j] << " ";
          cout << '\n';
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **公式求组合数**

---

- **公式求组合数**

  > 1、由**计数原理**中**组合的公式**可知`C(n, m) = n! / ((n-m)! * m!)`，因此求`C(n, m)`**需要求**`n!`、`(n-m)!`、`m!`这**三种阶乘**  
  > 2、由于**数据通常较大**，题目中常会要求**结果对 P 取模**，此时**对上面公式取模**，可以通过**乘法逆元**将**模运算的除法**转换为**模运算的乘法**。因此`C(n, m) % P`在**模 P 意义下**可等于`n! * inv[(n-m)!] * inv[m!] % P`，其中`inv[x]`表示 **x 在模 P 意义下**的**乘法逆元**，进而可等于`n! * inv[(n-m)! * m! % P] % P`  
  > 3、因此在实现中，可以先提前用数组`fac[]`**记录阶乘**(阶乘可以递推得到，`fac[i] = fac[i-1] * i`)，再通过**求逆元的方法**得到逆元，最后用**模 P 意义下的公式**计算组合数

- **求组合数 2**

  > 1、[求组合数 2](https://www.starrycoding.com/problem/46)：有 **q 次询问**，每次给出 **n 和 m**，输出`C(n, m)`的值。其中 q 不超过 10<sup>5</sup>，n 和 m 不超过 10<sup>7</sup>，结果对 10<sup>9</sup> + 7 取模  
  > 2、由于题目的**数据范围较大**，且**数据较离散**，先前的**递推法**会**耗费大量时间**，应使用**公式法**。注意到**模数是质数**，所以通过**费马小定理 + 快速幂**来**求逆元**，再按照公式法**求组合数**(注意取模)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  #define int long long
  const int N = 1e7 + 10; // 范围
  const int P = 1e9 + 7;  // 模数

  int fac[N]; // 记录阶乘

  // 初始化阶乘数组 fac[]
  void InitFac(int n)
  {
      fac[0] = 1;
      for (int i = 1; i <= n; i++)
          fac[i] = 1ll * fac[i - 1] * i % P;
  }

  // 快速幂取模
  int ModExp(int a, int b)
  {
      int res = 1;
      while (b)
      {
          if (b & 1)
              res = res * a % P;
          a = a * a % P;
          b >>= 1;
      }
      return res;
  }

  // 求逆元：费马小定理 + 快速幂
  int inv(int x)
  {
      return ModExp(x, P - 2);
  }

  // 求组合数
  int C(int n, int m)
  {
      // 特判
      if (n < 0 || m < 0 || n < m)
          return 0;

      // 公式
      return fac[n] * inv(fac[n - m] * fac[m] % P) % P;
  }

  void solve()
  {
      int n, m;
      cin >> n >> m;
      cout << C(n, m) << '\n';
  }

  signed main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

      InitFac(1e7); // 初始化 fac[]

      int T = 1;
      cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **线性求组合数**

---

- **线性求组合数**

  > 1、[求组合数-进阶](https://www.starrycoding.com/problem/73)：有 **q 次询问**，每次需要求出`C(n, m)`，输出 q 次询问的**结果之和**，结果对 10<sup>9</sup> + 7 取模。输入 q,a,b,c(不超过 10<sup>7</sup>)，再给出`n[1]`和`m[1]`，**之后的询问**按照`(n[i], m[i]) = (n[i-1] * a + b, m[i-1] * b + a) % c`生成  
  > 2、在上题基础上，由于**每次询问**`C(n, m)`都需要**求一次逆元**，共需要 O(n \* log n) 的复杂度，因此可以提前**预处理逆元**并**存入数组**`invfac[]`(即`invfac[i]`存储 i! 的逆元)  
  > 3、由于`invfac[i] = 1 / (i!)`，`invfac[i+1] = 1 / ((i+1)!)`，所以存在**状态转移方程**：`invfac[i] = invfac[i+1] * (i+1)`(分子乘上，和分母约分掉)。因此只需要计算最大的`invfac[n]`，在通过转移方程**线性递推**即可得到`invfac[]`。这样**全程只需要求一次逆元**，只需要 O(n + log n) = O(n) 的复杂度

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  #define int long long
  const int N = 1e7 + 10; // 范围
  const int P = 1e9 + 7;  // 模数

  int fac[N];    // 记录阶乘
  int invfac[N]; // 预处理逆元，存储 i! 的逆元

  int inv(int x);

  // 初始化阶乘数组 fac[]，预处理逆元
  void InitFac(int n)
  {
      fac[0] = 1;
      for (int i = 1; i <= n; i++)
          fac[i] = 1ll * fac[i - 1] * i % P;

      // 把 n! 的逆元存入 invfac[n]
      invfac[n] = inv(fac[n]);
      // 通过转移方程线性递推 invfac[]
      for (int i = n - 1; i >= 0; i--)
          invfac[i] = invfac[i + 1] * (i + 1) % P;
  }

  // 快速幂取模
  int ModExp(int a, int b)
  {
      int res = 1;
      while (b)
      {
          if (b & 1)
              res = res * a % P;
          a = a * a % P;
          b >>= 1;
      }
      return res;
  }

  // 求逆元：费马小定理 + 快速幂
  int inv(int x)
  {
      return ModExp(x, P - 2);
  }

  // 求组合数
  int C(int n, int m)
  {
      // 特判
      if (n < 0 || m < 0 || n < m)
          return 0;

      // 公式，修改为通过 invfac[] 计算
      return fac[n] * invfac[n - m] % P * invfac[m] % P;
  }

  void solve()
  {
      int q, a, b, c, n, m;
      cin >> q >> a >> b >> c >> n >> m;

      int sum = 0;
      // q 次询问
      for (int i = 1; i <= q; i++)
      {
          sum = (sum + C(n, m)) % P;

          // 准备下一次询问的 n, m
          n = (n * a + b) % c;
          m = (m * b + a) % c;
      }
      cout << sum;
  }

  signed main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

      InitFac(1e7); // 初始化 fac[]

      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **页底评论**

---
