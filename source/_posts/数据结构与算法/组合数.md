---
title: 组合数
author: 圣奇宝枣
description: 组合数
sticky: 0
date: 2023-11-25
updated: 2023-11-25
readmore: true
tags:
  - 组合数
  - 数学
  - C++
categories:
  - 数据结构与算法
---

---

#### **递推求组合数**

---

- **递推求组合数**

  > 1、**组合数**中有`C(n, m) = C(n-1, m-1) + C(n-1, m)`。其中`C(n, m)`意为从**n 个元素中选出 m 个元素**有多少种**不同组合**，其**总的可能**可划分为**组合中选了第一个**和**组合中没选第一个**两种。如果**组合中选了第一个**，那么**剩下的方案数**还有`C(n-1, m-1)`种(从剩余元素中选 m-1 个)；如果**组合中没选第一个**，那么**剩下的组合**中还有`C(n-1, m)`种；这**两种结果互斥**，因此相加便可得到**总的方案**  
  > 2、这种方法运用了**递推**与**DP**的思想，**上面的等式**为**状态转移方程**。其中，`C(n, m)`为**新状态**，通过方程将其转移为**两个老状态的和**。此外，需要确定**起始点**和**边界**：**起始点**为`C(i, 0) = 1`(从任意多的元素中选 0 个，有 1 种方案——不选)；**边界**为`C(i, j)`(其中 0 <= j <= i，i <= n)

<!-- more -->

- **求组合数 1**

  > 1、[求组合数 1](https://cdn.oj.eriktse.com/problem.php?id=1065)：给定 **n 和 m**，输出一个 **n\*m 的矩阵**，矩阵**下标从 0 开始**，矩阵的元素`a[i][j] = C(i, j)`，结果对 10<sup>9</sup> + 7 取模  
  > 2、注意在对`c[][]`**初始化**时，对于**i=0**和**j=0**都**已被初始化**，此外在**进行状态转移时**，需要**注意边界**(i < n，j < m，0 <= j <= i)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 1e3 + 10;
  const int P = 1e9 + 7;

  long long c[N][N];

  void solve()
  {
      int n, m;
      cin >> n >> m;
      // 初始化，C(i, 0) = 1
      for (int i = 0; i < n; i++)
          c[i][0] = 1LL;

      // 通过状态转移方程进行转移，C(i, j) = C(i - 1, j - 1) + C(i - 1, j)
      // 注意 i 边界，i < n
      for (int i = 1; i < n; i++)
          // 注意 j 边界，j <= i && j < m
          for (int j = 1; j <= i && j < m; j++)
              // 状态转移
              c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;

      for (int i = 0; i < n; i++)
      {
          for (int j = 0; j < m; j++)
              cout << c[i][j] << " ";
          cout << '\n';
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **公式求组合数**

---

- **公式求组合数**

  > 1、

---

#### **页底评论**

---
