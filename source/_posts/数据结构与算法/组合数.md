---
title: 组合数
author: 圣奇宝枣
description: 通过递推或公式法求组合数 C(n, m)
sticky: 0
date: 2023-11-25
updated: 2023-11-26
readmore: true
tags:
  - 组合数
  - 数学
  - C++
categories:
  - 数据结构与算法
---

---

#### **递推求组合数**

---

- **递推求组合数**

  > 1、**组合数**中有`C(n, m) = C(n-1, m-1) + C(n-1, m)`。其中`C(n, m)`意为从**n 个元素中选出 m 个元素**有多少种**不同组合**，其**总的可能**可划分为**组合中选了第一个**和**组合中没选第一个**两种。如果**组合中选了第一个**，那么**剩下的方案数**还有`C(n-1, m-1)`种(从剩余元素中选 m-1 个)；如果**组合中没选第一个**，那么**剩下的组合**中还有`C(n-1, m)`种；这**两种结果互斥**，因此相加便可得到**总的方案**  
  > 2、这种方法运用了**递推**与**DP**的思想，**上面的等式**为**状态转移方程**。其中，`C(n, m)`为**新状态**，通过方程将其转移为**两个老状态的和**。此外，需要确定**起始点**和**边界**：**起始点**为`C(i, 0) = 1`(从任意多的元素中选 0 个，有 1 种方案——不选)；**边界**为`C(i, j)`(其中 0 <= j <= i，i <= n)

<!-- more -->

- **求组合数 1**

  > 1、[求组合数 1](https://cdn.oj.eriktse.com/problem.php?id=1065)：给定 **n 和 m**(不超过 1000)，输出一个 **n\*m 的矩阵**，矩阵**下标从 0 开始**，矩阵的元素`a[i][j] = C(i, j)`，结果对 10<sup>9</sup> + 7 取模  
  > 2、注意在对`c[][]`**初始化**时，对于 **i=0** 和 **j=0** 都**已被初始化**，此外在**进行状态转移时**，需要**注意边界**(i < n，j < m，0 <= j <= i)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 1e3 + 10;
  const int P = 1e9 + 7;

  long long c[N][N];

  void solve()
  {
      int n, m;
      cin >> n >> m;
      // 初始化，C(i, 0) = 1
      for (int i = 0; i < n; i++)
          c[i][0] = 1LL;

      // 通过状态转移方程进行转移，C(i, j) = C(i - 1, j - 1) + C(i - 1, j)
      // 注意 i 边界，i < n
      for (int i = 1; i < n; i++)
          // 注意 j 边界，j <= i && j < m
          for (int j = 1; j <= i && j < m; j++)
              // 状态转移
              c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;

      for (int i = 0; i < n; i++)
      {
          for (int j = 0; j < m; j++)
              cout << c[i][j] << " ";
          cout << '\n';
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **公式求组合数**

---

- **公式求组合数**

  > 1、由**计数原理**中**组合的公式**可知`C(n, m) = n! / ((n-m)! * m!)`，因此求`C(n, m)`**需要求**`n!`、`(n-m)!`、`m!`这**三种阶乘**  
  > 2、由于**数据通常较大**，题目中常会要求**结果对 P 取模**，此时**对上面公式取模**，可以通过**乘法逆元**将**模运算的除法**转换为**模运算的乘法**。因此`C(n, m) % P`在**模 P 意义下**可等于`n! * inv[(n-m)!] * inv[m!] % P`，其中`inv[x]`表示 **x 在模 P 意义下**的**乘法逆元**，进而可等于`n! * inv[(n-m)! * m! % P] % P`  
  > 3、因此在实现中，可以先提前用数组`fac[]`**记录阶乘**(阶乘可以递推得到，`fac[i] = fac[i-1] * i`)，再通过**求逆元的方法**得到逆元，最后用**模 P 意义下的公式**计算组合数

- **求组合数 2**

  > 1、[求组合数 2](https://cdn.oj.eriktse.com/problem.php?id=1066)：有 **q 次询问**，每次给出 **n 和 m**，输出`C(n, m)`的值。其中 q 不超过 10<sup>5</sup>，n 和 m 不超过 10<sup>7</sup>，结果对 10<sup>9</sup> + 7 取模  
  > 2、由于题目的**数据范围较大**，且**数据较离散**，先前的**递推法**会**耗费大量时间**，应使用**公式法**。注意到**模数是质数**，所以通过**费马小定理 + 快速幂**来**求逆元**，再按照公式法**求组合数**(注意取模)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  #define int long long
  const int N = 1e7 + 10; // 范围
  const int P = 1e9 + 7;  // 模数

  int fac[N]; // 记录阶乘

  // 初始化阶乘数组 fac[]
  void InitFac(int n)
  {
      fac[0] = 1;
      for (int i = 1; i <= n; i++)
          fac[i] = 1ll * fac[i - 1] * i % P;
  }

  // 快速幂取模
  int ModExp(int a, int b)
  {
      int res = 1;
      while (b)
      {
          if (b & 1)
              res = res * a % P;
          a = a * a % P;
          b >>= 1;
      }
      return res;
  }

  // 求逆元：费马小定理 + 快速幂
  int inv(int x)
  {
      return ModExp(x, P - 2);
  }

  // 求组合数
  int C(int n, int m)
  {
      // 特判
      if (n < 0 || m < 0 || n < m)
          return 0;

      // 公式
      return fac[n] * inv(fac[n - m] * fac[m] % P) % P;
  }

  void solve()
  {
      int n, m;
      cin >> n >> m;
      cout << C(n, m) << '\n';
  }

  signed main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

      InitFac(1e7); // 初始化 fac[]

      int T = 1;
      cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **页底评论**

---
