---
title: 动态规划
author: 圣奇宝枣
description: 学习动态规划中更多常用的DP，如线性DP、区间DP、树形DP、数位DP、状压DP、概率DP、计数DP
sticky: 0
date: 2024-01-19
updated: 2024-01-20
readmore: true
tags:
  - DP
  - 动态规划
  - C++
categories:
  - 数据结构与算法
---

---

#### **线性 DP-最长上升子序列**

---

- **最长上升子序列**

  > 1、[最长上升子序列(easy)](https://cdn.oj.eriktse.com/problem.php?id=1105)：给定一个**长度为 n** 的**数组 a**(n 不超过 1000)，求其**最长上升子序列**(非降)的**长度**。注意：**子序列不一定是连续的**  
  > 2、对于**线性 DP**，通常用`dp[i]`表示**以 i 结尾**或**到 i 为止**，如果有**对应的代价**，通常用`dp[i][j]`表示**到 i 为止花费 j 的代价**的**价值最值**(见[背包问题](https://www.shengqibaozao.eu.org/2023/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/))
  > 3、**确定状态**：令`dp[i]`表示**以 i 结尾的最长上升子序列长度**  
  > 4、**确定转移**：对于输入的每一个`a[i]`，可知都有**两种情况**：一种是它作为**最长上升子序列的起点**，另一种是它**接续在其他上升子序列之后**。对于`a[i]`**作为起点**，`dp[i] = 1`；对于`a[i]`**作为接续**，应向左搜寻**小于等于 i 的元素 j**，`dp[i] = max(dp[i], dp[j] + 1)`，**遍历取最大值**  
  > 5、易知，该算法复杂度为 O(n<sup>2</sup>)，只能处理小规模数据，仍需优化

  <!-- more -->

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 1010;
  int a[N], dp[N]; // 以 i 为终点的最长上升子序列长度

  void solve()
  {
      int n;
      cin >> n;
      for (int i = 1; i <= n; i++)
          cin >> a[i];

      for (int i = 1; i <= n; i++)
      {
          dp[i] = 1; // 对于每个点，都可以先作为起点

          // 找左侧比当前点小的点，状态转移
          for (int j = 1; j < i; j++)
              if (a[j] <= a[i])
                  dp[i] = max(dp[i], dp[j] + 1);
      }

      // 找最长的上升子序列
      int ans = 0;
      for (int i = 1; i <= n; i++)
          ans = max(ans, dp[i]);

      cout << ans;
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

- **单调栈二分优化**

  > 1、[最长上升子序列(hard)](https://cdn.oj.eriktse.com/problem.php?id=1037)：在上题基础上，**数组长度 n** 改为不超过 2 \* 10<sup>5</sup>  
  > 2、在**遍历求**`dp[i]`的过程中，可知：对于**点 i 在接续时**，其**左侧点 j**，如果`dp[j]`**最长**且`a[j]`**最小**，那么**点 i** 接续到**点 j** 后**一定为最优**，因此需要维护一个**单调栈**(单调不减的单调栈，维护栈顶为`dp[j]`最长且`a[j]`最小的点的位置)  
  > 3、这个**单调栈**在维护时需要一些**特殊操作**，所以需要在原模型上**改良一下**：当**准备入栈的元素 i** 的`a[i]`**比栈顶元素单调不减**时，**将 i 入栈**，`dp[i] = dp[top] + 1`(从栈顶元素转移)；当**准备入栈的元素 i** 的`a[i]`**比栈内某些元素小**时，并不是**从栈顶向下依次出栈再取代**(因为并不满足`dp[i]`最长的条件)，而是找到**栈内第一个大于**`a[i]`的元素 k，**将其取代**，`dp[i] = dp[k]`(从元素 k 转移，且长度与其相同)  
  > 4、例如`{2, 5, 3, 4, 7, 3}`：当**第一个 3 需要入栈**时(i = 2)，**单调栈**内元素为`{2, 5}`，应找到**第一个大于 3 的元素**——5，将其替换，此时`dp[i] = dp[1] = 2`(1 为元素 5 的位置)，栈内变为`{2, 3}`(显然子序列`{2, 3}`比`{2, 5}`更优秀)；当**第二个 3 需要入栈**时(i = 5)，**单调栈**内元素为`{2, 3, 4, 7}`，应找到**第一个大于 3 的元素**——4，将其替换，此时`dp[i] = dp[3] = 3`(3 为元素 4 的位置)，栈内变为`{2, 3, 3, 7}`(其实际子序列为`{2, 3, 3}`，长度为 3)  
  > 5、对于**查找**的操作，可以使用**二分查找**，但因为其需要**操作下标**，所以**单调栈的实现**应该使用**数组实现**，不能使用`STL`的`stack`。此外，由于只需要**最长上升子序列**的**长度**，所以**单调栈的长度**就是**最长上升子序列的长度**，不再需要`dp[]`数组，栈内也**不需要维护点的位置**，而是可以**直接维护**`a[i]`

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;
  int a[N], stk[N], top = 0; // 用数组实现单调栈

  void solve()
  {
      int n, ans = 0;
      cin >> n;

      for (int i = 1; i <= n; i++)
          cin >> a[i];

      for (int i = 1; i <= n; i++)
      {
          // pos 即 a[i] 在单调栈中的位置
          // 找单调栈中第一个 > a[i] 的下标 = 最后一个 <= a[i] 的下标 + 1
          int pos = (upper_bound(stk + 1, stk + 1 + top, a[i]) - stk - 1) + 1;

          // 如果 pos 超出了 top 栈顶的位置，说明 a[i] 比栈顶单调不减
          if (pos == top + 1)
              ++top;       // 拓展单调栈长度，相当于拓展最长子序列长度
          stk[pos] = a[i]; // 入栈 或 取代位置

          // top，单调栈的长度，就是目前最长上升子序列的长度
          ans = max(ans, top);
      }

      cout << ans;
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **线性 DP-导弹拦截**

---

- **导弹拦截**

  > 1、[导弹拦截](https://cdn.oj.eriktse.com/problem.php?id=1028)：有**导弹拦截系统**，对于每个系统，其**首发可以拦截任意高度**的导弹，**之后发射的每一发**都**不能高于前一发的高度**。输入**来袭的导弹高度**(导弹数不超过 1000，高度不超过 30000)，询问如果只有一套系统时**最多能拦截多少发**，以及**需要多少套系统**才能**全部拦截**，依次输出  
  > 2、**第一问**询问的是**最长下降子序列**(非升)的长度，类似于**最长上升子序列**，使用**单调栈**实现。显然，当**准备入栈的元素 i** 的`a[i]`**比栈内某些元素大**时，查找栈内**第一个小于**`a[i]`的元素 k，**将其替换**。其余细节**与先前相似**  
  > 3、**第二问**询问**最少需要多少套系统**。需要根据**狄尔沃斯定理**：如果要使用**最少个数的非升子序列**覆盖一整个数组，其**所需序列数量**等同于**最长的相反规则子序列**的**长度**，此处即**最长上升子序列**的**长度**。因此需要求最长上升子序列的长度，即为答案  
  > 4、对于**最长上升子序列**，应维护一个严格**单调递增栈**。当**准备入栈的元素 i** 的`a[i]`**大于栈顶元素**时，才可以**入栈**；当**准备入栈的元素 i**的`a[i]`**小于等于栈内某些元素**时；查找栈内**第一个大于等于**`a[i]`的元素 k，**将其替换**。其余细节**与先前相似**

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 1010;
  int a[N];
  int stk[N], top = 0;

  void solve()
  {
      // 输入数据
      int n = 0;
      while (cin >> a[++n])
          ;
      --n;

      // 求最长非升子序列长度
      int ans = 0;
      for (int i = 1; i <= n; i++)
      {
          // upper_bound 原先用于查找第一个 > a[i] 的元素的位置
          // 查找第一个 < a[i] 的元素的位置，由于 stk 是降序，所以使用 lambda 更改 upper_bound 的比较规则
          int pos = (upper_bound(stk + 1, stk + 1 + top, a[i], [](const int &u, const int &v) { return u > v; }) - stk - 1) + 1;

          // pos 指向栈顶之上的位置，入栈，top++
          if (pos == top + 1)
              top++;

          // 替换 pos 位置的元素，更新 ans
          stk[pos] = a[i];
          ans = max(ans, top);
      }
      cout << ans << '\n';

      // 初始化
      top = 0, ans = 0;

      // 求最长上升子序列长度
      for (int i = 1; i <= n; i++)
      {
          // lower_bound 用于查找第一个 >= a[i] 的元素的位置
          // 查找第一个 >= a[i] 的元素的位置
          int pos = (lower_bound(stk + 1, stk + 1 + top, a[i]) - stk - 1) + 1;

          // pos 指向栈顶之上的位置，入栈，top++
          if (pos == top + 1)
              top++;

          // 替换 pos 位置的元素，更新 ans
          stk[pos] = a[i];
          ans = max(ans, top);
      }
      cout << ans << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **线性 DP-摆花**

---

- **摆花**

  > 1、[摆花](https://cdn.oj.eriktse.com/problem.php?id=1045)：一共有 **n 种花**，按 1~n 标号，**m 个盆**，进行摆花，其中对于**每种花**不得超过`a[i]`盆(n, m, `a[i]`都不超过 100)。摆花时，**同种花放在一起**，**不同种类花**按照**标号从小到大**排列。输出**共有多少种方案**，结果对 10<sup>6</sup> + 7 取模  
  > 2、对于条件中的`a[i]`可解读为**第 i 种花只有**`a[i]`**盆**，由**数据量较小**可以推断大致允许 O(n\*m\*`a[i]`) 的复杂度，此外**不同种类花**应由题意**按标号从小到大选择**
  > 3、**确定状态**：令`dp[i][j]`表示**到第 i 种花为止**，**一共放了 j 盆花**的**总方案数**  
  > 4、**确定转移**：假设当前有 **2 种花**，**4 个盆**，`a[1] = 3, a[2] = 2`，为方便理解可手算**可能性共 2 种**，即`{1,1,2,2}, {1,1,1,2}`。当 i=2, j=4 时，思考`dp[2][4]`**的转移**(到第 2 种花为止一共放了 4 盆)，有**多种情况**：**令 k 表示**当前需要讨论的**第 i 种花放了 k 盆**(此例当前即第 2 种花放了 k 盆)；当 k=0 时，`dp[2][4] += dp[1][4]`(要使第 2 种花放 0 盆，，其需要到第 1 种花已经摆了 4 盆)；当 k=1 时，`dp[2][4] += dp[1][3]`(要使第 2 种花放 1 盆，其需要到第 1 种花已经摆了 3 盆)；当 k=2 时，`dp[2][4] += dp[1][2]`；因为`a[2] = 2`**只有 2 盆**，所以**上述为全部的可能**。综上，**可以总结**：`dp[i][j] += dp[i-1][j-k]`，其中`k < min(a[i], j)`  
  > 5、**初始化**：`dp[1][j] = 1`，其中`j <= a[i]`，到**第 1 种花摆任意多盆**都**只有 1 种摆法**，从 i=2 开始转移；也可以直接令`dp[0][0] = 1`从 i=1 开始转移，也能转移出`dp[1][j] = 1`

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 110;
  const int P = 1e6 + 7;
  int a[N], dp[N][N]; // 到第 i 种花一共摆了 j 盆的总方案数

  void solve()
  {
      int n, m;
      cin >> n >> m;
      for (int i = 1; i <= n; i++)
          cin >> a[i];

      // 初始化(也可以直接写 dp[0][0] = 1)
      for (int j = 0; j <= a[1]; j++)
          dp[1][j] = 1;

      // 到第 i 种花(如果初始化 dp[0][0] = 1 则应从 i=1 开始转移)
      for (int i = 2; i <= n; i++)
          // 一共摆了 j 盆
          for (int j = 0; j <= m; j++)
              // 其中第 i 种花摆了 k 盆
              for (int k = 0; k <= a[i] && k <= j; k++)
                  // 状态转移，取模
                  dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % P;

      cout << dp[n][m];
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **区间 DP-石子合并**

---

- **石子合并**

  > 1、[石子合并](https://cdn.oj.eriktse.com/problem.php?id=1107)：有 **n 个石子**排成一列(n 不超过 300)，给出**每个石子的质量 m**。每次可以**合并相邻的石子或石堆**为一堆，代价为**两者质量之和**，最终要将**所有石子合为一堆**。由于**合并顺序不同**，总代价也不同，求**最小总代价**  
  > 2、对于**区间 DP**，通常用`dp[i][j]`表示**区间**`[i, j]`之间的**价值最值**，并用一个**遍历的 k** 将`[i, j]`划分为**两个子区间**进行**状态转移**  
  > 3、**确定状态**：令`dp[i][j]`表示合并到**区间**`[i, j]`所需的**最小代价**  
  > 4、**确定转移**：**遍历 k**(范围`[i, j)`)，将**区间**`[i, j]`分为`[i, k]`和`[k+1, j]`**两个子区间**。则`dp[i][j]`可由**合并到这两个子区间所需的最小价值**加上这一次**将这两个子区间合并所需的价值**(即`sum(i, j)`)转移而来，由于 **k 是在遍历的**，所以还需要**取最小值**。因此得到`dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum(i, j))`  
  > 5、**初始化**：`dp[i][i] = 0`，合并为**长度为 1** 的区间**不需要代价**；此外，由于转移方程要**与自身取 min**，其余应**初始化为无穷**  
  > 6、由于**大区间的转移**需要**小区间的值**，所以实现时应**先算小区间**。因此第一维应**枚举区间长度 len**，从**长度为 2 开始**(长度为 1 不需要转移且已初始化)；第二维则只需要**枚举起点 i**，**终点**即可表示为`j = i + len - 1`

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 310;
  const int INF = 0x3f3f3f3f;
  int m[N], dp[N][N], prefix[N]; // dp[i][j] 表示合并到区间 [i, j] 的最小价值，prefix 为前缀和

  void solve()
  {
      int n;
      cin >> n;
      for (int i = 1; i <= n; i++)
          cin >> m[i];

      // 处理前缀和
      for (int i = 1; i <= n; i++)
          prefix[i] = prefix[i - 1] + m[i];

      // 初始化
      memset(dp, INF, sizeof(dp));
      for (int i = 1; i <= n; i++)
          dp[i][i] = 0;

      // 枚举区间长度 k
      for (int len = 2; len <= n; len++)
          // 枚举起点 i，终点 j 即为 i + k - 1，注意 j 的初始化和自增
          for (int i = 1, j = i + len - 1; j <= n; i++, j++)
              // 枚举中间点 k，范围 [i, j)
              for (int k = i; k < j; k++)
                  dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + prefix[j] - prefix[i - 1]);

      cout << dp[1][n];
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **树形 DP-最大子树和**

---

- **最大子树和**

  > 1、[最大子树和](https://cdn.oj.eriktse.com/problem.php?id=1108)：共 **T 组案例**，每组给定一棵 **n 个节点的树**(n 不超过 10<sup>5</sup>)，再给出**每个节点**的**权值 w**(可能为负)，再给出 n-1 组 **u,v**，表示存在**连接节点 u 和 v 的边**。规定**连通块权值**为**块内所有节点权值之和**(注意连通块可以只是子树中联通的部分节点，不一定需要完整的子树)，求出**最大的连通块权值**  
  > 2、对于**树形 DP**，通常用`dp[i]`表示**以 i 为根的子树**的**价值最值**。**归属法**：因为**以 i 为根**可能有**多棵子树**，所以可以用**子树根 i 的值**代表**以它为根的一系列子树**中的**价值最值**。需要注意，这样只是处理**每棵子树**的**价值最值**，最终**根节点的最值**不一定是**整棵树最大的最值**(如下例)。实现时大多数**树形 DP**都**采用 DFS 遍历**  
  > 3、**确定状态**：令`dp[i]`表示**以 i 为根的子树**的**最大权值和**  
  > 4、**确定转移**：对于一棵**以 x 为根的树**，其**最大权值和**首先一定要**包含 x 的价值**(以 x 为根，就不能把 x 排出去)，可以以此作为**初始化**；**找到更大的权值和**的过程，可以看作**是否选择子树**，用 **y** 遍历 **x 的子节点**，考虑**每一棵子树 y 的最大权值和**是否会让价值更大(如果为负，显然 x 不包含子树 y 更优)，则需要用 **max** 比较**当前权值和**与**加上子树 y 的权值和**。因此，转移方程为`dp[x] = max(dp[x], dp[x] + dp[y])`  
  > 5、**初始化**：初始`dp[i] = w[i]`，因为**以 i 为根**至少**包含它自己**，并清空**邻接表 vec**(有多组数据，必须初始化)  
  > 6、由于**大子树的转移**需要**小子树的值**，所以实现时要**先从小子树开始**，**使用 DFS 遍历**，这样对于**任意一棵子树**，**深度优先**能使其需要的所有子树都**递归地得到值**。由于**图是双向图**，**拓展时**还需要**记录父节点**，防止重复处理。另外需要注意，处理的只是**以 i 为根的子树**的**最优权值和**，处理后并**不能说明根节点**就是**最大权值和**(比如某一叶子节点为 1000，其余节点都为负)，所以输出时仍需要**找最大值**

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 1e5 + 10;

  vector<int> g[N];
  int w[N], dp[N]; // dp[i] 表示以 i 为根的子树的最大权值和

  // x 为当前节点，pre 为父节点
  void DFS(int x, int pre)
  {
      // y 遍历所有子节点
      for (auto &y : g[x])
      {
          // 如果 y 等于父节点就跳过，防止双向图重复处理
          if (y == pre)
              continue;

          DFS(y, x); // 深度优先，递归处理 dp[y]

          dp[x] = max(dp[x], dp[x] + dp[y]); // 状态转移
      }
  }

  void solve()
  {
      int n;
      cin >> n;
      for (int i = 1; i <= n; i++)
          cin >> w[i];

      // 初始化
      for (int i = 1; i <= n; i++)
      {
          dp[i] = w[i]; // dp[i] 一定至少包含它自己
          g[i].clear();
      }

      // 建图
      for (int i = 1; i <= n - 1; i++)
      {
          int u, v;
          cin >> u >> v;
          g[u].push_back(v);
          g[v].push_back(u);
      }

      DFS(1, -1); // 此处调用父节点为 -1 相当于表示 1 看作根节点

      // 输出最大的 dp
      cout << *max_element(dp + 1, dp + n + 1) << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **页底评论**

---
