---
title: 单调栈与单调队列
author: 圣奇宝枣
description: 学习并使用单调栈、单调队列解决问题
sticky: 0
date: 2023-11-05
updated: 2023-11-05
readmore: true
tags:
  - 单调栈
  - 单调队列
  - 栈
  - 队列
  - C++
categories:
  - 数据结构与算法
---

---

#### **单调栈**

---

- **单调栈**

  > 1、在**栈**的基础上，如果保持**栈内元素**是**有序的**，则称为**单调栈**，分为**单调递增栈**和**单调递减栈**  
  > 2、通常**单调栈**主要用于求**位置最近**的**更大值**或**更小值**，我们将在**具体样例中分析**

<!-- more -->

- **伪代码模板**

  ```cpp
  int arr[n];
  stack<int> stk; // 可存值，可存下标，此处以存值为例

  for(int i = 0; i < n; i++)
  {
      while(!stk.empty() && arr[i]优于stk.top())
          stk.pop(); // 弹出栈顶

      // 此时栈顶为对目前元素的最优答案
      if(stk.empty())
          栈空的操作
      else
          栈非空的操作

      stk.push(arr[i]); // 当前元素入栈
  }
  ```

---

#### **例-单调栈**

---

- **例-单调栈**

  > 1、[单调栈](https://cdn.oj.eriktse.com/problem.php?id=1082)：给定长度为 n 的**整数数组**，求出每个元素**左边第一个比它小的元素**，如果**不存在**则输出 -1  
  > 2、由题意，我们需要找到**位置最近**且**小于该点**的元素，可以使用**单调递增栈**来维护数据。遍历地**向栈内压入元素**，如果**待压入元素**小于等于**栈顶元素**，就**将栈顶元素弹出**，直至**待压入元素**大于**栈顶元素**再**压入该元素**。这是因为**待压入元素**小于等于**栈顶元素**的情况下，数组**右侧元素**向左查找时，如果**栈顶元素**满足条件，那么**待压入元素**也一定满足条件，且**待压入元素**的**位置更近**，这意味着无论如何都**不会再使用到栈顶元素**，便将其弹出  
  > 3、例如数组`{1, 3, 4, 2, 5, 7}`，过程为：**遍历 1**，栈内为空，输出 -1，将 1 入栈；**遍历 3**，栈顶为 1，输出 1，将 3 入栈；**遍历 4**，栈顶为 3，输出 3，将 4 入栈。但当**遍历 2 时**，**与栈顶比较**，2 小于等于 4 和 3，弹出 4，弹出 3，栈顶为 1，输出 1，将 2 入栈。**重要的是**，遍历**右侧元素**(5 和 7)时，因为**有 2 的存在**，它**更小**(更容易满足答案条件)**也更近**(更近的才是答案)，所以一定不会用到**更左边的 3 和 4**，因此将其**从栈内弹出**即可

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;
  int a[N];

  void solve()
  {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++)
          cin >> a[i];

      stack<int> stk; // 栈内存放元素值
      for (int i = 0; i < n; i++)
      {
          // 如果待压入元素 <= 栈顶元素，且栈非空
          while (!stk.empty() && a[i] <= stk.top())
              stk.pop(); // 弹出栈顶元素

          // 如果栈空，则输出 -1，否则输出栈顶元素
          if (stk.empty())
              cout << -1 << ' ';
          else
              cout << stk.top() << ' ';

          stk.push(a[i]); // 将当前元素压入栈
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **单调队列**

---

- **单调队列**

  > 1、**单调队列**虽然基于**队列**，但**单调队列**中的**元素值不一定是单调**的，而是根据**某种规则**`f(x)`**的值**单调的(可能`f(x) = a[x]`，也可能`f(x) = a[x] + b[x]`等)  
  > 2、通常**单调队列**使用**双端队列**`deque`来维护，因为**队列两头都可以出入**。维护过程中始终保持**队头为当前最优解**，向队尾**依次为单调次优解**  
  > 3、**元素入队**始终**从队尾依次比较**，如果**该元素更优**则**队尾出队**，找到合适位置**该元素入队**。此外只需要**维护队头是否合法**，不合法时**队头出队**即可

- **伪代码模板**

  ```cpp
  int arr[n];
  deque<int> dq;  // 通常存下标更方便管理

  for(int i = 0; i < n; i++)
  {
      while(!dq.empty() && dq.front()不合法)
          dq.pop_front(); // 弹出队头

      while(!dq.empty() && arr[i]优于dq.back())
          dq.pop_back();  // 弹出队尾

      dq.push_back(i);  // 当前元素下标入队尾
      // 此时队头为最优
      需要的操作
  }
  ```

---

#### **例-滑动窗口**

---

- **例-滑动窗口**

  > 1、[滑动窗口](https://cdn.oj.eriktse.com/problem.php?id=1084)：给定长度为 n 的**整数数组**，有一个**长度为 k 的窗口**从数组最左依次滑动到最右，回答**窗口在每个位置**时窗口内元素的**最大值**和**最小值**  
  > 2、在该题中，**规则**`f(x) = a[x]`，即只需按照**元素值大小**单调，因此**该例的单调队列**内元素是**升序或降序**的  
  > 3、思路类似于**单调栈**，保持**队头**是**当前最优解**，**从队尾依次检查**并**弹出不够优越的元素**，维护**队头向队尾**依次为**单调次优解**

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;
  int a[N];

  void solve()
  {
      int n, k;
      cin >> n >> k;
      for (int i = 0; i < n; i++)
          cin >> a[i];

      deque<int> dq; // 存放下标

      // 先求最大值
      for (int i = 0; i < n; i++)
      {
          // 窗口为以 i 为右端点，大小为 k 的区间，即窗口为 [i + 1 - k, i]
          // 如果队列非空，并且队头下标非法，即对头元素在窗口外
          while (!dq.empty() && dq.front() < i + 1 - k)
              dq.pop_front(); // 弹出队头

          // 如果队列非空，且当前元素比队尾更大更优越
          while (!dq.empty() && a[i] >= a[dq.back()])
              dq.pop_back(); // 弹出队尾

          dq.push_back(i); // 当前元素下标入队尾
          // 此时队头为最大值

          // 前几次时还没有形成大小为 k 的窗口，形成后队头即为最大值
          if (i >= k - 1)
              cout << a[dq.front()] << ' ';
      }

      cout << '\n';
      dq = deque<int>(); // 清空 dq

      // 再求最小值
      for (int i = 0; i < n; i++)
      {
          // 窗口为以 i 为右端点，大小为 k 的区间，即窗口为 [i + 1 - k, i]
          // 如果队列非空，并且队头下标非法，即对头元素在窗口外
          while (!dq.empty() && dq.front() < i + 1 - k)
              dq.pop_front(); // 弹出队头

          // 如果队列非空，且当前元素比队尾更小更优越
          while (!dq.empty() && a[i] <= a[dq.back()])
              dq.pop_back(); // 弹出队尾

          dq.push_back(i); // 当前元素下标入队尾
          // 此时队头为最小值

          // 前几次时还没有形成大小为 k 的窗口，形成后队头即为最小值
          if (i >= k - 1)
              cout << a[dq.front()] << ' ';
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **页底评论**

---
