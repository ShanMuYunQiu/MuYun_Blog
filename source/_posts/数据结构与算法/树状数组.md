---
title: 树状数组
author: 圣奇宝枣
description: 学习树状数组，学习单点修改、区间修改和区间查询操作，使用树状数组来维护区间和
sticky: 0
date: 2023-11-08
updated: 2023-11-08
readmore: true
tags:
  - 树状数组
  - 树
  - C++
categories:
  - 数据结构与算法
---

---

#### **树状数组**

---

- **树状数组**

  > 1、**树状数组**常用于**维护区间和**，有以下操作：**单点修改**O(1)，**区间修改**O(log n)，**区间查询**O(log n)  
  > 2、**树状数组**的**结构如下图**，注意**树状数组**中一定**不能用下标 0**。`T[i]`所存的值为**管辖区间的和**，`T[i]`所覆盖的**管辖区间**为`[i - lowbit(i) + 1, i]`，**管辖区间长度**为`lowbit(i)`  
  > 3、`lowbit(i)`表示 i 的二进制**只保留最后一位 1**的结果(例如二进制`1101100`只保留后三位变为`100`)，**公式为**`lowbit(x) = x & -x`

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/树状数组.png)

- **区间查询**

  > 1、假如需要查询`[1, 7]`的**区间和**，可以通过**树状数组**的值进行拼凑，即`sum = T[7] + T[6] + T[4]`  
  > 2、由于`T[i]`**管辖区间长度**为`lowbit(i)`，所以很容易就能得到**拼凑所需的**`T[i]`。如该例首先一定会从`T[7]`**开始拼凑**，只需要**不断迭代**`T[i - lowbit[i]]`即可，如`T[7 - lowbit(7)] = T[6]`、`T[6 - lowbit(6)] = T[4]`、`T[4 - lowbit(4)] = T[0]`时结束  
  > 3、**注意**：这种方法只能得到`[1, r]`的**前缀和**，如果要求`[l, r]`**区间和**，需要按照**前缀和**思路处理`getsum(r) - getsum(l - 1)`

  ```cpp
  const int N = 3e5 + 10;
  int a[N], t[N];   // 原数组与树状数组
  int n;            // 数组大小

  int lowbit(int x)
  {
      return x & -x;
  }

  // 区间查询
  int getsum(int k)
  {
      int sum = 0;
      for (int i = k; i > 0; i -= lowbit(i))
          sum += t[i];
      return sum;
  }
  ```

- **单点修改**

  > 1、假如**原数组**中`a[3]`的值**增加了**，在**树状数组**中覆盖到`a[3]`的`T[i]`都**应该增加**，即`T[3]`、`T[4]`、`T[8]`应该修改，怎么确定被覆盖的位置？  
  > 2、首先一定会从`T[3]`**开始修改**，再向后**不断迭代**`T[i + lowbit(i)]`即可**确定其他位置**，如`T[3 + lowbit(3)] = T[4]`、`T[4 + lowbit(4)] = T[8]`类推，因此**迭代次数**是**log 级**

  ```cpp
  const int N = 3e5 + 10;
  int a[N], t[N];   // 原数组与树状数组
  int n;            // 数组大小

  int lowbit(int x)
  {
      return x & -x;
  }

  // 单点修改
  void update(int k, int x)
  {
      for (int i = k; i <= n; i += lowbit(i))
          t[i] += x;
  }
  ```

---

#### **例-单点修改**

---

- **单点修改**

  > 1、[单点修改](https://cdn.oj.eriktse.com/problem.php?id=1070)：给定一个**长度为 n 的数组 a**，**q 次操作**。操作有两种：输入`1 k v`表示`a[k] += v`，输入`2 l r`表示**查询**`[l, r]`**区间和**并输出  
  > 2、对于**大多数题目**，一开始**输入数组 a**时，应把**树状数组**每个元素看作**值为 0**，通过**单点修改**构造**初始的树状数组**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  #define int long long
  const int N = 3e5 + 10;
  int a[N], t[N];   // 原数组与树状数组
  int n, q;         // 数组大小

  int lowbit(int x)
  {
      return x & -x;
  }

  // 单点修改
  void update(int k, int x)
  {
      for (int i = k; i <= n; i += lowbit(i))
          t[i] += x;
  }

  // 区间查询
  int getsum(int k)
  {
      int sum = 0;
      for (int i = k; i > 0; i -= lowbit(i))
          sum += t[i];
      return sum;
  }

  void solve()
  {
      cin >> n >> q;
      for (int i = 1; i <= n; i++)
          cin >> a[i];

      // 构造树状数组
      for (int i = 1; i <= n; i++)
          update(i, a[i]);

      while (q--)
      {
          int op;
          cin >> op;

          // 单点修改
          if (op == 1)
          {
              int k, v;
              cin >> k >> v;
              update(k, v);
          }
          // 区间查询
          else
          {
              int l, r;
              cin >> l >> r;
              cout << getsum(r) - getsum(l - 1) << '\n';
          }
      }
  }

  signed main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **页底评论**

---
