---
title: 最短路
author: 圣奇宝枣
description: 学习 Dijkstra 单源带权最短路和 Floyd 多源带权最短路
sticky: 0
date: 2023-11-14
updated: 2023-11-14
readmore: true
tags:
  - Dijkstra
  - Floyd
  - 图
  - C++
categories:
  - 数据结构与算法
---

---

#### **Dijkstra 单源带权(朴素)**

---

- **Dijkstra 朴素算法**

  > 1、[最短路 1](https://cdn.oj.eriktse.com/problem.php?id=1073)：给定**n 个点 m 条边**的有向图(n 不超过 10<sup>3</sup>)，输出**点 1 到 n**的**最短距离**。对于**m 条边**，每次输入 u、v、w，表示存在一条**从 u 到 v**的**权值为 w**的有向边。如果不存在路径，输出 -1  
  > 2、先前在[图与回溯](https://www.shengqibaozao.eu.org/2023/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE%E4%B8%8E%E5%9B%9E%E6%BA%AF/)中介绍过**权值相等最短路**(无权最短路)，现在有了**权值**，需要做一个结构体保存。**Dijkstra**还使用一个**数组**`d[]`，`d[i]`表示**从起点 st 到 i 的最短距离**  
  > 3、**Dijkstra 思路如下图**：起始时，**建图**，标记所有`d[i]`为**无穷大**，以 1 为起点，**向外走一层**，**将经过的边松弛**(用边的权值更新所到点的`d[i]`，`d[i]`取较小值)；接下来，比较得到**最小的**`d[i]`，**以该点为当前起点**(图中为点 2)，先前的点已经可以忽略，继续**向外走一层**，**将经过的边松弛**(注意，`d[3]`取较小值更新为 3)；以此类推，**以 4 为当前起点**发现**点 4 没有出点**，**返回**；**以 3 为当前起点**，走到终点，更新`d[5]`为 6，所以**最短路**为 6  
  > 4、该算法结合了**贪心**和**DP**的思想，每个点**只拓展一次**，且拓展时**已为最短距离**

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/Dijkstra.png)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int INF = 0x3f;
  const int N = 1e3 + 10;

  // 出边
  struct Edge
  {
      // x 表示出点，w 表示权值
      int x, w;
  };

  vector<Edge> g[N]; // g 是一个 vector<Edge> 的数组
  int d[N];          // d[i] 表示从起点 st 到 i 的最短距离
  int n, m;

  // Dijkstra 朴素
  void Dijkstra(int st)
  {
      memset(d, INF, sizeof(d)); // 初始化 d[i] 为 INF
      d[st] = 0;                 // 起始点 d[st] 为 0

      bitset<N> vis; // 标记是否拓展过

      // 进行 n 轮检验
      for (int i = 1; i <= n; i++)
      {
          // 找出 d[i] 最小点 u
          int u = 1;
          for (int j = 1; j <= n; j++)
              // 如果当前的点 u 未被拓展(被拓展过就必须更换) 或 (d[j] < d[u] 且 j 未被拓展)
              if (vis[u] || !vis[j] && d[j] < d[u])
                  u = j;

          // 此时 u 点为 d[i] 最短点，d[u] 为当前最优长度
          // 从 u 点向下松弛，开始拓展，标记 vis[u]
          vis[u] = true;
          // 遍历所有 u 的出边
          for (auto &[v, w] : g[u])
              // 如果 v 未被拓展 且经 u 到 v 的总距离比原先(可能的) d[v] 更短
              if (!vis[v] && d[u] + w < d[v])
                  d[v] = d[u] + w; // 更新 d[v]
      }
  }

  void solve()
  {
      cin >> n >> m;
      for (int i = 1; i <= m; i++)
      {
          int u, v, w;
          cin >> u >> v >> w;
          // 判断不是自环
          if (u != v)
              g[u].push_back({v, w}); // 存储有向图
      }

      Dijkstra(1);

      cout << (d[n] ? d[n] : -1);
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **Dijkstra 单源带权(堆优化)**

---

- **Dijkstra 堆优化**

  > 1、待更新

---

#### **Floyd 多源带权**

---

- **Floyd 多源带权最短路**

  > 1、待更新

---

#### **页底评论**

---
