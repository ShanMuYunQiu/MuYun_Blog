---
title: 权值线段树和主席树
author: 山暮云秋
description: 学习权值线段树和主席树(可持久化权值线段树)，维护数组元素的属性(元素出现次数，或其他权值)，求第 k 大/小的元素
sticky: 0
readmore: true
tags:
  - 权值线段树
  - 树
  - C++
categories:
  - 数据结构与算法
abbrlink: 8893d943
date: 2024-08-08 00:00:00
updated: 2024-08-08 00:00:00
---

---

### **权值线段树**

---

- **权值线段树**

  > 1、[权值线段树](https://www.starrycoding.com/problem/86)：输入**操作次数** $q$ ($q \leq 2 \times 10^5$)，起始你有一个**空的多重集合**(允许元素多次出现)，对于每次操作：输入 $1\ x$ 表示向集合**添加元素** $x$，输入 $2\ l\ r$ 查询大小在 $[l, r]$ 之间的**元素个数**，输入 $3\ k$ 查询集合中**第** $k$ **小的元素**  
  > 2、先前介绍的**线段树**用于维护**原数组的区间信息**，而**权值线段树**用于维护**数组元素的某种属性**，例如**元素出现次数**或**其他权值**(但一般就是维护元素出现次数，即维护元素出现次数这个桶)，数据结构上与**线段树**类似  
  > 3、以**维护元素出现次数**为例，**原数组**若为`{1, 2, 1, 3, 5}`，则**元素出现次数**的**桶**内为`{[1]:2, [2]:1, [3]:1, [4]:0, [5]:1}`。给这个桶**建立线段树**即为**权值线段树**，每个节点的**管辖区间**表示**管辖数字的范围**，权值为**管辖范围内**这些数字的**出现次数**，如**节点**`[1, 4] : 4`表示**数字** $1 \to 4$ **共出现了** $4$ **次**(下图为线段树结构，请按上述描述类比理解权值线段树的结构)，树的**叶子结点**从左至右对应**这个桶本身**且**管辖区间**(对应桶的下标，也即元素值)从左至右都是**升序的**  
  > 4、**权值线段树**可以进行的操作有**单点更新**(不依赖 $lazytag$，插入一个元素时更新线段树权值)、**数量查询**(查询元素大小在 $[l, r]$ 之间的元素个数)、**数组查询**(查询整个数组中第 $k$ 大/小的元素值)，所有操作从**根节点开始**。**单点更新**，与**线段树**搜寻策略相同，但可以搜寻过程中**直接更新权值**(因为不需要维护 $lazytag$)，当然也可以**找到叶子后**递回时`pushup`。**数量查询**，即对**桶**求**区间和**，在**权值线段树**上的处理和**加法线段树**是相同的，凑出**完整的询问区间**求和即可  
  > 5、**数组查询**，查找**第** $k$ **小的元素值**，从**根节点**起，看**左子节点权值** $t[l]$：由于**管辖区间**(对应桶的下标，也即元素值)从左至右都是**升序的**，**权值** $t[l]$ 则表示**前** $t[l]$ **小**的元素都在**左子节点区间**。如果 $t[l] \geq k$，说明**第** $k$ **小**在**左子节点区间**，应**向左**继续查找**第** $k$ **小**；否则，则应向右查找**第** $k - t[l]$ **小**的元素(因为左区间有 $t[l]$ 个更小的元素，向右查询时应减去 $t[i]$ 排除掉这些元素)；最后，应查找到一个**叶子结点**，其**管辖区间**即为**所求元素值**。类似地，查找**第** $k$ **大**时应判断**右子节点权值**，如果 $t[r] \geq k$ 则向右查第 $k$ 大，否则向左查第 $k - t[r]$ 大

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShanMuYunQiu/Image/blog/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%93%E6%9E%842.png)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;

  int n = 2e5;   // 预想足够的元素个数
  int t[N << 2]; // 权值线段树

  // 上拉操作
  void pushup(int o)
  {
      t[o] = t[o << 1] + t[o << 1 | 1];
  }

  // 插入元素
  void insert(int x, int s = 1, int e = n, int o = 1)
  {
      // 到达叶子结点，计数 +1
      if (s == e)
      {
          t[o]++;
          return;
      }

      int mid = (s + e) >> 1;
      // 向左走
      if (mid >= x)
          insert(x, s, mid, o << 1);
      // 向右走
      else
          insert(x, mid + 1, e, o << 1 | 1);

      pushup(o);
  }

  // 数量查询，查找大小在 [l, r] 的元素个数
  int queryCnt(int l, int r, int s = 1, int e = n, int o = 1)
  {
      if (l <= s && e <= r)
          return t[o];

      int res = 0;
      int mid = (s + e) >> 1;
      // 判断是否需要向左走，如果左子区间 [s, mid] 与 [l, r] 有交集，就要走
      if (mid >= l)
          res += queryCnt(l, r, s, mid, o << 1);
      // 判断是否需要向右走，如果右子区间 [mid + 1, e] 与 [l, r] 有交集，就要走
      if (mid + 1 <= r)
          res += queryCnt(l, r, mid + 1, e, o << 1 | 1);

      return res;
  }

  // 数组查询，查找第 k 小的元素
  int queryVal(int k, int s = 1, int e = n, int o = 1)
  {
      // 到达叶子结点，返回管辖区间(所求元素)
      if (s == e)
          return s;

      int mid = (s + e) >> 1;

      // 看左子节点的权值
      int leftsum = t[o << 1];
      // 向左走
      if (leftsum >= k)
          return queryVal(k, s, mid, o << 1);
      // 向右走
      else
          return queryVal(k - leftsum, mid + 1, e, o << 1 | 1);
  }

  void solve()
  {
      int q;
      cin >> q;
      while (q--)
      {
          int op;
          cin >> op;
          if (op == 1)
          {
              int x;
              cin >> x;
              insert(x);
          }
          else if (op == 2)
          {
              int l, r;
              cin >> l >> r;
              cout << queryCnt(l, r) << '\n';
          }
          else
          {
              int k;
              cin >> k;
              cout << queryVal(k) << '\n';
          }
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **页底评论**

---
