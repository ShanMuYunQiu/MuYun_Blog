---
title: 线性DP
author: 圣奇宝枣
description: 学习动态规划中的线性DP(及其中的背包问题)，通过动态规划的思想不重不漏地表达整个集合，推导出线性的状态转移方程
sticky: 0
date: 2023-11-26
updated: 2023-12-14
readmore: true
tags:
  - 线性DP
  - 动态规划
  - C++
categories:
  - 数据结构与算法
---

---

#### **01 背包-采药**

---

- **采药**

  > 1、[采药](https://cdn.oj.eriktse.com/problem.php?id=1026)：输入 **T 和 M** 分别表示**拥有的总时间**和**药材种类**(T 不超过 1000，M 不超过 100)，对于每种药材，输入 **t 和 v**(都不超过 100)，表示采摘该药材**需要的时间**和**药材的价值**，每种药材**只可采摘一次**。可能输入**多组数据**，直到 **T 和 M 都为 0** 结束。对于**每组数据**，输出其**规定时间内**能采摘的**药材价值之和的最大值**  
  > 2、对于**每种药材**都可以**用 0 或 1 标记状态**(是否被选择)，是一个**01 背包**问题。运用**动态规划**的思想，先**确定状态**：令`dp[i][j]`表示**到第 i 个物品为止**，**用了 j 的时间**，**所获得的最大价值**  
  > 3、再**确定转移**，对于**当前的**`dp[i][j]`，有**两种情况**：如果**没选择当前第 i 个物品**，则`dp[i][j] = dp[i-1][j]`(没有花费时间，没有增加价值，和上一个——到第 i-1 个物品的状态相同)；如果**选择了当前第 i 个物品**，则`dp[i][j] = dp[i-1][j-t[i]] + v[i]`(当前状态等同于`dp[i-1][j-t[i]]`上一个物品的价值 + 当前物品价值，其中因为当前`dp[i][j]`花费的总时间为 j，所以上一个物品的时间应为`j-t[i]`)  
  > 4、最后确定**初始化和边界**：**初始化**`dp[0][i] = 0`(到第 0 个物品无论花费多少时间，价值为 0)；**边界**为 i <= M, j <= T

  <!-- more -->

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  int T, M;
  int dp[110][1010]; // dp[i][j] 表示到第 i 个物品花费 j 的时间的最大价值
  int t[110], v[110];

  void solve()
  {
      // 初始化
      for (int i = 0; i <= T; i++)
          dp[0][i] = 0;

      // 输入
      for (int i = 1; i <= M; i++)
          cin >> t[i] >> v[i];

      // 注意转移方程中，其中一种为 dp[i][j] = dp[i-1][j-t[i]] + v[i]，令 i_ = i-1，j_ = j-t[i]
      // 则隐含 i_ < i, j_ < j，所以遍历方向一定要从小到大
      // 状态转移，dp[i][j] = dp[i-1][j] 或 dp[i-1][j-t[i]] + v[i]，取大值
      for (int i = 1; i <= M; i++)
      {
          for (int j = 0; j <= T; j++)
          {
              // 注意判断时间的合法性，不要越界
              if (j - t[i] >= 0)
                  dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - t[i]] + v[i]);
              else
                  dp[i][j] = dp[i - 1][j];
          }
      }

      // 输出，到第 M 个物品花费 T 时间的最大价值
      cout << dp[M][T] << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      while (cin >> T >> M)
      {
          if (T == 0 && M == 0)
              break;
          solve();
      }
      return 0;
  }
  ```

- **滚动数组优化**

  > 1、回顾之前的思路中，`dp[i][j]`**所需的值**只有`dp[i-1][j]`与`dp[i-1][j-t[i]]`，而当**更新完当前**`dp[i][j]`后，**前一行**即`dp[i-1]`**行**就**不需要了**。因此，**实际需要的行数**只需要**两行**，一行表示**当前行**，一行表示**前一行**  
  > 2、由于**数组的拷贝**又**需要开销**，所以可以**换一种方法实现**。只开**两行的数组**`dp[0][]`与`dp[1][]`，**当前更新第 0 行时**就由**第 1 行的状态**转移过来，反之亦然。这样**交替更新**，就实现了**滚动数组**，节省空间  
  > 3、具体地，可以通过**奇偶性**或**位运算**实现。用`cur = i & 1`标记哪一行表示**当前行**，则`cur ^ 1`即为**另一行**(上一行)。最后输出时即输出**最后一行**`cur`的那一行，即`dp[M & 1][T]`

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  int T, M;
  int dp[2][1010]; // dp[i][j] 表示到第 i 个物品花费 j 的时间的最大价值
  int t[110], v[110];

  void solve()
  {
      // 初始化
      for (int i = 0; i <= T; i++)
          dp[0][i] = 0;

      // 输入
      for (int i = 1; i <= M; i++)
          cin >> t[i] >> v[i];

      // 注意转移方程中，其中一种为 dp[i][j] = dp[i-1][j-t[i]] + v[i]，令 i_ = i-1，j_ = j-t[i]
      // 则隐含 i_ < i, j_ < j，所以遍历方向一定要从小到大
      // 状态转移，dp[i][j] = dp[i-1][j] 或 dp[i-1][j-t[i]] + v[i]，取大值
      for (int i = 1; i <= M; i++)
      {
          // 滚动数组优化，cur 表示当前行，cur ^ 1 表示上一行(另一行)
          int cur = i & 1;

          for (int j = 0; j <= T; j++)
          {
              // 注意判断时间的合法性，不要越界
              if (j - t[i] >= 0)
                  dp[cur][j] = max(dp[cur ^ 1][j], dp[cur ^ 1][j - t[i]] + v[i]);
              else
                  dp[cur][j] = dp[cur ^ 1][j];
          }
      }

      // 输出，到第 M 个物品(最后一行的 cur = M & 1)花费 T 时间的最大价值
      cout << dp[M & 1][T] << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      while (cin >> T >> M)
      {
          if (T == 0 && M == 0)
              break;
          solve();
      }
      return 0;
  }
  ```

- **一维优化**

  > 1、在**滚动数组**中`dp[cur][j] = max(dp[cur ^ 1][j], dp[cur ^ 1][j - t[i]] + v[i]);`，其本质可看作**先将上一行复制到当前行**，再**进行转移**比较，因此可以再将其**压缩为一维**(省去了复制的步骤)，`dp[j]`表示**到目前为止**，**花费了 j 时间**的**最大价值**  
  > 2、此时**转移方程**变为`dp[j] = max(dp[j], dp[j - t[i]] + v[i])`，但**转移时**应使用**上一行时的数据**，如果**自左向右**遍历，**左侧的数据已被更新**(即`dp[j - t[i]]`已经变为当前行数据)。因此要**自右向左**遍历，范围从**最大时间开始**，始终满足`j - t[i] >= 0`

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  int T, M;
  int dp[1010]; // dp[j] 表示到当前为止花费 j 的时间的最大价值
  int t[110], v[110];

  void solve()
  {
      // 初始化
      for (int i = 0; i <= T; i++)
          dp[i] = 0;

      // 输入
      for (int i = 1; i <= M; i++)
          cin >> t[i] >> v[i];

      // 状态转移，dp[j] = max(dp[j], dp[j - t[i]] + v[i])
      for (int i = 1; i <= M; i++)
          // j 自右向左遍历，注意转移范围要保证 j - t[i] >= 0
          for (int j = T; j - t[i] >= 0; j--)
              dp[j] = max(dp[j], dp[j - t[i]] + v[i]);

      // 输出，到最后花费 T 时间的最大价值
      cout << dp[T] << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      while (cin >> T >> M)
      {
          if (T == 0 && M == 0)
              break;
          solve();
      }
      return 0;
  }
  ```

---

#### **完全背包-无穷背包**

---

- **无穷背包**

  > 1、[无穷背包](https://cdn.oj.eriktse.com/problem.php?id=1024)：给定**容积为 m 的背包**(不超过 10<sup>5</sup>)，有 **n 种商品**(不超过 500)，每种商品**价值为 w**(不超过 10<sup>9</sup>)，**体积为 v**(不超过 m)。若商品**数量无限**且**可以重复放入**同一商品，输出**最多可以带走多少价值**的物品  
  > 2、与上一题不同，每件物品**可以重复选择**，是**完全背包**问题。运用**动态规划**的思想，先**确定状态**：令`dp[i][j]`表示**到第 i 个物品为止**，**用了 j 的容积**，**所获得的最大价值**  
  > 3、再**确定转移**，对于**当前的**`dp[i][j]`，有**两种情况**：如果**没选择当前第 i 个物品**，则`dp[i][j] = dp[i-1][j]`(没有花费容积，没有增加价值，和上一个——到第 i-1 个物品的状态相同)，此时直接标记`dp[i][j]`，其相当于**选择了 0 个第 i 个物品**；如果**选择了当前第 i 个物品**，则`dp[i][j] = dp[i][j-v[i]] + w[i]`(当前状态等同于`dp[i][j-v[i]]`当前行当前个数-1 个物品的价值 + 当前物品价值，其中因为当前`dp[i][j]`花费的总容积为 j，所以当前数量-1 个物品的容积应为`j-v[i]`)  
  > 4、最后确定**初始化和边界**：**初始化**`dp[0][i] = 0`(到第 0 个物品无论花费多少容积，价值为 0)；**边界**为 i <= n, j <= m  
  > 5、由于**朴素算法**的**数组大小过大**，所以**栈空间不足**，需要用**滚动数组优化**为 **2 行的数组**

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 510;
  const int A = 1e5 + 10;

  int m, n;       // 容积和商品种类
  int dp[N][A];   // 到第 i 个物品花费 j 容积的最大价值
  int w[N], v[N]; // 商品价值和体积

  void solve()
  {
      cin >> m >> n;

      // 初始化
      for (int i = 0; i <= m; i++)
          dp[0][i] = 0;

      // 输入
      for (int i = 1; i <= n; i++)
          cin >> w[i] >> v[i];

      // 状态转移
      for (int i = 1; i <= n; i++)
      {
          for (int j = 0; j <= m; j++)
          {
              if (j - v[i] >= 0)
                  dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]);
              else
                  dp[i][j] = dp[i - 1][j];
          }
      }

      // 输出
      cout << dp[n][m] << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

- **滚动数组优化**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  #define int long long
  const int N = 510;
  const int A = 1e5 + 10;

  int m, n;       // 容积和商品种类
  int dp[2][A];   // 到第 i 个物品花费 j 容积的最大价值
  int w[N], v[N]; // 商品价值和体积

  void solve()
  {
      cin >> m >> n;

      // 初始化
      for (int i = 0; i <= m; i++)
          dp[0][i] = 0;

      // 输入
      for (int i = 1; i <= n; i++)
          cin >> w[i] >> v[i];

      // 状态转移
      for (int i = 1; i <= n; i++)
      {
          // 滚动数组优化：当前行为 cur，上一行为 cur ^ 1
          int cur = i & 1;

          for (int j = 0; j <= m; j++)
          {
              if (j - v[i] >= 0)
                  dp[cur][j] = max(dp[cur ^ 1][j], dp[cur][j - v[i]] + w[i]);
              else
                  dp[cur][j] = dp[cur ^ 1][j];
          }
      }

      // 输出，最后一行的 cur = n & 1
      cout << dp[n & 1][m] << '\n';
  }

  signed main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **多重背包-多重背包**

---

- **多重背包**

  > 1、[多重背包](https://cdn.oj.eriktse.com/problem.php?id=1103)：给定**容积为 m 的背包**，有 **n 种商品**(m,n 不超过 100)，其中每种商品**只有 s 件**，**价值为 w**，**体积为 v**(都不超过 100)。若**可以重复放入**同一商品，输出**最多可以带走多少价值**的物品  
  > 2、**多重背包**可以看作**商品限量**的**完全背包**。对于**每种商品有 s 件**，可以将其展开为 **s 件单独的只能选 1 次的商品**，即如**有 3 件商品 a**，可看作**有 3 个只能选 1 次的商品 a**，此时即将其转化为**01 背包**解决  
  > 3、实际实现中，**并不会**将展开的商品**存储下来**，而是**读到一件商品**，跑`s[i]`遍**一维 01 背包**。但注意，只适合**数据量较小**的情况

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 110;
  int dp[N]; // 一维 01 背包，到当前为止花费 j 容量的最大价值

  void solve()
  {
      int m, n;
      cin >> m >> n;

      for (int i = 1; i <= n; i++)
      {
          int s, w, v;
          cin >> s >> w >> v;

          // 执行 s 次 01 背包
          while (s--)
              // 一维 01 背包
              for (int j = m; j - v >= 0; j--)
                  dp[j] = max(dp[j], dp[j - v] + w);
      }

      // 输出到最后花费 m 容积的最大价值
      cout << dp[m];
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

- **二进制优化**

  > 1、[多重背包二周目](https://cdn.oj.eriktse.com/problem.php?id=1104)：在上题基础上，**n,m,s 范围**改为不超过 2000  
  > 2、由于**原思路**时间复杂度 O(n\*m\*s)，一定**超时**。原先的**拆分思路**为**将 s 拆分**为 **s 个 1 相加**，再来表示选择`[0, s]`**个物品**的情况(如 84 个商品相当于从中选 84 个 1 个商品相加表示)  
  > 3、还可以用**二进制拆分**的方式优化，从**二进制低位向高位**拆分，**剩余不够拆的**放在最后，例如`s = 116`时**可拆分为**`s = 1 + 2 + 4 + 8 + 16 + 32 + 53`，这样选择`[0, s]`**个物品**一定能够**被这些数组合得到**(如`84 = 1 + 2 + 4 + 8 + 16 + 53`)，也可以达到**原思路相同的效果**  
  > 4、此时执行**01 背包**时，可看作**拆分出的商品**被**打包在一起**，如上`s = 116`时即对 1 个商品、2 个商品、4 个商品、8 个商品等**进行选择**(其 w,v 也乘以对应的系数 1,2,4,8)

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  #define int long long

  const int N = 2010;
  int dp[N]; // 一维 01 背包，到当前为止花费 j 容量的最大价值

  void solve()
  {
      int m, n;
      cin >> m >> n;

      for (int i = 1; i <= n; i++)
      {
          int s, w, v;
          cin >> s >> w >> v;

          vector<int> vec; // 记录 s 的拆分
          // 从二进制低位向高位拆分 s
          int x = 1;
          while (s >= x)
          {
              vec.push_back(x);
              s -= x;
              x <<= 1;
          }
          // 如果还有剩余，也加入 vec
          if (s)
              vec.push_back(s);

          // 从 vec 中取 k 作为系数，用于表示 [0, s] 之间的所有可能
          for (int &k : vec)
              // 一维 01 背包(注意范围，v 也要乘系数)
              for (int j = m; j - k * v >= 0; j--)
                  dp[j] = max(dp[j], dp[j - k * v] + k * w);
      }

      // 输出到最后花费 m 容积的最大价值
      cout << dp[m];
  }

  signed main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **线性 DP-最长上升子序列**

---

- **最长上升子序列**

  > 1、[最长上升子序列(easy)](https://cdn.oj.eriktse.com/problem.php?id=1105)：给定一个**长度为 n** 的**数组 a**(n 不超过 1000)，求其**最长上升子序列**(非降)的**长度**。注意：**子序列不一定是连续的**  
  > 2、对于输入的每一个`a[i]`，可知都有**两种情况**：一种是它作为**最长上升子序列的起点**，另一种是它**接续在其他上升子序列之后**。**确定状态**：令`dp[i]`表示**以 i 结尾的最长上升子序列长度**  
  > 3、**确定转移**：对于`a[i]`**作为起点**，`dp[i] = 1`；对于`a[i]`**作为接续**，应向左搜寻**小于等于 i 的元素 j**，`dp[i] = max(dp[i], dp[j] + 1)`，**遍历取最大值**  
  > 4、易知，该算法复杂度为 O(n<sup>2</sup>)，只能处理小规模数据，仍需优化

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 1010;
  int a[N], dp[N]; // 以 i 为终点的最长上升子序列长度

  void solve()
  {
      int n;
      cin >> n;
      for (int i = 1; i <= n; i++)
          cin >> a[i];

      for (int i = 1; i <= n; i++)
      {
          dp[i] = 1; // 对于每个点，都可以先作为起点

          // 找左侧比当前点小的点，状态转移
          for (int j = 1; j < i; j++)
              if (a[j] <= a[i])
                  dp[i] = max(dp[i], dp[j] + 1);
      }

      // 找最长的上升子序列
      int ans = 0;
      for (int i = 1; i <= n; i++)
          ans = max(ans, dp[i]);

      cout << ans;
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

- **单调栈二分优化**

  > 1、[最长上升子序列(hard)](https://cdn.oj.eriktse.com/problem.php?id=1037)：在上题基础上，**数组长度 n** 改为不超过 2 \* 10<sup>5</sup>  
  > 2、在**遍历求**`dp[i]`的过程中，可知：对于**点 i 在接续时**，其**左侧点 j**，如果`dp[j]`**最长**且`a[j]`**最小**，那么**点 i** 接续到**点 j** 后**一定为最优**，因此需要维护一个**单调栈**(单调不减的单调栈，维护栈顶为`dp[j]`最长且`a[j]`最小的点的位置)  
  > 3、这个**单调栈**在维护时需要一些**特殊操作**，所以需要在原模型上**改良一下**：当**准备入栈的元素 i**的`a[i]`**比栈顶元素单调不减**时，**将 i 入栈**，`dp[i] = dp[top] + 1`(从栈顶元素转移)；当**准备入栈的元素 i**的`a[i]`**比栈内某些元素小**时，并不是**从栈顶向下依次出栈再取代**(因为并不满足`dp[i]`最长的条件)，而是找到**栈内第一个大于**`a[i]`的元素 k，**将其取代**，`dp[i] = dp[k]`(从元素 k 转移，且长度与其相同)  
  > 4、例如`{2, 5, 3, 4, 7, 3}`：当**第一个 3 需要入栈**时(i = 2)，**单调栈**内元素为`{2, 5}`，应找到**第一个大于 3 的元素**——5，将其替换，此时`dp[i] = dp[1] = 2`(1 为元素 5 的位置)，栈内变为`{2, 3}`(显然子序列`{2, 3}`比`{2, 5}`更优秀)；当**第二个 3 需要入栈**时(i = 5)，**单调栈**内元素为`{2, 3, 4, 7}`，应找到**第一个大于 3 的元素**——4，将其替换，此时`dp[i] = dp[3] = 3`(3 为元素 4 的位置)，栈内变为`{2, 3, 3, 7}`(其实际子序列为`{2, 3, 3}`，长度为 3)  
  > 5、对于**查找**的操作，可以使用**二分查找**，但因为其需要**操作下标**，所以**单调栈的实现**应该使用**数组实现**，不能使用`STL`的`stack`。此外，由于只需要**最长上升子序列**的**长度**，所以**单调栈的长度**就是**最长上升子序列的长度**，不再需要`dp[]`数组，栈内也**不需要维护点的位置**，而是可以**直接维护**`a[i]`

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;
  int a[N], stk[N], top = 0; // 用数组实现单调栈

  void solve()
  {
      int n, ans = 0;
      cin >> n;

      for (int i = 1; i <= n; i++)
          cin >> a[i];

      for (int i = 1; i <= n; i++)
      {
          // pos 即 a[i] 在单调栈中的位置
          // 找单调栈中第一个 > a[i] 的下标 = 最后一个 <= a[i] 的下标 + 1
          int pos = (upper_bound(stk + 1, stk + 1 + top, a[i]) - stk - 1) + 1;

          // 如果 pos 超出了 top 栈顶的位置，说明 a[i] 比栈顶单调不减
          if (pos == top + 1)
              ++top;       // 拓展单调栈长度，相当于拓展最长子序列长度
          stk[pos] = a[i]; // 入栈 或 取代位置

          // top，单调栈的长度，就是目前最长上升子序列的长度
          ans = max(ans, top);
      }

      cout << ans;
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **线性 DP-导弹拦截**

---

- **导弹拦截**

  > 1、[导弹拦截](https://cdn.oj.eriktse.com/problem.php?id=1028)：有**导弹拦截系统**，对于每个系统，其**首发可以拦截任意高度**的导弹，**之后发射的每一发**都**不能高于前一发的高度**。输入**来袭的导弹高度**(导弹数不超过 1000，高度不超过 30000)，询问如果只有一套系统时**最多能拦截多少发**，以及**需要多少套系统**才能**全部拦截**，依次输出  
  > 2、**第一问**询问的是**最长下降子序列**(非升)的长度，类似于**最长上升子序列**，使用**单调栈**实现。显然，当**准备入栈的元素 i**的`a[i]`**比栈内某些元素大**时，查找栈内**第一个小于**`a[i]`的元素 k，**将其替换**。其余细节**与先前相似**  
  > 3、**第二问**询问**最少需要多少套系统**。需要根据**狄尔沃斯定理**：如果要使用**最少个数的非升子序列**覆盖一整个数组，其**所需序列数量**等同于**最长的相反规则子序列**的**长度**，此处即**最长上升子序列**的**长度**。因此需要求最长上升子序列的长度，即为答案  
  > 4、对于**最长上升子序列**，应维护一个严格**单调递增栈**。当**准备入栈的元素 i**的`a[i]`**大于栈顶元素**时，才可以**入栈**；当**准备入栈的元素 i**的`a[i]`**小于等于栈内某些元素**时；查找栈内**第一个大于等于**`a[i]`的元素 k，**将其替换**。其余细节**与先前相似**

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 1010;
  int a[N];
  int stk[N], top = 0;

  void solve()
  {
      // 输出数据
      int n = 0;
      while (cin >> a[++n])
          ;
      --n;

      // 求最长非升子序列长度
      int ans = 0;
      for (int i = 1; i <= n; i++)
      {
          // upper_bound 原先用于查找第一个 > a[i] 的元素的位置
          // 查找第一个 < a[i] 的元素的位置，由于 stk 是降序，所以使用 lambda 更改 upper_bound 的比较规则
          int pos = (upper_bound(stk + 1, stk + 1 + top, a[i], [](const int &u, const int &v) { return u > v; }) - stk - 1) + 1;

          // pos 指向栈顶之上的位置，入栈，top++
          if (pos == top + 1)
              top++;

          // 替换 pos 位置的元素，更新 ans
          stk[pos] = a[i];
          ans = max(ans, top);
      }
      cout << ans << '\n';

      // 初始化
      top = 0, ans = 0;

      // 求最长上升子序列长度
      for (int i = 1; i <= n; i++)
      {
          // lower_bound 用于查找第一个 >= a[i] 的元素的位置
          // 查找第一个 >= a[i] 的元素的位置
          int pos = (lower_bound(stk + 1, stk + 1 + top, a[i]) - stk - 1) + 1;

          // pos 指向栈顶之上的位置，入栈，top++
          if (pos == top + 1)
              top++;

          // 替换 pos 位置的元素，更新 ans
          stk[pos] = a[i];
          ans = max(ans, top);
      }
      cout << ans << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **线性 DP-摆花**

---

- **摆花**

  > 1、[摆花](https://cdn.oj.eriktse.com/problem.php?id=1045)：一共有 **n 种花**，按 1~n 标号，**m 个盆**，进行摆花，其中对于**每种花**不得超过`a[i]`盆(n, m, `a[i]`都不超过 100)。摆花时，**同种花放在一起**，**不同种类花**按照**标号从小到大**排列。输出**共有多少种方案**，结果对 10<sup>6</sup> + 7 取模  
  > 2、对于条件中的`a[i]`可解读为**第 i 种花只有**`a[i]`**盆**，由**数据量较小**可以推断大致允许 O(n\*m\*`a[i]`) 的复杂度，此外**不同种类花**应由题意**按标号从小到大选择**。**确定状态**：令`dp[i][j]`表示**到第 i 种花为止**，**一共放了 j 盆花**的**总方案数**  
  > 3、**确定转移**：假设当前有 **2 种花**，**4 个盆**，`a[1] = 3, a[2] = 2`，为方便理解可手算**可能性共 2 种**，即`{1,1,2,2}, {1,1,1,2}`。当 i=2, j=4 时，思考`dp[2][4]`**的转移**(到第 2 种花为止一共放了 4 盆)，有**多种情况**：**令 k 表示**当前需要讨论的**第 i 种花放了 k 盆**(此例当前即第 2 种花放了 k 盆)；当 k=0 时，`dp[2][4] += dp[1][4]`(要使第 2 种花放 0 盆，，其需要到第 1 种花已经摆了 4 盆)；当 k=1 时，`dp[2][4] += dp[1][3]`(要使第 2 种花放 1 盆，其需要到第 1 种花已经摆了 3 盆)；当 k=2 时，`dp[2][4] += dp[1][2]`；因为`a[2] = 2`**只有 2 盆**，所以**上述为全部的可能**。综上，**可以总结**：`dp[i][j] += dp[i-1][j-k]`，其中`k < min(a[i], j)`  
  > 4、**初始化**：`dp[1][j] = 1`，其中`j <= a[i]`，到**第 1 种花摆任意多盆**都**只有 1 种摆法**，从 i=2 开始转移；也可以直接令`dp[0][0] = 1`从 i=1 开始转移，也能转移出`dp[1][j] = 1`

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 110;
  const int P = 1e6 + 7;
  int a[N], dp[N][N]; // 到第 i 种花一共摆了 j 盆的总方案数

  void solve()
  {
      int n, m;
      cin >> n >> m;
      for (int i = 1; i <= n; i++)
          cin >> a[i];

      // 初始化(也可以直接写 dp[0][0] = 1)
      for (int j = 0; j <= a[1]; j++)
          dp[1][j] = 1;

      // 到第 i 种花(如果初始化 dp[0][0] = 1 则应从 i=1 开始转移)
      for (int i = 2; i <= n; i++)
          // 一共摆了 j 盆
          for (int j = 0; j <= m; j++)
              // 其中第 i 种花摆了 k 盆
              for (int k = 0; k <= a[i] && k <= j; k++)
                  // 状态转移，取模
                  dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % P;

      cout << dp[n][m];
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **页底评论**

---
