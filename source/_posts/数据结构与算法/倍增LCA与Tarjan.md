---
title: 倍增LCA与Tarjan
author: 山暮云秋
description: 学习倍增 LCA 与 Tarjan
sticky: 0
readmore: true
tags:
  - LCA
  - Tarjan
  - C++
categories:
  - 数据结构与算法
abbrlink: 8b3a7218
date: 2024-08-17 00:00:00
updated: 2024-08-18 00:00:00
---

---

### **倍增 LCA**

---

- **倍增 LCA**

  > 1、[倍增 LCA](https://www.starrycoding.com/problem/92)：输入树的**节点个数** $n$，这棵树**以节点** $1$ **为根**，接下来 $n-1$ 行，分别输入节点 $2 \to n$ 的**父节点**，再输入**询问次数** $q$，每个询问给出**两个整数** $u, v$，输出 $u, v$ 的**最近公共祖先** $lca(u,v)$  
  > 2、**最近公共祖先 LCA**：**深度最大**的**公共祖先**，即几个节点的**父节点链**从下向上**最早相交的点** (可以是这两个点中的一个)。**性质**：$u \to v$ 的**简单路径**可以分为**两条链**，即 $u \to lca(u,v)$ 和 $lca(u,v) \to v$；类似于 $max, min, gcd$ 等运算，其**满足** $lca(x,y,z) = lca(x,lca(y,z))$；**多个点**的 $lca(x_1,x_2,...,x_k)$ 等价于 **DFS 序最小点** 和 **DFS 序最大点**的 $lca$  
  > 3、**倍增 LCA**：类似于**ST 表**，我们令 $fa[x][j]$ 表示**节点** $x$ **向上走** $2^j$ **所到达的点**，例如对于**节点** $x$，其向上**第一个父节点**为 $fa[x][0]$，**第二个**为 $fa[x][1]$，**第四个**为 $fa[x][2]$，**第八个**为 $fa[x][3]$；此外，从根开始以**节点深度**从上到下**标记层次**，用 $dep[x]$ 记录 $x$ **的深度**。这样的结构可以实现**快速跳跃**，要从 $x$ 向上**跳跃到目标层次**，可以**贪心**地**先迈大步再迈小步**：**从大到小**枚举 $j$，再检查 $fa[x][j]$ 是否**超过目标层次**，超过则**不操作**，不超过则 $x$ **跳跃到当前** $fa[x][j]$，继续向下枚举。例如，如果要从**第** $8$ **层**跳跃到**第** $2$ **层**，二者相隔 $6$ 个节点：为方便，从 $j = 3$ **开始枚举**，此时 $fa[x][j]$ 是向上 $8$ **个节点**的位置，超出目标范围不操作；继续**枚举** $j = 2$，此时 $fa[x][j]$ 为向上 $4$ **个节点**的位置，令 $x$ **跳到该位置**，此时**还差** $2$ **个节点**到目标；继续**枚举** $j = 1$，$x$ **跳到当前** $fa[x][j]$ **到达目标节点**。可以发现，起始**相隔的** $6$ **个节点**二进制为 $110_2$，$1$ **的位置**恰好指示了**对应位置** $j$ 需要跳跃  
  > 4、实现上，**初始化**最上面虚拟的点 $fa[1][0] = 0$ (无意义)，操作上需要**求** $fa[][]$ **数组**，再**求** $lca$。对于**求数组**，可以通过 **DFS** 得到，**转移方程**为 $fa[x][j] = fa[fa[x][j-1]][j-1]$，例如求 $fa[x][2] = fa[fa[x][1]][1]$ (求 $x$ 向上走 $2^2$ 步，等同于从 $x$ 向上走 $2^1$ 步再走 $2^1$ 步)，在 **DFS** 过程中，**上面的点**的 $fa[][]$ (即转移方程右侧)是已知的；此外，对于 $dep[]$ 有 $dep[x] = dep[fa[x][0]] + 1$ (深度为父节点 $+1$)。对于**求** $lca$，给定两点 $x, y$，首先将**深度大的**(假设是 $x$)向上跳至二者在**同一深度**(用上面的方法跳跃)，判断 $x, y$ **是否相等**(因为可能 $y$ 就是 $x$ 的祖先)，相等就输出 $y$；如果**不相等**，那么**二者一起向上跳**，依然**从大到小**枚举 $j$，但条件为**若** $fa[x][j] = fa[y][j]$ **则不跳** (始终保持两个点不相等)，这样操作后，最终**两个点**会留在 $lca$ **的子节点**，所以**返回父节点** $fa[x][0]$ 即为 $lca$

  <!-- more -->

- **代码实现**

  ```c++
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;
  int n, q;
  vector<int> g[N];  // 建图
  int fa[N][1 << 5]; // fa[x][j] 记录 x 向上 2^j 的节点编号
  int dep[N];        // 记录深度

  // DFS 建造 fa[][] 和 dep[]
  void DFS(int x)
  {
      // 求 fa[][]
      for (int j = 1; j <= 20; j++)
          fa[x][j] = fa[fa[x][j - 1]][j - 1];

      // 深度为父节点 + 1
      dep[x] = dep[fa[x][0]] + 1;

      // 遍历出点，深度优先
      for (auto &y : g[x])
          DFS(y);
  }

  // 求 lca
  int lca(int x, int y)
  {
      // 交换使得 x 深度大
      if (dep[x] < dep[y])
          swap(x, y);

      // 深度大的先跳至相同深度
      for (int j = 20; j >= 0; j--)
          // 如果 x 不会跳过头，即 目标点深度 >= y 的深度
          if (dep[fa[x][j]] >= dep[y])
              // 跳至目标点
              x = fa[x][j];

      // 判断 x,y 是否相等
      if (x == y)
          return y;

      // 不相同，两点一起向上跳，至 lca 的子节点
      for (int j = 20; j >= 0; j--)
          // 只要两点目标节点不相同
          if (fa[x][j] != fa[y][j])
              // 一起向上跳
              x = fa[x][j], y = fa[y][j];

      // 返回父节点即为 lca
      return fa[x][0];
  }

  void solve()
  {
      cin >> n;
      for (int i = 2; i <= n; i++)
      {
          cin >> fa[i][0];          // 输入 fa[i][0] 父节点
          g[fa[i][0]].push_back(i); // 建图
      }

      DFS(1);

      cin >> q;
      while (q--)
      {
          int x, y;
          cin >> x >> y;
          cout << lca(x, y) << '\n';
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **Tarjan 求 LCA**

---

- **Tarjan 求 LCA**

  > 1、

---

### **页底评论**

---
