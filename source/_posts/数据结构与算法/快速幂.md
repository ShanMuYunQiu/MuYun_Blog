---
title: 快速幂
author: 圣奇宝枣
description: 使用快速幂(二进制取幂)快速计算大指数幂的结果，了解幂取模、矩阵快速幂
sticky: 0
date: 2023-08-10
updated: 2023-08-10
readmore: true
tags:
  - 快速幂
  - C++
categories:
  - 数据结构与算法
---

---

#### **快速幂**

---

- **引入**

  > 1、假设我们要计算 a<sup>n</sup> 的值，最朴素的做法是**循环 n 次**，每次**在结果上乘以 a**。显然这种做法的**时间复杂度**为 O(n)，但当**n 非常大时**这种做法的**效率仍然较低**，而**快速幂**可以解决这个问题  
  > 2、我们先从一个**特例**引入：当**n 是 2 的幂**时，例如求 a<sup>64</sup> 的值，我们可以**按照下表的方式**计算。每次**将上一次循环得到的结果自乘**，就得到了**指数**为**下一级 2 的幂**的结果，以此类推，便很快就能得到**指数**为**所求 2 的幂**的结果  
  > 3、而对于**任意的 n**，例如求 a<sup>105</sup> 的值，我们可以**将指数 n 拆分成多个 2 的幂之和**，例如 a<sup>105</sup> = a<sup>1 + 8 + 32 + 64</sup> = a<sup>1</sup> \* a<sup>8</sup> \* a<sup>32</sup> \* a<sup>64</sup>，而**单独计算这些幂**便十分简单了，因此最终只需要**将需要的 2 的幂的结果相乘**即可  
  > 4、因此，**快速幂**又称**二进制取幂**(平方法)，其英文为**Binary Exponentiation**，其**时间复杂度**仅需 O(log n) 对数级

  <!-- more -->

  | 第 i 次循环 |                    计算的值                    | 第 i 次循环 |                     计算的值                      |
  | :---------: | :--------------------------------------------: | :---------: | :-----------------------------------------------: |
  |      1      | a<sup>1</sup> \* a<sup>1</sup> = a<sup>2</sup> |      4      |  a<sup>8</sup> \* a<sup>8</sup> = a<sup>16</sup>  |
  |      2      | a<sup>2</sup> \* a<sup>2</sup> = a<sup>4</sup> |      5      | a<sup>16</sup> \* a<sup>16</sup> = a<sup>32</sup> |
  |      3      | a<sup>4</sup> \* a<sup>4</sup> = a<sup>8</sup> |      6      | a<sup>32</sup> \* a<sup>32</sup> = a<sup>64</sup> |

- **代码实现**

  > 1、这个算法的关键，在于如何**将 n 分解为多个 2 的幂之和**。如上例，**105**的**二进制**为**1101001**，我们发现其**二进制 1 的位置的权重**便是拆开后**所需的 2 的幂**(最右起第一个 1 权重为 2<sup>0</sup>，第二个 1 权重为 2<sup>3</sup>，第三个 1 权重为 2<sup>5</sup>，第四个 1 权重为 2<sup>6</sup>)  
  > 2、因此，我们可以**通过这种方式完成拆分**。**代码实现**模板如下，其中部分**细节解释如下图**(以计算 7<sup>105</sup> 为例)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/快速幂.png)

  ```cpp
  // 快速幂，计算 a 的 n 次方
  unsigned long long BinExp(int a, int n)
  {
      unsigned long long result = 1;

      // 拆分指数 n，只要 n 不为 0 便继续循环
      while (n)
      {
          // 如果 n 的二进制最后一位是 1
          if (n & 1)
              // result 乘上 a 的 `2的当前位权值次方` 的结果
              result *= a;

          // a 自乘，a 变成下一级 a 的 `2的幂次方` 的结果，a^2 -> a^4 -> a^8
          a *= a;
          // 位运算右移一位，下一次循环判断下一位二进制
          n >>= 1;
      }

      return result;
  }
  ```

---

#### **幂取模**

---

- **引入**

  > 1、计算 a<sup>n</sup> % m 的值，其中**a、n、m 都是正整数**，这种运算方式称为**幂取模运算**  
  > 2、注意：**取模时**，**乘法运算**是**同样适用**的，即`(a * b) % m = ((a % m) * (b % m)) % m`  
  > 3、因此，我们只需要在**快速幂**的**适当位置**进行**取模运算**，就可以解决**直接运算会超出范围**的问题

- **代码实现**

  ```cpp
  #include <iostream>
  using namespace std;

  // 幂取模
  unsigned long long ModExp(int a, int n, int m)
  {
      unsigned long long result = 1;
      a %= m; // 对第一次的乘数 a 取模

      while (n)
      {
          if (n & 1)
              result = (result * a) % m; // 对结果取模，结果又是下一次运算的乘数之一

          a = (a * a) % m; // 对乘数 a 取模
          n >>= 1;
      }

      return result;
  }

  int main()
  {
      // 计算 a^n % m
      int a, n, m;
      cin >> a >> n >> m;

      unsigned long long ans = ModExp(a, n, m);
      cout << ans;
      return 0;
  }
  ```

---

#### **矩阵快速幂**

---

- **引入**

  > 1、**斐波那契数列**：`0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...`，计算**数列第 n 项的值**  
  > 2、将数列的**第 n+1 项**和**第 n 项**用**列向量**表示(如下图)，其表示为(F<sub>n+1</sub>, F<sub>n</sub>)，发现其等于**矩阵** \[[1, 1], [1, 0]] 乘以**列向量** (F<sub>n</sub>, F<sub>n-1</sub>)，继续向下**展开推导**，最终发现其等于**矩阵** \[[1, 1], [1, 0]]<sup>n</sup> 乘以**列向量** (F<sub>1</sub>, F<sub>0</sub>)  
  > 3、因此，我们可以通过计算**矩阵快速幂**得到答案，其也只需要在**快速幂**上进行部分修改即可

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/矩阵快速幂.png)

- **代码实现**

  ```cpp
  // 矩阵快速幂伪代码，只代表思路，不能直接运行
  // 其中 A,result,I 都是矩阵
  MAT MATExp(MAT A, int n)
  {
      // 将 result 初始化为单位矩阵 I
      MAT result = I;

      while (n)
      {
          if (n & 1)
              result *= A;

          A *= A;
          n >>= 1;
      }

      return result;
  }
  ```

---

#### **页底评论**

---
