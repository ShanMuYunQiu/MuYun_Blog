---
title: 背包问题
author: 圣奇宝枣
description: 学习动态规划中的背包问题，学习01背包、完全背包、多重背包
sticky: 0
date: 2023-11-26
updated: 2023-11-26
readmore: true
tags:
  - 背包问题
  - 动态规划
  - C++
categories:
  - 数据结构与算法
---

---

#### **01 背包-采药**

---

- **采药**

  > 1、[采药](https://cdn.oj.eriktse.com/problem.php?id=1026)：输入 **T 和 M** 分别表示**拥有的总时间**和**药材种类**(T 不超过 1000，M 不超过 100)，对于每种药材，输入 **t 和 v**(都不超过 100)，表示采摘该药材**需要的时间**和**药材的价值**，每种药材**只可采摘一次**。可能输入**多组数据**，直到 **T 和 M 都为 0** 结束。对于**每组数据**，输出其**规定时间内**能采摘的**药材价值之和的最大值**  
  > 2、对于**每种药材**都可以**用 0 或 1 标记状态**(是否被选择)，是一个**01 背包**问题。运用**动态规划**的思想，先**确定状态**：令`dp[i][j]`表示**到第 i 个物品为止**，**用了 j 的时间**，**所获得的最大价值**  
  > 3、再**确定转移**，对于**当前的**`dp[i][j]`，有**两种情况**：如果**没选择当前第 i 个物品**，则`dp[i][j] = dp[i-1][j]`(没有花费时间，没有增加价值，和上一个——到第 i-1 个物品的状态相同)；如果**选择了当前第 i 个物品**，则`dp[i][j] = dp[i-1][j-t[i]] + v[i]`(当前状态等同于`dp[i-1][j-t[i]]`上一个物品的价值 + 当前物品价值，其中因为当前`dp[i][j]`花费的总时间为 j，所以上一个物品的时间应为`j-t[i]`)  
  > 4、最后确定**初始化和边界**：**初始化**`dp[0][i] = 0`(到第 0 个物品无论花费多少时间，价值为 0)；**边界**为 i <= M, j <= T

  <!-- more -->

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  int T, M;
  int dp[110][1010]; // dp[i][j] 表示到第 i 个物品花费 j 的时间的最大价值
  int t[110], v[110];

  void solve()
  {
      // 初始化
      for (int i = 0; i <= T; i++)
          dp[0][i] = 0;

      // 输入
      for (int i = 1; i <= M; i++)
          cin >> t[i] >> v[i];

      // 注意转移方程中，其中一种为 dp[i][j] = dp[i-1][j-t[i]] + v[i]，令 i_ = i-1，j_ = j-t[i]
      // 则隐含 i_ < i, j_ < j，所以遍历方向一定要从小到大
      // 状态转移，dp[i][j] = dp[i-1][j] 或 dp[i-1][j-t[i]] + v[i]，取大值
      for (int i = 1; i <= M; i++)
      {
          for (int j = 0; j <= T; j++)
          {
              // 注意判断时间的合法性，不要越界
              if (j - t[i] >= 0)
                  dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - t[i]] + v[i]);
              else
                  dp[i][j] = dp[i - 1][j];
          }
      }

      // 输出，到第 M 个物品花费 T 时间的最大价值
      cout << dp[M][T] << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      while (cin >> T >> M)
      {
          if (T == 0 && M == 0)
              break;
          solve();
      }
      return 0;
  }
  ```

- **滚动数组优化**

  > 1、回顾之前的思路中，`dp[i][j]`**所需的值**只有`dp[i-1][j]`与`dp[i-1][j-t[i]]`，而当**更新完当前**`dp[i][j]`后，**前一行**即`dp[i-1]`**行**就**不需要了**。因此，**实际需要的行数**只需要**两行**，一行表示**当前行**，一行表示**前一行**  
  > 2、由于**数组的拷贝**又**需要开销**，所以可以**换一种方法实现**。只开**两行的数组**`dp[0][]`与`dp[1][]`，**当前更新第 0 行时**就由**第 1 行的状态**转移过来，反之亦然。这样**交替更新**，就实现了**滚动数组**，节省空间  
  > 3、具体地，可以通过**奇偶性**或**位运算**实现。用`cur = i & 1`标记哪一行表示**当前行**，则`cur ^ 1`即为**另一行**(上一行)。最后输出时即输出**最后一行**`cur`的那一行，即`dp[M & 1][T]`

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  int T, M;
  int dp[2][1010]; // dp[i][j] 表示到第 i 个物品花费 j 的时间的最大价值
  int t[110], v[110];

  void solve()
  {
      // 初始化
      for (int i = 0; i <= T; i++)
          dp[0][i] = 0;

      // 输入
      for (int i = 1; i <= M; i++)
          cin >> t[i] >> v[i];

      // 注意转移方程中，其中一种为 dp[i][j] = dp[i-1][j-t[i]] + v[i]，令 i_ = i-1，j_ = j-t[i]
      // 则隐含 i_ < i, j_ < j，所以遍历方向一定要从小到大
      // 状态转移，dp[i][j] = dp[i-1][j] 或 dp[i-1][j-t[i]] + v[i]，取大值
      for (int i = 1; i <= M; i++)
      {
          // 滚动数组优化，cur 表示当前行，cur ^ 1 表示上一行(另一行)
          int cur = i & 1;

          for (int j = 0; j <= T; j++)
          {
              // 注意判断时间的合法性，不要越界
              if (j - t[i] >= 0)
                  dp[cur][j] = max(dp[cur ^ 1][j], dp[cur ^ 1][j - t[i]] + v[i]);
              else
                  dp[cur][j] = dp[cur ^ 1][j];
          }
      }

      // 输出，到第 M 个物品(最后一行的 cur = M & 1)花费 T 时间的最大价值
      cout << dp[M & 1][T] << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      while (cin >> T >> M)
      {
          if (T == 0 && M == 0)
              break;
          solve();
      }
      return 0;
  }
  ```

---

#### **完全背包-无穷背包**

---

- **无穷背包**

  > 1、[无穷背包](https://cdn.oj.eriktse.com/problem.php?id=1024)：给定**容积为 m 的背包**(不超过 10<sup>5</sup>)，有 **n 种商品**(不超过 500)，每种商品都有**体积 v**(不超过 m)和**价值 w**(不超过 10<sup>9</sup>)。若商品**数量无限**且**可以重复放入**同一商品，输出**最多可以带走多少价值**的物品  
  > 2、与上一题不同，每件物品**可以重复选择**，是**完全背包**问题。运用**动态规划**的思想，先**确定状态**：令`dp[i][j]`表示**到第 i 个物品为止**，**用了 j 的容积**，**所获得的最大价值**  
  > 3、再**确定转移**，对于**当前的**`dp[i][j]`，有**两种情况**：如果**没选择当前第 i 个物品**，则`dp[i][j] = dp[i-1][j]`(没有花费容积，没有增加价值，和上一个——到第 i-1 个物品的状态相同)，此时直接标记`dp[i][j]`，其为**选择了 0 个第 i 个物品**；如果**选择了当前第 i 个物品**，则`dp[i][j] = dp[i][j-v[i]] + w[i]`(当前状态等同于`dp[i][j-v[i]]`当前行当前个数-1 个物品的价值 + 当前物品价值，其中因为当前`dp[i][j]`花费的总容积为 j，所以当前数量-1 个物品的容积应为`j-v[i]`)  
  > 4、最后确定**初始化和边界**：**初始化**`dp[0][i] = 0`(到第 0 个物品无论花费多少容积，价值为 0)；**边界**为 i <= n, j <= m  
  > 5、由于**朴素算法**的**数组大小过大**，所以**栈空间不足**，需要用**滚动数组优化**为 **2 行的数组**

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 510;
  const int A = 1e5 + 10;

  int m, n;       // 容积和商品种类
  int dp[N][A];   // 到第 i 个物品花费 j 容积的最大价值
  int w[N], v[N]; // 商品价值和体积

  void solve()
  {
      cin >> m >> n;

      // 初始化
      for (int i = 0; i <= n; i++)
          dp[i][0] = 0;

      // 输入
      for (int i = 1; i <= n; i++)
          cin >> w[i] >> v[i];

      // 状态转移
      for (int i = 1; i <= n; i++)
      {
          for (int j = 0; j <= m; j++)
          {
              if (j - v[i] >= 0)
                  dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]);
              else
                  dp[i][j] = dp[i - 1][j];
          }
      }

      // 输出
      cout << dp[n][m] << '\n';
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

- **滚动数组优化**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  #define int long long
  const int N = 510;
  const int A = 1e5 + 10;

  int m, n;       // 容积和商品种类
  int dp[2][A];   // 到第 i 个物品花费 j 容积的最大价值
  int w[N], v[N]; // 商品价值和体积

  void solve()
  {
      cin >> m >> n;

      // 初始化
      for (int i = 0; i <= n; i++)
          dp[i][0] = 0;

      // 输入
      for (int i = 1; i <= n; i++)
          cin >> w[i] >> v[i];

      // 状态转移
      for (int i = 1; i <= n; i++)
      {
          // 滚动数组优化：当前行为 cur，上一行为 cur ^ 1
          int cur = i & 1;

          for (int j = 0; j <= m; j++)
          {
              if (j - v[i] >= 0)
                  dp[cur][j] = max(dp[cur ^ 1][j], dp[cur][j - v[i]] + w[i]);
              else
                  dp[cur][j] = dp[cur ^ 1][j];
          }
      }

      // 输出，最后一行的 cur = n & 1
      cout << dp[n & 1][m] << '\n';
  }

  signed main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **页底评论**

---
