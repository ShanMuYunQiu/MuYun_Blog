---
title: 最小生成树
author: 圣奇宝枣
description: 学习基于点的 Prim 最小生成树和基于边的 Kruskal 最小生成树
sticky: 0
date: 2023-11-18
updated: 2023-11-18
readmore: true
tags:
  - Prim
  - Kruskal
  - 图
  - C++
categories:
  - 数据结构与算法
---

---

#### **Prim 最小生成树(朴素)**

---

- **生成树 与 MST**

  > 1、在**无向连通图**中，找出一个**节点最多**的**子联通图**(有 n 个点，n-1 条边)，这样的**子连通图**一定是**树**，称为**生成树**。**最小生成树**指各边**权值之和最小**的**生成树**，称为 **MST**(Minimum Spanning Tree)  
  > 2、如下图，便是一幅**无向连通图**，该图的**最小生成树**为图中**红色所示**的**子联通图**(有 5 个点，4 条边)，其**权值和为 10**  
  > 3、对于**最小生成树**的生成，可以通过**基于点的 Prim 最小生成树**与**基于边的 Kruskal 最小生成树**完成

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/最小生成树.png)

- **Prim 最小生成树(朴素)**

  > 1、[最小生成树](https://cdn.oj.eriktse.com/problem.php?id=1080)：给定 **n 个点 m 条边**(n 不超过 10<sup>5</sup>)的**无向图**，对于 **m 条边**，每次输入 u、v、w，表示存在一条**从 u 到 v** 的**权值为 w** 的边。输出其**最小生成树的权值之和**，如果没有则输出 -1  
  > 2、**Prim 最小生成树**通过**假想 inTree 标识在树内的点**，通过`d[i]`维护**点 i 到 inTree 的最近距离**，每次**将**`d[i]`**最小的点纳入 inTree**，直到**所有点都在 inTree 内**完成生成。在实际实现中，通过`inTree[i]`来**标识 i 在 inTree 内**，且设置`d[i] = 0`  
  > 3、其**思路如下图**：起始，**初始化**`d[]`**为无穷**；任选一点作为起点，此处**1 为起点**，标记`d[1] = 0`(在 inTree 内)，更新 **inTree 相邻的点**(即 2 3)的`d[i]`(取较小值)，此处**不需要更新点 4 5**是因为 **inTree 的相邻点 2 3 一定比他们更近**；将`d[i]`**最小的点纳入 inTree**(`d[2] = 0`)，再次**更新附近的**`d[i]`，注意此时`d[4] = min(1, 3) = 1`。以此类推，循环操作，直至生成树完成  
  > 4、在此通过**邻接矩阵**实现**朴素算法**，**朴素算法**只能处理**较小范围数据**，所以还不能完成该题

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/Prim最小生成树.png)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int INF = 0x3f3f3f3f;
  const int N = 1e3 + 10;
  int a[N][N], d[N]; // a 为无向图，d 为最短路径
  long long n, m, ans = 0;
  bitset<N> inTree;

  // Prim 朴素
  void Prim()
  {
      // 初始化 d[]
      memset(d, INF, sizeof(d));

      // 初始化：把 1 作为起点，计入 inTree，更新附近点的 d[j]
      d[1] = 0;
      inTree[1] = true;
      for (int j = 2; j <= n; j++)
          d[j] = min(d[j], a[1][j]); // 更新 1 到 j 的距离 d[j]

      // 还需 n-1 次操作(去除了起点)
      for (int i = 1; i < n; i++)
      {
          // 查找 d[i] 最小的点 u
          int u = 1;
          for (int j = 1; j <= n; j++)
              if (inTree[u] || (!inTree[j] && d[j] < d[u]))
                  u = j;

          // 计入答案，u 点纳入 inTree
          ans += d[u];
          inTree[u] = true;
          d[u] = 0;

          // 更新 u 附近的 d[j]，因为只将 u 纳入了 Intree，即只有 u 周围的点的 d[j] 可能有变动
          for (int j = 1; j <= n; j++)
          {
              if (inTree[j]) // 已经在 inTree 的不需要处理
                  continue;
              d[j] = min(d[j], a[u][j]); // 将 u 到 j 这条变动的新路距离 与 原先的 d[j] 取短
          }
      }
  }

  void solve()
  {
      cin >> n >> m;

      // 初始化 d，并设置自环为 0
      memset(a, INF, sizeof(a));
      for (int i = 1; i <= n; i++)
          a[i][i] = 0;

      // 存储无向图
      for (int i = 1; i <= m; i++)
      {
          int u, v, w;
          cin >> u >> v >> w;
          // 重边取短值
          a[u][v] = min(a[u][v], w);
          a[v][u] = min(a[v][u], w);
      }

      Prim();

      cout << ans;
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

#### **Prim 最小生成树(堆优化)**

---

- **Prim 最小生成树(堆优化)**

  > 1、[最小生成树](https://cdn.oj.eriktse.com/problem.php?id=1080)：给定 **n 个点 m 条边**(n 不超过 10<sup>5</sup>)的**无向图**，对于 **m 条边**，每次输入 u、v、w，表示存在一条**从 u 到 v** 的**权值为 w** 的边。输出其**最小生成树的权值之和**，如果没有则输出 -1  
  > 2、

---

#### **页底评论**

---
