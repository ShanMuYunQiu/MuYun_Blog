---
title: 二叉树
author: 圣奇宝枣
description: 学习树这种数据结构，学习二叉树的遍历、构造等实现
sticky: 0
date: 2023-08-28
updated: 2023-08-28
readmore: true
tags:
  - 二叉树
  - C++
categories:
  - 数据结构与算法
---

---

#### **树的知识**

---

- **认识树结构**

  > 1、**树**：指有**层次关系**的**N 个节点**的**有限集合**(如下图)；对于**空树**，**N = 0**；对于**非空树**，有且仅有**一个根**。除**根**外，可分为多个**互不相交**的**有限集合**，称为**子树**  
  > 2、**节点**：每个**数据**就是一个**节点**。**节点**可分为分为**根节点**、**分支节点**、**叶子结点**。在**两个节点的关系**上分为**前驱**(父节点)和**后继**(子节点)  
  > 3、**在树中**：**边**用来表明**两个节点**之间的**层次关系**(父子关系)；**高度**指的是**深度**(层次)，**树的高度**指的是整个树**最深的层次数**，如下图**E 的高度为 3**，**树的高度为 4**；**度**指的是**边的个数**(子节点的个数)，**树的度**指的是整个树各节点**度的最大值**，如下图**A 的度为 3**，**C 的度为 1**，**树的度为 3**

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/树.png)

- **度为 n 的树与 n 叉树**

  > 1、**度为 n 的树**：各节点**度的最大值为 n**，即**任意节点的度 <= n**；注意，**至少应有一个节点的度 = n**  
  > 2、**n 叉树**：树中每个节点**最多有 n 个子节点**，即**任意节点的度 <= n**；特别的，与**度为 n 的树**不同，允许**所有节点的度 < n**  
  > 3、因此，**度为 n 的树**一定可称为**n 叉树**，但**反之不可**

- **树的性质**

  > 1、对于一个**n 叉树**，其**第 i 层**至多有 n<sup>i-1</sup> 个节点，**高度为 h 的 n 叉树**至多有 (n<sup>h</sup> - 1) / (n - 1) 个节点(根据等比数列求和：1 + n + n<sup>2</sup> + ... + n<sup>h-2</sup> + n<sup>h-1</sup>)  
  > 2、**高度为 h 的 n 叉树**至少有 h 个节点，其只有**一个叉**；**高度为 h 的度为 n 的树**至少有 h + n - 1 个节点，其在**n 叉树**的基础上**至少有一个节点有 n 个叉**，根节点**重复计算了一次**所以**减去 1**  
  > 3、**有 m 个节点**的**n 叉树**的最小高度，当所有节点都有**n 个子节点**时， h = log<sub>n</sub>(m \* (n - 1) + 1)

---

#### **树的存储结构**

---

- **双亲表示法(顺序存储)**

  > 1、描述：使用一组**连续空间**(数组)存储**每个节点**，同时**每个节点**中有一个**伪指针**，指示该节点**父节点**在**数组中的位置**  
  > 2、如下图的**树**，**代码实现**如下，另附下表说明**详细的存储情况**。当`parent == -1`时，表示该节点为**根节点**

  ```cpp
  #define MAX_TREE_SIZE 100

  // 树的节点
  typedef struct ParentTreeNode
  {
      ElemType data;  // 节点存储的数据，ElemType 为数据的类型
      int parent;     // 伪指针：指向该节点父节点的下标
  } PTNode;

  // 树类型
  typedef struct ParentTree
  {
      PTNode nodes[MAX_TREE_SIZE];  // 用数组存储树的节点
      int num;                      // 节点数
  } PTree;
  ```

  | index  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  |
  | ------ | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
  | data   |  A  |  B  |  C  |  D  |  E  |  F  |  G  |  H  |  I  |  J  |  K  |  O  |  P  |
  | parent | -1  |  0  |  0  |  0  |  1  |  1  |  2  |  3  |  3  |  3  |  4  |  4  |  8  |

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/树.png)

- **孩子表示法(顺序+链式)**

  > 1、描述：将**每个节点**的**子节点**都用**单链表**连接起来，形成一个**线性结构**，**N 个节点**就会有**N 个孩子链表**  
  > 2、如下图的**树**，**代码实现**如下，另附下表说明**详细的存储情况**  
  > 3、**该结构的优势**：使用**链表连接孩子节点**，使得访问总是能够(跨层级时)**自上而下**、(同层级时)**自左向右**按照层次访问，符合直观想象

  ```cpp
  #define MAX_TREE_SIZE 100

  // 树的节点
  typedef struct ChildrenLinkedNode
  {
      ElemType data;  // 节点存储的数据，ElemType 为数据的类型
      CLNode *child;  // 指针指向下一个孩子节点
  } CLNode;

  // 树类型
  typedef struct ChildrenTree
  {
      CLNode nodes[MAX_TREE_SIZE];  // 用数组存储树的节点
      int num;                      // 节点数
  } CTree;
  ```

  | index       |  0  |  1  |  2  |  3  |  4  |  5   |  6   |  7   |  8  |  9   |  10  |  11  |  12  |
  | ----------- | :-: | :-: | :-: | :-: | :-: | :--: | :--: | :--: | :-: | :--: | :--: | :--: | :--: |
  | data        |  A  |  B  |  C  |  D  |  E  |  F   |  G   |  H   |  I  |  J   |  K   |  O   |  P   |
  | child       |  B  |  E  |  G  |  H  |  K  | null | null | null |  P  | null | null | null | null |
  | \|\_child   |  C  |  F  |     |  I  |  O  |      |      |      |     |      |      |      |      |
  | \|\_\_child |  D  |     |     |  J  |     |      |      |      |     |      |      |      |      |

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/树.png)

- **孩子兄弟表示法(链式-二叉链表)**

---

#### **页底评论**

---
