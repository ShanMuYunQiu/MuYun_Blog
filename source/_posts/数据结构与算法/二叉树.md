---
title: 二叉树
author: 圣奇宝枣
description: 学习树这种数据结构，学习二叉树的遍历、构造等实现
sticky: 0
date: 2023-08-28
updated: 2023-09-01
readmore: true
tags:
  - 二叉树
  - C++
categories:
  - 数据结构与算法
---

---

#### **树的知识**

---

- **认识树结构**

  > 1、**树**：指有**层次关系**的**N 个节点**的**有限集合**(如下图)；对于**空树**，**N = 0**；对于**非空树**，有且仅有**一个根**。除**根**外，可分为多个**互不相交**的**有限集合**，称为**子树**  
  > 2、**节点**：每个**数据**就是一个**节点**。**节点**可分为分为**根节点**、**分支节点**、**叶子结点**。在**两个节点的关系**上分为**前驱**(父节点)和**后继**(子节点)  
  > 3、**在树中**：**边**用来表明**两个节点**之间的**层次关系**(父子关系)；**高度**指的是**深度**(层次)，**树的高度**指的是整个树**最深的层次数**，如下图**E 的高度为 3**，**树的高度为 4**；**度**指的是**边的个数**(子节点的个数)，**树的度**指的是整个树各节点**度的最大值**，如下图**A 的度为 3**，**C 的度为 1**，**树的度为 3**

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/树.png)

- **度为 n 的树与 n 叉树**

  > 1、**度为 n 的树**：各节点**度的最大值为 n**，即**任意节点的度 <= n**；注意，**至少应有一个节点的度 = n**  
  > 2、**n 叉树**：树中每个节点**最多有 n 个子节点**，即**任意节点的度 <= n**；特别的，与**度为 n 的树**不同，允许**所有节点的度 < n**  
  > 3、因此，**度为 n 的树**一定可称为**n 叉树**，但**反之不可**

- **树的性质**

  > 1、对于一个**n 叉树**，其**第 i 层**至多有 n<sup>i-1</sup> 个节点，**高度为 h 的 n 叉树**至多有 (n<sup>h</sup> - 1) / (n - 1) 个节点(根据等比数列求和：1 + n + n<sup>2</sup> + ... + n<sup>h-2</sup> + n<sup>h-1</sup>)  
  > 2、**高度为 h 的 n 叉树**至少有 h 个节点，其只有**一个叉**；**高度为 h 的度为 n 的树**至少有 h + n - 1 个节点，其在**n 叉树**的基础上**至少有一个节点有 n 个叉**，根节点**重复计算了一次**所以**减去 1**  
  > 3、**有 m 个节点**的**n 叉树**的最小高度，当所有节点都有**n 个子节点**时， h = log<sub>n</sub>(m \* (n - 1) + 1)

---

#### **树的存储结构**

---

- **双亲表示法(顺序存储)**

  > 1、描述：使用一组**连续空间**(数组)存储**每个节点**，同时**每个节点**中有一个**伪指针**，指示该节点**父节点**在**数组中的位置**  
  > 2、如上例中的**树**，**代码实现**如下，另附下表说明**详细的存储情况**。当`parent == -1`时，表示该节点为**根节点**

  ```cpp
  #define MAX_TREE_SIZE 100

  // 树的节点
  typedef struct ParentTreeNode
  {
      ElemType data;  // 节点存储的数据，ElemType 为数据的类型
      int parent;     // 伪指针：指向该节点父节点的下标
  } PTNode;

  // 树类型
  typedef struct ParentTree
  {
      PTNode nodes[MAX_TREE_SIZE];  // 用数组存储树的节点
      int num;                      // 节点数
  } PTree;
  ```

  | index  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  |
  | ------ | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
  | data   |  A  |  B  |  C  |  D  |  E  |  F  |  G  |  H  |  I  |  J  |  K  |  O  |  P  |
  | parent | -1  |  0  |  0  |  0  |  1  |  1  |  2  |  3  |  3  |  3  |  4  |  4  |  8  |

- **孩子表示法(顺序+链式)**

  > 1、描述：将**每个节点**的**子节点**都用**单链表**连接起来，形成一个**线性结构**，**N 个节点**就会有**N 个孩子链表**  
  > 2、如上例中的**树**，**代码实现**如下，另附下表说明**详细的存储情况**  
  > 3、**该结构的优势**：使用**链表连接孩子节点**，使得访问总是能够(跨层级时)**自上而下**、(同层级时)**自左向右**按照层次访问，符合直观想象

  ```cpp
  #define MAX_TREE_SIZE 100

  // 树的节点
  typedef struct ChildrenLinkedNode
  {
      ElemType data;  // 节点存储的数据，ElemType 为数据的类型
      CLNode *child;  // 指针指向下一个孩子节点
  } CLNode;

  // 树类型
  typedef struct ChildrenTree
  {
      CLNode nodes[MAX_TREE_SIZE];  // 用数组存储树的节点
      int num;                      // 节点数
  } CTree;
  ```

  | index       |  0  |  1  |  2  |  3  |  4  |  5   |  6   |  7   |  8  |  9   |  10  |  11  |  12  |
  | ----------- | :-: | :-: | :-: | :-: | :-: | :--: | :--: | :--: | :-: | :--: | :--: | :--: | :--: |
  | data        |  A  |  B  |  C  |  D  |  E  |  F   |  G   |  H   |  I  |  J   |  K   |  O   |  P   |
  | child       |  B  |  E  |  G  |  H  |  K  | null | null | null |  P  | null | null | null | null |
  | \|\_child   |  C  |  F  |     |  I  |  O  |      |      |      |     |      |      |      |      |
  | \|\_\_child |  D  |     |     |  J  |     |      |      |      |     |      |      |      |      |

- **孩子兄弟表示法(链式-二叉链表)**

  > 1、又称**二叉树表示法**或**二叉链表表示法**，即以**二叉链表**作为树的**存储结构**。链表中的**节点**的**两个链**分别指向该节点的**第一个子节点**(左链)和**下一个兄弟节点**(右链)  
  > 2、如上例中的**树**，**代码实现**如下，下图展示了这种表示方法的**存储结构**

  ```cpp
  // 树的节点
  typedef struct ChildBrotherNode
  {
      ElemType data;        // 节点存储的数据，ElemType 为数据的类型
      CBNode *firstChild;    // 左链：指向该节点第一个子节点
      CBNode *nextSibling;   // 右链：指向该节点下一个兄弟节点
  } CBNode;
  ```

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/树2.png)

---

#### **二叉树**

---

- **二叉树与满二叉树**

  > 1、**二叉树**：英文为**Binary Tree**，指**节点的度不超过 2**的**有序树**(左右子树次序固定)，如下图  
  > 2、**满二叉树**：指二叉树**只有最后一层有叶子结点**且**不存在度为 1 的节点**(每一层只要有节点，必然扑满)  
  > 3、一个**高为 h 的满二叉树**的节点数为 2<sup>h</sup> - 1。按层序**从 1 编号**，**节点 i**的**左子**为 2 \* i，**右子**为 2 \* i + 1，**父节点**为 i / 2；按层序**从 0 编号**，**节点 i**的**左子**为 2 \* i + 1，**右子**为 2 \* i + 2，**父节点**为 i / 2(向下取整)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二叉树.png)

- **常见的树：完全二叉树**

  > 1、**完全二叉树**：当且仅当二叉树**每个节点的序号**都与**同高度的满二叉树节点序号**完全对应时，称为**完全二叉树**(即只有最后一层可以不铺满)，如下图  
  > 2、**完全二叉树**中，**只有最后两层可能有叶子结点**且**最多有一个度为 1 的节点**  
  > 3、**完全二叉树**的**编号**与**满二叉树**相同，因此**编号公式**通用。此外，如果节点 i <= n / 2，该节点为分支节点；如果节点 i > n / 2，该节点为叶子结点

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/完全二叉树.png)

- **常见的树：二叉查找树**

  > 1、**二叉查找树**：又称**二叉排序树**/**二叉搜索树**，其**任意节点**与其**左右子节点**的**大小关系**都有**左 < 中 < 右**，其常用于**元素的排序和查找**，如下图  
  > 2、在下面的**二叉查找树**中**插入新元素 12**，应放在**元素 11**的**右子节点处**(从根节点依次比较 12 与 10、13、11 的关系)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二叉查找树.png)

- **常见的树：AVL 树**

  > 1、**AVL 树**：又称**平衡二叉树**，是**二叉查找树**的一种**改进形式**。其**任意节点**的**左右子树深度差不超过 1**，且仍拥有**二叉查找树**的**节点大小关系**，如下图  
  > 2、**插入或删除元素**时，会**动态调整**树的结构，以便提高下次的**搜索效率**(解决了二叉查找树搜索次数不均衡，最极端情况下甚至会变为链表的问题)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/AVL树.png)

- **二叉树的性质**

  > 1、二叉树**第 i 层**最多有 2<sup>i-1</sup> 个节点；**高度为 h 的二叉树**最多有 2<sup>h</sup> - 1 个节点(即满二叉树)  
  > 2、**非空二叉树**中，**叶子结点**个数比**二分支节点**个数多 1 个。根据下图辅助证明：令**度**为 0、1、2 的**节点个数**分别为 n<sub>0</sub>、n<sub>1</sub>、n<sub>2</sub>，则有 n = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub>；此外，由于**总节点个数** = 边的个数 + 1，则有 n = 0 \* n<sub>0</sub> + 1 \* n<sub>1</sub> + 2 \* n<sub>2</sub> + 1 = n<sub>1</sub> + 2 \* n<sub>2</sub> + 1，**联立两式**证得：n<sub>0</sub> = n<sub>2</sub> + 1  
  > 3、用**n 个节点**构成一棵**二叉树**，其**最小的高度**(即构成完全二叉树时的高度)为：h = log<sub>2</sub>(n+1) 或 log<sub>2</sub>n + 1

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二叉树.png)

---

#### **二叉树的存储**

---

- **描述**

  > 1、先前介绍过了**树的存储结构**，**二叉树的存储思路**也与之类似，分为**顺序存储**和**链式存储**  
  > 2、**顺序存储**：思路与前面介绍的相同，使用**数组**。注意，**顺序存储**只适用于**完全二叉树形式**(如果不是完全二叉树，其空缺的节点应留空)，**节点中**存储的**父节点和两个子节点的下标**应使用先前的**关系公式**来指代。**顺序存储**的特点为：**存取快**、**增删慢**、**仅适用于完全二叉树形式**  
  > 3、**链式存储**：与前面介绍的类似，用**链表**存储，**节点中**存储**父节点和两个子节点的指针**。**链式存储**的特点为：**存取慢**、**增删快**。由于**便于维护**以及拥有更好的**普适性**，所以我们着重介绍**链式存储**，其代码如下

- **链式存储代码实现**

  ```cpp
  #include <iostream>
  #include <memory>
  using namespace std;

  // 树的最大节点个数
  #define MAX_TREE_SIZE 256
  // 树的节点的数据类型
  typedef int ElemType;

  // 树的节点
  typedef struct TreeNode
  {
          ElemType value;                   // 存储的数据
          shared_ptr<TreeNode> left, right; // 指向左子节点、右子节点
          shared_ptr<TreeNode> parent;      // 指向父节点

          // 构造函数
          TreeNode(ElemType val) : value(val), left(nullptr), right(nullptr)
          {
          }

          // 关联节点的成员函数
          void LinkNodes(shared_ptr<TreeNode> leftNode, shared_ptr<TreeNode> rightNode, shared_ptr<TreeNode> parentNode)
          {
              left = leftNode;
              right = rightNode;
              parent = parentNode;
          }
          // 释放当前节点的成员函数
          void ReleaseNode()
          {
              // 不要担心只释放了当前节点的值，由于智能指针的机制，当与该节点有关联的父节点和子节点更换绑定时，该节点的智能指针引用计数将 -1
              // 在该节点有关联的节点全部换绑之前，智能指针会保护这些数据不被销毁；当所有有关联的节点全部换绑后，引用计数为 0，数据将自动被销毁
              left = nullptr;
              right = nullptr;
              parent = nullptr;
          }
  } Node;

  int main()
  {
      // 使用 shared_pointer 智能指针，用 make_shared 创建对象
      // 也可以用 new 实现，如： Node *root = new Node(1); ，这样的话需要自行更改程序，并确保程序安全
      // 创建二叉树：根节点，其默认值为 1
      shared_ptr<Node> root = make_shared<Node>(1);

      // 使用时，创建新的节点，例如现在根节点下有数据为 2 的左子节点，数据为 3 的右子节点
      shared_ptr<Node> leftChild = make_shared<Node>(2);
      shared_ptr<Node> rightChild = make_shared<Node>(3);

      // 创建后，需要关联对应的节点
      root->LinkNodes(leftChild, rightChild, nullptr);
      leftChild->LinkNodes(nullptr, nullptr, root);
      rightChild->LinkNodes(nullptr, nullptr, root);

      // 输出数据
      cout << root->value << ' ' << root->left->value << ' ' << root->right->value << endl;

      // 使用后，销毁节点
      leftChild->ReleaseNode();
      rightChild->ReleaseNode();
      root->ReleaseNode();

      /*
      注意，这三个节点在当前示例中实际并未被销毁，因为第 47、50、51 行仍有 shared_ptr 指向它们的数据，应将它们指向 nullptr
      实际使用中，不会像这样创建根节点，通常只以根节点为标志向下创建子树(root->left = make_shared<Node>(value))，或只需要 root 和一个公用的 child 用于辅助创建节点
      如果是这种使用方式，ReleaseNode 就可以自动释放数据了，但仍需要(也只需要)手动设置 root = nullptr
      如果可能，最好自行在 Node 的基础上根据需要封装 Tree 类型，以便更方便地使用
      */
      return 0;
  }
  ```

---

#### **二叉树的遍历**

---

- **遍历顺序**

  > 1、**二叉树**有多种**遍历顺序**，其规则分别如下  
  > 2、**先序遍历**：也称**先根遍历**，其遍历顺序为**根-左-右**。下例**先序遍历**过程为：10-7-5-3-6-9-8-13-11-12-18  
  > 3、**中序遍历**：也称**中根遍历**，其遍历顺序为**左-根-右**。下例**中序遍历**过程为：3-5-6-7-8-9-10-11-12-13-18  
  > 4、**后序遍历**：也称**后根遍历**，其遍历顺序为**左-右-根**。下例**后序遍历**过程为：3-6-5-8-9-7-12-11-18-13-10  
  > 5、**层次遍历**：按照**层次顺序**进行遍历，同层级按照**从左向右**的顺序遍历。下例**层次遍历**过程为：10-7-13-5-9-11-18-3-6-8-12

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二叉查找树.png)

- **先序遍历代码实现**

  ```cpp
  // 先序遍历(递归)
  void PreOrder(shared_ptr<Node> root)
  {
      // 节点为空，什么都不做
      if (root == nullptr)
          return;

      // 访问根节点数据
      cout << root->value << '-';
      // 访问左子树
      PreOrder(root->left);
      // 访问右子树
      PreOrder(root->right);
  }

  // 先序遍历(循环)，伪代码，利用栈的思路实现
  void PreOrderByFor(shared_ptr<Node> root)
  {
      // 根节点入栈，push 用于实现入栈
      push(node);

      // 循环遍历，isEmptyStack 用于确定栈是否为空
      while (!isEmptyStack())
      {
          // cursor 表示当前节点，getTop 用于获取栈顶元素(但不出栈)
          shared_ptr<Node> cursor = getTop();

          // 如果节点不为空
          if (cursor != nullptr)
          {
              // 访问根节点数据
              cout << cursor->value << '-';
              // 将当前根节点的左子树入栈
              push(cursor->left);
          }
          // 如果节点为空，说明当前元素无效，出栈
          else
          {
              // 10-7-5-3-3.left
              // pop 用于获取栈顶元素(并出栈)，弹出栈顶空的无效元素
              pop();

              // 10-7-5-3
              // 当前栈顶元素已经完成了根-左的访问，接下来只需要访问右子树。根节点出栈，其右子树进栈
              cursor = pop();
              push(cursor->right);
          }
      }
  }
  ```

- **中、后序遍历代码实现**

  ```cpp
  // 只需在先序遍历的基础上稍作修改即可

  // 中序遍历(递归)
  void InOrder(shared_ptr<Node> root)
  {
      // 节点为空，什么都不做
      if (root == nullptr)
          return;

      // 访问左子树
      InOrder(root->left);
      // 访问根节点数据
      cout << root->value << '-';
      // 访问右子树
      InOrder(root->right);
  }

  // 后序遍历(递归)
  void PostOrder(shared_ptr<Node> root)
  {
      // 节点为空，什么都不做
      if (root == nullptr)
          return;

      // 访问左子树
      PostOrder(root->left);
      // 访问右子树
      PostOrder(root->right);
      // 访问根节点数据
      cout << root->value << '-';
  }
  ```

- **层次遍历代码实现**

  > 1、**层次遍历**的一个问题是如何实现**按层遍历**，由于**树是链式的**，很难在遍历完树的**最右侧节点**后找到**下一层的最左侧节点**  
  > 2、一种解决办法是使用**队列**来**按层处理**，每次**按顺序进入一层的节点**，再在队列中**访问下一层节点**。此时前一层节点**离开队列**，新一层节点**进入队列**

  ```cpp
  // 队列：临时存储上一层节点；层次遍历的顺序与进入/离开队列的顺序一致
  // 也可以使用顺序结构(数组)实现队列，但链式结构更加灵活
  typedef struct LinkedNode
  {
          shared_ptr<Node> node;       // 存储队列当前元素
          shared_ptr<LinkedNode> next; // 指向队列下一个元素

          // 构造函数
          LinkedNode(shared_ptr<Node> n) : node(n), next(nullptr)
          {
          }
  } Queue;

  // 定义队列的(虚拟的)首节点和尾节点
  shared_ptr<Queue> head, tail;

  // 初始化队列
  shared_ptr<Queue> initQueue()
  {
      shared_ptr<Node> temp = make_shared<Node>(-1); // 构造具有(树中数据)非法值的节点(该节点数据实际不使用)
      head = make_shared<Queue>(temp);
      tail = head;
      return head;
  }

  // 判断队列是否为空
  bool isEmpty()
  {
      if (head == tail)
          return true;
      return false;
  }

  // 将节点计入队列末尾
  void push(shared_ptr<Node> node)
  {
      shared_ptr<Queue> _next = make_shared<Queue>(node); // 创建队列新节点
      tail->next = _next;                                 // 将其挂载到队列末尾
      tail = _next;                                       // 将队列末尾指向新节点
  }

  // 获取队列的头部(并退出队列)
  shared_ptr<Queue> pull()
  {
      if (isEmpty())
          return nullptr;
      shared_ptr<Queue> first = head->next; // 获取第一个有效节点(注意不是 head，是 head 的下一个节点)
      head->next = first->next;             // 将队列首节点指向下一个(第二个)有效节点

      // 如果没有后续节点，将 tail 设置指向 head
      if (first->next == nullptr)
          tail = head;

      // 将 first 与队列下一个节点断开
      first->next = nullptr;

      return first;
  }

  // 层次遍历
  void LevelOrder(shared_ptr<Node> node)
  {
      // 初始化辅助队列
      initQueue();
      // 将树的根节点入队
      push(node);

      // 循环将每个层次的节点入队出队
      while (!isEmpty())
      {
          // 将队列的第一个有效节点出队
          shared_ptr<Queue> queueNode = pull();

          // 访问节点数据
          shared_ptr<Node> treeNode = queueNode->node;
          cout << treeNode->value << '-';

          // 将节点的左右孩子入队
          if (treeNode->left != nullptr)
              push(treeNode->left);
          if (treeNode->right != nullptr)
              push(treeNode->right);
      }
  }
  ```

---

#### **线索二叉树**

---

- **线索二叉树**

---

#### **页底评论**

---
