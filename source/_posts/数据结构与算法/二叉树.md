---
title: 二叉树
author: 圣奇宝枣
description: 学习树这种数据结构，学习二叉树的遍历、构造等实现
sticky: 0
date: 2023-08-28
updated: 2023-08-30
readmore: true
tags:
  - 二叉树
  - C++
categories:
  - 数据结构与算法
---

---

#### **树的知识**

---

- **认识树结构**

  > 1、**树**：指有**层次关系**的**N 个节点**的**有限集合**(如下图)；对于**空树**，**N = 0**；对于**非空树**，有且仅有**一个根**。除**根**外，可分为多个**互不相交**的**有限集合**，称为**子树**  
  > 2、**节点**：每个**数据**就是一个**节点**。**节点**可分为分为**根节点**、**分支节点**、**叶子结点**。在**两个节点的关系**上分为**前驱**(父节点)和**后继**(子节点)  
  > 3、**在树中**：**边**用来表明**两个节点**之间的**层次关系**(父子关系)；**高度**指的是**深度**(层次)，**树的高度**指的是整个树**最深的层次数**，如下图**E 的高度为 3**，**树的高度为 4**；**度**指的是**边的个数**(子节点的个数)，**树的度**指的是整个树各节点**度的最大值**，如下图**A 的度为 3**，**C 的度为 1**，**树的度为 3**

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/树.png)

- **度为 n 的树与 n 叉树**

  > 1、**度为 n 的树**：各节点**度的最大值为 n**，即**任意节点的度 <= n**；注意，**至少应有一个节点的度 = n**  
  > 2、**n 叉树**：树中每个节点**最多有 n 个子节点**，即**任意节点的度 <= n**；特别的，与**度为 n 的树**不同，允许**所有节点的度 < n**  
  > 3、因此，**度为 n 的树**一定可称为**n 叉树**，但**反之不可**

- **树的性质**

  > 1、对于一个**n 叉树**，其**第 i 层**至多有 n<sup>i-1</sup> 个节点，**高度为 h 的 n 叉树**至多有 (n<sup>h</sup> - 1) / (n - 1) 个节点(根据等比数列求和：1 + n + n<sup>2</sup> + ... + n<sup>h-2</sup> + n<sup>h-1</sup>)  
  > 2、**高度为 h 的 n 叉树**至少有 h 个节点，其只有**一个叉**；**高度为 h 的度为 n 的树**至少有 h + n - 1 个节点，其在**n 叉树**的基础上**至少有一个节点有 n 个叉**，根节点**重复计算了一次**所以**减去 1**  
  > 3、**有 m 个节点**的**n 叉树**的最小高度，当所有节点都有**n 个子节点**时， h = log<sub>n</sub>(m \* (n - 1) + 1)

---

#### **树的存储结构**

---

- **双亲表示法(顺序存储)**

  > 1、描述：使用一组**连续空间**(数组)存储**每个节点**，同时**每个节点**中有一个**伪指针**，指示该节点**父节点**在**数组中的位置**  
  > 2、如上例中的**树**，**代码实现**如下，另附下表说明**详细的存储情况**。当`parent == -1`时，表示该节点为**根节点**

  ```cpp
  #define MAX_TREE_SIZE 100

  // 树的节点
  typedef struct ParentTreeNode
  {
      ElemType data;  // 节点存储的数据，ElemType 为数据的类型
      int parent;     // 伪指针：指向该节点父节点的下标
  } PTNode;

  // 树类型
  typedef struct ParentTree
  {
      PTNode nodes[MAX_TREE_SIZE];  // 用数组存储树的节点
      int num;                      // 节点数
  } PTree;
  ```

  | index  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  |
  | ------ | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
  | data   |  A  |  B  |  C  |  D  |  E  |  F  |  G  |  H  |  I  |  J  |  K  |  O  |  P  |
  | parent | -1  |  0  |  0  |  0  |  1  |  1  |  2  |  3  |  3  |  3  |  4  |  4  |  8  |

- **孩子表示法(顺序+链式)**

  > 1、描述：将**每个节点**的**子节点**都用**单链表**连接起来，形成一个**线性结构**，**N 个节点**就会有**N 个孩子链表**  
  > 2、如上例中的**树**，**代码实现**如下，另附下表说明**详细的存储情况**  
  > 3、**该结构的优势**：使用**链表连接孩子节点**，使得访问总是能够(跨层级时)**自上而下**、(同层级时)**自左向右**按照层次访问，符合直观想象

  ```cpp
  #define MAX_TREE_SIZE 100

  // 树的节点
  typedef struct ChildrenLinkedNode
  {
      ElemType data;  // 节点存储的数据，ElemType 为数据的类型
      CLNode *child;  // 指针指向下一个孩子节点
  } CLNode;

  // 树类型
  typedef struct ChildrenTree
  {
      CLNode nodes[MAX_TREE_SIZE];  // 用数组存储树的节点
      int num;                      // 节点数
  } CTree;
  ```

  | index       |  0  |  1  |  2  |  3  |  4  |  5   |  6   |  7   |  8  |  9   |  10  |  11  |  12  |
  | ----------- | :-: | :-: | :-: | :-: | :-: | :--: | :--: | :--: | :-: | :--: | :--: | :--: | :--: |
  | data        |  A  |  B  |  C  |  D  |  E  |  F   |  G   |  H   |  I  |  J   |  K   |  O   |  P   |
  | child       |  B  |  E  |  G  |  H  |  K  | null | null | null |  P  | null | null | null | null |
  | \|\_child   |  C  |  F  |     |  I  |  O  |      |      |      |     |      |      |      |      |
  | \|\_\_child |  D  |     |     |  J  |     |      |      |      |     |      |      |      |      |

- **孩子兄弟表示法(链式-二叉链表)**

  > 1、又称**二叉树表示法**或**二叉链表表示法**，即以**二叉链表**作为树的**存储结构**。链表中的**节点**的**两个链**分别指向该节点的**第一个子节点**(左链)和**下一个兄弟节点**(右链)  
  > 2、如上例中的**树**，**代码实现**如下，下图展示了这种表示方法的**存储结构**

  ```cpp
  // 树的节点
  typedef struct ChildBrotherNode
  {
      ElemType data;        // 节点存储的数据，ElemType 为数据的类型
      CBNode *firstChild;    // 左链：指向该节点第一个子节点
      CBNode *nextSibling;   // 右链：指向该节点下一个兄弟节点
  } CBNode;
  ```

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/树2.png)

---

#### **二叉树**

---

- **二叉树与满二叉树**

  > 1、**二叉树**：英文为**Binary Tree**，指**节点的度不超过 2**的**有序树**(左右子树次序固定)，如下图  
  > 2、**满二叉树**：指二叉树**只有最后一层有叶子结点**且**不存在度为 1 的节点**(每一层只要有节点，必然扑满)  
  > 3、一个**高为 h 的满二叉树**的节点数为 2<sup>h</sup> - 1。按层序**从 1 编号**，**节点 i**的**左子**为 2 \* i，**右子**为 2 \* i + 1，**父节点**为 i / 2；按层序**从 0 编号**，**节点 i**的**左子**为 2 \* i + 1，**右子**为 2 \* i + 2，**父节点**为 i / 2(向下取整)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二叉树.png)

- **常见的树：完全二叉树**

  > 1、**完全二叉树**：当且仅当二叉树**每个节点的序号**都与**同高度的满二叉树节点序号**完全对应时，称为**完全二叉树**(即只有最后一层可以不铺满)，如下图  
  > 2、**完全二叉树**中，**只有最后两层可能有叶子结点**且**最多有一个度为 1 的节点**  
  > 3、**完全二叉树**的**编号**与**满二叉树**相同，因此**编号公式**通用。此外，如果节点 i <= n / 2，该节点为分支节点；如果节点 i > n / 2，该节点为叶子结点

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/完全二叉树.png)

- **常见的树：二叉查找树**

  > 1、**二叉查找树**：又称**二叉排序树**/**二叉搜索树**，其**任意节点**与其**左右子节点**的**大小关系**都有**左 < 中 < 右**，其常用于**元素的排序和查找**，如下图  
  > 2、在下面的**二叉查找树**中**插入新元素 12**，应放在**元素 11**的**右子节点处**(从根节点依次比较 12 与 10、13、11 的关系)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二叉查找树.png)

- **常见的树：AVL 树**

  > 1、**AVL 树**：又称**平衡二叉树**，是**二叉查找树**的一种**改进形式**。其**任意节点**的**左右子树深度差不超过 1**，且仍拥有**二叉查找树**的**节点大小关系**，如下图  
  > 2、**插入或删除元素**时，会**动态调整**树的结构，以便提高下次的**搜索效率**(解决了二叉查找树搜索次数不均衡，最极端情况下甚至会变为链表的问题)

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/AVL树.png)

- **二叉树的性质**

  > 1、二叉树**第 i 层**最多有 2<sup>i-1</sup> 个节点；**高度为 h 的二叉树**最多有 2<sup>h</sup> - 1 个节点(即满二叉树)  
  > 2、**非空二叉树**中，**叶子结点**个数比**二分支节点**个数多 1 个。根据下图辅助证明：令**度**为 0、1、2 的**节点个数**分别为 n<sub>0</sub>、n<sub>1</sub>、n<sub>2</sub>，则有 n = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub>；此外，由于**总节点个数** = 边的个数 + 1，则有 n = 0 \* n<sub>0</sub> + 1 \* n<sub>1</sub> + 2 \* n<sub>2</sub> + 1 = n<sub>1</sub> + 2 \* n<sub>2</sub> + 1，**联立两式**证得：n<sub>0</sub> = n<sub>2</sub> + 1  
  > 3、用**n 个节点**构成一棵**二叉树**，其**最小的高度**(即构成完全二叉树时的高度)为：h = log<sub>2</sub>(n+1) 或 log<sub>2</sub>n + 1

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/二叉树.png)

---

#### **二叉树的存储**

---

- **描述**

  > 1、先前介绍过了**树的存储结构**，**二叉树的存储思路**也与之类似，分为**顺序存储**和**链式存储**  
  > 2、**顺序存储**：思路与前面介绍的相同，使用**数组**。注意，**顺序存储**只适用于**完全二叉树形式**(如果不是完全二叉树，其空缺的节点应留空)，**节点中**存储的**父节点和两个子节点的下标**应使用先前的**关系公式**来指代。**顺序存储**的特点为：**存取快**、**增删慢**、**仅适用于完全二叉树形式**  
  > 3、**链式存储**：与前面介绍的类似，用**链表**存储，**节点中**存储**父节点和两个子节点的指针**。**链式存储**的特点为：**存取慢**、**增删快**。由于**便于维护**以及拥有更好的**普适性**，所以我们着重介绍**链式存储**，其代码如下

- **链式存储代码实现**

  ```cpp
  #include <iostream>
  #include <memory>
  using namespace std;

  // 树的最大节点个数
  #define MAX_TREE_SIZE 256
  // 树的节点的数据类型
  typedef int ElemType;

  // 树的节点
  typedef struct TreeNode
  {
          ElemType value;                   // 存储的数据
          shared_ptr<TreeNode> left, right; // 指向左子节点、右子节点
          shared_ptr<TreeNode> parent;      // 指向父节点

          // 构造函数
          TreeNode(ElemType val) : value(val), left(nullptr), right(nullptr)
          {
          }

          // 关联节点的成员函数
          void LinkNodes(shared_ptr<TreeNode> leftNode, shared_ptr<TreeNode> rightNode, shared_ptr<TreeNode> parentNode)
          {
              left = leftNode;
              right = rightNode;
              parent = parentNode;
          }
          // 释放当前节点的成员函数
          void ReleaseNode()
          {
              // 不要担心只释放了当前节点的值，由于智能指针的机制，当与该节点有关联的父节点和子节点更换绑定时，该节点的智能指针引用计数将 -1
              // 在该节点有关联的节点全部换绑之前，智能指针会保护这些数据不被销毁；当所有有关联的节点全部换绑后，引用计数为 0，数据将自动被销毁
              left = nullptr;
              right = nullptr;
              parent = nullptr;
          }
  } Node;

  int main()
  {
      // 使用 shared_pointer 智能指针，用 make_shared 创建对象
      // 也可以用 new 实现，如： Node *root = new Node(1); ，这样的话需要自行更改程序，并确保程序安全
      // 创建二叉树：根节点，其默认值为 1
      shared_ptr<Node> root = make_shared<Node>(1);

      // 使用时，创建新的节点，例如现在根节点下有数据为 2 的左子节点，数据为 3 的右子节点
      shared_ptr<Node> leftChild = make_shared<Node>(2);
      shared_ptr<Node> rightChild = make_shared<Node>(3);

      // 创建后，需要关联对应的节点
      root->LinkNodes(leftChild, rightChild, nullptr);
      leftChild->LinkNodes(nullptr, nullptr, root);
      rightChild->LinkNodes(nullptr, nullptr, root);

      // 输出数据
      cout << root->value << ' ' << root->left->value << ' ' << root->right->value << endl;

      // 使用后，销毁节点
      leftChild->ReleaseNode();
      rightChild->ReleaseNode();
      root->ReleaseNode();
      return 0;
  }
  ```

---

#### **二叉树的遍历**

---

- **先序遍历**

---

#### **页底评论**

---
