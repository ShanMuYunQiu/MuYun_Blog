---
title: 线段树
author: 山暮云秋
description: 学习线段树，维护区间信息
sticky: 0
readmore: true
tags:
  - 线段树
  - 树
  - C++
categories:
  - 数据结构与算法
abbrlink: 8893d943
date: 2024-08-05 00:00:00
updated: 2024-08-05 00:00:00
---

---

### **加法线段树**

---

- **线段树**

  > 1、先前学习了运用**树状数组**维护**区间和**，而**线段树**是一种**更高效更通用**的方法，通过 $lazytag$ 优化后可以在 $O(\log n)$ 下完成**区间修改和查询**(朴素版只能单点修改和区间查询)，还可以维护更多的**区间信息**(区间和、区间积、异或和、最值等满足可加性或集合合并性质的信息)，运用了**分治**思想  
  > 2、**线段树**是一种基于**二叉树**的**数据结构**，**朴素版**的**每个节点**包含的信息有：**编号** $o$、**管辖区间** $[s, e]$、**权值**(即维护的区间信息)。为了实现**区间修改**，还会加入**懒标记** $lazytag$

  <!-- more -->

- **加法线段树**

  > 1、[加法线段树](https://www.starrycoding.com/problem/12)：给定**数组长度** $n$ 和**操作次数** $q$ ($n,q \leq 2 \times 10^5$)，再给出数组 $a[]$ 和 这 $q$ 次操作。对于每次操作，输入 $1\ l\ r\ x$ 表示将**区间** $[l, r]$ **每个元素加上** $x$，输入 $2\ l\ r$ 输出**区间** $[l, r]$ **数字之和**  
  > 2、在**线段树**中，用**一个节点**表示**一段区间**(用管辖区间 $[s, e]$ 记录)。对于**编号**，运用**二叉树的编号性质**来**构造整棵树**，即**编号为** $o$ **的节点**，**左子节点**为 $2o = o \lt\lt 1$，**右子节点**为 $2o + 1 = o \lt\lt 1 \lor 1$，因此，我们需要开 $4n = n \lt\lt 2$ **大小的数组**存下这棵树，一般以**编号** $1$ **为根**。对于**管辖区间**，先计算**节点** $o$ 的**中间值** $mid = \lfloor \frac{s + e}{2} \rfloor = (s + e) \gt\gt 1$，则**左子节点管辖** $[s, mid]$，右子节点管辖 $[mid + 1, e]$；特别地，如果当前节点**区间长度**为 $1$，那么**没有子节点**。线段树结构示意图如下图  
  > 3、实现上(可以结合代码理解)，**线段树**的每次操作都**从根开始**，因此每个节点的**管辖区间**都可以**由父节点算出来**，所以可以**不存储管辖区间**。**上拉操作**`pushup`用**子节点的信息**更新**自己的信息**(在此处，当前节点区间和 = 两子节点区间和之和)，该函数也决定**线段树的功能**。**建树**`buildTree`用**分治**的思想分别**建立左右子树**，用`pushup`**更新当前节点**，建立子树  
  > 4、**线段树**的**区间修改**逻辑(如下图)：例如要修改 $[1, 4] + 2$，从**根节点出发**，每到一个节点就检查**当前管辖区间**是否**完全包含于目标区间**。如果不是，就继续向下**找子节点并剪枝**(不走与目标节点完全没关系的节点，例如 $[7, 11]$)；如果是，例如 $[1, 3]$，则将**该节点权值**增加 $2 \times 3 = 6$ (包含 $3$ 个点)，但从**此节点开始**，向下的**整棵子树**直至**叶子结点**都相应地需要更新，全部完成后还要**自下而上更新整棵树**，对**复杂度**没有任何优化，为了实现快速的**区间修改和查询**，必须引入**懒标记** $lazytag$  
  > 5、$lazytag$ 用于表示某个节点**尚未更新给子节点的值**(但不是子节点应该加的权值，而是这次任务每元素修改的值)。在上例中，$[1, 3]$ 的**节点权值** $+6$，并将其 $lz += 2$，表示该节点**自己已更新**，但**左右子节点**都还欠**每元素** $+2$ **未更新**，该值将在下次经过此节点时**下放给子节点**。当 $lz = 0$ 表示当前节点**左右子节点**都**已经被更新**，相应地，当前节点**是否已被更新**取决于**父节点**的 $lz$ 是否为 $0$。注意，使用**懒标记**后必须配合**下放操作**  
  > 6、**下放操作**`pushdown`用于**向下走之前**，使当前节点的 $lz$ 下放，使**子节点**的权值和 $lz$ **被更新**。**区间修改**`add`调用整合上述的操作，**向下走之前执行下放**，查询**管辖范围完全在目标区间内**的节点，**修改**它的权值和 $lz$，并在**递回时执行上拉**更新值。**区间查询**`query`与**区间修改**类似，只做了一点变化

  ![](https://cdn.jsdelivr.net/gh/ShanMuYunQiu/Image/blog/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%93%E6%9E%84.png)
  ![](https://cdn.jsdelivr.net/gh/ShanMuYunQiu/Image/blog/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%93%E6%9E%842.png)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 2e5 + 10;
  using ll = long long;

  int n, q;
  ll a[N]; // 原数组
  ll t[N << 2]; // 线段树，注意大小为 4n = n << 2，t[x] 表示节点 x 所表示的管辖区间(不存储)的元素之和
  ll lz[N << 2]; // 懒标记，表示节点 o 尚未更新给子节点的值

  // 上拉操作
  void pushup(int o)
  {
      t[o] = t[o << 1] + t[o << 1 | 1]; // 向上更新父节点
  }

  // 建树(预设参数)，当前管辖区间 [s, e]，节点编号 o
  void buildTree(int s = 1, int e = n, int o = 1)
  {
      // 区间长度为 1，得到区间和，结束递归
      if (s == e)
      {
          t[o] = a[s];
          return;
      }

      int mid = (s + e) >> 1;
      buildTree(s, mid, o << 1);         // 左子树
      buildTree(mid + 1, e, o << 1 | 1); // 右子树
      pushup(o);                         // 更新当前节点
  }

  // 下放操作，当前管辖区间 [s, e]，节点编号 o
  void pushdown(int s, int e, int o)
  {
      // lz[o] == 0 无需下放
      if (!lz[o])
          return;

      // ls 是左子节点编号，rs 是右子节点编号
      int mid = (s + e) >> 1;
      int ls = o << 1, rs = o << 1 | 1;

      // 注意，lz[o] 表示区间里每个点都要 +lz[o]，所以要乘上区间长度
      t[ls] += lz[o] * (mid - s + 1);
      t[rs] += lz[o] * (e - mid);

      lz[ls] += lz[o], lz[rs] += lz[o]; // lz 也要下放

      lz[o] = 0; // 标记下放完成
  }

  // 区间修改，目标区间 [l, r]，修改值 x，当前管辖区间 [s, e]，节点编号 o
  void add(int l, int r, ll x, int s = 1, int e = n, int o = 1)
  {
      // 找到管辖区间 [s, e] 完全在目标区间 [l, r] 内的节点
      if (l <= s && e <= r)
      {
          t[o] += 1ll * (e - s + 1) * x; // 修改当前节点的值
          lz[o] += x;              // 标记 lz
          return;                  // 不再向下走
      }

      // 向下走之前，一定要先下放
      pushdown(s, e, o);

      int mid = (s + e) >> 1;
      // 判断向下走的方向，剪枝
      // 判断是否需要向左走，如果左子区间 [s, mid] 与 [l, r] 有交集，就要走
      if (mid >= l)
          add(l, r, x, s, mid, o << 1);
      // 判断是否需要向右走，如果右子区间 [mid + 1, e] 与 [l, r] 有交集，就要走
      if (mid + 1 <= r)
          add(l, r, x, mid + 1, e, o << 1 | 1);

      // 递归回来的时候，记得 pushup
      pushup(o);
  }

  // 区间查询，目标区间 [l, r]，当前管辖区间 [s, e]，节点编号 o
  ll query(int l, int r, int s = 1, int e = n, int o = 1)
  {
      // 找到管辖区间 [s, e] 完全在目标区间 [l, r] 内的节点
      if (l <= s && e <= r)
          return t[o]; // 直接返回当前节点的值

      ll res = 0; // 记录结果

      // 向下走之前，一定要先下放
      pushdown(s, e, o);

      int mid = (s + e) >> 1;
      // 判断向下走的方向，剪枝
      // 判断是否需要向左走，如果左子区间 [s, mid] 与 [l, r] 有交集，就要走
      if (mid >= l)
          res += query(l, r, s, mid, o << 1);
      // 判断是否需要向右走，如果右子区间 [mid + 1, e] 与 [l, r] 有交集，就要走
      if (mid + 1 <= r)
          res += query(l, r, mid + 1, e, o << 1 | 1);

      // query 没有进行修改，所以可以不 pushup

      return res;
  }

  void solve()
  {
      cin >> n >> q;
      for (int i = 1; i <= n; i++)
          cin >> a[i];
      buildTree();

      while (q--)
      {
          int op;
          cin >> op;
          if (op == 1)
          {
              ll l, r, x;
              cin >> l >> r >> x;
              add(l, r, x);
          }
          else
          {
              ll l, r;
              cin >> l >> r;
              cout << query(l, r) << '\n';
          }
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int T = 1;
      // cin >> T;
      while (T--)
          solve();
      return 0;
  }
  ```

---

### **页底评论**

---
