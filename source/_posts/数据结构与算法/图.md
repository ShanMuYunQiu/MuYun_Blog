---
title: 图
author: 圣奇宝枣
description: 入门图这种数据结构，学习图的存储，学习BFS、DFS进行遍历，能够通过回溯法和剪枝进行搜索
sticky: 0
date: 2023-10-21
updated: 2023-10-21
readmore: true
tags:
  - DFS
  - BFS
  - 回溯法
  - 剪枝
  - 图
  - C++
categories:
  - 数据结构与算法
---

---

#### **图的存储**

---

- **邻接表**

  > 1、在计算机中，**图的存储方式**有**多种**，最常用的是**邻接表**和**邻接矩阵**。**邻接矩阵**由于适用范围很小，故不考虑这种写法  
  > 2、**出度**：如下图便是一幅**有向图**，其中**一个节点**指向的**其他节点**称为这个节点的**出度**，**指向出度节点的路径**称为这个节点的**出边**。如下图中 2、5 为 1 的**出度**  
  > 3、**邻接表**：就是将**一个点的所有出点**(邻接点)保存在一个数组中；**拓展**的过程，也就是**遍历这个数组**的过程。**这个数组**我们称为**邻接表**

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/邻接表.png)

- **vector 建图**

  > 1、上述数组的**长度显然是可变的**，所以选择使用`vector`来**建图**  
  > 2、我们将**每个点的所有出点**存入对应的`vector`中，命名为`g[]`(graph)  
  > 3、**拓展**的时候，**只需要遍历**对应的`g[]`**数组**即可

---

#### **图的遍历**

---

- **DFS 深度优先搜索**

  > 1、**DFS**是**深度优先搜索**，英文为**Depth First Search**。一句话简言之：**一条路走到黑**  
  > 2、其**算法精髓**是**先往深处走**，**走完了再回头**  
  > 3、对应的**数据结构**是**栈**，每次**从栈顶取出一个点**，再**将所有出点入栈**，完成一次拓展

- **BFS 广度优先搜索**

  > 1、**BFS**是**广度优先搜索**，英文为**Breadth First Search**。与 DFS 不同，其每次**将所有出点放入队列**，然后小心地向下试探  
  > 2、其**算法精髓**是**小步走**，**尽量不往深处走**  
  > 3、对应的**数据结构**是**队列**，每次**从队头取出一个点**，然后**将所有出点推入队列**，完成一次拓展

- **注意事项**

  > 1、以上**两种搜索**一般都需要保证**不走重复的点**，否则很容易**产生环**从而无限循环，所以会使用一个`bool vis[]`来**标记某个点是否走过**。但是**树**上一般**不需要标记**，因为**树一定没有环**  
  > 2、一般来说，**DFS**用来求**树上问题**较多，**BFS**用于求**权值相等的最短路**(最少操作次数等)

- **例-树的遍历**

  > 1、[树的遍历](https://cdn.oj.eriktse.com/problem.php?id=1021)：给定一棵**大小为 n**(不超过 50)，**根为 1**的树，求出其按照**DFS**和**BFS**进行**遍历时的顺序**，将**所有出点**按照**编号从小到大排序**后进行遍历  
  > 2、输入一个整数 n 表示**树的大小**，接下来 **n-1 个整数**表示 **2~n 的父节点**。第一行输出 **DFS 序**，第二行输出 **BFS 序**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 60;
  vector<int> g[N]; // 图
  int fa[N];        // 二叉树节点的父节点

  // 深度优先(也可以通过 stack 实现)
  void DFS(int x)
  {
      cout << x << ' '; // 输出当前节点

      // 遍历当前节点的所有出点
      for (auto &y : g[x])
      {
          // 如果 y 作为 x 的出点指向了 x 的父节点，则跳过(该题可以省略)
          if (y == fa[x])
              continue;

          DFS(y); // 递归地向下遍历
      }
  }

  // 广度优先
  void BFS(int root)
  {
      queue<int> q; // 创建队列
      q.push(root); // 将初始节点推入队列

      // 只要队列不为空
      while (q.size())
      {
          int x = q.front(); // x 获取队头
          q.pop();           // 释放队头
          cout << x << ' ';  // 输出当前节点

          for (auto &y : g[x])
          {
              // 如果 y 作为 x 的出点指向了 x 的父节点，则跳过(该题可以省略)
              if (y == fa[x])
                  continue;

              q.push(y); // 将出点推入队尾
          }
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int n;
      cin >> n;

      for (int i = 2; i <= n; i++)
      {
          cin >> fa[i];          // 输入 i 的父节点
          g[fa[i]].push_back(i); // 建立图，从父节点 fa[i] 指向子节点 i
      }

      // 对出点进行排序
      for (int i = 1; i <= n; i++)
          sort(g[i].begin(), g[i].end());

      DFS(1);
      cout << endl;
      BFS(1);
      cout << endl;
      return 0;
  }
  ```

---

#### **页底评论**

---
