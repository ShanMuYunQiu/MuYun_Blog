---
title: 图
author: 圣奇宝枣
description: 入门图这种数据结构，学习图的存储，学习BFS、DFS进行遍历搜索，学习回溯法和剪枝
sticky: 0
date: 2023-10-21
updated: 2023-11-09
readmore: true
tags:
  - DFS
  - BFS
  - 回溯法
  - 剪枝
  - 图
  - C++
categories:
  - 数据结构与算法
---

---

#### **图的存储**

---

- **邻接表**

  > 1、在计算机中，**图的存储方式**有**多种**，最常用的是**邻接表**和**邻接矩阵**。**邻接矩阵**由于适用范围很小，故一般不考虑这种写法  
  > 2、**出度**：如下图便是一幅**有向图**，其中**一个节点**指向的**其他节点**称为这个节点的**出度**，**指向出度节点的路径**称为这个节点的**出边**。如下图中 2、5 为 1 的**出度**  
  > 3、**邻接表**：就是将**一个点的所有出点**(邻接点)保存在一个数组中；**拓展**的过程，也就是**遍历这个数组**的过程。**这个数组**我们称为**邻接表**

  <!-- more -->

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/邻接表.png)

- **vector 邻接表建图**

  > 1、上述数组的**长度显然是可变的**，所以选择使用`vector`来**建图**  
  > 2、我们将**每个点的所有出点**存入对应的`vector`中，命名为`g[]`(graph)  
  > 3、**拓展**的时候，**只需要遍历**对应的`g[]`**数组**即可，且`vector`**建图**的**出点支持排序**

---

#### **图的遍历**

---

- **DFS 深度优先搜索**

  > 1、**DFS**是**深度优先搜索**，英文为**Depth First Search**。一句话简言之：**一条路走到黑**  
  > 2、其**算法精髓**是**先往深处走**，**走完了再回头**  
  > 3、对应的**数据结构**是**栈**，每次**从栈顶取出一个点**，再**将所有出点入栈**，完成一次拓展

  ```cpp
  // 深度优先(可用递归，也可用栈实现)
  void DFS(int x)
  {
      cout << g[x] << ' ';  // 输出当前节点

      // 深度优先，遍历当前节点所有出点
      for (int &y : g[x])
      {
          if (该元素先前已被遍历过)
              continue;

          DFS(y); // 深度优先地向下递归
      }
  }
  ```

- **BFS 广度优先搜索**

  > 1、**BFS**是**广度优先搜索**，英文为**Breadth First Search**。与 DFS 不同，其每次**将所有出点放入队列**，然后小心地向下试探  
  > 2、其**算法精髓**是**小步走**，**尽量不往深处走**  
  > 3、对应的**数据结构**是**队列**，每次**从队头取出一个点**，然后**将所有出点推入队列**，完成一次拓展

  ```cpp
  // 广度优先(用队列实现)
  void DFS(int root)
  {
      queue<int> q; // 创建队列
      q.push(root); // 将初始节点推入队列

      // 只要队列不为空
      while (q.size())
      {
          int x = q.front(); // x 获取队头
          q.pop();           // 释放队头
          cout << x << ' ';  // 输出当前节点

          for (auto &y : g[x])
          {
              if (该元素先前已被遍历过)
                  continue;

              q.push(y); // 将出点推入队尾
          }
      }
  }
  ```

- **注意事项**

  > 1、以上**两种搜索**一般都需要保证**不走重复的点**，否则很容易**产生环**从而无限循环，所以会使用一个`bool vis[]`来**标记某个点是否走过**。但是**树**上一般**不需要标记**，因为**树一定没有环**  
  > 2、一般来说，**DFS**用来求**树上问题**较多，**BFS**用于求**权值相等的最短路**(最少操作次数等)

---

#### **例-树的遍历**

---

- **树的遍历**

  > 1、[树的遍历](https://cdn.oj.eriktse.com/problem.php?id=1021)：给定一棵**大小为 n**(不超过 50)，**根为 1**的树，求出其按照**DFS**和**BFS**进行**遍历时的顺序**，将**所有出点**按照**编号从小到大排序**后进行遍历。输入一个整数 n 表示**树的大小**，接下来 **n-1 个整数**表示 **2~n 的父节点**。第一行输出 **DFS 序**，第二行输出 **BFS 序**  
  > 2、**存储树**最简单的办法就是存储**节点的父节点**，只要知道**树的根节点**和**每个节点的父节点**就可以表示一棵树。我们可以反过来，用图存储**父节点**的**子节点**(出度)，再对图进行`BFS`和`DFS`**遍历**即可  
  > 3、由于**树上的元素**遍历时**不会重复**，不会**形成环**，所以不需要**打标记**确定重复

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;

  const int N = 60;
  vector<int> g[N]; // 图
  int fa[N];        // 二叉树节点的父节点

  // 深度优先(也可以通过 stack 实现)
  void DFS(int x)
  {
      cout << x << ' '; // 输出当前节点

      // 遍历当前节点的所有出点
      for (auto &y : g[x])
      {
          // 如果 y 作为 x 的出点指向了 x 的父节点，则跳过(该题可以省略)
          if (y == fa[x])
              continue;

          DFS(y); // 递归地向下遍历
      }
  }

  // 广度优先
  void BFS(int root)
  {
      queue<int> q; // 创建队列
      q.push(root); // 将初始节点推入队列

      // 只要队列不为空
      while (q.size())
      {
          int x = q.front(); // x 获取队头
          q.pop();           // 释放队头
          cout << x << ' ';  // 输出当前节点

          for (auto &y : g[x])
          {
              // 如果 y 作为 x 的出点指向了 x 的父节点，则跳过(该题可以省略)
              if (y == fa[x])
                  continue;

              q.push(y); // 将出点推入队尾
          }
      }
  }

  int main()
  {
      ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
      int n;
      cin >> n;

      for (int i = 2; i <= n; i++)
      {
          cin >> fa[i];          // 输入 i 的父节点
          g[fa[i]].push_back(i); // 建立图，从父节点 fa[i] 指向子节点 i
      }

      // 对出点进行排序
      for (int i = 1; i <= n; i++)
          sort(g[i].begin(), g[i].end());

      DFS(1);
      cout << endl;
      BFS(1);
      cout << endl;
      return 0;
  }
  ```

---

#### **例-图的遍历**

---

- **图的遍历**

  > 1、[图的遍历](https://cdn.oj.eriktse.com/problem.php?id=1092)：给定一个**n 个点 m 条边**的**有向图**，图中可能有**重边和自环**，点的编号为**1~n**。求出**从点 1 出发**，**能够到达的所有点**  
  > 2、

- **代码实现**

  ```cpp

  ```

---

#### **回溯与剪枝**

---

- **回溯法模板**(基于 DFS)

  ```cpp
  func()
  {
      递归出口;

      剪枝函数;

      向后拓展(可能还包含剪枝)
      {
          修改现场;

          func();

          恢复现场;
      }
  }
  ```

- **回溯法特点**

  - **解决一切问题**

    > 1、用**回溯法**几乎可以**解决所有问题**，但只能在**问题规模较小**时使用  
    > 2、当**问题规模较大**时基本就失效了，因为**时间复杂度极高**

  - **生成解空间**

    > 1、**回溯法**可以用于**生成解空间**，其实就是一个**带剪枝的暴力枚举**  
    > 2、**回溯法**通常用于生成**子集树**、**排列树**等解空间，然后在**解空间**中通过**数学方法**来**剪枝**，即减少不必要的操作，从而**缩小解空间**。最终**找出最好的解**

  - **往回走恢复现场**

    > 1、**回溯法**之所以叫回溯，是因为**所有子问题的解**最终都要**回归到原问题**。通过**合并操作**，利用**函数关系**进行**解的传递**  
    > 2、**恢复现场**是及其关键的一步，常见的**恢复现场**包括**对标记的恢复**、**数组状态的恢复**、**局面地图的恢复**等

---

#### **例-N 皇后**

---

- **N 皇后**

  > 1、[N 皇后](https://leetcode.cn/problems/n-queens/)：现在有一个 **n\*n 的棋盘**，要放入 **n 个皇后**，要满足**每个皇后的攻击范围**(横竖斜)内**不能出现其他皇后**，找出**所有的可行方案**  
  > 2、我们将棋盘**每一行看作一层**，易知每一层**有且只有一个皇后**。按照层次进行**枚举**，例如第一层选择(0, 0)位置，此时**修改棋盘的状态**，标记其攻击范围为**不可落子状态**，再进行**第二层的落子**。如果到某一层发现**无法落子**(如下图)，那么就必须**向上一层回溯**，要将上一层**设置的状态解除**，并重新向下枚举**上一层的落点**，再继续向下尝试。如果**所有层都可以落子**，表明这是一种**合法的方案**  
  > 3、接下来处理**如何标记被占领状态**。我们可以发现，每一层(第 i 层)**只需要枚举不需要标记**，每一列可以用`vis[j]`表示**第 j 列被占**；此时可以用`vis2[k]`表示 **i+j = k 这条左下-右上的斜线被占**，可以用`vis3[k]`表示 **i+n-j = k 这条左上-右下的斜线被占**

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/N皇后问题.png)

- **代码实现**

  ```cpp
  #include <bits/stdc++.h>
  #include <string>
  #include <vector>
  using namespace std;

  const int N = 15;
  vector<vector<string>> res; // 返回的结果
  vector<string> tmp;         // 当前状态的地图情况
  bitset<N> vis, vis2, vis3;  // true 表示被占领

  // 表示当前正在处理第 dep 行
  void DFS(int dep, int n)
  {
      // 递归出口
      if (dep == n)
      {
          // 执行此处时，说明已经完成了合法的地图，将其计入答案
          res.push_back(tmp);
          return; // 退出
      }

      // 向后拓展：第 dep 行，选择第 j 个位置落子
      for (int j = 0; j < n; j++)
      {
          // 判断可行性，剪枝(也可单独写一个剪枝函数)
          if (vis[j] || vis2[dep + j] || vis3[dep + n - j])
              continue;

          // 修改现场(状态转移)
          vis[j] = true;
          vis2[dep + j] = true;
          vis3[dep + n - j] = true;
          tmp[dep][j] = 'Q';

          // 继续处理下一行
          DFS(dep + 1, n);

          // 恢复现场
          vis[j] = false;
          vis2[dep + j] = false;
          vis3[dep + n - j] = false;
          tmp[dep][j] = '.';
      }
  }

  int main()
  {
      int n;
      cin >> n;
      tmp.resize(n); // 初始化为 n 的大小
      for (int i = 0; i < n; i++)
      {
          tmp[i].resize(n); // 每一行的字符串也初始化为 n 的大小
          for (int j = 0; j < tmp[i].size(); j++)
              tmp[i][j] = '.'; // 将整个地图初始化为 .
      }

      DFS(0, n);

      // 输出答案
      for (auto ans : res)
      {
          for (int i = 0; i < n; i++)
              cout << ans[i] << endl;
          cout << endl;
      }
      return 0;
  }
  ```

---

#### **页底评论**

---
