---
title: 双指针
author: 圣奇宝枣
description: 学习双指针的思路，了解同向双指针和相向双指针的常用情景
sticky: 0
date: 2023-08-08
updated: 2023-08-08
readmore: true
tags:
  - 双指针
  - C++
categories:
  - 算法
---

---

#### **同向双指针**

---

- **例题引入**

  > 1、给定一个**已知序列**且**数组元素都是正数**，如`{2, 3, 1, 2, 4, 3}`，再给定一个`target`，从中**找出最短的一个子序列**，使**子序列的和**大于等于`target`，输出**最短子序列的长度**  
  > 2、普通的**暴力做法**是两层循环分别枚举**子序列的左右端点**，显然这样的**时间复杂度**为**O(n<sup>2</sup>)**，运行速度很慢  
  > 3、另一种思路是使用**双指针**：由于**数组元素都是正数**，因此当**子序列向右延伸**时**和一定递增**。我们先以`[0, 3]`为**第一个子序列**，**和为 8**；向右移动**左指针**，发现`[1, 3]`**和为 6**不满足条件，便**向右移动右指针**指向`[1, 4]`，**和为 10**；继续向右移动**左指针**，发现`[2, 4]`**和为 7**满足条件；以此类推直至末尾。最终发现**最短子序列**是`[4, 5]`**长度为 2**  
  > 4、这种思路下，**左右指针**都**不需要向左回退**，因此两个指针都**最多只需要遍历一次数列**，**时间复杂度**为**O(n)**

<!-- more -->

- **代码实现**

  ```cpp
  #include <iostream>
  using namespace std;

  int arr[100001];

  int main()
  {
      int n, target;
      cin >> n >> target;
      for (int i = 0; i < n; i++)
          cin >> arr[i];

      int L = 0, R = 0;                  // 左右指针
      int sum = arr[R], ans_min = n + 1; // 初始化 sum 和 ans，sum 为 arr[R] 的值，ans_min 为整个序列的长度 +1
      // 双指针：以左指针作为基准向右推进
      while (L < n)
      {
          // 如果右指针没有到尽头，且当前和不够
          while (R < n && sum < target)
          {
              // 移动右指针
              R++;
              sum += arr[R];
          }

          // 如果满足条件(为了防止到尽头仍然和不够)
          if (sum >= target)
              ans_min = min((R - L + 1), ans_min); // 更新子序列最小值

          // 移动左指针
          sum -= arr[L];
          L++;
      }

      // 如果 ans_min 没有改变，说明整个序列的和都不满足要求，输出 -1
      if (ans_min == n + 1)
          cout << "-1";
      else
          cout << ans_min;
      return 0;
  }
  ```

---

#### **页底评论**

---
