---
title: 双指针
author: 圣奇宝枣
description: 学习双指针的思路，了解同向双指针和相向双指针的常用情景
sticky: 0
date: 2023-08-08
updated: 2023-08-08
readmore: true
tags:
  - 双指针
  - C++
categories:
  - 算法
---

---

#### **同向双指针-滑动窗口**

---

- **例题引入**

  > 1、给定一个**已知序列**且**数组元素都是正数**(例如`{2, 3, 1, 2, 4, 3}`)，再给定一个`target`(例如 7)，从中**找出最短的一个子序列**，使**子序列的和**大于等于`target`，输出**最短子序列的长度**  
  > 2、普通的**暴力做法**是两层循环分别枚举**子序列的左右端点**，显然这样的**时间复杂度**为**O(n<sup>2</sup>)**，运行速度很慢  
  > 3、另一种思路是使用**双指针**：由于**数组元素都是正数**，因此当**子序列向右延伸**时**和一定递增**。我们先以`[0, 3]`为**第一个子序列**，**和为 8**；向右移动**左指针**，发现`[1, 3]`**和为 6**不满足条件，便**向右移动右指针**指向`[1, 4]`，**和为 10**；继续向右移动**左指针**，发现`[2, 4]`**和为 7**满足条件；以此类推直至末尾。最终发现**最短子序列**是`[4, 5]`**长度为 2**  
  > 4、这种思路下，**左右指针**都**不需要向左回退**，因此两个指针都**最多只需要遍历一次数列**，**时间复杂度**为**O(n)**

<!-- more -->

- **代码实现**

  ```cpp
  #include <iostream>
  using namespace std;

  int arr[100001];

  int main()
  {
      int n, target;
      cin >> n >> target;
      for (int i = 0; i < n; i++)
          cin >> arr[i];

      int L = 0, R = 0;                  // 左右指针
      int sum = arr[R], ans_min = n + 1; // 初始化 sum 和 ans，sum 为 arr[R] 的值，ans_min 为整个序列的长度 +1
      // 双指针：以左指针作为基准向右推进
      while (L < n)
      {
          // 如果右指针没有到尽头，且当前和不够
          while (R < n && sum < target)
          {
              // 移动右指针
              R++;
              sum += arr[R];
          }

          // 如果满足条件(为了防止到尽头仍然和不够)
          if (sum >= target)
              ans_min = min((R - L + 1), ans_min); // 更新子序列最小值

          // 移动左指针
          sum -= arr[L];
          L++;
      }

      // 如果 ans_min 没有改变，说明整个序列的和都不满足要求，输出 -1
      if (ans_min == n + 1)
          cout << "-1";
      else
          cout << ans_min;
      return 0;
  }
  ```

---

#### **相向双指针-三数之和**

---

- **两数之和**

  > 1、给定一个**升序排列的序列**(例如`{2, 3, 4, 6, 8}`)，再给定一个`target`(例如 9)，从序列中**找出两个数**，满足**它们的和等于**`target`，输出这两个数  
  > 2、简单推测可得，**暴力枚举**的**时间复杂度**为**O(n<sup>2</sup>)**，而使用**双指针**只需要**O(n)**  
  > 3、因为数列是**升序**的，所以我们先**从两端开始**(左指针指向最左，右指针指向最右)。如果两指针之和**大于目标值**，由于**升序排列**，说明**右指针值**加上任意一个**左指针向右的值**都会**大于目标**，应当让**右指针向左移动**；相对的，如果两指针之和**小于目标值**，说明**左指针值**加上任意一个**右指针向左的值**都会**小于目标**，应当让**左指针向右移动**。以此类推，直到**找到目标**或者**两指针重叠**

- **代码实现**

  ```cpp
  #include <iostream>
  using namespace std;

  int arr[100001];

  int main()
  {
      int n, target;
      cin >> n >> target;
      for (int i = 0; i < n; i++)
          cin >> arr[i];

      bool flag = true;
      int L = 0, R = n - 1;
      while (L < R)
      {
          if (arr[L] + arr[R] > target)
          {
              R--;
              continue;
          }
          else if (arr[L] + arr[R] < target)
          {
              L++;
              continue;
          }
          else
          {
              cout << arr[L] << " " << arr[R] << endl;
              flag = false;
              break;
          }
      }

      if (flag)
          cout << "-1";
      return 0;
  }
  ```

- **三数之和**

  > 1、给定一个**升序排列的序列**(例如`{-4, -1, -1, 0, 1, 2}`)，是否存在**子序列**`{arr[i], arr[j], arr[k]}`**满足**`i != j != k`**且三数之和等于 0**，子序列**元素顺序不重要**，输出**满足条件**的所有**不重复的子序列**  
  > 2、因为**元素顺序不重要**，即`{-1, 0, 1}`和`{1, -1, 0}`是**相同答案**，我们可以**规定**`i < j < k`。**i**作为**最左侧的数**，通过遍历(范围`[0, n-2)`)得到，**j**和**k**采取上面**两数之和**的方式，用**双指针**来快速判断  
  > 3、需要注意，输出需要**避免重复**，则**下标为 1 和 2**的`-1`可以看作**同一组判断**，因此可以**跳过一组**避免重复(j 和 k 也同理)。此外，对于**优化**而言：如果序列**当前 i 对应值与后两个相邻数之和大于 0**，那么**向后整个序列再任取两个数之和**都会**大于 0**；如果**当前 i 对应的值与最后两个数之和小于 0**，那么**这轮的 i 再任取两个数之和**都会**小于 0**

- **代码实现**

  ```cpp
  #include <iostream>
  using namespace std;

  int arr[100001];

  int main()
  {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++)
          cin >> arr[i];

      bool flag = true;
      int i, j, k, sum;
      // 遍历最左侧的数 i
      for (i = 0; i < n - 2; i++)
      {
          // 如果这一次判断与上一次判断是同一组判断，则跳过
          if (i > 0 && arr[i] == arr[i - 1])
              continue;
          // 当前 i 对应值与后两个相邻数之和大于 0，则向后整个序列任取两个数都大于 0，且之后 arr[i] 只会更大，所以 break
          if (arr[i] + arr[i + 1] + arr[i + 2] > 0)
              break;
          // 当前 i 对应值与最后两个数之和小于 0，则这轮 i 任取两个数都小于 0，但之后 arr[i] 还可能变大，所以 continue
          if (arr[i] + arr[n - 1] + arr[n - 2] < 0)
              continue;

          // 这一轮 i 的 j(左指针) 和 k(右指针)
          j = i + 1;
          k = n - 1;
          while (j < k)
          {
              sum = arr[i] + arr[j] + arr[k];
              if (sum > 0)
                  k--;
              else if (sum < 0)
                  j++;
              else
              {
                  cout << arr[i] << " " << arr[j] << " " << arr[k] << endl;
                  flag = false;

                  // 改变 j 和 k，并且跳过重复的判断
                  j++;
                  while (j < k && arr[j] == arr[j - 1])
                      j++;
                  k--;
                  while (k > j && arr[k] == arr[k + 1])
                      k--;
              }
          }
      }

      if (flag)
          cout << "-1";
      return 0;
  }
  ```

---

#### **相向双指针-接雨水**

---

---

#### **页底评论**

---
