---
title: 离散化
author: 圣奇宝枣
description: 使用离散化的方式优化更关注相对大小的数列
sticky: 0
date: 2023-08-09
updated: 2023-08-09
readmore: true
tags:
  - 离散化
  - C++
categories:
  - 算法
---

---

#### **离散化**

---

- **引入**

  > 1、对于**元素个数不多**、**值域很大**的**有序无重复数列**，且更关注**数列的相对大小**(而不是绝对大小)，可以使用**离散化**的方式优化程序。**离散化**本质上是一种**哈希**，即把**一个数字**映射为**另一个数字**  
  > 2、例如对于一个长度为 10<sup>5</sup> 的**有序无重复数列**`{1, 2, 5, ..., 10^9}`(元素最大值为 10<sup>9</sup>)，要**判断相对大小关系**。如果**将元素大小作为下标**建立新数组，**一定会爆栈**。但是还可以**将元素位置作为下标**，将数列**离散化**，**映射为**`{0, 1, 2, ...}`

<!-- more -->

- **代码实现**

  > 1、通常读入的数组**不是有序无重复的**，因此我们需要先进行**排序**和**去重**。**排序**可以**直接使用**`sort`，**去重**通常使用`unique`**配合**`erase`**实现**(此外也给出了数组的实现方式)。然后，我们需要算出**离散化后的值**，通常使用**二分查找**的方式实现  
  > 2、如下例，单独给出了**去重**和**二分**的框架。且在下面附上**完整程序**的一个示例

  ```cpp
  /* 去重 - vector */
  vector<int> vec = {1, 13, 2, 5, 10000, 2, 13}; // 使用 vector 保存原始数据
  sort(vec.begin(), vec.end());                  // 使用 sort 排序
  // unique 函数返回一个迭代器，指向不重复序列的尾后位置(即被排到末尾的重复元素的首元素位置)
  // erase 从重复元素首元素，删除到末尾，删除掉所有重复元素
  vec.erase(unique(vec.begin(), vec.end()), vec.end());

  /* 去重 - 数组 */
  int n = 7;                                     // 实际数组长度
  int arr[100001] = {1, 13, 2, 5, 10000, 2, 13}; // 使用数组保存原始数据
  sort(arr, arr + n);                            // 使用 sort 排序
  // 使用 unique 返回的位置，减去首元素位置，得到不重复数列的长度
  // 后面程序使用数组，只需要使用 arr[0] 到 arr[len] 即可，后面部分是重复元素
  int len = unique(arr, arr + n) - arr;

  /* 二分 - 查找当前数字在数组中的位置(查找映射值) */
  // 也可以直接使用 lower_bound
  // 原始数据的 vector 或 数组 是全局变量
  int binary_search(int L, int R, int key)
  {
      int mid;
      // 这种二分写法需要范围略大一些
      L--;
      R++;

      while (L + 1 != R)
      {
          mid = (R + L) / 2;
          if (vec[mid] < key)
              L = mid;
          else
              R = mid;
      }

      return R;
  }
  ```

  ```cpp
  #include <algorithm>
  #include <iostream>
  #include <vector>
  using namespace std;

  vector<int> vec, res;

  int binary_search(int L, int R, int key)
  {
      int mid;
      L--;
      R++;
      while (L + 1 != R)
      {
          mid = (R + L) / 2;
          if (vec[mid] < key)
              L = mid;
          else
              R = mid;
      }
      return R;
  }

  int main()
  {
      int n, num;
      cin >> n;
      while (n--)
      {
          cin >> num;
          vec.push_back(num);
      }

      sort(vec.begin(), vec.end());
      vec.erase(unique(vec.begin(), vec.end()), vec.end());

      int value;
      for (int key : vec)
      {
          value = binary_search(0, vec.size() - 1, key);
          res.push_back(value);
      }

      // 输出映射的结果
      for (int i = 0; i < res.size(); i++)
          cout << vec[i] << ' ' << res[i] << endl;
      return 0;
  }
  ```

---

#### **例题练习**

---

- **例题描述**

  > 1、假设有一条长度不超过 10<sup>5</sup> 的**数轴**，程序首先**输入两个参数**：**n**(要添加的点的个数)、**m**(要询问的次数)。接下来 n 行，每行**输入 p 和 q**，表示**数轴上 p 处的值为 q**；接下来 m 行，每行**输入 x 和 y**，表示**询问区间**`[x, y]`**的区间和**，并输出答案  
  > 2、一共有**两大组数据**：**数轴点和值**以及**询问区间**。我们可以将**所有的点**记录到一起，按照**所有的点**的**相对大小位置**(作为离散化的总的目录)来**离散化**处理，再分别按照两组数据**对应的点离散化的结果**，将数据**按照离散化的下标转存**，代码如下

- **代码实现**

  ```cpp
  #include <algorithm>
  #include <iostream>
  #include <utility>
  #include <vector>
  using namespace std;

  vector<pair<int, int>> info;  // 存储数轴点和值
  vector<pair<int, int>> query; // 存储查询区间
  vector<int> all_point;        // 存储数轴点和区间点，即所有要离散化的点

  // 查询 key 在所有点中的相对大小位置，离散化处理
  int binary_search(int L, int R, int key)
  {
      int mid;
      L--;
      R++;
      while (L + 1 != R)
      {
          mid = (L + R) / 2;
          if (all_point[mid] < key)
              L = mid;
          else
              R = mid;
      }
      return R;
  }

  int main()
  {
      int n, m;
      cin >> n >> m;

      int p, q;
      // 读入数轴点和值
      for (int i = 0; i < n; i++)
      {
          cin >> p >> q;
          info.push_back({p, q});
          all_point.push_back(p);
      }
      // 读入询问区间
      for (int i = 0; i < m; i++)
      {
          cin >> p >> q;
          query.push_back({p, q});

          all_point.push_back(p);
          all_point.push_back(q);
      }

      // all_point 排序去重
      sort(all_point.begin(), all_point.end());
      all_point.erase(unique(all_point.begin(), all_point.end()), all_point.end());

      // 先离散化 info
      int arr[10001]; // 记录 info 离散化处理后的结果
      for (auto item : info)
      {
          int x = binary_search(0, all_point.size() - 1, item.first); // 计算坐标离散化后的坐标
          arr[x] += item.second; // 将离散化后的数据存储到新数组，下标变成了离散化的下标
      }

      // 计算区间和，使用前缀和优化，先预处理前缀和
      int sum[10001] = {};
      sum[0] = arr[0];
      for (int i = 1; i < all_point.size(); i++)
          sum[i] = sum[i - 1] + arr[i];

      // 处理询问
      for (auto item : query)
      {
          // L 和 R 也处理成离散化的坐标
          int L = binary_search(0, all_point.size() - 1, item.first);
          int R = binary_search(0, all_point.size() - 1, item.second);

          // 计算前缀和，输出答案
          if (L == 0)
          {
              cout << sum[R] << endl;
              continue;
          }
          cout << sum[R] - sum[L - 1] << endl;
      }
      return 0;
  }
  ```

---

#### **页底评论**

---
