---
title: P1364 医院设置
author: 山暮云秋
sticky: 0
readmore: true
tags:
  - BFS
categories:
  - 算法题
date: 2024-02-21 00:00:00
---

##### [P1364 医院设置](https://www.luogu.com.cn/problem/P1364)

<!-- more -->

## 解题思路

1、由题意，无论取哪个点作**根**(医院)，都能够形成一棵**树**。首先，需要**先整理这棵树**，用**邻接表建图**记录这棵树的情况。注意：为了方便**双向访问**，应建立**双向图**  

2、对于**树的总代价**，可通过 **BFS** 一层一层**向外遍历节点**，标记**节点 i 的层数**为`dep[i]`，得到**每个节点的代价**`w[i] * dep[i]`，将**所有节点代价相加**即为总代价  

3、由于**数据范围较小**，所以可以直接**遍历整棵树**，让每一个节点**都作一次根**跑一遍 **BFS**，取这些树中**总代价最小的**即为答案

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 110, INF = 0x3f3f3f3f;

vector<int> g[N]; // 建图记录树的情况
int w[N], dep[N]; // 居民数 和 深度

int BFS(int x)
{
    int res = 0;   // 记录当前答案
    bitset<N> vis; // 标记是否访问过

    queue<int> q;
    q.push(x);
    dep[x] = 0;
    vis[x] = true;

    while (q.size())
    {
        int x = q.front();
        q.pop();

        for (int &y : g[x])
        {
            if (vis[y])
                continue;

            dep[y] = dep[x] + 1;
            res += w[y] * dep[y];
            vis[y] = true;
            q.push(y);
        }
    }

    return res;
}

void solve()
{
    int n;
    cin >> n;
    // 建立双向图
    for (int i = 1; i <= n; i++)
    {
        int u, v;
        cin >> w[i] >> u >> v;
        if (u)
            g[i].push_back(u), g[u].push_back(i);
        if (v)
            g[i].push_back(v), g[v].push_back(i);
    }

    // 遍历每个节点作根的情况，记录最小答案
    int ans = INF;
    for (int i = 1; i <= n; i++)
        ans = min(ans, BFS(i));
    cout << ans;
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    // cin >> T;
    while (T--)
        solve();
    return 0;
}
```

## 页底评论
