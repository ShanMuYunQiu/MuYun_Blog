---
title: 乘法逆元
author: 圣奇宝枣
description: 运用乘法逆元解决模意义下的除法问题，将其转换为模意义下的乘法，了解多种求乘法逆元的思路
sticky: 0
date: 2023-08-11
updated: 2023-08-12
readmore: true
tags:
  - 乘法逆元
  - C++
categories:
  - 算法
---

---

#### **乘法逆元介绍**

---

- **引入**

  > 1、对于**模意义下的运算**，例如我们知道**有**`(a + b) % p = (a % p) + (b % p)`或者`(a * b) % p = (a % p) * (b % p)`**成立**，但是对于**模意义下的除法**却**不成立**：`(a / b) % p != (a % p) / (b % p)`。不过，我们可以把**模意义的除法**转换成**模意义的乘法**  
  > 2、举例探讨：(7 / 2) % 5 中，把**除法转成乘法**写作 (7 \* (1/2)) % 5，再将**分数**写成**幂的形式**写作 (7 \* 2<sup>-1</sup>) % 5  
  > 3、由于**取模运算**的**结果一定是整数**，所以 (7 \* 2<sup>-1</sup>) % 5 **结果一定是整数**，即说明必定能把 2<sup>-1</sup> 这个分数**转换成某个整数**。所以，问题的关键就在于**能转换成哪个整数**  
  > 4、这时便需要引入**乘法逆元**的概念了，它可以辅助我们完成**模意义的除法**到**模意义的乘法**的**转换**

<!-- more -->

- **乘法逆元**

  > 1、类比初中的**倒数**的概念：如果 **a \* b = 1**，则 **a 和 b 互为倒数**。对于 (7 \* 2<sup>-1</sup>) % 5 来说，其**可以等价地写成** (7 \* 3) % 5，这是因为**在模 5 下**，**有** (3 \* 2) % 5 = 1 **成立**。可以**近似地理解成**，**3 和 2**在**模 5**下**互为倒数**，但这里实际**不称作倒数**，而称作**乘法逆元**  
  > 2、因此，对于上面的例子，**7 乘 (1/2) 模 5**，就可以理解成**7 乘 (2 的乘法逆元) 模 5**，这样便可以**转换成模意义的乘法**得到结果。即**被除数**除以**除数**再**模 n**，等同于**被除数**乘**除数的乘法逆元**再**模 n**  
  > 3、如何得到**乘法逆元**？例如**求 (1/2) 在模 7 下的乘法逆元**，就要看**谁乘 2 模 7 等于 1**，显然存在 (2 \* 4) % 7 = 1，因此**4 是 (1/2) 的乘法逆元**，算式写作 2<sup>-1</sup> mod 7 = 4。注意此时式子中 2<sup>-1</sup> **代表逆元**，**而不是分数**  
  > 4、**乘法逆元**的**详细定义**如下图。**模运算**下也会继承一些**普通幂运算的性质**，如下图的**运算示例**。**乘法逆元**还有一些**性质**，如下图

  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/乘法逆元.png)
  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/乘法逆元运算.png)
  ![](https://cdn.jsdelivr.net/gh/ShengQiBaoZao/Image/blog/算法/乘法逆元性质.png)

---

#### **求逆元-拓展欧几里得算法**

---

- **引入**

  > 1、由于前面**乘法逆元性质**中提到，只有当`gcd(a, n) = 1`(即 a, n 互素，n 为模数)才有**乘法逆元**存在。先前介绍过[拓展欧几里得算法](https://www.shengqibaozao.eu.org/2023/08/10/gcd%20%E5%92%8C%20lcm/)，因为`gcd(a, n) = 1`，根据**裴蜀定理**一定有`as + tn = gcd(a, n) = 1`，**等式两边同时模 n**，便得到 **a\*s 和 1 在模 n 下同余**。易知，**模 n 下 a 的逆元是 s**  
  > 2、因此，要求**乘法逆元**时，就可以调用**拓展欧几里得算法**，把 **a, n** 当做参数传入，其**返回的 s 即为所求**

- **代码实现**

  ```cpp
  #include <cstdio>
  #include <iostream>
  using namespace std;

  int ex_gcd(int a, int b, int &s, int &t)
  {
      // s, t 表示 s_i 和 t_i，其默认值为 s_1 = 0 和 t_1 = 1
      // s_ 和 t_ 表示 s_i-1 和 t_i-1，其默认值表示 s_0 = 1 和 t_0 = 0
      int s_ = 1, t_ = 0, q, temp;
      while (a % b)
      {
          q = a / b;

          // 迭代公式：s_i+1 = s_i-1 - s_i * q_i
          temp = s;       // 记录当前 s_i
          s = s_ - s * q; // 计算 s_i+1
          s_ = temp;      // 下一轮 s_i
          // 迭代公式计算 t_i+1
          temp = t;
          t = t_ - t * q;
          t_ = temp;

          temp = a % b;
          a = b;
          b = temp;
      }
      return b;
  }

  int main()
  {
      // 求 (a / b) % n 的值，易证 s 为 b 的乘法逆元
      // s, t 表示 s_i 和 t_i，其默认值为 s_1 = 0 和 t_1 = 1
      int a, b, n, s = 0, t = 1;
      cin >> a >> b >> n;

      // 如果 b, n 互素，算出 b 的乘法逆元，存入 s
      if (ex_gcd(b, n, s, t) == 1)
      {
          // 得到最小的正整数的乘法逆元
          int min_pos_s_ = (s % n + n) % n;
          // 被除数 除以 除数 再模 n，等同于 被除数 乘 除数的乘法逆元 再模 n
          // 对于模乘法，(a * b) % n = ((a % n) * (b % n)) % n
          cout << ((a % n) * (min_pos_s_ % n)) % n;
      }
      else
          cout << "Impossible";
      return 0;
  }
  ```

---

#### **页底评论**

---
